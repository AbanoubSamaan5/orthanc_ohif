{"version":3,"file":"7197.bundle.3de9898f8adab1511b21.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getToolbarModule.ts"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-seg';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import { utils } from '@ohif/core';\r\nimport { metaData, triggerEvent, eventTarget } from '@cornerstonejs/core';\r\nimport { CONSTANTS, segmentation as cstSegmentation } from '@cornerstonejs/tools';\r\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\r\n\r\nconst loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager\r\n) {\r\n  const instance = instances[0];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'SEG',\r\n    loading: false,\r\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    segments: {},\r\n    sopClassUids,\r\n    instance,\r\n    instances: [instance],\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n  };\r\n\r\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n\r\n  if (!referencedSeriesSequence) {\r\n    console.error('ReferencedSeriesSequence is missing for the SEG');\r\n    return;\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\r\n\r\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n  const { displaySetService } = servicesManager.services;\r\n  const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\r\n    displaySet.referencedSeriesInstanceUID\r\n  );\r\n\r\n  const referencedDisplaySet = referencedDisplaySets[0];\r\n\r\n  if (!referencedDisplaySet) {\r\n    // subscribe to display sets added which means at some point it will be available\r\n    const { unsubscribe } = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\r\n      ({ displaySetsAdded }) => {\r\n        // here we can also do a little bit of search, since sometimes DICOM SEG\r\n        // does not contain the referenced display set uid , and we can just\r\n        // see which of the display sets added is more similar and assign it\r\n        // to the referencedDisplaySet\r\n        const addedDisplaySet = displaySetsAdded[0];\r\n        if (addedDisplaySet.SeriesInstanceUID === displaySet.referencedSeriesInstanceUID) {\r\n          displaySet.referencedDisplaySetInstanceUID = addedDisplaySet.displaySetInstanceUID;\r\n          unsubscribe();\r\n        }\r\n      }\r\n    );\r\n  } else {\r\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\r\n  }\r\n\r\n  displaySet.load = async ({ headers }) =>\r\n    await _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(\r\n  segDisplaySet,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager,\r\n  headers\r\n) {\r\n  const { SOPInstanceUID } = segDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  if (\r\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExists(segDisplaySet)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  segDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\r\n      try {\r\n        await _loadSegments({\r\n          extensionManager,\r\n          servicesManager,\r\n          segDisplaySet,\r\n          headers,\r\n        });\r\n      } catch (e) {\r\n        segDisplaySet.loading = false;\r\n        return reject(e);\r\n      }\r\n    }\r\n\r\n    segmentationService\r\n      .createSegmentationForSEGDisplaySet(segDisplaySet)\r\n      .then(() => {\r\n        segDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        segDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nasync function _loadSegments({\r\n  extensionManager,\r\n  servicesManager,\r\n  segDisplaySet,\r\n  headers,\r\n}: withAppTypes) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n\r\n  const { segmentationService, uiNotificationService } = servicesManager.services;\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\r\n\r\n  const referencedDisplaySet = servicesManager.services.displaySetService.getDisplaySetByUID(\r\n    segDisplaySet.referencedDisplaySetInstanceUID\r\n  );\r\n\r\n  if (!referencedDisplaySet) {\r\n    throw new Error('referencedDisplaySet is missing for SEG');\r\n  }\r\n\r\n  let { imageIds } = referencedDisplaySet;\r\n\r\n  if (!imageIds) {\r\n    // try images\r\n    const { images } = referencedDisplaySet;\r\n    imageIds = images.map(image => image.imageId);\r\n  }\r\n\r\n  // Todo: what should be defaults here\r\n  const tolerance = 0.001;\r\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\r\n    const { percentComplete } = evt.detail;\r\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\r\n      percentComplete,\r\n    });\r\n  });\r\n\r\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.createFromDICOMSegBuffer(\r\n    imageIds,\r\n    arrayBuffer,\r\n    { metadataProvider: metaData, tolerance }\r\n  );\r\n\r\n  let usedRecommendedDisplayCIELabValue = true;\r\n  results.segMetadata.data.forEach((data, i) => {\r\n    if (i > 0) {\r\n      data.rgba = data.RecommendedDisplayCIELabValue;\r\n\r\n      if (data.rgba) {\r\n        data.rgba = dicomlabToRGB(data.rgba);\r\n      } else {\r\n        usedRecommendedDisplayCIELabValue = false;\r\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\r\n      }\r\n    }\r\n  });\r\n\r\n  if (!usedRecommendedDisplayCIELabValue) {\r\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\r\n    uiNotificationService.show({\r\n      title: 'DICOM SEG import',\r\n      message:\r\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\r\n      type: 'warning',\r\n      duration: 5000,\r\n    });\r\n  }\r\n\r\n  Object.assign(segDisplaySet, results);\r\n}\r\n\r\nfunction _segmentationExists(segDisplaySet) {\r\n  return cstSegmentation.state.getSegmentation(segDisplaySet.displaySetInstanceUID);\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'dicom-seg',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import dcmjs from 'dcmjs';\r\n\r\n/**\r\n * Converts a CIELAB color to an RGB color using the dcmjs library.\r\n * @param cielab - The CIELAB color to convert.\r\n * @returns The RGB color as an array of three integers between 0 and 255.\r\n */\r\nfunction dicomlabToRGB(cielab: number[]): number[] {\r\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\r\n\r\n  return rgb;\r\n}\r\n\r\nexport { dicomlabToRGB };\r\n","import { Types } from '@ohif/core';\r\n\r\nconst segProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/seg',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  name: 'Segmentations',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n      syncGroups: [\r\n        {\r\n          type: 'hydrateseg',\r\n          id: 'sameFORId',\r\n          source: true,\r\n          target: true,\r\n          // options: {\r\n          //   matchingRules: ['sameFOR'],\r\n          // },\r\n        },\r\n      ],\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'segDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    segDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SEG',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'Segmentations',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: {\r\n            allowUnmatchedView: true,\r\n            syncGroups: [\r\n              {\r\n                type: 'hydrateseg',\r\n                id: 'sameFORId',\r\n                source: true,\r\n                target: true,\r\n                // options: {\r\n                //   matchingRules: ['sameFOR'],\r\n                // },\r\n              },\r\n            ],\r\n          },\r\n          displaySets: [\r\n            {\r\n              id: 'segDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: segProtocol.id,\r\n      protocol: segProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { segProtocol };\r\n","import dcmjs from 'dcmjs';\r\nimport { Types } from '@ohif/core';\r\nimport { cache, metaData } from '@cornerstonejs/core';\r\nimport {\r\n  segmentation as cornerstoneToolsSegmentation,\r\n  Enums as cornerstoneToolsEnums,\r\n  utilities,\r\n} from '@cornerstonejs/tools';\r\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\r\nimport { createReportDialogPrompt } from '@ohif/extension-default';\r\nimport { classes, DicomMetadataStore } from '@ohif/core';\r\n\r\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\nimport PROMPT_RESPONSES from '../../default/src/utils/_shared/PROMPT_RESPONSES';\r\n\r\nconst { segmentation: segmentationUtils } = utilities;\r\n\r\nconst { datasetToBlob } = dcmjs.data;\r\n\r\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\r\n  const { viewports, activeViewportId } = viewportGridService.getState();\r\n  const targetViewportId = viewportId || activeViewportId;\r\n\r\n  const viewport = viewports.get(targetViewportId);\r\n\r\n  return viewport;\r\n};\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    Segmentation: { generateSegmentation },\r\n  },\r\n} = adaptersSEG;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    RTSS: { generateRTSSFromSegmentations },\r\n  },\r\n} = adaptersRT;\r\n\r\nconst { downloadDICOMData } = helpers;\r\n\r\nconst commandsModule = ({\r\n  servicesManager,\r\n  extensionManager,\r\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\r\n  const {\r\n    segmentationService,\r\n    uiDialogService,\r\n    displaySetService,\r\n    viewportGridService,\r\n    toolGroupService,\r\n    customizationService,\r\n  } = servicesManager.services as AppTypes.Services;\r\n\r\n  const actions = {\r\n    /**\r\n     * Loads segmentations for a specified viewport.\r\n     * The function prepares the viewport for rendering, then loads the segmentation details.\r\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentations - Array of segmentations to be loaded.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\r\n      // Todo: handle adding more than one segmentation\r\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n      const segmentation = segmentations[0];\r\n      const segmentationId = segmentation.segmentationId;\r\n      const label = segmentation.config.label;\r\n      const segments = segmentation.config.segments;\r\n\r\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n      await segmentationService.createLabelmapForDisplaySet(displaySet, {\r\n        segmentationId,\r\n        segments,\r\n        label,\r\n      });\r\n\r\n      segmentationService.addOrUpdateSegmentation(segmentation);\r\n\r\n      await segmentationService.addSegmentationRepresentation(viewport.viewportId, {\r\n        segmentationId,\r\n      });\r\n\r\n      return segmentationId;\r\n    },\r\n    /**\r\n     * Generates a segmentation from a given segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * its referenced volume, extracts label maps from the\r\n     * segmentation volume, and produces segmentation data\r\n     * alongside associated metadata.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be generated.\r\n     * @param params.options - Optional configuration for the generation process.\r\n     *\r\n     * @returns Returns the generated segmentation data.\r\n     */\r\n    generateSegmentation: ({ segmentationId, options = {} }) => {\r\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\r\n\r\n      const { imageIds } = segmentation.representationData.Labelmap;\r\n\r\n      const segImages = imageIds.map(imageId => cache.getImage(imageId));\r\n      const referencedImages = segImages.map(image => cache.getImage(image.referencedImageId));\r\n\r\n      const labelmaps2D = [];\r\n\r\n      let z = 0;\r\n\r\n      for (const segImage of segImages) {\r\n        const segmentsOnLabelmap = new Set();\r\n        const pixelData = segImage.getPixelData();\r\n        const { rows, columns } = segImage;\r\n\r\n        // Use a single pass through the pixel data\r\n        for (let i = 0; i < pixelData.length; i++) {\r\n          const segment = pixelData[i];\r\n          if (segment !== 0) {\r\n            segmentsOnLabelmap.add(segment);\r\n          }\r\n        }\r\n\r\n        labelmaps2D[z++] = {\r\n          segmentsOnLabelmap: Array.from(segmentsOnLabelmap),\r\n          pixelData,\r\n          rows,\r\n          columns,\r\n        };\r\n      }\r\n\r\n      const allSegmentsOnLabelmap = labelmaps2D.map(labelmap => labelmap.segmentsOnLabelmap);\r\n\r\n      const labelmap3D = {\r\n        segmentsOnLabelmap: Array.from(new Set(allSegmentsOnLabelmap.flat())),\r\n        metadata: [],\r\n        labelmaps2D,\r\n      };\r\n\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const representations = segmentationService.getRepresentationsForSegmentation(segmentationId);\r\n\r\n      Object.entries(segmentationInOHIF.segments).forEach(([segmentIndex, segment]) => {\r\n        // segmentation service already has a color for each segment\r\n        if (!segment) {\r\n          return;\r\n        }\r\n\r\n        const { label } = segment;\r\n\r\n        const firstRepresentation = representations[0];\r\n        const color = segmentationService.getSegmentColor(\r\n          firstRepresentation.viewportId,\r\n          segmentationId,\r\n          segment.segmentIndex\r\n        );\r\n\r\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\r\n          color.slice(0, 3).map(value => value / 255)\r\n        ).map(value => Math.round(value));\r\n\r\n        const segmentMetadata = {\r\n          SegmentNumber: segmentIndex.toString(),\r\n          SegmentLabel: label,\r\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\r\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\r\n          RecommendedDisplayCIELabValue,\r\n          SegmentedPropertyCategoryCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n          SegmentedPropertyTypeCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n        };\r\n        labelmap3D.metadata[segmentIndex] = segmentMetadata;\r\n      });\r\n\r\n      const generatedSegmentation = generateSegmentation(\r\n        referencedImages,\r\n        labelmap3D,\r\n        metaData,\r\n        options\r\n      );\r\n\r\n      return generatedSegmentation;\r\n    },\r\n    /**\r\n     * Downloads a segmentation based on the provided segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * uses it to generate the corresponding DICOM dataset, which\r\n     * is then downloaded with an appropriate filename.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\r\n     *\r\n     */\r\n    downloadSegmentation: ({ segmentationId }) => {\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const generatedSegmentation = actions.generateSegmentation({\r\n        segmentationId,\r\n      });\r\n\r\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\r\n    },\r\n    /**\r\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\r\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\r\n     * and in its absence, defaults to 'Research Derived Series'.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be stored.\r\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\r\n     *\r\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\r\n     * otherwise throws an error.\r\n     */\r\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\r\n      const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n      if (!segmentation) {\r\n        throw new Error('No segmentation found');\r\n      }\r\n\r\n      const { label } = segmentation;\r\n      const defaultDataSource = dataSource ?? extensionManager.getActiveDataSource();\r\n\r\n      const {\r\n        value: reportName,\r\n        dataSourceName: selectedDataSource,\r\n        action,\r\n      } = await createReportDialogPrompt({\r\n        servicesManager,\r\n        extensionManager,\r\n        title: 'Store Segmentation',\r\n      });\r\n\r\n      if (action === PROMPT_RESPONSES.CREATE_REPORT) {\r\n        try {\r\n          const selectedDataSourceConfig = selectedDataSource\r\n            ? extensionManager.getDataSources(selectedDataSource)[0]\r\n            : defaultDataSource;\r\n\r\n          const generatedData = actions.generateSegmentation({\r\n            segmentationId,\r\n            options: {\r\n              SeriesDescription: reportName || label || 'Research Derived Series',\r\n            },\r\n          });\r\n\r\n          if (!generatedData || !generatedData.dataset) {\r\n            throw new Error('Error during segmentation generation');\r\n          }\r\n\r\n          const { dataset: naturalizedReport } = generatedData;\r\n\r\n          await selectedDataSourceConfig.store.dicom(naturalizedReport);\r\n\r\n          // add the information for where we stored it to the instance as well\r\n          naturalizedReport.wadoRoot = selectedDataSourceConfig.getConfig().wadoRoot;\r\n\r\n          DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n          return naturalizedReport;\r\n        } catch (error) {\r\n          console.debug('Error storing segmentation:', error);\r\n          throw error;\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     * Converts segmentations into RTSS for download.\r\n     * This sample function retrieves all segentations and passes to\r\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\r\n     * converts dataset to downloadable blob.\r\n     *\r\n     */\r\n    downloadRTSS: ({ segmentationId }) => {\r\n      const segmentations = segmentationService.getSegmentation(segmentationId);\r\n      const vtkUtils = {\r\n        vtkImageMarchingSquares,\r\n        vtkDataArray,\r\n        vtkImageData,\r\n      };\r\n\r\n      const RTSS = generateRTSSFromSegmentations(\r\n        segmentations,\r\n        classes.MetadataProvider,\r\n        DicomMetadataStore,\r\n        cache,\r\n        cornerstoneToolsEnums,\r\n        vtkUtils\r\n      );\r\n\r\n      try {\r\n        const reportBlob = datasetToBlob(RTSS);\r\n\r\n        //Create a URL for the binary.\r\n        const objectUrl = URL.createObjectURL(reportBlob);\r\n        window.location.assign(objectUrl);\r\n      } catch (e) {\r\n        console.warn(e);\r\n      }\r\n    },\r\n    setBrushSize: ({ value, toolNames }) => {\r\n      const brushSize = Number(value);\r\n\r\n      toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\r\n        if (toolNames?.length === 0) {\r\n          segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize);\r\n        } else {\r\n          toolNames?.forEach(toolName => {\r\n            segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize, toolName);\r\n          });\r\n        }\r\n      });\r\n    },\r\n    setThresholdRange: ({\r\n      value,\r\n      toolNames = [\r\n        'ThresholdCircularBrush',\r\n        'ThresholdSphereBrush',\r\n        'ThresholdCircularBrushDynamic',\r\n        'ThresholdSphereBrushDynamic',\r\n      ],\r\n    }) => {\r\n      const toolGroupIds = toolGroupService.getToolGroupIds();\r\n      if (!toolGroupIds?.length) {\r\n        return;\r\n      }\r\n\r\n      for (const toolGroupId of toolGroupIds) {\r\n        const toolGroup = toolGroupService.getToolGroup(toolGroupId);\r\n        toolNames?.forEach(toolName => {\r\n          toolGroup.setToolConfiguration(toolName, {\r\n            threshold: {\r\n              range: value,\r\n            },\r\n          });\r\n        });\r\n      }\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    /**\r\n     * Obsolete?\r\n     */\r\n    loadSegmentationDisplaySetsForViewport: {\r\n      commandFn: actions.loadSegmentationDisplaySetsForViewport,\r\n    },\r\n    /**\r\n     * Obsolete?\r\n     */\r\n    loadSegmentationsForViewport: {\r\n      commandFn: actions.loadSegmentationsForViewport,\r\n    },\r\n\r\n    generateSegmentation: {\r\n      commandFn: actions.generateSegmentation,\r\n    },\r\n    downloadSegmentation: {\r\n      commandFn: actions.downloadSegmentation,\r\n    },\r\n    storeSegmentation: {\r\n      commandFn: actions.storeSegmentation,\r\n    },\r\n    downloadRTSS: {\r\n      commandFn: actions.downloadRTSS,\r\n    },\r\n    setBrushSize: {\r\n      commandFn: actions.setBrushSize,\r\n    },\r\n    setThresholdRange: {\r\n      commandFn: actions.setThresholdRange,\r\n    },\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'SEGMENTATION',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { id } from './id';\r\nimport React from 'react';\r\n\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getHangingProtocolModule from './getHangingProtocolModule';\r\nimport getCommandsModule from './commandsModule';\r\nimport { getToolbarModule } from './getToolbarModule';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\r\n});\r\n\r\nconst OHIFCornerstoneSEGViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n  getCommandsModule,\r\n  getToolbarModule,\r\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\r\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSEGViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          commandsManager={commandsManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n  getHangingProtocolModule,\r\n};\r\n\r\nexport default extension;\r\n","export function getToolbarModule({ servicesManager }: withAppTypes) {\r\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\r\n  return [\r\n    {\r\n      name: 'evaluate.cornerstone.hasSegmentation',\r\n      evaluate: ({ viewportId }) => {\r\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\r\n        return {\r\n          disabled: !segmentations?.length,\r\n        };\r\n      },\r\n    },\r\n    {\r\n      name: 'evaluate.cornerstone.segmentation',\r\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\r\n        // Todo: we need to pass in the button section Id since we are kind of\r\n        // forcing the button to have black background since initially\r\n        // it is designed for the toolbox not the toolbar on top\r\n        // we should then branch the buttonSectionId to have different styles\r\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\r\n        if (!segmentations?.length) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'No segmentations available',\r\n          };\r\n        }\r\n\r\n        const activeSegmentation = segmentationService.getActiveSegmentation(viewportId);\r\n        if (!Object.keys(activeSegmentation.segments).length) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: 'Add segment to enable this tool',\r\n          };\r\n        }\r\n\r\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\r\n\r\n        if (!toolGroup) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        if (!toolNames) {\r\n          return {\r\n            disabled: false,\r\n            // isActive: false,\r\n          };\r\n        }\r\n\r\n        const toolName = toolbarService.getToolNameForButton(button);\r\n\r\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        const isPrimaryActive = toolNames\r\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\r\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\r\n\r\n        return {\r\n          disabled: false,\r\n          isActive: isPrimaryActive,\r\n        };\r\n      },\r\n    },\r\n  ];\r\n}\r\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","displaySetService","services","referencedDisplaySet","getDisplaySetsForSeries","unsubscribe","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","addedDisplaySet","load","async","headers","segDisplaySet","segmentationService","cstSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","length","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","getDisplaySetByUID","Error","imageIds","images","map","image","imageId","tolerance","eventTarget","addEventListener","Enums","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","createFromDICOMSegBuffer","metadataProvider","metaData","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","x","Math","round","CONSTANTS","show","title","message","type","duration","assign","_loadSegments","e","createSegmentationForSEGDisplaySet","then","catch","_load","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","syncGroups","source","target","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","segmentation","segmentationUtils","utilities","datasetToBlob","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","commandsModule","uiDialogService","viewportGridService","toolGroupService","customizationService","actions","loadSegmentationsForViewport","segmentations","viewportId","viewport","getTargetViewport","activeViewportId","getState","targetViewportId","get","displaySetInstanceUIDs","segmentationId","label","config","createLabelmapForDisplaySet","addOrUpdateSegmentation","addSegmentationRepresentation","options","cornerstoneToolsSegmentation","representationData","Labelmap","segImages","cache","getImage","referencedImageId","labelmaps2D","z","segImage","segmentsOnLabelmap","Set","pixelData","getPixelData","segment","add","Array","from","allSegmentsOnLabelmap","labelmap","labelmap3D","flat","metadata","segmentationInOHIF","getSegmentation","representations","getRepresentationsForSegmentation","entries","segmentIndex","firstRepresentation","color","getSegmentColor","rgb2DICOMLAB","slice","value","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","algorithmType","SegmentAlgorithmName","algorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","generatedSegmentation","dataset","storeSegmentation","dataSource","defaultDataSource","getActiveDataSource","reportName","dataSourceName","selectedDataSource","action","createReportDialogPrompt","PROMPT_RESPONSES","CREATE_REPORT","selectedDataSourceConfig","getDataSources","generatedData","naturalizedReport","store","dicom","getConfig","DicomMetadataStore","addInstances","debug","downloadRTSS","vtkUtils","vtkImageMarchingSquares","vtkDataArray","vtkImageData","classes","MetadataProvider","cornerstoneToolsEnums","reportBlob","objectUrl","URL","createObjectURL","window","location","warn","setBrushSize","toolNames","brushSize","Number","getToolGroupIds","setBrushSizeForToolGroup","toolName","setThresholdRange","toolGroup","getToolGroup","setToolConfiguration","threshold","range","definitions","loadSegmentationDisplaySetsForViewport","commandFn","defaultContext","Component","React","OHIFCornerstoneSEGViewport","props","fallback","getCommandsModule","getToolbarModule","toolbarService","evaluate","getSegmentationRepresentations","disabled","button","disabledText","activeSegmentation","getActiveSegmentation","getToolGroupForViewport","getToolNameForButton","hasTool","isActive","includes","getActivePrimaryMouseButtonTool","getViewportModule","commandsManager","component","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}