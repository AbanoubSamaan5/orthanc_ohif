{"version":3,"file":"2585.bundle.5ca272e7b5b14f58a7e7.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js"],"sourcesContent":["function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n","import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n","const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getColorLUT(index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getColorLUT(index);\n}\n","import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n","import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotation(...annotationBaseData) {\n        let annotation = {\n            annotationUID: null,\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.toolName,\n            },\n            data: {\n                text: '',\n                handles: {\n                    points: new Array(),\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                label: '',\n            },\n        };\n        for (const baseData of annotationBaseData) {\n            annotation = csUtils.deepMerge(annotation, baseData);\n        }\n        return annotation;\n    }\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n","import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.resetCamera();\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n","import { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { removeAnnotation } from '../../../stateManagement';\nfunction removeContourFromElement(viewportId, segmentationId, removeFromCache = false) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    annotationUIDsMap.forEach((annotationSet) => {\n        annotationSet.forEach((annotationUID) => {\n            removeAnnotation(annotationUID);\n        });\n    });\n}\nexport default removeContourFromElement;\n","import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n","import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n","const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(element, surface, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getSurfaceActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.uid.startsWith(getSurfaceActorUID(viewport.id, segmentationId, '')));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n","import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n","export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK: newBoundsIJK, topLeftWorld, bottomRightWorld, } = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        operationData.isInObjectBoundsIJK = newBoundsIJK;\n        operationData.isInObject = createEllipseInPoint({\n            topLeftWorld,\n            bottomRightWorld,\n            center,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n","import { cache, Enums, eventTarget } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../../../stateManagement/segmentation/helpers';\nimport { getReferenceVolumeForSegmentationVolume } from '../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume';\nfunction getStrategyDataForVolumeViewport({ operationData }) {\n    const { volumeId } = operationData;\n    if (!volumeId) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n            detail: {\n                type: 'Segmentation',\n                message: 'No volume id found for the segmentation',\n            },\n            cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n    }\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = getReferenceVolumeForSegmentationVolume(volumeId);\n    if (!segmentationVolume || !imageVolume) {\n        return null;\n    }\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { voxelManager: segmentationVoxelManager } = segmentationVolume;\n    const { voxelManager: imageVoxelManager, imageData } = imageVolume;\n    return {\n        segmentationImageData,\n        segmentationVoxelManager,\n        segmentationScalarData: null,\n        imageScalarData: null,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {\n    const { segmentationId } = operationData;\n    let segmentationImageData;\n    let segmentationVoxelManager;\n    let segmentationScalarData;\n    let imageScalarData;\n    let imageVoxelManager;\n    let imageData;\n    if (strategy.ensureSegmentationVolumeFor3DManipulation) {\n        strategy.ensureSegmentationVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        segmentationVoxelManager = operationData.segmentationVoxelManager;\n        segmentationImageData = operationData.segmentationImageData;\n        segmentationScalarData = null;\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return null;\n        }\n        const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n        if (!actorEntry) {\n            return null;\n        }\n        const currentSegImage = cache.getImage(labelmapImageId);\n        segmentationImageData = actorEntry.actor.getMapper().getInputData();\n        segmentationVoxelManager = currentSegImage.voxelManager;\n        const currentSegmentationImageId = operationData.imageId;\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        if (!segmentationImage) {\n            return null;\n        }\n        segmentationScalarData = segmentationImage.getPixelData?.();\n    }\n    if (strategy.ensureImageVolumeFor3DManipulation) {\n        strategy.ensureImageVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        imageVoxelManager = operationData.imageVoxelManager;\n        imageScalarData = operationData.imageScalarData;\n        imageData = operationData.imageData;\n    }\n    else {\n        const currentImageId = viewport.getCurrentImageId();\n        if (!currentImageId) {\n            return null;\n        }\n        const image = cache.getImage(currentImageId);\n        imageData = image ? null : viewport.getImageData();\n        imageScalarData = image?.getPixelData() || imageData.getScalarData();\n        imageVoxelManager = image?.voxelManager;\n    }\n    return {\n        segmentationImageData,\n        segmentationScalarData,\n        imageScalarData,\n        segmentationVoxelManager,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyData({ operationData, viewport, strategy, }) {\n    if (!operationData) {\n        return null;\n    }\n    if (('volumeId' in operationData && operationData.volumeId != null) ||\n        ('referencedVolumeId' in operationData &&\n            operationData.referencedVolumeId != null)) {\n        return getStrategyDataForVolumeViewport({ operationData });\n    }\n    return getStrategyDataForStackViewport({ operationData, viewport, strategy });\n}\nexport { getStrategyData };\n","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n","import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n","import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n","import { triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../../eventListeners/annotations/contourSegmentation/contourSegmentationCompleted';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n","import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n","export default function getCanvasEllipseCorners(ellipseCanvasPoints) {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [topLeft, bottomRight];\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return;\n    }\n    const denom = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denom;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denom;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const data = annotation.data;\n        const point = data.handles.points[0] || data.contour?.polyline[0];\n        if (!annotation.isVisible) {\n            continue;\n        }\n        const dir = vec3.create();\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        vec3.sub(dir, focalPoint, point);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n","class EdgeLocator {\n  constructor() {\n    let oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n  initialize() {\n    this.edgeMap.clear();\n  }\n  computeEdgeKey(pointId0, pointId1) {\n    return this.oriented || pointId0 < pointId1 ?\n    // Cantor pairing function:\n    0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n  }\n  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    let node = this.edgeMap.get(key);\n    if (!node) {\n      // Didn't find key, so add a new edge entry\n      node = {\n        key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n    }\n    return node;\n  }\n  insertEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    const node = {\n      key,\n      edgeId: this.edgeMap.size,\n      value: newEdgeValue\n    };\n    this.edgeMap.set(key, node);\n    return node;\n  }\n  isInsertedEdge(pointId0, pointId1) {\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    return this.edgeMap.get(key);\n  }\n  static getEdgePointIds(node) {\n    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n    const pointId0 = node.key - 0.5 * (n + 1) * n;\n    const pointId1 = n - pointId0;\n    return [pointId0, pointId1];\n  }\n}\nfunction newInstance() {\n  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\nvar vtkEdgeLocator = {\n  newInstance\n};\n\nexport { vtkEdgeLocator as default };\n","// ----------------------------------------------------------------------------\n// Marching squares case functions (using lines to generate the 2D tessellation).\n// For each case, a list of edge ids that form the triangles. A -1 marks the\n// end of the list of edges. Edges are taken three at a time to generate\n// triangle points.\n// ----------------------------------------------------------------------------\nconst MARCHING_SQUARES_CASES = [[-1, -1, -1, -1, -1] /* 0 */, [0, 3, -1, -1, -1] /* 1 */, [1, 0, -1, -1, -1] /* 2 */, [1, 3, -1, -1, -1] /* 3 */, [2, 1, -1, -1, -1] /* 4 */, [0, 3, 2, 1, -1] /* 5 */, [2, 0, -1, -1, -1] /* 6 */, [2, 3, -1, -1, -1] /* 7 */, [3, 2, -1, -1, -1] /* 8 */, [0, 2, -1, -1, -1] /* 9 */, [1, 0, 3, 2, -1] /* 10 */, [1, 2, -1, -1, -1] /* 11 */, [3, 1, -1, -1, -1] /* 12 */, [0, 1, -1, -1, -1] /* 13 */, [3, 0, -1, -1, -1] /* 14 */, [-1, -1, -1, -1, -1] /* 15 */];\n\nconst EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];\nfunction getCase(index) {\n  return MARCHING_SQUARES_CASES[index];\n}\n\n// Define the four edges of the pixel by the following pairs of vertices\nfunction getEdge(eid) {\n  return EDGES[eid];\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\nvar vtkCaseTable = {\n  getCase,\n  getEdge\n};\n\nexport { vtkCaseTable as default };\n"],"names":["annotationUID","drawingElementType","nodeUID","evt","shiftKey","ctrlKey","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","Shift","CtrlAlt","CtrlMeta","Ctrl","AltMeta","Alt","Meta","defaultManager","resetAnnotationManager","setAnnotationManager","setPreprocessingFn","annotation","uid","data","cachedStats","checkAndDefineCachedStatsProperty","handles","textBox","checkAndDefineTextBoxProperty","isLocked","checkAndSetAnnotationLocked","isVisible","checkAndSetAnnotationVisibility","triggerSegmentationAdded","segmentationId","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_ADDED","triggerSegmentationModified","SEGMENTATION_MODIFIED","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationModified","viewportId","type","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","getColorLUT","index","internalGetHiddenSegmentIndices","specifier","representation","Set","Object","entries","segments","reduce","acc","segmentIndex","segment","visible","add","Number","getSubPixelSpacingAndXYDirections","addCanvasPointsToArray","getArea","polyline","activateClosedContourEdit","viewportIdsToRender","this","isEditingClosed","detail","currentPoints","element","canvasPos","canvas","enabledElement","getEnabledElement","viewport","prevCanvasPoints","contour","map","worldToCanvas","spacing","xDir","yDir","configuration","subPixelResolution","editData","editCanvasPoints","startCrossingIndex","undefined","editIndex","commonData","movingTextBox","isInteractingWithTool","addEventListener","MOUSE_UP","mouseUpClosedContourEditCallback","MOUSE_DRAG","mouseDragClosedContourEditCallback","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","hideElementCursor","deactivateClosedContourEdit","removeEventListener","resetElementCursor","worldPos","world","createMemo","lastCanvasPoint","length","lastWorldPoint","canvasToWorld","worldPosDiff","xDist","Math","abs","yDist","checkAndRemoveCrossesOnEditLine","currentEditIndex","checkForFirstCrossing","snapIndex","findSnapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","checkForSecondCrossing","removePointsAfterSecondCrossing","finishEditAndStartNewEdit","renderingEngine","points","closed","targetWindingDirection","Clockwise","autoGenerated","triggerAnnotationModified","lastEditCanvasPoint","pop","augmentedEditCanvasPoints","lowIndex","highIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","i","canvasPoint","push","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","doneEditMemo","updatedPoints","decimateConfig","decimate","enabled","epsilon","cancelClosedContourEdit","toolInstance","bind","pointsAreWithinCloseContourProximity","getFirstLineSegmentIntersectionIndexes","activateDraw","isDrawing","contourHoleProcessingEnabled","event","contourHoleAdditionModifierKey","drawData","canvasPoints","polylineIndex","newAnnotation","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","deltaPoints","worldPosDelta","worldPosition","hasMoved","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","invalidated","ChangeTypes","HandlesUpdated","allowOpenContours","firstPoint","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","options","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updateContourPolyline","triggerContourAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","remainingPoints","newArea","utilities","cancelDrawing","minPoints","max","shouldHaltDrawing","removeAnnotation","isClosedContour","crossedLineSegment","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","distance","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","min","dir","proximity","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","numPointsToRemove","firstLine","lastLine","didCrossLine","editCanvasPointsLessLastOne","snapCanvasPosition","editIndexCrossed","findOpenUShapedContourVectorToPeak","first","last","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","findOpenUShapedContourVectorToPeakOnRender","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activeHandleIndex","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","sqrt","magB","acos","PI","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","handle","reverse","_getRenderingOptions","styleSpecifier","toolGroupId","toolName","getToolName","id","lineWidth","lineDash","color","fillColor","fillOpacity","getAnnotationStyle","width","closePath","renderContour","svgDrawingHelper","getImageData","renderClosedContour","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","parentAnnotationUID","allContours","drawPath","drawPolyline","alwaysRenderOpenContourHandles","radius","handleGroupUID","handlePoints","shift","drawHandles","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","canvasPolyline","childContours","center","circlePoints","angle","x","cos","y","sin","crosshair","polylineUID","DefaultHistoryMemo","PointsManager","AnnotationTool","A","createAnnotation","annotationBaseData","highlighted","metadata","text","Array","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","getViewReference","createAndAddAnnotation","addAnnotation","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","isSuvScaled","getTextLines","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","canvasBoundingBox","point","annotationCanvasCoordinate","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","shadow","background","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","context","property","locked","markerSize","lineOpacity","textbox","isPointNearTool","createAnnotationState","deleting","cloneData","spline","state","structuredClone","pointsManager","create3","createAnnotationMemo","annotationMemo","restoreMemo","newState","setViewReference","assign","annotationData","segmentation","addContourSegmentationAnnotation","setAnnotationSelected","render","currentAnnotation","getAnnotation","History","console","warn","operationType","memo","hydrateBase","ToolClass","FrameOfReferenceUID","getFrameOfReferenceUID","camera","getCamera","viewPlaneNormal","viewplaneNormal","viewUp","instance","referencedImageId","finalViewPlaneNormal","finalViewUp","StackViewport","closestImageIndex","getImageIds","Error","getReferencedImageId","ContourBaseTool","renderAnnotation","renderStatus","getRenderingEngine","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","annotationStyle","annotationRendered","renderAnnotationInstance","interpolationUID","cancelAnnotation","moveAnnotation","getChildAnnotations","forEach","childAnnotation","polylineData","transforms","updateWindingDirection","getPolylinePoints","renderContext","polylineCanvasPoints","getContourHolesDataCanvas","ContourSegmentationBaseTool","PreviewSegmentIndex","interpolation","InterpolationManager","addTool","isContourSegmentationTool","contourAnnotation","activeSeg","getActiveSegmentation","representationData","Contour","getActiveSegmentIndex","contourSegAnnotation","removeContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerSegmentationDataModified","toolGroupIds","getViewportIdsWithSegmentation","getToolGroupForViewport","triggerAnnotationRenderForToolGroupIds","segmentationRepresentations","getSegmentationRepresentation","segmentationRepresentation","find","rep","SegmentationRepresentations","annotationLocked","getLockedSegmentIndices","includes","getSVGStyleForSegment","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidth","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDash","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","handleContourSegmentation","geometryIds","annotationUIDsMap","contourRepresentation","size","segmentSpecificMap","Map","geometryId","geometry","getGeometry","Enums","CONTOUR","validateGeometry","segmentSpecificConfig","contourSet","contours","contourSegmentationAnnotation","annotationGroupSelector","set","resetCamera","addContourSetsToElement","removeFromCache","annotationSet","internalCache","load","cfun","ofun","actor","getProperty","setRGBTransferFunction","setScalarOpacity","uuidv4","async","labelMapData","config","getSegmentation","Labelmap","_ensureVolumeHasVolumeId","stackData","imageIds","volumeLoader","_handleMissingVolume","blendMode","MAXIMUM_INTENSITY_BLEND","useIndependentComponents","LABELMAP_EDGE_PROJECTION_BLEND","referenceVolumeId","getVolumeId","baseVolume","segDims","dimensions","refDims","debug","volumeInputs","representationUID","result","defaultActor","getDefaultActor","callback","get","added","volumeInputArray","firstImageVolume","segImageVolume","segData","voxelManager","getCompleteScalarDataArray","imageData","segImageData","cubeData","Float32Array","getScalarDataLength","dims","getDimensions","z","iTuple","removeActors","oldMapper","getMapper","mapper","convertMapperToNotSharedMapper","setMapper","setBlendMode","arrayAgain","getInputData","getPointData","getArray","onSegmentationDataModified","segVolumeId","segVoxelManager","array","getData","slices","from","_","getAtIndex","setData","modified","setNumberOfComponents","setColorMixPreset","setForceNearestInterpolation","setIndependentComponents","addActor","referencedId","segmentationRepresentationUID","originalBlendMode","getBlendMode","preLoad","addEventListenerDebounced","SEGMENTATION_DATA_MODIFIED","actorEntry","getActor","createVolumeActor","volumeActor","addVolumesAsIndependentComponents","addVolumesToViewports","stackInputs","addImageSlicesToViewports","defaultLabelmapConfig","renderOutlineInactive","renderFillInactive","surface","surfaceActorEntry","surfaceActor","setVisibility","surfaceMapper","currentPolyData","newPoints","newPolys","polys","getPoints","currentPolys","getPolys","polyData","triangles","values","setPolys","setInputData","getRenderer","resetCameraClippingRange","surfacePolyData","setColor","setLineWidth","clippingFilter","filteredSurfaceActors","getActors","filter","startsWith","BrushStrategy","COMPOSITIONS","childFunctions","StrategyCallbacks","OnInteractionStart","addListMethod","Initialize","OnInteractionEnd","Fill","CreateIsInThreshold","addSingletonMethod","Interpolate","AcceptPreview","RejectPreview","INTERNAL_setValue","Preview","ComputeInnerCircleRadius","EnsureSegmentationVolumeFor3DManipulation","EnsureImageVolumeFor3DManipulation","AddPreview","GetStatistics","compositions","name","initializers","_initialize","_fill","_onInteractionStart","fill","operationData","initializedData","initialize","func","segmentationVoxelManager","getArrayOfModifiedSlices","onInteractionStart","call","addPreview","configurationName","initializer","key","strategyFunction","keys","operationName","strategy","imageVoxelManager","segmentationImageData","centerWorld","isInObject","isInObjectBoundsIJK","brushStrategy","createInitialized","listName","args","returnValue","value","isInitialized","previewSegmentIndex","centerIJK","useCenterSegmentIndex","hasSegmentIndex","hasPreviewIndex","nestedBounds","getBoundsIJK","boundsIJK","centerSegmentIndexInfo","existingValue","getAtIJKPoint","threshold","isDynamic","range","oldThreshold","dynamicRadius","useDelta","ijk","idx","Infinity","useDeltaSqr","pointIJK","gray","isArray","dynamicRadiusInCanvas","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","activeStrategy","islandRemoval","floodFillSegmentIsland","removeExternalIslands","removeInternalIslands","arrayOfSlices","preview","onInteractionEnd","previewColor","viewportIds","setSegmentIndexColor","changedIndices","labelmapMemo","oldValue","setAtIndex","undoIf","hasPreviewSegmentIndex","segmentsLocked","isWithinThreshold","createIsInThreshold","setValue","addPoint","useSegmentIndex","previewOnHover","centerSegmentIndex","handleUseSegmentCenterIndex","voxelValue","indices","getStatistics","segmentIndices","determineSegmentIndex","dynamicThreshold","erase","regionFill","labelmapStatistics","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","eraseInsideCircle","eraseInsideSphere","transformWorldToIndex","sphereComposition","newBoundsIJK","topLeftWorld","bottomRightWorld","SPHERE_STRATEGY","fillInsideSphere","SPHERE_THRESHOLD_STRATEGY","SPHERE_THRESHOLD_STRATEGY_ISLAND","thresholdInsideSphere","thresholdInsideSphereIsland","getStrategyData","referencedVolumeId","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","segmentationVolume","imageVolume","segmentationScalarData","imageScalarData","getStrategyDataForVolumeViewport","labelmapImageId","getCurrentLabelmapImageIdForViewport","currentSegImage","getImage","currentSegmentationImageId","segmentationImage","getPixelData","currentImageId","getCurrentImageId","image","getScalarData","getStrategyDataForStackViewport","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","toFixed","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","numberOfSlices","imageAnnotations","sliceIndex","filteredInterpolatedAnnotations","imageAnnotation","every","parent","parentKey","item","getInterpolationDataCollection","interpolatedDataCollection","createPolylineToolData","referencedToolData","childAnnotationUIDs","interpolationSources","sources","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","startIndex","pair","list","_getBoundingPair","sliceRange","annotationPair","canInterpolate","rangeToInterpolate","found","getRangeToInterpolate","sliceEdited","j","_getSlicePositionOfToolData","selectHandles","handleCount","destPoints","sourcePoints","subselect","interval","floor","dotValues","prevVec3","nextVec3","getPoint","prevPoint","nextPoint","dot","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","region","start","end","midIndex","ceil","addInterval","firstHandle","indexValue","getPointArray","source","destSourceIndex","finish","count","v","round","dP","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","endIndex","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","has","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","viewRef","onInterpolationComplete","parentAnnotation","_addInterpolatedContour","_linearlyInterpolateContour","arr","slicedArray","c","nodesPerSegment","ci","n","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","concat","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","indexOf","updateChildInterpolationUID","toolType","renderingEngineId","eventDetails","ANNOTATION_INTERPOLATION_PROCESS_COMPLETED","startInterpolation","createBasicStatsState","storePointData","maxIJK","maxLPS","minIJK","minLPS","runMean","m2","m3","m4","allValues","pointsInShape","basicStatsCallback","newValue","pointLPS","newArray","it","delta","delta_n","term1","basicGetStatistics","unit","stdDev","squaredDiffSum","skewness","variance","pow","kurtosis","median","sorted","mid","calculateMedian","named","freshState","BasicStatsCalculator","statsInit","statsCallback","InstanceBasicStatsCalculator","getCanvasEllipseCorners","ellipseCanvasPoints","bottom","top","left","right","distanceToPoint","lineStart","lineEnd","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","r3","r4","a2","b2","r1","r2","denom","num","rect","height","minDistance","lineSegments","rectToLineSegments","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","segmentSize","amountOfKnots","minKnotDistance","isNaN","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","getContinuousUniformDistributionValues","shouldSmooth","smoothing","smoothOnAdd","smoothOnEdit","followingIndex","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","pointA","pointB","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","changedIniIndex","changedEndIndex","filterAnnotationsForDisplay","filterOptions","VolumeViewport","spacingInNormalDirection","colonIndex","imageURI","substring","isReferenceViewable","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSamePlane","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","filterAnnotationsWithinSlice","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","getPointsInLineOfSight","pickedPoint","pointToPick","getIntensityFromWorld","normalDirection","step","bounds","getBounds","currentPos","_inBounds","xMin","xMax","yMin","yMax","zMin","zMax","padding","getWorldWidthAndHeightFromCorners","viewRight","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getWorldWidthAndHeightFromTwoPoints","worldPos1","worldPos2","isPlaneIntersectingAABB","origin","normal","minX","minY","minZ","maxX","maxY","maxZ","vertices","normalVec","originVec","planeDistance","initialSign","vertex","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","INTERPOLATED_ANNOTATIONS_REMOVED","nextAnnotation","viewportNewData","imageIndex","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","onComputationComplete","representations","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","segmentColor","getSegmentIndexColor","segmentationVisible","activeSegmentation","isActive","mergedConfig","getViewportIdsWithToolToRender","requireParallelNormals","viewports","getViewports","getViewport","vp","EdgeLocator","oriented","arguments","edgeMap","clear","computeEdgeKey","pointId0","pointId1","insertUniqueEdge","newEdgeValue","edgeId","insertEdge","isInsertedEdge","getEdgePointIds","vtkEdgeLocator","newInstance","MARCHING_SQUARES_CASES","EDGES","vtkCaseTable","getCase","getEdge","eid"],"sourceRoot":""}