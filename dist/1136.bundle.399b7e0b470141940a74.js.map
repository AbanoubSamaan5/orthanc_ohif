{"version":3,"file":"1136.bundle.399b7e0b470141940a74.js","mappings":"0JAIe,SAAS,EAACA,EAAgBC,GACrC,MAAMC,EAAQF,EAAeE,MAC7B,IAAKF,EAAeG,SAAWH,EAAeE,MAC1C,OAEJ,MAAME,GAAQ,SAQd,GAPAF,EAAMG,MAAQ,CACVC,sBAAuB,EACvBC,0CAA2C,EAC3CC,sBAAuB,EACvBC,gBAAiB,EACjBC,qBAAsB,GAEtBR,EAAO,CACP,IAAIS,EAAST,EAAMS,OACdA,IAEGA,EADAX,EAAeY,SAASC,SACf,IAEJX,EAAMY,MACF,IAGA,KAGjBH,EAAOX,EAAgBC,EAC3B,CACA,MAAMc,GAAiB,SAAQX,EAC/BF,EAAMG,MAAMI,eAAiBM,EAC7Bf,EAAegB,SAAU,EACzBhB,EAAeiB,aAAc,CACjC,C,8DCnCe,SAAS,EAACjB,EAAgBkB,GACrC,MAAMC,EAAY,IAAI,IACtB,IAAKnB,EAAeY,SAASQ,cACzB,OAAOD,EAEXA,EAAUE,UAAUrB,EAAeG,OAAOmB,MAAQ,EAAGtB,EAAeG,OAAOoB,OAAS,GACpF,MAAMC,EAAQxB,EAAeY,SAASa,SACxB,IAAVD,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,KAEzC,IAAIC,EAAa7B,EAAeY,SAASM,MACrCY,EAAc9B,EAAeY,SAASM,MAC1C,MAAMI,EAAQtB,EAAeY,SAASQ,cAAcW,KAAKC,GACpDhC,EAAeY,SAASQ,cAAca,KAAKD,EAAI,GAC9CT,EAASvB,EAAeY,SAASQ,cAAcW,KAAKG,GACrDlC,EAAeY,SAASQ,cAAca,KAAKC,EAAI,GACpD,GAAmE,SAA/DlC,EAAeY,SAASQ,cAAce,qBAClCnC,EAAeE,MAAMkC,gBACrBpC,EAAeE,MAAMmC,mBACrBR,GACI7B,EAAeE,MAAMmC,mBACjBrC,EAAeE,MAAMkC,gBAExBpC,EAAeE,MAAMmC,mBAC1BrC,EAAeE,MAAMkC,kBACrBN,GACI9B,EAAeE,MAAMkC,gBACjBpC,EAAeE,MAAMmC,yBAMjC,GAFAR,EAAa7B,EAAeY,SAASQ,cAAciB,mBACnDP,EAAc9B,EAAeY,SAASQ,cAAcgB,gBAEhD,iBADApC,EAAeY,SAASQ,cAAce,qBACtB,CAChB,MAAMG,EAAgBtC,EAAeG,OAAOoB,QAAUA,EAASO,GACzDS,EAAkBvC,EAAeG,OAAOmB,OAASA,EAAQO,GAC/DA,EAAaC,EAAcH,KAAKa,IAAID,EAAiBD,GACjDtC,EAAeY,SAASQ,cAAcgB,gBACtCpC,EAAeY,SAASQ,cAAciB,mBACtCR,GACI7B,EAAeY,SAASQ,cAAciB,mBAClCrC,EAAeY,SAASQ,cAAcgB,gBAEzCpC,EAAeY,SAASQ,cAAciB,mBAC3CrC,EAAeY,SAASQ,cAAcgB,kBACtCN,GACI9B,EAAeY,SAASQ,cAAcgB,gBAClCpC,EAAeY,SAASQ,cAAciB,mBAEtD,CAoBJ,OAlBAlB,EAAUD,MAAMW,EAAYC,GACd,IAAVN,GACAL,EAAUO,QAASF,EAAQG,KAAKC,GAAM,KAE1CT,EAAUE,UAAUrB,EAAeY,SAAS6B,YAAYT,EAAGhC,EAAeY,SAAS6B,YAAYP,GACjF,IAAVV,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,UAE3Bc,IAAVxB,GACAC,EAAUD,MAAMA,EAAOA,GAEvBlB,EAAeY,SAAS+B,OACxBxB,EAAUD,OAAO,EAAG,GAEpBlB,EAAeY,SAASgC,OACxBzB,EAAUD,MAAM,GAAI,GAExBC,EAAUE,WAAWC,EAAQ,GAAIC,EAAS,GACnCJ,CACX,C,0ECtEe,SAAS,EAAChB,EAAQD,EAAO2C,EAAUhC,GAC9C,QAAe6B,IAAXvC,EACA,MAAM,IAAI2C,MAAM,8DAEpB,QAAcJ,IAAVxC,EACA,OAAO,SAEX,MAAMgB,GAAQ,OAAiBf,EAAQD,EAAO,GAAG6C,YACjD,IAAIC,EAkBJ,MAjBiB,OAAbH,GAAqB3C,EAAM+C,YAC3BD,EAAM,CACFE,YAAa,EACbC,aAAc,UAGST,IAAtBxC,EAAMgD,kBACYR,IAAvBxC,EAAMiD,eACNH,EAAM,CACFE,YAAaE,MAAMC,QAAQnD,EAAMgD,aAC3BhD,EAAMgD,YAAY,GAClBhD,EAAMgD,YACZC,aAAcC,MAAMC,QAAQnD,EAAMiD,cAC5BjD,EAAMiD,aAAa,GACnBjD,EAAMiD,eAGb,CACHjC,QACAuB,YAAa,CACTT,EAAG,EACHE,EAAG,GAEPc,MACAM,OAAQpD,EAAMoD,OACdC,kBAAkB,EAClB9B,SAAU,EACVkB,OAAO,EACPC,OAAO,EACPY,YAAatD,EAAMsD,YACnBX,WACAY,OAAQvD,EAAMuD,OACd5C,cAAuB6B,IAAb7B,EAAyBA,EAAWX,EAAMW,SACpDO,cAAe,CACXa,KAAM,CACFD,EAAG,EACHE,EAAG,GAEPH,KAAM,CACFC,EAAG9B,EAAMwD,QACTxB,EAAGhC,EAAMyD,MAEbvB,qBAA2CM,IAA1BxC,EAAMkC,gBAAgC,EAAIlC,EAAMkC,gBACjEC,wBAAiDK,IAA7BxC,EAAMmC,mBAAmC,EAAInC,EAAMmC,mBACvEF,qBAAsB,QAGlC,C,ycC1DWyB,E,qKACX,SAAWA,GACPA,EAAuB,IAAI,MAC3BA,EAA4B,SAAI,WAChCA,EAA2B,QAAI,SAClC,CAJD,CAIGA,IAAsBA,EAAoB,CAAC,I,w5BCL9C,MAAMC,EAAmBC,OAAO,mBAC1BC,EAAmBD,OAAO,mBAC1BE,EAAsBF,OAAO,qBAC7BG,EAAaH,OAAO,cACX,MAAMI,EACjB,WAAAC,CAAYC,GACR,MAAMC,EAAaC,OAAOC,OAAQH,aAAgBF,GAAYD,KAAcG,EACtEA,EAAKH,GACL,MACNK,OAAOE,KAAKF,OAAOG,eAAeC,KAAMT,EAAY,CAChDU,MAAON,IAEf,CACA,GAAAO,CAAIC,EAAKF,GACL,OAAOC,EAAIF,KAAKT,GAAaY,EAAKF,EAAO,KAC7C,CACA,GAAAG,CAAID,GACA,OAmIR,SAAaR,EAAYQ,GACrB,OAAOR,EAAWQ,EACtB,CArIeC,CAAIJ,KAAKT,GAAaY,EACjC,CACA,KAAAE,CAAMF,GACF,OA8ER,SAAeR,EAAYW,GACvB,GAAIA,EAAKC,SAAS,KAAM,CACpB,IAAIC,EAAc,EAClB,MAAMC,EAAYH,EACZZ,EAAOe,EAAUC,MAAM,GAAI,GAC3BC,EAA4B,IAAhBjB,EAAKkB,OACvB,IAAK,MAAMT,KAAOR,EACVC,OAAOiB,UAAUC,eAAeC,KAAKpB,EAAYQ,KAChDQ,GAAaR,EAAIa,WAAWP,IAAcN,IAAQT,YAC5CC,EAAWQ,KAChBK,GAGV,OAAOA,EAAc,CACzB,CACA,cAAcb,EAAWW,EAC7B,CA9FeD,CAAML,KAAKT,GAAaY,EAAM,GACzC,CACA,OAAAc,CAAQC,GACJC,EAAQnB,KAAKT,GAAa2B,EAC9B,CACA,MAAAE,GACI,OAAO,IAAI5B,EAASQ,KACxB,CACA,MAAAqB,CAAOC,GACCC,EAAcD,IACd1B,OAAO4B,KAAKF,GAAML,SAASd,IACvBD,EAAIF,KAAKT,GAAaY,EAAKmB,EAAKnB,GAAM,KAAK,GAGvD,CACA,IAAAsB,GACI,MAAMC,EAAU,CAAC,EAMjB,OALAP,EAAQnB,KAAKT,IAAa,CAACY,EAAKF,UACP,IAAVA,GACP0B,EAAQD,EAASvB,EAAKF,EAC1B,IAEGyB,CACX,CACA,aAAOE,CAAOC,GACV,OAAOA,aAAmBrC,EACpBqC,EACArC,EAASsC,oBACnB,CACA,yBAAOC,CAAmBC,EAAW,MACjC,IAAIC,EAAkBzC,EAASL,GAK/B,GAJM8C,aAA2BzC,IAC7ByC,EAAkB,IAAIzC,EACtBA,EAASL,GAAoB8C,GAE7BD,EAAU,CACV,MAAME,EAAa,CAAC,EAOpB,OANAD,EAAgBhB,SAASX,IACrB,GAAIA,EAAKU,WAAWgB,GAAW,CAC3B,MAAMG,EAAU7B,EAAK8B,MAAM,GAAGJ,MAAa,GAC3CE,EAAWC,GAAWF,EAAgB7B,IAAIE,EAC9C,KAEG4B,CACX,CACA,OAAOD,CACX,CACA,yBAAOH,GACH,IAAIO,EAAkB7C,EAASH,GAK/B,OAJMgD,aAA2B7C,IAC7B6C,EAAkB,IAAI7C,EAASA,EAASuC,sBACxCvC,EAASH,GAAoBgD,GAE1BA,CACX,CACA,wBAAOC,CAAkBT,EAASU,GAC9B,IAAIC,EAAW,KACf,GAAIX,aAAmBrC,EACnBgD,EAAWX,OAEV,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACtD,IAAIY,EAAoBjD,EAASF,GAC3BmD,aAA6BC,UAC/BD,EAAoB,IAAIC,QACxBlD,EAASF,GAAuBmD,GAEpCD,EAAWC,EAAkBrC,IAAIyB,GAC3BW,aAAoBhD,IACtBgD,EAAW,IAAIhD,EAASA,EAASoC,OAAOpC,EAAS8C,kBAAkBC,KACnEE,EAAkBvC,IAAI2B,EAASW,GAEvC,CACA,OAAOA,CACX,CACA,4BAAOG,GACH,OAAOnD,EAASsC,qBAAqBV,QACzC,EAmBJ,SAASD,EAAQxB,EAAYuB,GACzB,IAAK,MAAMf,KAAOR,EACduB,EAASf,EAAKR,EAAWQ,GAEjC,CAmBA,SAASD,EAAIP,EAAYQ,EAAKF,EAAO2C,GACjC,QAYJ,SAAoBzC,GAChB,IAAI0C,EAAMC,EAASC,EACnB,GAAmB,iBAAR5C,IAAqB0C,EAAO1C,EAAIS,OAAS,GAAK,EACrD,OAAO,EAEXmC,GAAY,EACZ,MAAQD,EAAU3C,EAAI6C,QAAQ,IAAKD,EAAW,KAAO,GAAG,CACpD,GAAID,EAAUC,EAAW,GAAKD,IAAYD,EACtC,OAAO,EAEXE,EAAWD,CACf,CACA,OAAO,CACX,CAzBQG,CAAW9C,KACPoB,EAActB,GApB1B,SAAgBN,EAAYuD,EAAQC,EAAQP,GACxC,IAAIQ,EACJ,GAAIR,EAAWS,IAAIF,GACf,OAAOjD,EAAIP,EAAYuD,EAAQ,KAAMN,GAEzCA,EAAWU,IAAIH,GACfC,EAAY,EACZ,IAAK,MAAMG,KAASJ,EACZvD,OAAOiB,UAAUC,eAAeC,KAAKoC,EAAQI,KAExCrD,EAAIP,EADoB,IAAjB4D,EAAM3C,OAAesC,EAAS,GAAGA,KAAUK,IAC7BJ,EAAOI,GAAQX,MACnCQ,GAKd,OADAR,EAAWY,OAAOL,GACG,IAAdC,CACX,CAImBK,CAAO9D,EAAYQ,EAAKF,EAAO2C,aAAsBc,QAAUd,EAAa,IAAIc,UAE3F/D,EAAWQ,GAAOF,GACX,GAGf,CAkBA,SAASsB,EAAcM,GACnB,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACjD,MAAMhB,EAAYjB,OAAO+D,eAAe9B,GACxC,GAAIhB,IAAcjB,OAAOiB,WAA2B,OAAdA,EAClC,OAAO,CAEf,CACA,OAAO,CACX,CACA,SAASc,EAAQD,EAASvB,EAAKF,GAC3B,MAAM2D,EAAYzD,EAAI6C,QAAQ,KAC9B,GAAIY,GAAa,EAAG,CAChB,MAAMC,EAAS1D,EAAIO,MAAM,EAAGkD,GAC5B,IAAIE,EAAapC,EAAQmC,GACzB,GAA0B,iBAAfC,GAA0C,OAAfA,EAAqB,CACvD,MAAMC,EAAkBD,EACxBA,EAAa,CAAC,OACiB,IAApBC,IACPD,EAAW,IAAMC,GAErBrC,EAAQmC,GAAUC,CACtB,CACAnC,EAAQmC,EAAY3D,EAAIO,MAAMkD,EAAY,EAAGzD,EAAIS,QAASX,EAC9D,MAEIyB,EAAQvB,GAAOF,CAEvB,CACAT,EAASuC,qBAAqB7B,IAAI,cAAc,G,+pBCtLhD,MAAM8D,EAAe,CAAC,EACtB,IAAIC,EACJ,SAASC,EAAyBC,EAASC,GACvC,MAAMC,EAAwB,KAAMC,mBAAmBH,GACvD,GAAIE,EAEA,OADAE,EAAuBF,EAAsBG,QAASL,GAC/CE,EAEX,MAAMI,EAASN,EAAQ/B,MAAM,KAAK,GAC5BsC,EAASV,EAAaS,IAAWR,EACvC,IAAKS,EACD,MAAM,IAAItG,MAAM,+DAA+DqG,MAEnF,MAAME,EAAkBD,EAAOP,EAASC,GAExC,OADAG,EAAuBI,EAAgBH,QAASL,GACzCQ,CACX,CACA,SAASJ,EAAuBK,EAAcT,GAC1CU,QAAQC,QAAQF,GACXG,MAAMvJ,KAYf,SAA4BA,GACxB,IAAKA,EAAMwJ,aAAc,CACrB,MAAM,MAAEpI,EAAK,OAAEC,EAAM,mBAAEoI,GAAuBzJ,EACxCwJ,EAAe,IAAaE,wBAAwB,CACtDC,WAAY3J,EAAM4J,eAClBxI,QACAC,SACAoI,uBAEJzJ,EAAMwJ,aAAeA,EACrBxJ,EAAM4J,aAAe,IAAMJ,EAAaK,uBACjC7J,EAAM8J,WAAWC,SAC5B,CACJ,CAxBQC,CAAmBhK,IACnB,OAAa,IAAa,IAAOiK,aAAc,CAAEjK,SAAQ,IAExDkK,OAAOC,IACR,MAAMC,EAAe,CACjBzB,UACAwB,UAEJ,OAAa,IAAa,IAAOE,kBAAmBD,EAAa,GAEzE,CAeO,SAASE,EAAU3B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aACrE,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,sDAEpB,OAAO8F,EAAyBC,EAASC,GAASI,OACtD,CACO,SAASyB,EAAkB9B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aAC7E,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,8DAEpB,MAAMuG,EAAkBT,EAAyBC,EAASC,GAI1D,OAHK,KAAME,mBAAmBH,IAC1B,KAAM+B,mBAAmB/B,EAASQ,GAE/BA,EAAgBH,OAC3B,CACO,SAAS2B,EAAmBC,EAAUhC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aAC/E,IAAKI,GAAgC,IAApBA,EAASxF,OACtB,MAAM,IAAIxC,MAAM,oEAKpB,OAHoBgI,EAASC,KAAKlC,GACvB8B,EAAkB9B,EAASC,IAG1C,CACO,SAASkC,EAA2BC,EAAmBnC,EAAU,CAAC,GACrE,QAA0BpG,IAAtBuI,EACA,MAAM,IAAInI,MAAM,4EAEIJ,IAApBoG,EAAQD,UACRC,EAAQD,QAAU,YAAW,YAEjC,MAAM,QAAEA,EAAO,iBAAEqC,EAAgB,WAAEC,EAAU,oBAAEC,GAAwBtC,EACjEuC,EAAmB,MAAa,mBAAoBJ,GACpD3F,EAAS+F,EAAiB1H,KAAO0H,EAAiB3H,SAClD,sBAAE4H,IAA0B,OAAuBxC,EAAQyC,cAAcC,KAAMlG,GAC/EmG,EAAkB,IAAIH,EAAsBJ,EAAmB,EAAI5F,GACnEoG,EAAiB7C,EACjB8C,EAA+B,MAAa,mBAAoBV,GACtE,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,mBACNI,SAAUD,IAEd,MAAME,EAAuC,MAAa,sBAAuBZ,GACjF,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,sBACNI,SAAUC,IAEd,IAAwB7D,IAAI0D,EAAgB,CACxCF,KAAM,qBACNI,SAAU,CACNE,eAAgBhD,EAAQgD,kBAGhC,MAAMC,EAAmB,MAAa,mBAAoBd,GAC1D,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,mBACNI,SAAU,IACHG,EACHC,cAAe,EACfC,WAAY,EACZC,QAAS,EACTC,gBAAiB,EACjBC,oBAAqB,KAG7B,MAAMC,EAAaC,EAAyBzD,EAAS,CACjDgB,WAAY4B,EACZN,aACAD,mBACAK,aAAc,CACVC,KAAMC,EAAgBtH,YAAYa,MAEtCoG,sBACAmB,WAAY,CAAClB,EAAiB3H,QAAS2H,EAAiB1H,MACxD6I,QAAS,CACLnB,EAAiBhJ,mBACjBgJ,EAAiBjJ,iBAErBqK,OAAQpB,EAAiBqB,qBACzBC,UAAWtB,EAAiBuB,wBAC5BC,oBAAqBxB,EAAiBwB,oBACtC5B,kBAAmBA,IAMvB,OAJAoB,EAAWpB,kBAAoBA,EAC1B,KAAMjC,mBAAmBH,IAC1B,KAAMiE,aAAajE,EAASwD,GAEzBA,CACX,CACO,SAASU,EAA4BC,EAAoBlE,EAAU,CAAC,GACvE,GAAkC,IAA9BkE,EAAmB1H,OACnB,MAAM,IAAIxC,MAAM,6EAEpB,MAAMmK,EAAkB,GAaxB,OAZeD,EAAmBjC,KAAI,CAACE,EAAmBiC,KACtD,MAAMC,EAAa,CACftE,QAASC,GAASsE,oBAAoBnC,IAClC,YAAW,cACZnC,GAGP,OADAmE,EAAgBI,KAAKF,EAAWtE,SACzBmC,EAA2BC,EAAmB,IAC9CkC,EACHrB,eAAgBoB,EAAQ,GAC1B,GAGV,CACO,SAASZ,EAAyBzD,EAASC,GAC9C,MAAM,WAAEe,EAAU,OAAE4C,EAAM,UAAEE,EAAS,aAAEpB,EAAY,iBAAEL,EAAgB,WAAEC,EAAU,oBAAE0B,EAAmB,oBAAEzB,EAAmB,kBAAEH,GAAuBnC,EAC9IyD,EAAazD,EAAQyD,WACrBC,EAAU1D,EAAQ0D,QACxB,IAAKD,IAAeC,EAChB,MAAM,IAAI1J,MAAM,iEAEpB,MAAMxB,EAAQiL,EAAW,GACnBhL,EAASgL,EAAW,GACpBlK,EAAqBmK,EAAQ,GAC7BpK,EAAkBoK,EAAQ,GAC1BnB,EAAmB,CACrBwB,sBACAlJ,KAAMpC,EACNmC,QAASpC,EACTsL,wBAAyBD,GAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GACtDW,WAAYX,EAAYA,EAAUvH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GACvDmI,cAAeZ,EAAYA,EAAUvH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GAC1DsH,qBAAsBD,GAAU,CAAC,EAAG,EAAG,GACvCe,aAAc,CAACpL,EAAiBC,GAChCD,gBAAiBA,EACjBC,mBAAoBA,GAElBiD,EAAShE,EAAQC,EACjBoI,EAAqBE,EAAWvE,OAASA,EAC/C,IAAImI,EAeAzB,EAAeC,EAAYC,EAd/B,GAAIrC,EAAY,CACZ,KAAMA,aAAsB6D,YACxB7D,aAAsB8D,cACtB9D,aAAsB+D,aACtB/D,aAAsBgE,YACtB,MAAM,IAAI/K,MAAM,4GAEpB2K,EAAkB5D,CACtB,MACK,IAAKqB,EAAkB,CACxB,MAAM,sBAAEI,IAA0B,OAAuBC,GAAcC,KAAMlG,GAE7EmI,EADwB,IAAInC,EAAsBhG,EAEtD,CAEA,GAAImI,aAA2BC,WAC3B1B,EAAgB,EAChBC,EAAa,EACbC,EAAU,OAET,GAAIuB,aAA2BG,YAChC5B,EAAgB,GAChBC,EAAa,GACbC,EAAU,QAET,GAAIuB,aAA2BI,WAChC7B,EAAgB,GAChBC,EAAa,GACbC,EAAU,OAET,MAAIuB,aAA2BE,cAMhC,MAAM,IAAI7K,MAAM,+BALhBkJ,EAAgB,GAChBC,EAAa,GACbC,EAAU,EAId,CACA,MAAMH,EAAmB,CACrBI,gBAAiB,EACjB2B,0BAA2BL,EAAgBnI,OAASiH,EAAW,GAAKA,EAAW,GACzE,MACA,cACN5I,KAAMpC,EACNmC,QAASpC,EACT0K,gBACAC,aACAC,WAEEN,EAAW,CACbP,mBACAU,oBAEJ,CAAC,mBAAoB,oBAAoBpG,SAAS6F,IAC9C,IAAwBxD,IAAIa,EAAS,CACjC2C,OACAI,SAAUA,EAASJ,IAAS,CAAC,GAC/B,IAEN,MAAMuC,EAAKlF,EACLa,EAAgB0B,IAAwB,IAAiB4C,KAC3D,IAAaC,2BAA2B,CAAE1B,aAAYwB,QACtD,IAAanE,wBAAwB,CACjCrI,SACAD,QACAqI,qBACAE,WAAY4D,EACZM,OAER,IAAIG,EAAgBT,EAAgB,GAChCU,EAAgBV,EAAgB,GACpC,IAAK,IAAIW,EAAI,EAAGA,EAAIX,EAAgBnI,OAAQ8I,IACpCX,EAAgBW,GAAKF,IACrBA,EAAgBT,EAAgBW,IAEhCX,EAAgBW,GAAKD,IACrBA,EAAgBV,EAAgBW,IAGxC,MAAMlO,EAAQ,CACV2I,QAASA,EACTwF,UAAW,EACXlL,aAAc,EACdD,YAAa,EACbpC,MAAsD,QAA/CiL,EAAiB+B,0BACxBnE,mBAAoBoC,EAAiBI,gBACrCmC,SAAU/C,GAAcC,KACxB+C,MAAO,EACPL,gBACAC,gBACAxK,KAAMoI,EAAiBpI,KACvBD,QAASqI,EAAiBrI,QAC1B8K,eAAW9L,EACXnB,OAAQwK,EAAiBpI,KACzBrC,MAAOyK,EAAiBrI,QACxB+K,UAAM/L,EACNL,mBAAoBgJ,EAAiBhJ,mBACrCD,gBAAiBiJ,EAAiBjJ,gBAClCsM,oBAAqBrD,EAAiBwB,oBACtCvJ,QAAQ,EACRwG,aAAc,IAAMJ,EAAaK,gBACjCL,eACAiF,YAAa9E,EAAW+E,WACxB3D,qBAIJ,OAFAE,IAAajL,GACb,KAAM4M,aAAa5M,EAAM2I,QAAS3I,GAC3BA,CACX,CACO,SAAS2O,EAAgBhG,GAO5B,IAAqBiG,gBANE,EAAGC,wBAClBA,EAAkBlG,SACXkG,EAAkBlG,UAAYA,IAK7C,MAAMQ,EAAkB,KAAML,mBAAmBH,GAC7CQ,GACAA,EAAgB2F,UAExB,CACO,SAASC,EAAiBnE,GAC7BA,EAASnF,SAASkD,IACdgG,EAAgBhG,EAAQ,GAEhC,CACO,SAASqG,IACZ,MAAMC,EAAc,IAAqBC,iBACzC9K,OAAO4B,KAAKiJ,GAAaxJ,SAAS6F,IAC9B,MAAM6D,EAAWF,EAAY3D,GAC7BlH,OAAO4B,KAAKmJ,GAAU1J,SAAS8E,IAC3B,MAAM6E,EAAiBD,EAAS5E,GAAU8E,MAC1C,IAAKD,EACD,OAEJ,MAAMP,EAAoBO,EAAeP,mBACnC,QAAElG,EAAO,SAAE2G,GAAaT,EAC9B,IAAIU,EACA5G,EACA4G,EAAa,KAAMzG,mBAAmBH,GAEjC2G,IACLC,EAAa,KAAMC,oBAAoBF,IAEvCC,GACAA,EAAWE,QACf,IAEJ,IAAqBC,kBAAkBpE,EAAK,GAEpD,CACO,SAASqE,EAAoB1G,EAAQ2G,GACxCpH,EAAaS,GAAU2G,CAC3B,CACO,SAASC,EAA2BD,GACvC,MAAME,EAAiBrH,EAEvB,OADAA,EAAqBmH,EACdE,CACX,CACO,SAASC,IACZ3L,OAAO4B,KAAKwC,GAAc/C,SAASmK,UAAuBpH,EAAaoH,KACvEnH,OAAqBjG,CACzB,CACO,SAASwN,EAAoClD,EAAoBlE,EAAU,CAAC,GAC/E,OAAOiE,EAA4BC,EAAoB,IAChDlE,EACHyC,aAAc,CAAEC,KAAM,eAE9B,CACO,SAAS2E,EAAmClF,EAAmBnC,EAAU,CAAC,GAC7E,OAAOkC,EAA2BC,EAAmB,IAC9CnC,EACHyC,aAAc,CAAEC,KAAM,eAE9B,C,gDC9We,MAAM4E,SACR1L,KAAK2L,oBAAsB,yCAA2C,CAC/E,sBAAOC,CAAgBzH,GACnB,MAAM0H,EAAQ1H,EAAQ0H,MAAM7L,KAAK2L,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMC,EAAQD,EAAM,GAAGzJ,MAAM,KAAKiE,KAAK0F,GAAOC,OAAOD,KACrD,OAAqB,IAAjBD,EAAMlL,OACCkL,EAAM,GAEVA,CACX,CACA,wBAAOG,CAAkB9H,GACrB,MAAM2H,EAAQ9L,KAAK4L,gBAAgBzH,GACnC,OAAOzF,MAAMC,QAAQmN,GAASA,EAAM,GAAKA,CAC7C,CACA,0BAAOI,CAAoB/H,GACvB,MAAM2H,EAAQ9L,KAAK4L,gBAAgBzH,GACnC,OAAOzF,MAAMC,QAAQmN,GAASA,EAAM,GAAKA,CAC7C,CACA,qBAAOK,CAAeL,GAClB,OAAIpN,MAAMC,QAAQmN,GACP,GAAGA,EAAM,MAAMA,EAAM,KAEzBM,OAAON,EAClB,CACA,sBAAOO,CAAgBlI,EAAS2H,GAC5B,MAAMD,EAAQ1H,EAAQ0H,MAAM7L,KAAK2L,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMS,EAAiBtM,KAAKmM,eAAeL,GAC3C,OAAO3H,EAAQoI,QAAQvM,KAAK2L,oBAAqB,GAAGE,EAAM,KAAKS,IACnE,E,gDClCW,MAAME,EACjB,WAAA/M,CAAYgN,EAAgB,CAAC,GACzBzM,KAAK0M,YAAc,EACnB1M,KAAK2M,QAAU,EACf3M,KAAK4M,UAAY,EACjB5M,KAAK6M,SAAW,IAChB,MAAM,YAAEC,EAAc,KAAI,WAAEjF,EAAa,EAAC,SAAEgF,EAAW,KAASJ,EAC1DM,EAAaD,EAAcjF,EACjC7H,KAAK6M,SAAWA,EAChB7M,KAAKgN,MAAQ,IAAIC,YAAYF,EAAa/M,KAAK4M,WAC/C5M,KAAKkN,KAAO,IAAIjE,aAAajJ,KAAKgN,OAClChN,KAAK0M,YAAc7E,CACvB,CACA,OAAA5G,CAAQkM,GACJ,IAAK,IAAIzD,EAAI,EAAGA,EAAI1J,KAAK2M,QAASjD,IAC9ByD,EAAKnN,KAAKoN,SAAS1D,GAAIA,EAE/B,CACA,UAAI9I,GACA,OAAOZ,KAAK2M,OAChB,CACA,cAAI9E,GACA,OAAO7H,KAAK0M,WAChB,CACA,mBAAIW,GACA,OAAOrN,KAAK2M,QAAU3M,KAAK0M,WAC/B,CACA,QAAAU,CAAS5E,GAIL,GAHIA,EAAQ,IACRA,GAASxI,KAAK2M,SAEdnE,EAAQ,GAAKA,GAASxI,KAAK2M,QAC3B,OAEJ,MAAMW,EAAStN,KAAK0M,YAAclE,EAClC,OAAOxI,KAAKkN,KAAKK,SAASD,EAAQA,EAAStN,KAAK0M,YACpD,CACA,aAAAc,CAAchF,GACV,MAAMwE,EAAQ,GAId,GAHIxE,EAAQ,IACRA,GAASxI,KAAK2M,SAEdnE,EAAQ,GAAKA,GAASxI,KAAK2M,QAC3B,OAEJ,MAAMW,EAAStN,KAAK0M,YAAclE,EAClC,IAAK,IAAIkB,EAAI,EAAGA,EAAI1J,KAAK0M,YAAahD,IAClCsD,EAAMrE,KAAK3I,KAAKkN,KAAKxD,EAAI4D,IAE7B,OAAON,CACX,CACA,IAAAS,CAAKC,EAAiB,EAAGb,EAAW7M,KAAK6M,UACrC,GAAI7M,KAAKqN,gBAAkBK,EAAiB1N,KAAK0M,aAC7C1M,KAAKkN,KAAKtM,OACV,OAEJ,MAAM+M,EAAU3N,KAAKkN,KAAKtM,OAASiM,EAC7Be,EAAW,IAAIX,YAAYU,EAAU3N,KAAK0M,YAAc1M,KAAK4M,WAC7DiB,EAAU,IAAI5E,aAAa2E,GACjCC,EAAQ3N,IAAIF,KAAKkN,MACjBlN,KAAKkN,KAAOW,EACZ7N,KAAKgN,MAAQY,CACjB,CACA,OAAAE,GACI,MAAMC,EAAY9Q,KAAK+Q,MAAMhO,KAAK2M,QAAU,GAC5C,IAAK,IAAIjD,EAAI,EAAGA,EAAIqE,EAAWrE,IAAK,CAChC,MAAMuE,EAAavE,EAAI1J,KAAK0M,YACtBwB,GAAYlO,KAAK2M,QAAU,EAAIjD,GAAK1J,KAAK0M,YAC/C,IAAK,IAAIyB,EAAY,EAAGA,EAAYnO,KAAK0M,YAAayB,IAAa,CAC/D,MAAMC,EAAapO,KAAKkN,KAAKe,EAAaE,GAC1CnO,KAAKkN,KAAKe,EAAaE,GAAanO,KAAKkN,KAAKgB,EAAWC,GACzDnO,KAAKkN,KAAKgB,EAAWC,GAAaC,CACtC,CACJ,CACJ,CACA,aAAAC,GACI,OAAOrO,KAAKkN,IAChB,CACA,IAAAvE,CAAK2F,GACDtO,KAAKyN,KAAK,GACV,MAAMH,EAAStN,KAAKY,OAASZ,KAAK0M,YAClC,IAAK,IAAIhD,EAAI,EAAGA,EAAI1J,KAAK0M,YAAahD,IAClC1J,KAAKkN,KAAKxD,EAAI4D,GAAUgB,EAAM5E,GAElC1J,KAAK2M,SACT,CACA,GAAAtG,CAAIkI,GACA,MAAMC,EAAU,GAChB,IAAK,IAAI9E,EAAI,EAAGA,EAAI1J,KAAK2M,QAASjD,IAC9B8E,EAAQ7F,KAAK4F,EAAEvO,KAAKoN,SAAS1D,GAAIA,IAErC,OAAO8E,CACX,CACA,UAAIC,GACA,OAAOzO,KAAKqG,KAAKqI,GAAMA,GAC3B,CACA,KAAAC,GACI,MAAMC,EAAM,CAAEtR,EAAG,GAAIE,EAAG,IACpBwC,KAAK0M,aAAe,IACpBkC,EAAIC,EAAI,IAEZ,MAAM,EAAEvR,EAAC,EAAEE,EAAC,EAAEqR,GAAMD,EAQpB,OAPA5O,KAAKiB,SAASyN,IACVpR,EAAEqL,KAAK+F,EAAE,IACTlR,EAAEmL,KAAK+F,EAAE,IACLG,GACAA,EAAElG,KAAK+F,EAAE,GACb,IAEGE,CACX,CACA,cAAOE,EAAQ,EAAExR,EAAC,EAAEE,EAAC,EAAEqR,IACnB,MAAM7B,EAAQR,EAAcuC,QAAQzR,EAAEsD,QACtC,IAAI0M,EAAS,EACb,IAAK,IAAI5D,EAAI,EAAGA,EAAIpM,EAAEsD,OAAQ8I,IAC1BsD,EAAME,KAAKI,KAAYhQ,EAAEoM,GACzBsD,EAAME,KAAKI,KAAY9P,EAAEkM,GACzBsD,EAAME,KAAKI,KAAYuB,EAAIA,EAAEnF,GAAK,EAGtC,OADAsD,EAAML,QAAUrP,EAAEsD,OACXoM,CACX,CACA,SAAAgC,CAAUC,EAAQ,GAAI3B,EAAS,GAC3B,MAAM4B,EAAW,IAAI1C,EAAc,CAC/BM,YAAamC,EACbpH,WAAY7H,KAAK0M,cAErB,IAAK,IAAIhD,EAAI,EAAGA,EAAIuF,EAAOvF,IAAK,CAC5B,MAAMlB,GAAS8E,EAASrQ,KAAK+Q,MAAOhO,KAAKY,OAAS8I,EAAKuF,IAAUjP,KAAKY,OACtEsO,EAASvG,KAAK3I,KAAKoN,SAAS5E,GAChC,CACA,OAAO0G,CACX,CACA,cAAOH,CAAQjC,EAAc,IAAK2B,GAC9B3B,EAAc7P,KAAKkS,IAAIrC,EAAa2B,GAAQ7N,QAAU,GACtD,MAAMwO,EAAY,IAAI5C,EAAc,CAAEM,cAAajF,WAAY,IAI/D,OAHI4G,GACAA,EAAOxN,SAASqN,GAAUc,EAAUzG,KAAK2F,KAEtCc,CACX,CACA,cAAOC,CAAQvC,EAAc,KACzB,OAAO,IAAIN,EAAc,CAAEM,cAAajF,WAAY,GACxD,E,gDC7IW,MAAMyH,EACjB,WAAA7P,CAAYa,GACRN,KAAKM,KAAOA,GAAQ,SACxB,CACA,SAAOiP,CAAG/K,GACN,GAAIA,EAAQgL,SACR,OAAOhL,EAAQgL,SAEnB,MAAMA,EAAW,IAAIF,EAAoB,eAWzC,OAVA9K,EAAQO,MAAM0K,IACV,IACID,EAASlM,IAAImM,GAAG,EACpB,CACA,MAAOC,GACHF,EAASG,OAAOD,EACpB,KACAE,IACAJ,EAASG,OAAOC,EAAO,IAEpBJ,CACX,CACA,GAAAlM,CAAIhG,EAAGuS,GAAO,GACV7P,KAAK8P,UAAYxS,EACjB0C,KAAK6P,OAASA,EACV7P,KAAK+P,UACL/P,KAAK+P,QAAQjL,QAAQxH,GACrB0C,KAAK+P,aAAU/R,EAEvB,CACA,OAAA8G,GACI9E,KAAK6P,MAAO,EACR7P,KAAK+P,UACL/P,KAAK+P,QAAQjL,QAAQ9E,KAAK8P,WAC1B9P,KAAK+P,aAAU/R,EAEvB,CACA,MAAA2R,CAAOC,GACH5P,KAAKgQ,aAAeJ,EACpB5P,KAAK+P,SAASJ,OAAOC,EACzB,CACA,SAAAK,GACI,GAAIjQ,KAAKgQ,aACL,MAAMhQ,KAAKgQ,aAEf,OAAOhQ,KAAK8P,SAChB,CACA,OAAQ1Q,OAAO8Q,iBACX,MAAQlQ,KAAK6P,MAAM,CACf,GAAI7P,KAAKgQ,aACL,MAAMhQ,KAAKgQ,aAEf,QAAuBhS,IAAnBgC,KAAK8P,kBACC9P,KAAK8P,UACP9P,KAAK6P,MACL,MAGH7P,KAAK+P,UACN/P,KAAK+P,QAAU,CAAC,EAChB/P,KAAK+P,QAAQvL,QAAU,IAAIK,SAAQ,CAACC,EAAS6K,KACzC3P,KAAK+P,QAAQjL,QAAUA,EACvB9E,KAAK+P,QAAQJ,OAASA,CAAM,WAG9B3P,KAAK+P,QAAQvL,OACvB,OACMxE,KAAK8P,SACf,CACA,aAAM7O,CAAQC,EAAUiP,GACpB,IAAI3H,EAAQ,EACZ,IACI,UAAW,MAAMvI,KAASD,KAAM,CAC5B,MAAM,KAAE6P,GAAS7P,KACjB,UACUkB,EAASjB,EAAO4P,EAAMrH,GAC5BA,GACJ,CACA,MAAOkH,GACH,IAAKG,EAAM,CACPO,QAAQC,KAAK,yCAA0CX,GACvD,QACJ,CACA,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,EAAGG,EAKzB,CACJ,CACJ,CACA,MAAOH,GACH,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,GAAG,EAKzB,CACJ,CACA,QAAAY,CAASC,EAAiBJ,GACtB,OAAOI,EAAgBvQ,KAAMA,KAAK2P,OAAOa,KAAKxQ,OAAO+E,MAAK,KACjD/E,KAAK6P,MACN7P,KAAK8E,SACT,IACA8K,IACA5P,KAAK2P,OAAOC,GACRO,EACAA,EAAcP,GAGdQ,QAAQC,KAAK,2BAA4BT,EAC7C,GAER,CACA,iBAAMa,GACF,UAAW,MAAM/G,KAAK1J,KAClB,GAAI0J,EACA,OAAOA,EAGf,OAAO1J,KAAK8P,SAChB,CACA,iBAAMY,GACF,UAAW,MAAMhH,KAAK1J,MAEtB,OAAOA,KAAK8P,SAChB,CACA,cAAAa,GACI,MAAMnM,EAAUxE,KAAKyQ,cAErB,OADAjM,EAAQgL,SAAWxP,KACZwE,CACX,CACA,cAAAoM,GACI,MAAMpM,EAAUxE,KAAK0Q,cAErB,OADAlM,EAAQgL,SAAWxP,KACZwE,CACX,E,gDC3IJ,MAAMqM,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IAELC,EAAwB,CAC1B,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,IAELC,EAAc,CAChB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,IAENC,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEI,MAAMC,EACjB,cAAOC,CAAQC,EAAaC,GACxB,IAAK,MAAO5I,EAAO6I,KAAQD,EAAOnS,KAC9BkS,EAAYlS,KAAKiB,IAAIsI,EAAO8I,gBAAgBD,GAEpD,CACA,WAAA5R,CAAY7C,EAAOC,EAAQ0U,EAAQ,GAC/BvR,KAAKf,KAAO,IAAIuS,IAChBxR,KAAKnD,OAAS,EACdmD,KAAKpD,MAAQ,EACboD,KAAKuR,MAAQ,EACbvR,KAAKyR,UAAY,EACjBzR,KAAK0R,UAAY,EACjB1R,KAAK2R,SAAW,EAChB3R,KAAK4R,qBAAuB5I,WAC5BhJ,KAAK6R,iBAAmB,SAAU1M,GAC9BA,EAAW2M,KAAK,GAOhB9R,KAAKiB,SANY,CAACuH,EAAOuJ,EAAKV,KAC1B,MAAM,MAAE3V,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,IACzBvE,EAAWqD,EAAQkB,GAAKzJ,CAC5B,GAGR,EACAD,KAAKI,IAAOoI,IACR,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UACjBQ,GAAKzJ,EAAQkB,GAAK1J,KAAKyR,UACvBM,EAAM/R,KAAKkS,OAAOxI,EAAGuI,GAC3B,OAAOF,GAAK9R,OAASD,KAAKmS,YAAY,EAE1CnS,KAAKoS,OAAS,CAACH,EAAGI,KACd,MAAMC,EAAWL,EAAII,EAAIrS,KAAKnD,OAC9B,OAAOmD,KAAKf,KAAKmB,IAAIkS,EAAS,EAElCtS,KAAKE,IAAM,CAACsI,EAAOvI,KACf,QAAcjC,IAAViC,EACA,OAEJ,MAAMyJ,EAAIlB,EAAQxI,KAAKpD,MACjBqV,GAAKzJ,EAAQkB,GAAK1J,KAAKpD,MACvByU,EAAMrR,KAAKf,KAAKmB,IAAI6R,GAC1B,IAAKZ,EAED,YADArR,KAAKf,KAAKiB,IAAI+R,EAAG,CAAC,CAAEvW,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,WAG9C,MAAMsS,EAAWvS,KAAKwS,UAAUnB,EAAK3H,GAC/B+I,EAAOpB,EAAIkB,GACXG,EAAOrB,EAAIkB,EAAW,GAC5B,IAAKE,EACD,OAAKC,GAAQA,EAAKzS,QAAUA,GAASyS,EAAKV,MAAQtI,OAIlDgJ,EAAKV,WAHDX,EAAIkB,GAAY,CAAE7W,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,UAMhD,MAAM,MAAEvE,EAAK,IAAEsW,EAAK/R,MAAO0S,GAAaF,EACxC,GAAIxS,IAAU0S,GAAYjJ,GAAKhO,EAC3B,OAEJ,MAAMkX,EAAY,CAAElX,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,SACpC4S,EAAUnJ,EAAIhO,EACdoX,EAAcD,EAAUN,EAAW,EAAIA,EACvCQ,EAAUF,EAAUJ,EAAOC,EACjC,IAAIM,EAAUH,EAAUxB,EAAIkB,EAAW,GAAKE,EAC5C,GAAIM,GAAS9S,QAAUA,GAAS8S,GAASf,MAAQtI,EAiB7C,OAhBAqJ,EAAQf,WACJgB,GAAS/S,QAAUA,GAAS+S,EAAQtX,QAAUgO,EAAI,GAClDqJ,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,IAEhBS,GAAStX,QAAUgO,IACxBsJ,EAAQtX,QACJsX,EAAQtX,QAAUsX,EAAQhB,MAC1BX,EAAI4B,OAAOV,EAAU,GACrBS,EAAU3B,EAAIkB,GACVS,GAAStX,QAAUgO,EAAI,GAAKsJ,EAAQ/S,QAAUA,IAC9C8S,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,OAMrC,GAAIS,GAAS/S,QAAUA,GAAS+S,EAAQtX,QAAUgO,EAAI,EAQlD,OAPAsJ,EAAQtX,aACJqX,GAASf,IAAMtI,IACfqJ,EAAQf,IAAMtI,EACVqJ,EAAQf,MAAQe,EAAQrX,OACxB2V,EAAI4B,OAAOV,EAAU,KAKjC,GAAIS,GAAStX,QAAUgO,GAAKsJ,EAAQhB,MAAQtI,EAAI,EAS5CA,IAAMsJ,GAAStX,OACfsX,EAAQtX,QAERmX,GAAWb,EAAMtI,EAAI,EACrB2H,EAAI4B,OAAOH,EAAa,EAAGF,EAAW,CAClClX,MAAOgO,EAAI,EACXsI,IAAKe,EAAQf,IACb/R,MAAO8S,EAAQ9S,QAInBoR,EAAI4B,OAAOH,EAAa,EAAGF,GAE3BG,GAASf,IAAMtI,IACfqJ,EAAQf,IAAMtI,OAvBlB,CACIsJ,EAAQ/S,MAAQA,EAChB,MAAMiT,EAAW7B,EAAIkB,EAAW,GAC5BW,GAAUxX,OAASgO,EAAI,GAAKwJ,EAASjT,QAAUA,IAC/CoR,EAAI4B,OAAOV,EAAW,EAAG,GACzBS,EAAQhB,IAAMkB,EAASlB,IAG/B,CAgBA,EAEJhS,KAAKpD,MAAQA,EACboD,KAAKnD,OAASA,EACdmD,KAAKuR,MAAQA,EACbvR,KAAKyR,UAAY7U,EACjBoD,KAAK0R,UAAY1R,KAAKyR,UAAY5U,CACtC,QACSmD,KAAKqF,cAAgB,SAAU8N,EAAYC,mBAChD,MAAMjO,EAAa,IAAIgO,EAAUnT,KAAKqT,WAEtC,OADArT,KAAKqG,IAAIwL,iBAAiB1M,GACnBA,CACX,CAAG,CACH,KAAAmO,CAAM9K,GACF,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UAGvB,MAAO,CAAC/H,GAFIlB,EAAQkB,GAAK1J,KAAKyR,UAAazR,KAAKnD,OACtCI,KAAK+Q,MAAMxF,EAAQxI,KAAK0R,WAEtC,CACA,OAAA6B,EAAS7J,EAAGuI,EAAGI,IACX,OAAO3I,EAAI2I,EAAIrS,KAAK0R,UAAYO,EAAIjS,KAAKyR,SAC7C,CACA,MAAAS,CAAOxI,EAAGuI,EAAGI,EAAI,GACb,MAAMhB,EAAMrR,KAAKf,KAAKmB,IAAI6R,EAAII,EAAIrS,KAAKnD,QACvC,IAAKwU,EACD,OAEJ,MACMU,EAAMV,EADErR,KAAKwS,UAAUnB,EAAK3H,IAElC,OAAOA,GAAKqI,GAAKrW,MAAQqW,OAAM/T,CACnC,CACA,GAAAqF,CAAImF,GACA,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UACjBQ,GAAKzJ,EAAQkB,GAAK1J,KAAKyR,UACvBM,EAAM/R,KAAKkS,OAAOxI,EAAGuI,GAC3B,YAAsBjU,IAAf+T,GAAK9R,KAChB,CACA,OAAOuI,GACH,MAAMkB,EAAIlB,EAAQxI,KAAKpD,MACjBqV,GAAKzJ,EAAQkB,GAAK1J,KAAKpD,MACvByU,EAAMrR,KAAKf,KAAKmB,IAAI6R,GAC1B,IAAKZ,EACD,OAEJ,MAAMkB,EAAWvS,KAAKwS,UAAUnB,EAAK3H,GAC/BqI,EAAMV,EAAIkB,GAChB,IAAKR,GAAOA,EAAIrW,MAAQgO,EACpB,OAEJ,GAAIqI,EAAIC,MAAQtI,EAAI,EAQhB,OAPAqI,EAAIC,WACAD,EAAIrW,OAASqW,EAAIC,MACjBX,EAAI4B,OAAOV,EAAU,GAChBlB,EAAIzQ,QACLZ,KAAKf,KAAKuE,OAAOyO,KAK7B,GAAIF,EAAIrW,QAAUgO,EAEd,YADAqI,EAAIrW,QAGR,MAAM8X,EAAS,CACXvT,MAAO8R,EAAI9R,MACXvE,MAAOgO,EAAI,EACXsI,IAAKD,EAAIC,KAEbD,EAAIC,IAAMtI,EACV2H,EAAI4B,OAAOV,EAAW,EAAG,EAAGiB,EAChC,CACA,SAAAhB,CAAUnB,EAAK3H,GACX,IAAK,IAAIlB,EAAQ,EAAGA,EAAQ6I,EAAIzQ,OAAQ4H,IAAS,CAC7C,MAAQwJ,IAAKyB,GAASpC,EAAI7I,GAC1B,GAAIkB,EAAI+J,EACJ,OAAOjL,CAEf,CACA,OAAO6I,EAAIzQ,MACf,CACA,OAAAK,CAAQC,EAAUkD,GACd,MAAMsP,EAActP,GAASsP,YAC7B,IAAK,MAAOC,EAAWtC,KAAQrR,KAAKf,KAAM,CACtC,MAAM2U,EAAWF,EAAc,IAAIrC,GAAOA,EAC1C,IAAK,MAAMU,KAAO6B,EACd1S,EAASyS,EAAY3T,KAAKpD,MAAOmV,EAAKV,EAE9C,CACJ,CACA,UAAAwC,CAAW3S,GACP,IAAK,MAAOyS,EAAWtC,KAAQrR,KAAKf,KAChCiC,EAASyS,EAAY3T,KAAKpD,MAAOyU,EAEzC,CACA,KAAAyC,GACI9T,KAAKf,KAAK6U,OACd,CACA,IAAAtS,GACI,MAAO,IAAIxB,KAAKf,KAAKuC,OACzB,CACA,YAAA4D,CAAaiN,EAAI,EAAG9M,GACXA,EAIDA,EAAUuM,KAAK,GAHfvM,EAAY,IAAIvF,KAAK4R,qBAAqB5R,KAAKpD,MAAQoD,KAAKnD,OAASmD,KAAK2R,UAK9E,MAAM,MAAE/U,EAAK,OAAEC,EAAM,SAAE8U,GAAa3R,KACpC,IAAK,IAAIiS,EAAI,EAAGA,EAAIpV,EAAQoV,IAAK,CAC7B,MAAMZ,EAAMrR,KAAKoS,OAAOH,EAAGI,GAC3B,GAAKhB,EAGL,GAAiB,IAAbM,EACA,IAAK,MAAMI,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAIrV,GAChB,MAAElB,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,IACzBnE,EAAUwO,EAAYrK,GAAKzJ,CAEnC,MAGA,IAAK,MAAM8R,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAIrV,EAAQ+U,GACxB,MAAEjW,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,GAAKiI,EAC9B,IAAK,IAAIqC,EAAO,EAAGA,EAAOrC,EAAUqC,IAChCzO,EAAUwO,EAAYrK,EAAIsK,GAAQ/T,EAAM+T,EAGpD,CAER,CACA,OAAOzO,CACX,CACA,SAAA0O,CAAUvK,EAAGuI,EAAGI,EAAGpS,EAAOmE,GACtB,MAAM2N,EAAM/R,KAAKkS,OAAOxI,EAAGuI,EAAGI,GAC9B,IAAKN,EACD,MAAM,IAAI3T,MAAM,iBAAiBsL,KAAKuI,KAAKI,sBAE/C,MAAM6B,EAAQ,CAAC,CAACnC,EAAKE,EAAGI,IAClB8B,EAAepC,EAAI9R,MACzB,GAAIkU,IAAiBlU,EACjB,MAAM,IAAI7B,MAAM,WAAW+V,uBAAkClU,oBAEjE,OAAOD,KAAKoU,MAAMF,EAAOC,EAAclU,EAAOmE,EAClD,CACA,KAAAgQ,CAAMF,EAAOG,EAAapU,EAAOmE,GAC7B,IAAIkQ,EAAM,EACV,MAAM,OAAEC,GAAS,EAAI,UAAEC,GAAY,EAAI,YAAEC,GAAc,GAAWrQ,GAAW,CAAC,EACxEsQ,EAAe,CAAEH,SAAQC,YAAWC,eAC1C,KAAOP,EAAMtT,QAAQ,CACjB,MAAM+T,EAAMT,EAAMrJ,OACX/H,GAAW6R,EAClB,GAAI7R,EAAQ7C,QAAUoU,EAClB,SAEJvR,EAAQ7C,MAAQA,EAChBqU,GAAOxR,EAAQkP,IAAMlP,EAAQpH,MAC7B,MAAMkZ,EAAY5U,KAAK6U,cAAcF,EAAKD,GAAcI,QAAQC,GAAaA,GAAYA,EAAS,GAAG9U,QAAUoU,IAC/GH,EAAMvL,QAAQiM,EAClB,CACA,OAAON,CACX,CACA,QAAAU,CAASC,EAAQC,GACb,IAAK,IAAI7C,EAAI6C,EAAU,GAAG,GAAI7C,GAAK6C,EAAU,GAAG,GAAI7C,IAChD,IAAK,IAAIJ,EAAIiD,EAAU,GAAG,GAAIjD,GAAKiD,EAAU,GAAG,GAAIjD,IAAK,CACrD,IAAIF,EACAV,EACJ,IAAK,IAAI3H,EAAIwL,EAAU,GAAG,GAAIxL,GAAKwL,EAAU,GAAG,GAAIxL,IAAK,CACrD,MAAMzJ,EAAQgV,EAAOvL,EAAGuI,EAAGI,QACbrU,IAAViC,GAICoR,IACDA,EAAM,GACNrR,KAAKf,KAAKiB,IAAI+R,EAAII,EAAIrS,KAAKnD,OAAQwU,IAEnCU,GAAOA,EAAI9R,QAAUA,IACrB8R,OAAM/T,GAEL+T,IACDA,EAAM,CAAErW,MAAOgO,EAAGsI,IAAKtI,EAAGzJ,SAC1BoR,EAAI1I,KAAKoJ,IAEbA,EAAIC,OAdAD,OAAM/T,CAed,CACJ,CAER,CACA,aAAA6W,CAAcM,GAAM,UAAEX,GAAY,EAAI,OAAED,GAAS,EAAI,YAAEE,GAAc,IACjE,MAAO1C,EAAKE,EAAGI,EAAG+C,GAAkBD,GAC9B,MAAEzZ,EAAK,IAAEsW,GAAQD,EACjBsD,EAAU3Z,EAAQ,GAAKsE,KAAKkS,OAAOxW,EAAQ,EAAGuW,EAAGI,GACjDiD,EAAWtD,EAAMhS,KAAKpD,OAASoD,KAAKkS,OAAOF,EAAKC,EAAGI,GACnDvG,EAAQ0I,EACR,CAAC9Y,EAAQ,EAAIA,EAAQ,EAAIA,EAAOsW,EAAMhS,KAAKpD,MAAQoV,EAAM,EAAIA,GAC7D,CAACtW,EAAOsW,GACR4C,EAAY,GACdS,GACAT,EAAUjM,KAAK,CAAC0M,EAASpD,EAAGI,IAE5BiD,GACAV,EAAUjM,KAAK,CAAC2M,EAAUrD,EAAGI,IAEjC,IAAK,MAAMkD,KAASH,IACfX,EAAc3D,EAAwBD,GAAe,CACtD,MAAO,CAAE2E,EAAQC,GAAUF,EACrBG,EAAQF,EAASvD,EACjB0D,EAAQF,EAASpD,EACvB,GAAIqD,EAAQ,GAAKA,GAAS1V,KAAKnD,OAC3B,SAEJ,GAAI8Y,EAAQ,GAAKA,GAAS3V,KAAKuR,MAC3B,SAEJ,MAAMF,EAAMrR,KAAKoS,OAAOsD,EAAOC,GAC/B,GAAKtE,EAGL,IAAK,MAAMuE,KAAWvE,EAAK,CACvB,MAAMwE,EAAmBT,GACpBX,GAAe3D,GACfyD,GAAUkB,EAAS,GAAKzE,GACxBuD,GAAUkB,EAAS,GAAK1E,GACzBF,EACE+E,EAAQ5D,KAAOlG,EAAM,IAAM8J,EAAQla,OAASoQ,EAAM,IACpD8I,EAAUjM,KAAK,CAACiN,EAASF,EAAOC,EAAOE,GAE/C,CACJ,CACA,OAAOjB,CACX,E,+BCrXG,SAASkB,EAAaC,GACzB,OAAQC,EAASD,EAAY,cAAgBC,EAASD,EAAY,gBACtE,CACO,SAASC,EAASD,EAAYE,GACjC,MAAMC,EAAe,QAASH,EAAaA,EAAaA,EAAWI,MACnE,QAAKD,KAGIA,EAAaE,IAAIH,EAC9B,C,kGCPe,SAASI,EAAYF,EAAOG,GACvC,MAAMC,EAAqBD,EAAOE,cAC7BpU,MAAM,KACN6Q,OAAO,GACP5M,IAAIoQ,aACH,WAAEC,GAiDZ,SAAuBH,GACnB,IAAIzY,EAAM6Y,IACNxH,GAAOwH,IACX,IAAK,IAAIjN,EAAI,EAAGA,EAAI6M,EAAmB3V,OAAQ8I,GAAK,EAChD5L,EAAMb,KAAKa,IAAIA,EAAKyY,EAAmB7M,IACvCyF,EAAMlS,KAAKkS,IAAIA,EAAKoH,EAAmB7M,IAE3C,MAAMkN,GAAUzH,EAAMrR,GAAO,EAC7B,MAAO,CACH4Y,WAAY,EAAEE,EAAQA,GACtB9Y,MACAqR,MAER,CA9D2B0H,CAAcN,GAC/BzY,EAAM4Y,EAAW,GACjB9Z,EAAQ8Z,EAAW,GAAKA,EAAW,GACnCI,EAAO,mBACPC,EAA+B,GACrC,IAAK,IAAIrN,EAAI,EAAGA,EAAI6M,EAAmB3V,OAAQ8I,GAAK,EAAG,CACnD,IAAIzJ,EAAQsW,EAAmB7M,GAC/B,MAAMsN,EAAIT,EAAmB7M,EAAI,GAC3BuN,EAAIV,EAAmB7M,EAAI,GAC3BwN,EAAIX,EAAmB7M,EAAI,GACjCzJ,GAASA,EAAQnC,GAAOlB,EACxBma,EAA6BpO,KAAK,CAAC1I,EAAO+W,EAAGC,EAAGC,GACpD,EAmDJ,SAAkCzI,EAAQ3C,EAAOgL,GAC7C,MAAMla,EAAQkP,EAAM,GAAKA,EAAM,GACzBqL,EAAW1I,EAAOpI,KAAI,EAAE/I,EAAG0Z,EAAGC,EAAGC,KAAO,CAC1C5Z,EAAIV,EAAQkP,EAAM,GAClBkL,EACAC,EACAC,KAEJJ,EAAKM,kBACLD,EAASlW,SAAQ,EAAE3D,EAAG0Z,EAAGC,EAAGC,KAAOJ,EAAKO,YAAY/Z,EAAG0Z,EAAGC,EAAGC,IAEjE,CA7DII,CAAyBP,EAA8BL,EAAYI,GACnEX,EAAMoB,cAAcC,uBAAuB,EAAGV,GAC9C,MAAMW,EAAqBnB,EAAOoB,cAC7BtV,MAAM,KACN6Q,OAAO,GACP5M,IAAIoQ,YACHkB,EAAO,mBACPC,EAAa,GACnB,IAAK,IAAIlO,EAAI,EAAGA,EAAI+N,EAAmB7W,OAAQ8I,GAAK,EAAG,CACnD,IAAIzJ,EAAQwX,EAAmB/N,GAC/B,MAAMmO,EAAUJ,EAAmB/N,EAAI,GACvCzJ,GAASA,EAAQnC,GAAOlB,EACxBgb,EAAWjP,KAAK,CAAC1I,EAAO4X,GAC5B,EAiDJ,SAAwCpJ,EAAQ3C,EAAOgM,GACnD,MAAMlb,EAAQkP,EAAM,GAAKA,EAAM,GACzBqL,EAAW1I,EAAOpI,KAAI,EAAE/I,EAAGE,KAAO,CAACF,EAAIV,EAAQkP,EAAM,GAAItO,KAC/Dsa,EAAIV,kBACJD,EAASlW,SAAQ,EAAE3D,EAAGE,KAAOsa,EAAIC,SAASza,EAAGE,IAEjD,CAtDIwa,CAA+BJ,EAAYlB,EAAYiB,GACvD,MAAMM,EAAW9B,EAAMoB,cACvBU,EAASC,iBAAiB,EAAGP,GAC7B,MAAOQ,EAAkBC,EAAoBC,EAAkBC,GAAuBhC,EAAOiC,gBAAgBnW,MAAM,KAAK6Q,OAAO,GAAG5M,IAAIoQ,YACtIwB,EAASO,sBAAsB,GAAG,GAClCP,EAASQ,+BAA+B,EAAGN,GAC3CF,EAASS,iCAAiC,EAAGN,GAC7CH,EAASU,+BAA+B,EAAGN,GAC3CJ,EAASW,iCAAiC,EAAGN,GAChB,MAAzBhC,EAAOuC,eACPZ,EAASa,mCAEbb,EAASc,SAA0B,MAAjBzC,EAAO0C,OACzB,MAAMC,EAAUxC,WAAWH,EAAO2C,SAC5BC,EAAUzC,WAAWH,EAAO4C,SAC5BC,EAAW1C,WAAWH,EAAO6C,UAC7BC,EAAgB3C,WAAWH,EAAO8C,eACxCnB,EAASoB,WAAWJ,GACpBhB,EAASqB,WAAWJ,GACpBjB,EAASsB,YAAYJ,GACrBlB,EAASuB,iBAAiBJ,EAC9B,C,0EC5BA,QAzBkBtO,IACd,MAAM2O,EAUV,SAAwD3O,GACpD,MAAM4O,GAAwB,UACxBD,EAAgC,GAUtC,OATAC,EAAsBzY,SAAS0Y,IAC3B,MAAMC,GAAY,OAAyB9O,GACvC8O,EAAUhZ,QACV6Y,EAA8B9Q,KAAK,CAC/BgR,kBACAE,YAAaD,EAAUvT,KAAKnK,GAAaA,EAASmN,MAE1D,IAEGoQ,CACX,CAvB0CK,CAA+ChP,GAChF2O,GAA+B7Y,QAGpC6Y,EAA8BxY,SAAQ,EAAG0Y,kBAAiBE,kBACjDF,EAAgBI,kBACjBJ,EAAgBK,gBAAgBH,EACpC,GACF,C,oFCHC,SAASI,EAAoB9V,GAChC,MACM+V,EAAsB,IADH,MAAa,EAAAC,gBAAgBC,YAAajW,IAwBnE,OApBK+V,EAAoBvc,qBACrBuc,EAAoBvc,mBAAqB,GAExCuc,EAAoBxc,kBACrBwc,EAAoBxc,gBAAkB,GAErCwc,EAAoBrR,gBACrBqR,EAAoBrR,cAAgB,CAAC,EAAG,EAAG,IAE1CqR,EAAoBtR,aACrBsR,EAAoBtR,WAAa,CAAC,EAAG,EAAG,IAEvCsR,EAAoBlS,uBACrBkS,EAAoBlS,qBAAuB,CAAC,EAAG,EAAG,IAEjDkS,EAAoBhS,0BACrBgS,EAAoBhS,wBAA0B,IAAIe,aAAa,CAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,KAGhBiR,CACX,CAmBO,SAASG,EAAc7e,GAC1B,MAAM2I,EAAU3I,EAAM2I,SAChB,oBAAEuD,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE4B,EAAyB,gBAAE3B,GAAqB,MAAa,mBAAoBtD,IAC5I,YAAE3F,EAAW,aAAEC,EAAY,eAAE6b,GAAmB9e,GAChD,SAAE2C,GAAa,MAAa,sBAAuBgG,GACnDoW,EAAuB,MAAa,gBAAiBpW,GACrDqW,EAAc,MAAa,EAAAL,gBAAgBM,YAAatW,GACxDuW,EA1DH,SAAgCJ,GACnC,OAAK1a,OAAO+a,OAAO,EAAAC,oBAAoBC,SAASP,GAGzCA,EAFI,EAAAM,mBAAmBE,MAGlC,CAqD+BC,CAAuBT,GAElD,MAAO,CACHE,cACAQ,cAAeT,EACfD,eAAgBI,EAChBvc,WACAwI,iBANqBsT,EAAoB9V,GAOzCkD,iBAAkB,CACdC,gBACAC,aACAE,kBACAD,UACA4B,4BACA1B,sBACAlJ,YAAaA,EACbC,aAAcA,EACdN,WACAmc,eAAgBI,GAG5B,C,oFC9Ee,SAASO,EAAgC7U,GACpD,MAAQ4B,qBAAsBkT,EAA6B,wBAAEhT,GAA6B,MAAa,mBAAoB9B,EAAS,IAC9H+U,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GmT,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,MAAME,EAAY,gBAAgBJ,EAA8B,GAAIA,EAA8B,GAAIA,EAA8B,IAEpI,IAAIpT,EACJ,SAASyT,EAAYpX,GACjB,MAAM,qBAAE6D,GAAyB,MAAa,mBAAoB7D,GAC5DqX,EAAiB,cACjBC,EAAS,gBAAgBzT,EAAqB,GAAIA,EAAqB,GAAIA,EAAqB,IAEtG,OADA,SAASwT,EAAgBF,EAAWG,GAC7B,SAASD,EAAgBH,EACpC,CACA,GATmD,YAA9BjV,EAAS,GAAGhE,MAAM,KAAK,GAwBvC,CACD,MAAMsZ,EAAqB,CACvBtV,EAAS,GACTA,EAASnJ,KAAK+Q,MAAM5H,EAASxF,OAAS,KAIpC+a,GAFqBJ,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IAC5B,MAAa,mBAAoBA,EAAmB,KACnF,IAAKC,EACD,MAAM,IAAIvd,MAAM,yDAEpB,MAAMod,EAAiB,cACjBI,EAAe,gBAAgBD,EAAuB3T,qBAAqB,GAAI2T,EAAuB3T,qBAAqB,GAAI2T,EAAuB3T,qBAAqB,IACjL,SAASwT,EAAgBF,EAAWM,GACpC,MAAMC,EAAsC,SAASL,EAAgBH,GACrEvT,EACI7K,KAAK6e,IAAID,GACL5e,KAAK+Q,MAAM5H,EAASxF,OAAS,EACzC,KAjCmB,CACf,MAAMmb,EAAqB3V,EAASC,KAAKlC,IAE9B,CACH6X,SAFaT,EAAYpX,GAGzBA,cAGR4X,EAAmBE,MAAK,CAACC,EAAGhF,IAAMA,EAAE8E,SAAWE,EAAEF,WACjD,MAAMG,EAAYJ,EAAmBnb,OACrCkH,EACI7K,KAAK6e,IAAIC,EAAmBI,EAAY,GAAGH,SACvCD,EAAmB,GAAGC,WACrBG,EAAY,EACzB,CAoBA,MAAM,eAAEC,EAAc,qBAAEC,GAAyB,MAAa,mBAAoBjW,EAAS,KACrF,gCAAEkW,IAAoC,UAAmBC,UAe/D,OAdiB,IAAZzU,IAAiB0U,MAAM1U,IAAcwU,IAClCD,GACAjM,QAAQqM,MAAM,2DACd3U,EAAUuU,GAELD,GACLhM,QAAQqM,MAAM,iFACd3U,EAAUsU,IAGVhM,QAAQqM,MAAM,gHACd3U,EAAU,IAGXA,CACX,C,+BCtEA,SAAS4U,EAAMzc,EAAOnC,EAAKqR,GACvB,OAAOlS,KAAKkS,IAAIrR,EAAKb,KAAKa,IAAIqR,EAAKlP,GACvC,C,qMCCA,MAAM0c,EAAa,IAAInL,IACvB,SAASoL,EAAiBzgB,GACtBwgB,EAAWzc,IAAI/D,EAAS0gB,KAAM1gB,EAClC,CACA,SAAS2gB,EAAYxc,GACjB,OAAOqc,EAAWvc,IAAIE,EAC1B,CACA,SAASyc,IACL,OAAOre,MAAM6D,KAAKoa,EAAWnb,OACjC,CACA,SAASwb,EAAqBC,EAAW9G,GACrC,MAAM+G,EAAe,IAAaC,eAAe9W,KAAK+W,GAAe,IAAaC,gBAAgBD,KAC5FE,EAAgBP,IAAmB1W,KAAKkX,GAAiBT,EAAYS,KAErEC,EADYN,EAAaO,OAAOH,GACJI,MAAMvhB,IACpC,MAAQwhB,UAAWC,GAAoBzhB,EACvC,GAAIyhB,EAAgBhd,SAAWqc,EAAUrc,OACrC,OAAO,EAEX,IAAK,IAAI8I,EAAI,EAAGA,EAAIkU,EAAgBhd,OAAQ8I,GAAK,EAC7C,KAAK,QAAQkU,EAAgBld,MAAMgJ,EAAI,EAAGA,EAAI,GAAIuT,EAAUvc,MAAMgJ,EAAI,EAAGA,EAAI,IACzE,OAAO,EAGf,OAAO,CAAI,IAEf,IAAK8T,EACD,OAAO,KAEX,MAAM3F,EAAU,GAChB,IAAI,OAAS1B,EAAO,aAAc,CAC9B,MAAM0H,EAAgB1H,EACjBoB,cACAuG,iBAAiB,GACjBC,iBACL,IAAKF,EACD,MAAO,CACHvd,KAAMkd,EAAgBX,MAG9B,IAAK,IAAInT,EAAI,EAAGA,EAAImU,EAAcjd,OAAQ8I,GAAK,EAC3CmO,EAAQlP,KAAK,CACT1I,MAAO4d,EAAcnU,GACrBmO,QAASgG,EAAcnU,EAAI,IAGvC,CACA,MAAO,CACHpJ,KAAMkd,EAAgBX,KACtBhF,UAER,C,+DCrDe,SAASmG,EAAgCC,GACpD,MAAMnH,EAAO,mBACb,IAAIoH,EAAQ,EACRC,EAAQ,KAOZ,YANuBngB,IAAnBigB,EAASC,YAA0ClgB,IAAnBigB,EAASE,QACzCD,EAAQD,EAASC,MACjBC,EAAQF,EAASE,OAErBrH,EAAKO,YAAY6G,EAAO,EAAK,EAAK,GAClCpH,EAAKO,YAAY8G,EAAO,EAAK,EAAK,GAC3BrH,CACX,C,gGCRe,SAASsH,EAAiCH,EAAUI,EAAqB,MACpF,MAAM,YAAE7f,EAAW,aAAEC,GAAiB,gBAA8Bwf,EAASC,MAAOD,EAASE,OAEvFG,EADQ5f,MAAM6D,KAAK,CAAE3B,OAAQyd,IAAsB,CAACE,EAAG7U,KAAOA,EAAI,IAAM2U,EAAqB,KAC/EG,SAAShhB,GAElB,EADG,OAAMA,EAAGiB,EAAcD,GACtBhB,EAAGA,EAAGA,EAAG,GAAK,KAEvBsZ,EAAO,mBAKb,OAJAA,EAAK2H,uBAAuB,iBAAyB,CACjD9D,OAAQ2D,EACRrZ,mBAAoB,KAEjB6R,CACX,C,+BCjBe,SAAS4H,EAASC,EAAMC,EAAYtR,EAAS,GACxD,MAAMuR,EAAoB,GAC1B,IAAK,IAAInV,EAAI4D,EAAQ5D,EAAIiV,EAAK/d,OAAQ8I,GAAKkV,EACvCC,EAAkBlW,KAAKe,GAE3B,OAAOmV,CACX,C,+CCNO,SAASC,EAAUC,GACtB,GAAY,OAARA,GAA+B,iBAARA,EACvB,OAAOA,EAEX,GAAmB,mBAARA,EACP,OAAOA,EAEX,GAA+B,mBAApBzN,gBACP,OAAOyN,EAEX,GAAIrgB,MAAMC,QAAQogB,GACd,OAAOA,EAAI1Y,IAAIyY,GAEd,CACD,MAAME,EAAY,CAAC,EACnB,IAAK,MAAM7e,KAAO4e,EACVnf,OAAOiB,UAAUC,eAAeC,KAAKge,EAAK5e,KAC1C6e,EAAU7e,GAAO2e,EAAUC,EAAI5e,KAGvC,OAAO6e,CACX,CACJ,C,+CCtBe,SAASC,EAAUC,GAC9B,IAAIC,EAAO,WACX,IAAK,IAAIzV,EAAI,EAAGA,EAAIwV,EAAIte,OAAQ8I,IAC5ByV,GAAQD,EAAIE,WAAW1V,GACvByV,IACKA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAEzE,OAAQA,IAAS,GAAGE,SAAS,GACjC,C,+GCJe,SAASC,EAAkBC,EAAaC,EAAUC,GAC7D,MAAM,UAAExX,EAAS,QAAEH,EAAO,SAAE1B,GAAamZ,EACzC,IAAKnZ,EAASxF,OACV,OAEJ,MAAM8e,EAAUzX,EAAUvH,MAAM,EAAG,GAC7Bif,EAAc,SAASD,EAASD,GACtC,GAAIxiB,KAAK6e,IAAI6D,GAAe,EAAI,EAAAC,QAC5B,OAEJ,MACMC,GAD2B,OAA4B,CAAE5X,YAAWH,WAAW2X,GACrB,EAChE,IAAIK,EACJ,IAAK,IAAIpW,EAAI,EAAGA,EAAItD,EAASxF,OAAQ8I,IAAK,CACtC,MAAMvF,EAAUiC,EAASsD,IACnB,qBAAE1B,GAAyB,MAAa,mBAAoB7D,GAC5D4b,EAAM,cACZ,SAASA,EAAKP,EAAUxX,GACxB,MAAMgY,EAAM,SAASD,EAAKN,GACtBxiB,KAAK6e,IAAIkE,GAAOH,IAChBC,EAAiB3b,EAEzB,CACA,OAAO2b,CACX,C,oFCzBO,SAASG,EAAqBzkB,GACjC,MAAM,iBAAEmL,EAAgB,iBAAEU,EAAgB,eAAEiT,EAAc,SAAEnc,EAAQ,cAAE6c,EAAa,YAAER,IAAiB,QAAchf,GACpH,IAAI,WAAEoN,EAAU,cAAEC,GAAkBlC,EAClB,MAAdiC,GAAuC,MAAjBC,IACtBD,EAAa,CAAC,EAAG,EAAG,GACpBC,EAAgB,CAAC,EAAG,EAAG,IAE3B,MAAMsS,EAAe,gBAAgBvS,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACxEwS,EAAe,gBAAgBvS,EAAc,GAAIA,EAAc,GAAIA,EAAc,IACjFwS,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,IAAIrT,EAASpB,EAAiBqB,qBAChB,MAAVD,IACAA,EAAS,CAAC,EAAG,EAAG,IAEpB,MAAMmY,EAAWvZ,EAAiBhJ,oBAAsBnC,EAAMmC,mBACxDwiB,EAAWxZ,EAAiBjJ,iBAAmBlC,EAAMkC,gBACrD0iB,EAAU5kB,EAAMwD,QAChBqhB,EAAU7kB,EAAMyD,KAChBqhB,EAAW,EAAAV,QAIjB,MAAO,CACH3a,mBAHuBzJ,EAAMyJ,oBAkBrC,SAAmDmE,GAC/C,IAAInE,EAAqB,GACS,QAA9BmE,GACAA,EAA0ByR,SAAS,QACL,kBAA9BzR,KACAnE,EAAqB,GAEzB,OAAOA,CACX,CAzBQsb,CAA0ClZ,EAAiB+B,2BAG3DrB,SACAE,UAAW,IAAIkT,KAAiBC,KAAiBC,GACjDxT,WAAY,CAACuY,EAASC,EAPV,GAQZvY,QAAS,CAACoY,EAAUC,EAAUG,GAC9BE,UAAWJ,EAAUC,EATT,EAUZ1Z,mBACAU,mBACAC,cAAeD,EAAiBC,cAChCgT,iBACAnc,WACA6c,gBACAR,cAER,C,0ECRA,QA/BA,SAA4Cte,GACxC,MAAMukB,EAASvkB,EAASwkB,aAClB,yBAAEC,EAAwB,YAAEpB,IAAgB,OAAqCrjB,EAAUukB,GACjG,IAAKlB,EACD,OAEJ,MAAM,gBAAEE,EAAe,WAAEmB,GAAeH,EAClC1K,EAAa7Z,EACd2kB,YACAnD,MAAMxB,GAAMA,EAAE4E,eAAiBvB,EAAYzU,UAC5CoR,EAAE6E,MAAQxB,EAAYzU,WACrBiL,GACD3F,QAAQC,KAAK,sCAAuCkP,EAAYzU,UAEpE,MAAMkW,EAAcjL,EAAWI,MACzB8K,GAAa,OAAcD,EAAavB,EAAiBmB,IACzD,IAAE9iB,EAAG,IAAEqR,EAAG,QAAErM,GAAYme,EACxBC,EAAiBjkB,KAAKkkB,OAAOhS,EAAMrR,GAAO6iB,GAA4B,EAC5E,IAAIS,GAAete,EAAUhF,IAAQqR,EAAMrR,GAAQojB,EAQnD,OAPAE,EAAankB,KAAK+Q,MAAMoT,GACpBA,EAAaF,EAAiB,EAC9BE,EAAaF,EAAiB,EAEzBE,EAAa,IAClBA,EAAa,GAEV,CACHF,iBACAE,aAER,C,+DC/Be,SAASC,EAAqBld,GACzC,MAAMmd,EAAoB,MAAa,oBAAqBnd,IAAY,CAAC,EACnEod,EAAsB,MAAa,sBAAuBpd,IAAY,CAAC,GACvE,SAAEhG,GAAaojB,EACfC,EAAoB,CACtBC,aAAcH,EAAkBG,cAAgB,EAChDC,iBAAkBJ,EAAkBI,kBAAoB,EACxDvjB,YAEEwjB,EAAY,MAAa,gBAAiBxd,IAAY,CAAC,EAC7D,MAAO,IACAqd,KACc,OAAbrjB,GAAqB,CACrByjB,MAAOD,EAAUC,MACjBC,OAAQF,EAAUE,OAClBC,OAAQH,EAAUG,QAG9B,C,qFChBA,MAAMC,EAAgB,EAAAnC,QAAU,EAAAA,QAC1BoC,EAASvS,GAAMxS,KAAK6e,IAAI7e,KAAK6e,IAAIrM,GAAK,GAAKsS,EAC3CE,EAAS,CAACxS,EAAGyS,IAAQF,EAAMvS,EAAEyS,KAASF,EAAMvS,EAAEyS,EAAM,KAAOF,EAAMvS,EAAEyS,EAAM,IACzEC,EAAiB1S,GAAMwS,EAAOxS,EAAG,IAAMwS,EAAOxS,EAAG,IAAMwS,EAAOxS,EAAG,GACxD,SAAS2S,EAAcpB,EAAavB,EAAiBmB,GAChE,MAAMyB,EAAYrB,EAAYsB,YAAYC,eAC1C,IAAIC,EACJ,MAAMva,EAAYoa,EAAUI,eAC5B,GAAIN,EAAcla,GACdua,GAAU,OAAsBxB,OAE/B,CACD,MAAO0B,EAAIC,EAAIC,GAAMP,EAAUQ,gBAW/BL,EAVmB,CACf,CAAC,EAAG,EAAG,GACP,CAACE,EAAK,EAAG,EAAG,GACZ,CAAC,EAAGC,EAAK,EAAG,GACZ,CAACD,EAAK,EAAGC,EAAK,EAAG,GACjB,CAAC,EAAG,EAAGC,EAAK,GACZ,CAACF,EAAK,EAAG,EAAGE,EAAK,GACjB,CAAC,EAAGD,EAAK,EAAGC,EAAK,GACjB,CAACF,EAAK,EAAGC,EAAK,EAAGC,EAAK,IAELvc,KAAK0F,GAAOsW,EAAUS,aAAa/W,IAC5D,CACA,MAAMtP,EAAY,IACbsmB,kBACAC,WACAC,qBAAqBxD,EAAiB,CAAC,EAAG,EAAG,IAClD+C,EAAQvhB,SAASiiB,GAAOzmB,EAAU0mB,MAAMD,KACxC,MAAME,EAAwB,IAAIxC,GAClCnkB,EAAU0mB,MAAMC,GAChB,MAAMC,EAAeD,EAAsB,GAC3C,IAAIE,EAAO3M,IACP4M,GAAQ5M,IACZ,IAAK,IAAIjN,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMpM,EAAIklB,EAAQ9Y,GAAG,GACjBpM,EAAIimB,IACJA,EAAOjmB,GAEPA,EAAIgmB,IACJA,EAAOhmB,EAEf,CACA,MAAO,CACHQ,IAAKwlB,EACLnU,IAAKoU,EACLzgB,QAASugB,EACTlN,MAAO6K,EACPvB,kBACAmB,aAER,C,8DCtDe,SAAS4C,EAA4BjE,EAAaE,GAC7D,MAAM,UAAExX,EAAS,QAAEH,GAAYyX,EACzBkE,EAAUxb,EAAUvH,MAAM,EAAG,GAC7BgjB,EAAUzb,EAAUvH,MAAM,EAAG,GAC7Bgf,EAAUzX,EAAUvH,MAAM,EAAG,GAC7Bif,EAAc,CAChB,SAAS8D,EAAShE,GAClB,SAASiE,EAASjE,GAClB,SAASC,EAASD,IAEhBkE,EAAmB,cACzB,SAASA,EAAkBhE,EAAY,GAAK7X,EAAQ,GAAI6X,EAAY,GAAK7X,EAAQ,GAAI6X,EAAY,GAAK7X,EAAQ,IAE9G,OADiC,YAAY6b,EAEjD,C,2GCVA,MAAMC,EAAe,EAAI,EAAAhE,QAEnBiE,EAAmBC,MAAa,IAAAC,0BAAyBrG,MAAMjZ,IAAWzD,OAD5Dke,EACuE4E,EAAOhZ,UADzEkZ,EACmFvf,KAD7Dya,EAAI+E,UAAU,EAAGhnB,KAAKa,IAAIohB,EAAIte,OAAQojB,EAAOpjB,SAAzE,IAACse,EAAK8E,CAC0F,IACpG,SAASE,EAAqChoB,EAAUukB,EAAQ0D,EAAUC,GAAmB,GACxG,MAAM,gBAAE3E,GAAoBgB,EACtB4D,EAAenoB,EAAS2kB,YAC9B,IAAKwD,EAAazjB,OACd,MAAO,CACH+f,yBAA0B,KAC1BpB,YAAa,KACb+E,SAAU,MAGlB,MAAMC,EAAeF,EAChBhe,KAAKme,IACN,MAAMF,EAAWE,EAAG1D,cAAgB0D,EAAGzD,IACvC,OAAO,KAAM0D,UAAUH,EAAS,IAE/BxP,QAAQ4P,KAASA,IACtB,GAAIP,EAAU,CACV,MAAMQ,GAAiB,OAAYR,GAC7BS,EAAmBL,EAAa/R,WAAWkS,GAAOC,EAAe9J,SAAS6J,EAAG5Z,YAC7EyU,EAAcgF,EAAaK,IACzB7D,IAAKuD,GAAaD,EAAaO,GAEvC,MAAO,CAAErF,cAAaoB,yBADWkE,EAAmBtF,EAAaE,EAAiBvjB,EAAUkoB,GAC5CE,WACpD,CACA,IAAKC,EAAa3jB,OACd,MAAO,CACH+f,yBAA0B,KAC1BpB,YAAa,KACb+E,SAAU,MAGlB,MAAMQ,EAAW,CACbnE,yBAA0BhK,IAC1B4I,YAAa,KACb+E,SAAU,MAERS,EAAmBR,EAAa7G,KAAKmG,GAC3C,IAAK,IAAIna,EAAI,EAAGA,EAAI6a,EAAa3jB,OAAQ8I,IAAK,CAC1C,MAAM6V,EAAcgF,EAAa7a,GACjC,GAAIqb,IAAqBlB,EAAgBtE,GACrC,SAEJ,MAAMoB,EAA2BkE,EAAmBtF,EAAaE,EAAiBvjB,GAC9EykB,EAA2BiD,EAC3BkB,EAASnE,2BACTmE,EAASnE,yBAA2BA,EACpCmE,EAASvF,YAAcA,EACvBuF,EAASR,SAAWD,EAAa3a,GAAGqX,IAE5C,CACA,OAAO+D,CACX,CACA,SAASD,EAAmBtF,EAAaE,EAAiBvjB,EAAUkoB,GAAmB,GACnF,MAAM,cAAEY,GAAkB9oB,EAAS+oB,gBACnC,IAAItE,EAA2BqE,EAI/B,OAHKA,GAAkBZ,IACnBzD,GAA2B,OAA4BpB,EAAaE,IAEjEkB,CACX,C,+DCxDA,QAVA,SAAkC7V,GAC9B,MAAMoa,GAAmB,UACnBC,EAAkB,GAMxB,OALAD,EAAiBjkB,SAAS0Y,IACtB,MACMyL,EADYzL,EAAgB0L,qBACEvQ,QAAQwQ,GAAOA,EAAGC,YAAYza,KAClEqa,EAAgBxc,QAAQyc,EAAkB,IAEvCD,CACX,C,+BCVe,SAASK,EAAqC1O,GACzD,IAAI2O,EAAY,GAChB,MAAOvH,EAAOC,GAASrH,EAAK4O,WAC5B5O,EAAK6O,SAASzH,EAAOC,EAAO,KAAMsH,GAClCA,EAAYA,EAAU3Q,QAAO,CAACrF,EAAG4C,IAAMA,EAAI,GAAM,IACjD,MAAMuT,EAAa,IAAIlnB,MAAM,MAAM8C,QAAQ6E,KAAI,CAACoJ,EAAG4C,IACxC6L,GAAUC,EAAQD,GAAS,KAAc7L,IAE9CwT,EAAKJ,EAAU,KACfK,EAAQ7oB,KAAK8oB,KAAK,EAAIF,GAAMA,GAC5BG,EAAKJ,EAAW,KAChBK,EAAKR,EAAU,KACfS,EAAQjpB,KAAK8oB,KAAK,EAAIE,GAAMA,GAC5BE,EAAKP,EAAW,KAChBQ,EAAKnpB,KAAKkkB,MAAO,GAAKgF,EAAKH,IAAQF,EAAQI,IAC3CG,EAAKppB,KAAKkkB,MAAM6E,EAAMI,EAAKN,EAAS,GAC1C,MAAO,CAAC7oB,KAAKkkB,MAAMkF,EAAKD,EAAK,GAAInpB,KAAKkkB,MAAMkF,EAAKD,EAAK,GAC1D,C,+CCjBe,SAASE,EAAsBtF,GAC1C,MAAMqB,EAAYrB,EAAYsB,YAAYC,eACpCgE,EAASlE,EAAUmE,eAAenE,EAAUoE,aAClD,MAAO,CACH,CAACF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAEtC,C,gECbO,MAAMG,EAAevC,IACxB,MAAMjhB,EAAS,YACTgc,EAAMiF,EAAStJ,SAAS3X,GACxBihB,EAASF,UAAU/gB,GACnBihB,EACA3b,EAAQ0W,EAAIlc,QAAQ,eAC1B,OAAkB,IAAXwF,EAAe0W,EAAMA,EAAI+E,UAAU,EAAGzb,EAAQ,EAAE,C,yECgB3D,QApBA,SAAiCtM,EAAU4O,EAAUsZ,GAAmB,GACpE,MAAM3D,EAASvkB,EAASwkB,aAClB,WAAEE,EAAU,gBAAEnB,GAAoBgB,GAClC,yBAAEE,EAAwB,SAAE2D,IAAa,OAAqCpoB,EAAUukB,EAAQ3V,EAAUsZ,GAChH,IAAKE,EACD,MAAM,IAAIlmB,MAAM,uCAAuC0M,qBAE3D,MAAMiL,EAAa7Z,EAASyqB,SAASrC,GACrC,IAAKvO,EAED,OADA3F,QAAQC,KAAK,sCAAuCiU,GAC7C,KAEX,MAAMtD,EAAcjL,EAAWI,MAE/B,MAAO,CACH8K,YAFe,OAAcD,EAAavB,EAAiBmB,GAG3DD,2BACAF,SAER,C,8DCHA,QAjBA,SAAqCvkB,EAAU4O,EAAUsZ,GAAmB,GACxE,MAAM,WAAEnD,EAAU,yBAAEN,EAAwB,OAAEF,IAAW,OAAwBvkB,EAAU4O,EAAUsZ,IAC/F,IAAEtmB,EAAG,IAAEqR,EAAG,QAAErM,GAAYme,EACxB2F,EAAiB3pB,KAAKkkB,OAAOhS,EAAMrR,GAAO6iB,GAE1CkG,GADY/jB,EAAUhF,IAAQqR,EAAMrR,GACJ8oB,EAEtC,MAAO,CACHA,iBACAE,iBAHqB7pB,KAAKkkB,MAAM0F,GAIhCE,eAAgB,CACZ9F,aACAN,2BACAF,UAGZ,C,gDCjBO,MAAMuG,EAA6BxF,GACd5hB,OAAO+a,OAAO6G,GAAmByF,MAAMhnB,GAA2B,iBAAVA,IAAuB+L,OAAOkb,UAAUjnB,I,+BCD7G,SAASknB,EAAaC,GACjC,OAAI1oB,MAAMC,QAAQyoB,GACPA,EAAMH,MAAMhnB,GAAU+L,OAAOwQ,MAAMvc,KAEvC+L,OAAOwQ,MAAM4K,EACxB,C,+CCLe,SAASC,EAAaljB,GACjC,MAAMmjB,EAAanjB,EAAQnB,QAAQ,KACnC,OAAOmB,EAAQ8f,UAAUqD,EAAa,EAC1C,C,+ECFA,MAAMC,EAA6B,IAAI/V,IACjCgW,EAA+B,6BAC/BC,EAAgC,CAClCD,+BACA1T,MAAO,KACHyT,EAA2BzT,OAAO,EAEtCxQ,IAAK,CAACnD,EAAKunB,KACPH,EAA2BrnB,IAAIC,EAAKunB,EAAQ,EAEhDC,MAAO,IACI,IAAInW,IAAI+V,GAEnBK,QAAUC,IACNN,EAA2BzT,QAC3B+T,EAAM5mB,SAAQ,CAAChB,EAAOE,KAClBonB,EAA2BrnB,IAAIC,EAAKF,EAAM,GAC5C,EAENG,IAAK,CAAC0G,KAASghB,KACX,GAAIhhB,IAAS0gB,EACT,OAAOM,EACFzhB,KAAK0hB,GAAUR,EAA2BnnB,IAAI2nB,KAC9CrK,MAAM3R,QAAc/N,IAAP+N,GACtB,IAGR,IAAAic,aAAYP,EAA8BrnB,IAAIoQ,KAAKiX,IACnD,S,84FC7BIQ,E,qDACJ,SAAWA,GACPA,EAAoBA,EAA0B,KAAI,GAAK,OACvDA,EAAoBA,EAA6B,QAAI,GAAK,UAC1DA,EAAoBA,EAA4B,OAAI,GAAK,QAC5D,CAJD,CAIGA,IAAwBA,EAAsB,CAAC,IAClD,MAAMC,EACF,WAAAzoB,CAAY0oB,GACRnoB,KAAKooB,gBAAkB,IAAI5W,IAC3BxR,KAAKqoB,UAAY,IAAI7W,IACrBxR,KAAKsoB,QAAUH,CACnB,CACA,WAAII,GACA,OAAqC,IAA9BvoB,KAAKooB,gBAAgBI,MAAsC,IAAxBxoB,KAAKqoB,UAAUG,IAC7D,CACA,gBAAAC,CAAiB3hB,EAAM5F,EAAUkD,GAC7B,MAAMskB,EAAW5hB,EAAK9D,QAAQ,KAE9B,IADkC,IAAd0lB,EACH,CACb,MAAMC,EAAiB7hB,EAAKmd,UAAU,EAAGyE,GACzC,IAAIE,EAA4B5oB,KAAKqoB,UAAUjoB,IAAIuoB,GAC9CC,IACDA,EAA4B,IAAIV,EAAqBloB,KAAKsoB,SAC1DtoB,KAAKqoB,UAAUnoB,IAAIyoB,EAAgBC,IAEvC9hB,EAAOA,EAAKmd,UAAUyE,EAAW,GACjCE,EAA0BH,iBAAiB3hB,EAAM5F,EAAUkD,EAC/D,MAEIpE,KAAK6oB,kBAAkB/hB,EAAM5F,EAAUkD,EAE/C,CACA,mBAAA0kB,CAAoBhiB,EAAM5F,EAAUkD,GAChC,MAAMskB,EAAW5hB,EAAK9D,QAAQ,KAE9B,IADkC,IAAd0lB,EACH,CACb,MAAMC,EAAiB7hB,EAAKmd,UAAU,EAAGyE,GACnCE,EAA4B5oB,KAAKqoB,UAAUjoB,IAAIuoB,GACrD,IAAKC,EACD,OAEJ9hB,EAAOA,EAAKmd,UAAUyE,EAAW,GACjCE,EAA0BE,oBAAoBhiB,EAAM5F,EAAUkD,GAC1DwkB,EAA0BL,SAC1BvoB,KAAKqoB,UAAU7kB,OAAOmlB,EAE9B,MAEI3oB,KAAK+oB,qBAAqBjiB,EAAM5F,EAAUkD,EAElD,CACA,KAAA4kB,GACItqB,MAAM6D,KAAKvC,KAAKqoB,UAAUY,WAAWhoB,SAAQ,EAAER,EAAWyoB,MAEtD,GADAA,EAAMF,SACFE,EAAMX,QAIN,MAAM,IAAInqB,MAAM,4CAHhB4B,KAAKqoB,UAAU7kB,OAAO/C,EAI1B,IAEJT,KAAKmpB,sBACT,CACA,iBAAAN,CAAkB/hB,EAAM5F,EAAUkD,GAC9B,IAAIglB,EAAeppB,KAAKooB,gBAAgBhoB,IAAI0G,GACvCsiB,IACDA,EAAe,IAAI5X,IACnBxR,KAAKooB,gBAAgBloB,IAAI4G,EAAMsiB,IAEnC,MACMC,EADajlB,GAASklB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBC,EAAmBL,EAAahpB,IAAIc,IAAa+mB,EAAoByB,KACvED,EAAmBJ,EACnBjZ,QAAQC,KAAK,oDAGjB+Y,EAAalpB,IAAIgB,EAAUuoB,EAAmBJ,GAC9CrpB,KAAKsoB,QAAQG,iBAAiB3hB,EAAM5F,EAAUkD,GAClD,CACA,oBAAA2kB,CAAqBjiB,EAAM5F,EAAUkD,GACjC,MACMilB,EADajlB,GAASklB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBJ,EAAeppB,KAAKooB,gBAAgBhoB,IAAI0G,GAC9C,IAAKsiB,EACD,QAEcloB,EAAW,CAACA,GAAYxC,MAAM6D,KAAK6mB,EAAa5nB,SACxDP,SAAS0oB,IACf,MAAMF,EAAmBL,EAAahpB,IAAIupB,IAAiB1B,EAAoByB,KAE/E,OAD2BD,EAAmBJ,GAE1C,OAEJrpB,KAAKsoB,QAAQQ,oBAAoBhiB,EAAM6iB,EAAcvlB,GACrD,MAAMwlB,EAAmBH,EAAmBJ,EACxCO,IAAqB3B,EAAoByB,KACzCN,EAAa5lB,OAAOmmB,GAGpBP,EAAalpB,IAAIypB,EAAcC,EACnC,IAECR,EAAaZ,MACdxoB,KAAKooB,gBAAgB5kB,OAAOsD,EAEpC,CACA,uBAAA+iB,CAAwB/iB,EAAMsiB,GAC1B1qB,MAAM6D,KAAK6mB,EAAaH,WAAWhoB,SAAQ,EAAE6oB,EAAUC,MAEnD,IAAK,IAAIC,EADU/B,EAAoBsB,QACHQ,EAAaC,IAAiB,EAAG,CACjE,KAAMD,EAAcC,GAChB,SAEJ,MAAMC,EAAaD,IAAiB/B,EAAoBsB,QACxDvpB,KAAK8oB,oBAAoBhiB,EAAMgjB,EAAU,CAAER,QAASW,IACpDF,GAAeC,CACnB,IAER,CACA,oBAAAb,GACIzqB,MAAM6D,KAAKvC,KAAKooB,gBAAgBa,WAAWhoB,SAAQ,EAAE6F,EAAMsiB,MACvDppB,KAAK6pB,wBAAwB/iB,EAAMsiB,EAAa,GAExD,EC9HJ,MAAMc,EACF,WAAAzqB,GACIO,KAAKmqB,uBAAyB,IAAI3Y,GACtC,CACA,gBAAAiX,CAAiBN,EAAQrhB,EAAM5F,EAAUkD,GACrC,IAAIgmB,EAAiBpqB,KAAKmqB,uBAAuB/pB,IAAI+nB,GAChDiC,IACDA,EAAiB,IAAIlC,EAAqBC,GAC1CnoB,KAAKmqB,uBAAuBjqB,IAAIioB,EAAQiC,IAE5CA,EAAe3B,iBAAiB3hB,EAAM5F,EAAUkD,EACpD,CACA,mBAAA0kB,CAAoBX,EAAQrhB,EAAM5F,EAAUkD,GACxC,MAAMgmB,EAAiBpqB,KAAKmqB,uBAAuB/pB,IAAI+nB,GAClDiC,IAGLA,EAAetB,oBAAoBhiB,EAAM5F,EAAUkD,GAC/CgmB,EAAe7B,SACfvoB,KAAKmqB,uBAAuB3mB,OAAO2kB,GAE3C,CACA,KAAAa,GACItqB,MAAM6D,KAAKvC,KAAKmqB,uBAAuBlB,WAAWhoB,SAAQ,EAAEknB,EAAQkC,MAChEA,EAAqBrB,QACrBhpB,KAAKmqB,uBAAuB3mB,OAAO2kB,EAAO,GAElD,E,gDC5BW,SAASmC,EAAyBC,EAAqBvP,GAClE,MAAMwN,EAAO+B,EAAoBC,UACjC,IAAK,IAAIhiB,EAAQ,EAAGA,EAAQggB,EAAMhgB,IAAS,CACvC,MAAMiiB,EAAa,GACnBF,EAAoBG,aAAaliB,EAAOiiB,GACxCA,EAAW,GAAKA,EAAW,GAAKzP,EAChCyP,EAAW,GAAKA,EAAW,GAAKzP,EAChCyP,EAAW,GAAKA,EAAW,GAAKzP,EAChCuP,EAAoBI,aAAaniB,EAAOiiB,EAC5C,CACJ,C,0BCVe,SAASG,EAAUC,GAC9B,IAEIC,EAFAhtB,EAAM+sB,EAAgB,GACtB1b,EAAM0b,EAAgB,GAE1B,MAAME,EAAYF,EAAgBjqB,OAClC,IAAK,IAAI4H,EAAQ,EAAGA,EAAQuiB,EAAWviB,IACnCsiB,EAAcD,EAAgBriB,GAC9B1K,EAAMb,KAAKa,IAAIA,EAAKgtB,GACpB3b,EAAMlS,KAAKkS,IAAIA,EAAK2b,GAExB,MAAO,CACHhtB,MACAqR,MAER,CCdA,MAAM6b,EAAkB5rB,OAAO,iBACzB6rB,EAAiB,CAAC,EAClBC,EAAc,WACdC,EAAoB,IACX,SAASC,EAAa1pB,EAASkC,EAAWuL,GACrD,OAEJ,SAA0BzN,EAAS2pB,EAAQlc,GACvC,IAAImc,EAAe5pB,EAAQ2pB,GACrBC,aAAwB5sB,QAC1B4sB,EAAe,CAAC,GAChB1rB,OAAOG,eAAe2B,EAAS2pB,EAAQ,CAAEprB,MAAOqrB,KAEpD,IAAK,IAAIC,GAAQ,EAAM7hB,EAAI,EAAG6hB,GAAS7hB,EAAI4hB,EAAa1qB,SAAU8I,EAAG,CACjE,IAAI8hB,EAAsB,EAAlBF,EAAa5hB,GACjB8hB,EAAIrc,GACJoc,GAAQ,EACRC,GAAQ,IAGRA,EAAI,EACA9hB,EAAI,IAAM4hB,EAAa1qB,QACvB0qB,EAAa3iB,KAAK,IAG1B2iB,EAAa5hB,GAAK8hB,CACtB,CACA,OAAOF,CACX,CAvBWG,CAA6B,OAAZ/pB,GAAuC,iBAAZA,EAAuBA,EAAUupB,EAAgBD,GAAiC,iBAAR7b,GAAoBA,EAAM,EAAIA,EAAM+b,KAAiB,GAAGQ,KAA0B,iBAAd9nB,EAAyBA,EAAYunB,EAC1O,C,eCLA,MAAMtD,EAAQ,CAAC,EAaf,EAZyB,CACrBvkB,IAAK,CAACa,EAASujB,KACX,MAAMiE,GAAW,EAAAtE,EAAA,GAAaljB,GAC9B0jB,EAAM8D,GAAYjE,CAAO,EAE7BtnB,IAAK,CAAC0G,EAAM3C,KACR,GAAa,2BAAT2C,EAAmC,CACnC,MAAM6kB,GAAW,EAAAtE,EAAA,GAAaljB,GAC9B,OAAO0jB,EAAM8D,EACjB,I,0BCXO,SAASC,EAAWC,EAAIC,EAAIC,EAAY,MACnD,OAAQ9uB,KAAK6e,IAAI+P,EAAG,GAAKC,EAAG,IAAMC,GAC9B9uB,KAAK6e,IAAI+P,EAAG,GAAKC,EAAG,IAAMC,GAC1B9uB,KAAK6e,IAAI+P,EAAG,GAAKC,EAAG,IAAMC,CAClC,C,gDCJe,SAASC,EAAsBxjB,EAAOX,GACjD,QAAIW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,GAI/B,C,eCgBA,QAzBA,SAAiDokB,EAAgBC,GAC7D,IAAIhH,EAEAA,EADAgH,EACmB,EAAC,EAAAC,EAAA,IAAmBD,KAGpB,EAAAC,EAAA,MAEvB,MAAMC,EAAuB,GAe7B,OAdAlH,EAAiBjkB,SAAS0Y,IACtB,MAAM0S,EAAeJ,EAAepL,YAC9BjH,EAAYD,EAAgB0L,qBAClC,IAAK,MAAMC,KAAM1L,EAAW,CACxB,MAAM0S,EAAWhH,EAAGzE,YACpB,GAAIyL,EAAS1rB,SAAWyrB,EAAazrB,OACjC,SAEgByrB,EAAaE,OAAM,EAAGxL,SAAUuL,EAAS5O,MAAM8O,GAAYzL,IAAQyL,EAAQzL,SAE3FqL,EAAqBzjB,KAAK2c,EAElC,KAEG8G,CACX,E,iHCzBA,MAGA,EAH8B5wB,GACnBA,EAAMixB,SAASC,QAAUlxB,EAAMixB,SAASjL,kBAAkBI,MCKtD,SAAS+K,EAAkBlxB,EAAQmxB,EAAezuB,OAAWH,EAAWkuB,EAAoB,cAAeW,EAAkB,CACxIC,YAAa,CAAEC,UAAW,CAAC,EAAG,MAE9B,KAAKtxB,GAAYA,aAAkBuxB,mBAC/B,MAAM,IAAI5uB,MAAM,8BAEpB,MAAM6uB,GAAYL,EAAczoB,QAC1B3I,GAASyxB,GAAYL,EACrB9I,EAASmJ,GAAYL,EAErBM,EAAa,qBADI1xB,EAAM2I,SAAW2f,EAAOhZ,WAEzCqiB,EAAUC,SAASC,cAAc,OACjCC,EAAmBC,OAAOD,kBAAoB,EAC/CT,EAAgBC,cACjBD,EAAgBC,YAAc,CAAEC,UAAW,CAAC,EAAG,KAEnD,MAAMS,EAAgB/xB,EAAOmB,MACvB6wB,EAAiBhyB,EAAOoB,OAC9BswB,EAAQO,MAAM9wB,MAAQ,GAAG4wB,EAAgBF,EAAmB,SAC5DH,EAAQO,MAAM7wB,OAAS,GAAG4wB,EAAiBH,EAAmB,SAC9DH,EAAQO,MAAMC,WAAa,SAC3BR,EAAQO,MAAME,SAAW,WACzBR,SAASS,KAAKC,YAAYX,GAC1B,MAAMY,EAAWb,EAAW9qB,MAAM,KAAKspB,KAAK,KAC5CyB,EAAQa,aAAa,yBAA0BD,GAC/C,MAAME,GAAkB,EAAAC,EAAA,IAAkBf,GACpCxT,GAAkB,EAAAwS,EAAA,IAAmBD,IACvC,IAAIiC,EAAA,GAAgBjC,GACxB,IAAIhwB,EAAWyd,EAAgByU,YAAYlB,GAC3C,IAAKhxB,EAAU,CACX,MAAMmyB,EAAgB,CAClBnB,aACApmB,KAAMmmB,EAAW,EAAAqB,aAAaC,aAAe,EAAAD,aAAaE,MAC1DrB,UACAsB,eAAgB,IACT5B,EACH6B,gBAAgB,IAGxB/U,EAAgBgV,cAAcN,GAC9BnyB,EAAWyd,EAAgByU,YAAYlB,EAC3C,CACA,OAAO,IAAIroB,SAASC,IAChB,IAAI8pB,GAAkB,GAClB,cAAEC,GAAkBhC,EACxB,MAAMiC,EAAmBC,IACrB,GAAIH,EACA,OAEJ,GAAIC,EAAe,CACf,MAAMG,EAAaH,EAInB,OAHAA,EAAgB,KAChB3yB,EAAS+yB,iBAAiBD,QAC1B9yB,EAASD,QAEb,CACgBR,EAAOyzB,WAAW,MAC1BC,UAAUlB,EAAiB,EAAG,EAAGA,EAAgBrxB,MAAOqxB,EAAgBpxB,OAAQ,EAAG,EAAGpB,EAAOmB,MAAOnB,EAAOoB,QACnH,MAAMkL,EAAS7L,EAASkzB,cAAc,CAAC,EAAG,IACpCC,EAAWnzB,EAASkzB,cAAc,CACpCnB,EAAgBrxB,MAAQ0wB,EACxB,IAEEgC,EAAapzB,EAASkzB,cAAc,CACtC,EACAnB,EAAgBpxB,OAASywB,IAEvBiC,EAAc,SAAS,CAAC,EAAG,EAAG,GAAIrzB,EAASkzB,cAAc,CAAC,EAAI9B,EAAkB,IAAKvlB,GACrFynB,EAAa,SAAS,CAAC,EAAG,EAAG,GAAItzB,EAASkzB,cAAc,CAAC,EAAG,EAAI9B,IAAoBvlB,GAE1F6mB,GAAkB,EAClBzB,EAAQrE,oBAAoB,EAAA2G,OAAOC,eAAgBZ,GACnDa,YAAW,KACPhW,EAAgBiW,eAAe1C,GACdE,SAASyC,iBAAiB,4BAA4B9B,OAC9D9sB,SAASksB,IACdA,EAAQ2C,QAAQ,GAClB,GACH,GACHhrB,EAAQ,CACJiD,SACAunB,aACAD,WACAU,YAdgB,EAehBR,cACAC,cACF,EAENrC,EAAQ1E,iBAAiB,EAAAgH,OAAOC,eAAgBZ,GAC5C7B,EACA/wB,EAAS8zB,WAAW,CAAClM,IAAS,GAAO,GAGrC5nB,EAAS+zB,kBAAkBrD,GAE/B1wB,EAASg0B,cACQ,OAAb/xB,GAAsB,EAAqB3C,IAC3CU,EAASi0B,cAAc,CACnBlS,SAAU,CACNC,MAAO1iB,EAAMgO,cACb2U,MAAO3iB,EAAMiO,iBAIzBvN,EAASD,QAAQ,GAEzB,C,mCC7Ge,SAASm0B,EAAkB30B,EAAQmxB,EAAezuB,EAAUkyB,EAAoBC,GAE3F,GADe1D,EACJ9hB,SACP,MAAM,IAAI1M,MAAM,wCAEpB,MAAM5C,EAAQoxB,EAERtxB,EAAiB,CACnBG,SACAS,UAHa,EAAAq0B,EAAA,GAAmB90B,EAAQD,EAAO2C,GAI/C3C,QACAg1B,eAAgB,CAAC,GAErBl1B,EAAemB,WAAY,EAAAg0B,EAAA,GAAmBn1B,GAE9C,OAAO,IAAIuJ,SAAQ,CAACC,EAAS6K,MACzB,EAAA+gB,EAAA,GAAcp1B,EAFE,MAGhBwJ,EAAQ,KAAK,GAErB,C,eCfe,SAAS6rB,EAAkBvsB,GACtC,MAAM,OAAE3I,EAAM,QAAE0I,EAAO,cAAE0qB,EAAa,YAAE7oB,EAAc,EAAA4qB,YAAYC,UAAS,SAAE9qB,GAAW,EAAE,kBAAEmmB,EAAoB,cAAa,gBAAE4E,GAAkB,EAAK,UAAEC,GAAY,EAAK,YAAEC,GAAc,EAAOnE,gBAAiBoE,GAAyB7sB,EACpO0G,EAAW+jB,GAAe/jB,SAC1BmiB,EAAWniB,IAAa3G,EACxB0oB,EAAkBgC,GAAiBoC,EACnC,IAAKA,EAAqBpC,iBAC1BoC,EACAC,EAAWJ,EAAkBV,EAAoBzD,EACvD,OAAO,IAAI9nB,SAAQ,CAACC,EAAS6K,KACzB,SAASwhB,EAAgBvE,EAAezoB,GACpC,MAAM,SAAEhG,GAAaizB,EAAShxB,IAAI,sBAAuB+D,IAAY,CAAC,EAChE3I,GAASyxB,GAAYL,EACrB9I,EAASmJ,GAAYL,EACvBpxB,IACAA,EAAM+C,YAAc/C,EAAM+C,aAAe/C,EAAMixB,UAAUC,QAEzDqE,IACAt1B,EAAOoB,OAAS,IAChBpB,EAAOmB,MAAQ,KAEfo0B,GAAex1B,IACfC,EAAOmB,MAAQpB,GAAUC,EAAOoB,OAASrB,EAAMoB,MAASpB,EAAMqB,QAElEpB,EAAOiyB,MAAM9wB,MAAWnB,EAAOmB,MAAQ0wB,iBAAlB,KACrB7xB,EAAOiyB,MAAM7wB,OAAYpB,EAAOoB,OAASywB,iBAAnB,KAClBxJ,GAAUgN,GACVnhB,EAAO,IAAIvR,MAAM,0CAErB8yB,EAASz1B,EAAQmxB,EAAezuB,EAAU+tB,EAAmBW,GAAiB9nB,KAAKD,EACvF,CACA,SAASqL,EAAcxK,EAAOxB,GAC1BiM,QAAQzK,MAAMA,EAAOxB,GACrBwL,EAAOhK,EACX,CAQA,MAAMvB,EAAU,CACZitB,UAAWP,EACX9qB,eAEJ,GAAI8E,EAAU,CACV,MAAMgZ,EAASwN,EAAA,GAAM7M,UAAU3Z,GAC1BgZ,GACDnU,EAAO,IAAIvR,MAAM,aAAa0M,yBAGlCqmB,EAAgBrN,EADGA,EAAO1d,SAAS,GAEvC,MAEImrB,EAAA,EAAqBC,WApBzB,SAAqBrtB,EAASstB,EAAcrtB,GACxC,OAAO,IAAA6B,mBAAkB9B,EAASC,GAASW,MAAMvJ,IAC7C21B,EAAgBpwB,KAAKf,KAAMxE,EAAO2I,EAAQ,IAC1CwB,IACAwK,EAAcpP,KAAKf,KAAM2F,EAAOxB,EAAQ,GAEhD,EAcgDqM,KAAK,KAAMrM,EAAS,KAAMC,GAAU4B,EAAa,CAAE7B,WAAW4B,EAC9G,GAER,C,eC/DA,MAAM0pB,GACY,iCADZA,GAEY,iCAEX,MAAMiC,GACT,WAAAjyB,CAAYkyB,EAAQ,QAASnJ,EAAO,IAChCxoB,KAAK4tB,UAAY,EACjB5tB,KAAK4xB,cAAgB,EACrB5xB,KAAK6xB,cAAgB,EACrB7xB,KAAK8xB,KAAO,IAAIpzB,MAChBsB,KAAK2xB,MAAQA,EACb3xB,KAAK+xB,MAAQvJ,CACjB,CACA,QAAIA,GACA,OAAOxoB,KAAK+xB,KAChB,CACA,QAAIvJ,CAAK7a,GACL3N,KAAK8xB,KAAO,IAAIpzB,MAAMiP,GACtB3N,KAAK+xB,MAAQpkB,EACb3N,KAAK4tB,UAAY,EACjB5tB,KAAK4xB,cAAgB,EACrB5xB,KAAK6xB,cAAgB,CACzB,CACA,IAAAG,CAAKC,EAAQ,GACT,KAAOA,EAAQ,GAAKjyB,KAAK6xB,cAAgB,GAAG,CACxC,MAAM1c,EAAOnV,KAAK8xB,KAAK9xB,KAAK4tB,UAC5BzY,EAAK+c,aAAY,GACb/c,EAAK9L,IACL8oB,EAAA,EAAYC,cAAc,IAAIC,YAAY5C,GAAqB,CAC3D6C,OAAQ,CACJC,QAAQ,EACRlpB,GAAI8L,EAAK9L,GACTmpB,cAAerd,EAAKqd,eAAiB,aACrCC,KAAMtd,MAIlB8c,IACAjyB,KAAK4xB,gBACL5xB,KAAK6xB,gBACL7xB,KAAK4tB,UAAY5tB,KAAK4tB,SAAW,EAAI5tB,KAAKwoB,MAAQxoB,KAAKwoB,IAC3D,CACJ,CACA,MAAAkK,CAAOC,GACH,SAAI3yB,KAAK6xB,cAAgB,GAAKc,EAAU3yB,KAAK8xB,KAAK9xB,KAAK4tB,cACnD5tB,KAAKgyB,QACE,EAGf,CACA,IAAAY,CAAKX,EAAQ,GACT,KAAOA,EAAQ,GAAKjyB,KAAK4xB,cAAgB,GAAG,CACxC,MAAMiB,GAAe7yB,KAAK4tB,SAAW,GAAK5tB,KAAKwoB,KACzCrT,EAAOnV,KAAK8xB,KAAKe,GACvB1d,EAAK+c,aAAY,GACb/c,EAAK9L,IACL8oB,EAAA,EAAYC,cAAc,IAAIC,YAAY5C,GAAqB,CAC3D6C,OAAQ,CACJC,QAAQ,EACRlpB,GAAI8L,EAAK9L,GACTmpB,cAAerd,EAAKqd,eAAiB,aACrCC,KAAMtd,MAIlB8c,IACAjyB,KAAK4tB,SAAWiF,EAChB7yB,KAAK6xB,gBACL7xB,KAAK4xB,eACT,CACJ,CACA,IAAAjpB,CAAKwM,GACD,IAAKA,EACD,OAEJ,MAAMsd,EAAOtd,EAAK+c,YACZ/c,EACAA,EAAK2d,eACX,OAAKL,GAGLzyB,KAAK4xB,cAAgB,EACjB5xB,KAAK6xB,cAAgB7xB,KAAK+xB,OAC1B/xB,KAAK6xB,gBAET7xB,KAAK4tB,UAAY5tB,KAAK4tB,SAAW,GAAK5tB,KAAK+xB,MAC3C/xB,KAAK8xB,KAAK9xB,KAAK4tB,UAAY6E,EACpBA,QATP,CAUJ,EAEJ,MAAMM,GAAqB,IAAIrB,GCnE/B,SAtBA,SAA4BvtB,EAAS6uB,GACjC,MAAMrsB,GAAmB,IAAAvG,KAAI,mBAAoB+D,GACjD,IAAKwC,EACD,MAAM,IAAIvI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAE0E,EAAa,WAAED,EAAYZ,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAEhJ,EAAkB,gBAAED,GAAoBiJ,EAC9ChJ,IAAuB,EACvBD,IAAoB,EACpB,MAAMu1B,EAAY,cAClB,iBAAiBA,EAAWlrB,EAAQc,GAAgBlL,EAAqB,GACzE,iBAAiBs1B,EAAWA,EAAWrqB,GAAalL,EAAkB,GACtE,MAAMw1B,EAAM,cAQZ,OAPA,SAASA,EAAKF,EAAaC,GAGP,CAFA,SAASC,EAAKtqB,GAGhBlL,EAFK,SAASw1B,EAAKrqB,GAGhBlL,EAGzB,ECrBe,SAASw1B,GAAmBhvB,EAASivB,GAChD,MAAMzsB,GAAmB,IAAAvG,KAAI,mBAAoB+D,GACjD,IAAKwC,EACD,MAAM,IAAIvI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAE0E,EAAa,WAAED,EAAYZ,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAEhJ,EAAkB,gBAAED,GAAoBiJ,EAC9ChJ,IAAuB,EACvBD,IAAoB,EACpB,MAAM21B,EAAqB,cAG3B,OAFA,iBAAiBA,EAAoBtrB,EAAQa,EAAYlL,GAAmB01B,EAAY,GAAK,KAC7F,iBAAiBC,EAAoBA,EAAoBxqB,EAAelL,GAAsBy1B,EAAY,GAAK,KACxG10B,MAAM6D,KAAK8wB,EACtB,C,2ECde,SAASC,GAAyB3H,GAC7C,MAAMzG,GAAmB,EAAAiH,EAAA,MACnBvS,EAAY,GASlB,OARAsL,EAAiBjkB,SAAS0Y,IACcA,EAAgB4Z,eACxBtyB,SAAS/E,IAC7BA,EAASs3B,YAAY7H,IACrB/R,EAAUjR,KAAKzM,EACnB,GACF,IAEC0d,CACX,C,gBCVe,SAAS6Z,GAAkCnlB,EAAOpS,GAC7D,MAAMw3B,EAGH,SAAkDplB,EAAOpS,GAC5D,MAAMkK,EAAWlK,EAASy3B,cACpBC,EAAsB13B,EAAS23B,yBACrC,GAAwB,IAApBztB,EAASxF,OACT,OAAO,KAEX,MAAM2a,EAAepX,IACjB,MAAM2vB,EA4Cd,SAA0B3vB,GACtB,MAAM4vB,EAAmB3C,EAAShxB,IAAI,mBAAoB+D,GAC1D,KAAK4vB,GACCA,EAAiBnrB,sBAAsBlK,OACE,IAAvCq1B,EAAiBnrB,WAAWhI,QAC9BmzB,EAAiBlrB,yBAAyBnK,OACE,IAA1Cq1B,EAAiBlrB,cAAcjI,QACjCmzB,EAAiB/rB,gCAAgCtJ,OACE,IAAjDq1B,EAAiB/rB,qBAAqBpH,QAC1C,OAAO,KAEX,MAAM,WAAEgI,EAAU,cAAEC,EAAa,qBAAEb,GAA0B+rB,EACvDC,EAAS,SAAS,iBAAkBprB,GACpCqrB,EAAS,SAAS,iBAAkBprB,GACpCqrB,EAAc,WAAW,cAAeF,EAAQC,GACtD,MAAO,CAAErrB,aAAYC,gBAAeb,uBAAsBksB,cAC9D,CA5D8BC,CAAiBhwB,GACvC,IAAK2vB,EACD,OAAO,KAEX,MAAMM,EAAQ7f,GAAO8f,cAAcP,EAAcI,YAAaJ,EAAc9rB,sBAE5E,OADiBuM,GAAO+f,qBAAqBF,EAAO9lB,EACrC,EAEbimB,EAAe,CACjBvY,SAAUT,EAAYnV,EAASwtB,KAAyBjd,IACxDnO,MAAOorB,GAELY,EAAiBpuB,EAAS1F,MAAMkzB,EAAsB,GAC5D,IAAK,IAAIlqB,EAAI,EAAGA,EAAI8qB,EAAe5zB,OAAQ8I,IAAK,CAC5C,MACMsS,EAAWT,EADNiZ,EAAe9qB,IAE1B,GAAiB,OAAbsS,EAAJ,CAGA,KAAIA,GAAYuY,EAAavY,UAKzB,MAJAuY,EAAavY,SAAWA,EACxBuY,EAAa/rB,MAAQkB,EAAIkqB,EAAsB,CAHnD,CAQJ,CACA,MAAMa,EAAgBruB,EAAS1F,MAAM,EAAGkzB,GACxC,IAAK,IAAIlqB,EAAI+qB,EAAc7zB,OAAS,EAAG8I,GAAK,EAAGA,IAAK,CAChD,MACMsS,EAAWT,EADNkZ,EAAc/qB,IAEzB,GAAiB,OAAbsS,GAAqBA,IAAauY,EAAavY,SAAnD,CAGA,KAAIA,EAAWuY,EAAavY,UAKxB,MAJAuY,EAAavY,SAAWA,EACxBuY,EAAa/rB,MAAQkB,CAHzB,CAQJ,CACA,OAAO6qB,EAAavY,WAAarF,IAAW,KAAO4d,CACvD,CArD4BG,CAAyCpmB,EAAOpS,GACxE,OAAOw3B,EAAkBA,EAAgBlrB,MAAQ,IACrD,C,gBCJA,SAASmsB,GAA8Bz4B,GACnC,MAAQU,MAAOg4B,EAAa/3B,OAAQg4B,GAAiB34B,EAAS4N,aACxD,mBAAEgrB,EAAkB,mBAAEC,GAAuB74B,EAAS84B,mBACtDC,GAAiB,EAAAC,GAAA,GAAqBh5B,EAAU,CAAC,EAAG,IACpDi5B,GAAc,EAAAD,GAAA,GAAqBh5B,EAAU,CAAC04B,EAAc,EAAG,IAC/DQ,GAAc,EAAAF,GAAA,GAAqBh5B,EAAU,CAAC,EAAG24B,EAAe,IAChEQ,EAAY,SAAS,cAAeF,EAAaF,GACjDK,EAAY,SAAS,cAAeF,EAAaH,GACjDM,EAAc,WAAW,cAAeF,EAAWC,GACzD,eAAeD,EAAWA,GAC1B,eAAeC,EAAWA,GAC1B,eAAeC,EAAaA,GAC5B,MAAMC,EAAev4B,KAAKkS,IAAIlS,KAAK6e,IAAIuZ,EAAU,IAAKp4B,KAAK6e,IAAIuZ,EAAU,IAAKp4B,KAAK6e,IAAIuZ,EAAU,KAC3FI,EAAex4B,KAAKkS,IAAIlS,KAAK6e,IAAIwZ,EAAU,IAAKr4B,KAAK6e,IAAIwZ,EAAU,IAAKr4B,KAAK6e,IAAIwZ,EAAU,KACjG,IAAK,YAAgB,EAAGE,KAAkB,YAAgB,EAAGC,GACzD,MAAM,IAAIr3B,MAAM,0DAEpB,MAAM,aAAE4G,GAAiB9I,EAASw5B,eAC5BC,EAAgBz5B,EAAS84B,mBACzB7vB,EAAaH,EAAa4wB,aAAaD,GAC7C,MAAO,CACH/4B,MAAO+4B,EAAc/4B,MACrBC,OAAQ84B,EAAc94B,OACtBsI,aACA2vB,qBACAC,qBAER,CC3BA,MAAM,GAAQ,CAAC,EACTc,GAAsC,CACxCvyB,IAAK,CAACykB,EAAOL,KACT,MAAOoO,EAAaC,GAAehO,EAC7BiO,EAAU,GAAGF,KAAeC,IAC7B,GAAMC,KACP,GAAMA,GAAW,CAAC,GAEtB,GAAMA,GAAWtO,CAAO,EAE5BtnB,IAAK,CAAC0G,EAAMgvB,EAAaC,KACrB,GAAa,8BAATjvB,EACA,OAEJ,MAAMkvB,EAAU,GAAGF,KAAeC,IAClC,GAAI,GAAMC,GACN,OAAO,GAAMA,GAEjB,MAAMC,EAAiB,GAAGF,KAAeD,IACzC,OAAI,GAAMG,GACC,YAAY,cAAe,GAAMA,SAD5C,CAEA,IAGR,IAAAjO,aAAY6N,GAAoCz1B,IAAIoQ,KAAKqlB,KACzD,YCFA,SArBA,SAA+CK,EAAWC,GACtD,MAAMC,EAAWF,EAAUG,gBACrBC,EAAWH,EAAUE,gBACrBE,GAAoB,IAAAn2B,KAAI,mBAAoBg2B,EAAS/W,YACrDmX,GAAoB,IAAAp2B,KAAI,mBAAoBk2B,EAASjX,YAC3D,IAAKkX,IAAsBC,EAEvB,YADApmB,QAAQ2V,IAAI,6DAGhB,MAAQ7d,wBAAyBuuB,GAASD,EAE1C,IADyBD,EAAkBruB,wBAAwBqkB,OAAM,CAAC9c,EAAG/F,IAAMzM,KAAK6e,IAAIrM,EAAIgnB,EAAK/sB,IAXnF,MAcd,YADA0G,QAAQ2V,IAAI,qGAAsGwQ,GAAmBruB,wBAAyBsuB,GAAmBtuB,yBAGrL,MAAMwuB,EAAwBH,EAAkBvuB,qBAC1C2uB,EAAwBH,EAAkBxuB,qBAC1CjK,EAAc,cAAc,cAAe24B,EAAuBC,GAClEC,EAAM,qBAAqB,cAAe74B,GAChD,GAAoCuF,IAAI,CAAC4yB,EAAU7sB,GAAI8sB,EAAU9sB,IAAKutB,EAC1E,ECxBe,SAASC,GAA+B36B,GACnD,MAAM,UAAEmmB,EAAS,WAAExa,GAAe3L,EAASw5B,gBAAkB,CAAC,EAC9D,IAAKrT,IAAcxa,EACf,MAAO,GAEX,MAAM,OAAEpM,GAAWS,EACb46B,EAAQvJ,OAAOD,iBAEfyJ,EAAiB,CAACt7B,EAAOmB,MAAQk6B,EAAO,GACxCE,EAAoB,CACtBv7B,EAAOmB,MAAQk6B,EACfr7B,EAAOoB,OAASi6B,GAEdG,EAAmB,CAAC,EAAGx7B,EAAOoB,OAASi6B,GACvCI,EAAeh7B,EAASkzB,cAPR,CAAC,EAAG,IAQpB+H,EAAgBj7B,EAASkzB,cAAc2H,GACvCK,EAAmBl7B,EAASkzB,cAAc4H,GAC1CK,EAAkBn7B,EAASkzB,cAAc6H,GACzCK,EAAejV,EAAUkV,aAAaL,GACtCM,EAAgBnV,EAAUkV,aAAaJ,GACvCM,EAAmBpV,EAAUkV,aAAaH,GAC1CM,EAAkBrV,EAAUkV,aAAaF,GAC/C,OAaJ,UAAuC,WAAExvB,EAAU,UAAEwa,EAAS,aAAEiV,EAAY,cAAEE,EAAa,iBAAEC,EAAgB,gBAAEC,EAAe,aAAER,EAAY,cAAEC,EAAa,iBAAEC,EAAgB,gBAAEC,IAC3K,MAAMM,EAAoBC,GAAYN,EAAczvB,GAC9CqvB,EACA7U,EAAUS,aAAa,CAAC,EAAG,EAAG,IAC9B+U,EAAqBD,GAAYJ,EAAe3vB,GAChDsvB,EACA9U,EAAUS,aAAa,CAACjb,EAAW,GAAK,EAAG,EAAG,IAC9CiwB,EAAwBF,GAAYH,EAAkB5vB,GACtDuvB,EACA/U,EAAUS,aAAa,CACrBjb,EAAW,GAAK,EAChBA,EAAW,GAAK,EAChB,IAEFkwB,EAAuBH,GAAYF,EAAiB7vB,GACpDwvB,EACAhV,EAAUS,aAAa,CAAC,EAAGjb,EAAW,GAAK,EAAG,IACpD,MAAO,CACH8vB,EACAE,EACAE,EACAD,EAER,CApCWE,CAA8B,CACjCnwB,aACAwa,YACAiV,eACAE,gBACAC,mBACAC,kBACAR,eACAC,gBACAC,mBACAC,mBAER,CAyBA,SAASO,GAAYK,EAAYpwB,GAC7B,OAAQowB,EAAW,GAAK,GACpBA,EAAW,GAAKpwB,EAAW,GAAK,GAChCowB,EAAW,GAAK,GAChBA,EAAW,GAAKpwB,EAAW,GAAK,GAChCowB,EAAW,GAAK,GAChBA,EAAW,GAAKpwB,EAAW,GAAK,CACxC,C,wFCrDA,SAXA,SAAwBslB,GACpB,MAAM7xB,GAAiB,EAAA48B,GAAA,IAAkB/K,GACzC,IAAK7xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACrB,KAAMY,aAAoBi8B,GAAA,GACtB,MAAM,IAAI/5B,MAAM,qFAAqFlC,EAAS4K,QAElH,OAAO5K,EAASk8B,qBACpB,E,uCCVA,SAASC,GAAcjyB,GACnB,GAAIA,EAASxF,QAAU,EACnB,OAAO,EAEX,MAAM03B,EAAWlyB,EAAS,IACpB,SAAEjI,EAAQ,kBAAEo6B,GAAsBnH,EAAShxB,IAAI,sBAAuBk4B,IACtE,wBAAEpwB,EAAuB,aAAEY,EAAY,oBAAEX,EAAmB,QAAEnJ,EAAO,KAAEC,EAAI,mBAAEu5B,GAAwBpH,EAAShxB,IAAI,mBAAoBk4B,GAC5I,GAAIE,EACA,OAAO,EAEX,MAAMC,EAAe,CACjBt6B,WACA+J,0BACAY,eACAX,sBACAnJ,UACAC,OACAs5B,qBAEJ,IAAIG,GAAc,EAClB,IAAK,IAAIhvB,EAAI,EAAGA,EAAItD,EAASxF,OAAQ8I,IAAK,CACtC,MAAMvF,EAAUiC,EAASsD,IACnB,SAAEvL,EAAQ,kBAAEo6B,GAAsBnH,EAAShxB,IAAI,sBAAuB+D,IACtE,wBAAE+D,EAAuB,aAAEY,EAAY,QAAE9J,EAAO,KAAEC,GAASmyB,EAAShxB,IAAI,mBAAoB+D,GAClG,GAAIo0B,IAAsBE,EAAaF,kBAAmB,CACtDG,GAAc,EACd,KACJ,CACA,GAAIv6B,IAAas6B,EAAat6B,SAAU,CACpCu6B,GAAc,EACd,KACJ,CACA,GAAI15B,IAAYy5B,EAAaz5B,QAAS,CAClC05B,GAAc,EACd,KACJ,CACA,GAAIz5B,IAASw5B,EAAax5B,KAAM,CAC5By5B,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,EAAA,IAAQzwB,EAAyBuwB,EAAavwB,yBAA0B,CACzEwwB,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,EAAA,IAAQ7vB,EAAc2vB,EAAa3vB,cAAe,CACnD4vB,GAAc,EACd,KACJ,CACJ,CACA,OAAOA,CACX,C,oDCpDO,MAAME,GAAY,IAAIC,IAAI,CAC7B,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BAEW,SAASC,GAAsBC,GAC1C,IAAKA,EACD,OAAO,EAGX,OADar6B,MAAMC,QAAQo6B,GAAaA,EAAY,CAACA,IACzCrb,MAAMqD,GAAQ6X,GAAUv1B,IAAI0d,IAC5C,C,mDCpBAiY,eAAeC,IAA6B,SAAE/8B,EAAQ,QAAEkI,EAAU,CAAC,IAC/D,MAAMuV,EAAkBzd,EAASiwB,qBACjC,IAAIrhB,EAAW1G,EAAQ0G,UAAY,IAAG,EAAAouB,EAAA,OACtC,GAAmC,IAA/BpuB,EAAS1I,MAAM,KAAKxB,OAAc,CAElCkK,EAAW,IADI,KAAAquB,mCACSruB,GAC5B,CACA,MAAM,GAAEzB,EAAE,QAAE8jB,GAAYjxB,EAClBgxB,EAAa9oB,EAAQ8oB,YAAc7jB,EACnCjD,EAAWlK,EAASy3B,cACpByF,EAAuBl9B,EAASm9B,sBAChCC,EAAoBp9B,EAASq9B,mBACnC5f,EAAgBgV,cAAc,CAC1BzB,aACApmB,KAAM,EAAAwnB,aAAaC,aACnBpB,UACAsB,eAAgB,CACZ+K,WAAYp1B,EAAQo1B,WACpBC,YAAar1B,EAAQq1B,sBAGP,KAAAC,sBAAqB5uB,EAAU,CACjD1E,cAEGuzB,OACP,MAAMC,EAAiBjgB,EAAgByU,YAAYlB,SAC7C,SAAuBvT,EAAiB,CAC1C,CACI7O,aAEL,CAACoiB,IACJ,MAAM2M,EAAiC,KACnCD,EAAe39B,SACfkxB,EAAQrE,oBAAoB,EAAA2G,OAAOqK,2BAA4BD,EAA+B,EASlG,OANI1M,EAAQ1E,iBAAiB,EAAAgH,OAAOqK,2BAA4BD,GAGhED,EAAeG,oBAAoBX,GACnCQ,EAAe3K,iBAAiBqK,GAChCM,EAAe39B,SACR29B,CACX,C,gBC5CAZ,eAAegB,IAA6B,SAAE99B,EAAQ,QAAEkI,IACpD,MAAMw1B,EAAiB19B,GACjB,GAAEmN,EAAE,QAAE8jB,GAAYyM,EAClBjgB,EAAkBzd,EAASiwB,sBAC3B,WAAEqN,GAAep1B,EACjB8oB,EAAa9oB,EAAQ8oB,YAAc7jB,EACnCya,EAASwN,EAAA,GAAM7M,UAAUmV,EAAelT,eAC9C,KAAM5C,aAAkBmW,GAAA,GACpB,MAAM,IAAI77B,MAAM,+KAEpB,MAAMiwB,EAAgB,CAClBnB,aACApmB,KAAM,EAAAwnB,aAAaE,MACnBrB,UACAsB,eAAgB,CACZ+K,eAGFU,EAAWN,EAAeL,mBAChC5f,EAAgBgV,cAAcN,GAC9B,MAAM8L,EAAgBxgB,EAAgByU,YAAYlB,GAIlD,aAHMiN,EAAcC,SAAStW,EAAO1d,UACpC+zB,EAAclL,iBAAiBiL,GAC/BC,EAAcl+B,SACPk+B,CACX,C,wCCAA,SAASE,GAAiBp6B,GACtB,OAAOhD,KAAKkkB,MAAMlhB,EAAQ,GAAA2f,SAAW,GAAAA,OACzC,CAEA,SA/BA,SAAS0a,EAAYr6B,EAAOs6B,EAAY,GACpC,GAAI77B,MAAMC,QAAQsB,GACd,OAAOA,EAAMoG,KAAKoJ,GAAM6qB,EAAY7qB,EAAG8qB,KAAY7O,KAAK,MAE5D,GAAIzrB,SAAmD,KAAVA,EACzC,MAAO,MAEXA,EAAQ+L,OAAO/L,GACf,MAAMu6B,EAAWv9B,KAAK6e,IAAI7b,GAC1B,GAAIu6B,EAAW,KACX,MAAO,GAAGv6B,IAEd,MAAMw6B,EAAiBD,GAAY,IAC7BD,EAAY,EACZC,GAAY,GACRD,EAAY,EACZC,GAAY,EACRD,EACAC,GAAY,GACRD,EAAY,EACZC,GAAY,IACRD,EAAY,EACZC,GAAY,KACRD,EAAY,EACZA,EAAY,EACtC,OAAOt6B,EAAMy6B,QAAQD,EACzB,EC3Be,SAASE,GAAmBx1B,EAAYvI,EAAOC,GAC1D,MAAM+9B,EAASz1B,EAAWvE,SAAWhE,EAAQC,EAAS,EAChDg+B,EAAQ11B,EAAWvE,SAAWhE,EAAQC,EAAS,EACrD,GAAI+9B,GAAUC,EAAO,CACjB,MAAMC,EAAgB,IAAI7xB,aAAarM,EAAQC,GAC/C,IAAIyQ,EAAS,EACTytB,EAAa,EACjB,MAAMC,EAAYJ,EAAS,EAAI,EAC/B,IAAK,IAAIt9B,EAAI,EAAGA,EAAIV,EAAOU,IACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIX,EAAQW,IAAK,CAC7B,MAAMwZ,EAAI7R,EAAWmI,GACf2J,EAAI9R,EAAWmI,EAAS,GACxB4J,EAAI/R,EAAWmI,EAAS,GAC9BwtB,EAAcC,IAAe/jB,EAAIC,EAAIC,GAAK,EAC1C5J,GAAU0tB,EACVD,GACJ,CAEJ,OAAOD,CACX,CAEI,OAAO31B,CAEf,CCZA,SATA,SAA6BjJ,GACzB,GAAIA,aAAoB,KAAgB,CAEpC,OADeo1B,EAAA,GAAM7M,UAAUvoB,EAASwqB,eAC1BtgB,QAClB,CACK,GAAIlK,EAASy3B,YACd,OAAOz3B,EAASy3B,aAExB,ECVO,SAASsH,GAAyBjuB,EAAOwb,GAC5C,MAAM0S,EAAc,IAAIluB,GACxB,OAAIwb,GAAQ0S,EAAYt6B,QACpBu6B,GAAaD,GACNA,IAEXC,GAAaD,GACNA,EAAYx6B,MAAM,EAAG8nB,GAChC,CACA,SAAS2S,GAAanuB,GAClB,IAAK,IAAItD,EAAIsD,EAAMpM,OAAS,EAAG8I,EAAI,EAAGA,IAAK,CACvC,MAAMuI,EAAIhV,KAAK+Q,MAAM/Q,KAAKm+B,UAAY1xB,EAAI,KACzCsD,EAAMtD,GAAIsD,EAAMiF,IAAM,CAACjF,EAAMiF,GAAIjF,EAAMtD,GAC5C,CACJ,C,4ECdA,SAAS2xB,GAAeC,GACpB,MAAMC,EAAMD,EAAEjc,SAAS,IACvB,OAAqB,GAAdkc,EAAI36B,OAAc,IAAM26B,EAAMA,CACzC,CACA,SAASC,GAASxkB,EAAGC,EAAGC,GACpB,MAAO,IAAMmkB,GAAerkB,GAAKqkB,GAAepkB,GAAKokB,GAAenkB,EACxE,CACA,SAASukB,GAASF,GACd,MAAMG,EAAS,4CAA4CC,KAAKJ,GAChE,OAAOG,EACD,CACE1kB,EAAG4kB,SAASF,EAAO,GAAI,IACvBzkB,EAAG2kB,SAASF,EAAO,GAAI,IACvBxkB,EAAG0kB,SAASF,EAAO,GAAI,KAEzB,IACV,CChBO,SAASG,GAAUC,EAAMC,GAC5B,GAAID,IAASC,EACT,OAAO,EAEX,GAAY,MAARD,GAAwB,MAARC,EAChB,OAAO,EAEX,IACI,OAAOC,KAAKC,UAAUH,KAAUE,KAAKC,UAAUF,EACnD,CACA,MAAOp2B,GAEH,OADAyK,QAAQqM,MAAM,kDAAmD9W,GAC1Dm2B,IAASC,CACpB,CACJ,C,oDCbA,MAAMG,GAAU,CAAClvB,EAAO7M,IACb6M,EAAMmvB,QAAO,CAACC,EAAI9+B,MACpB8+B,EAAG9+B,EAAE6C,IAAQi8B,EAAG9+B,EAAE6C,KAAS,IAAIwI,KAAKrL,GAC9B8+B,IACR,CAAC,GAsBR,SAASC,GAAUC,EAAWC,GAC1B,MAAMC,EAAe,CAAC,EACtB,IAAIC,EAAwB,GAC5B,MAAMC,EAAY98B,OAAO4B,KAAK86B,GAC9B,IAAK,IAAI5yB,EAAI,EAAGA,EAAIgzB,EAAU97B,OAAQ8I,IAAK,CACvC,MAAMizB,EAAkB,IAAI9D,IACtB+D,EAASN,EAAUI,EAAUhzB,IACnC,IAAK,IAAIuI,EAAI,EAAGA,EAAI2qB,EAAOh8B,OAAQqR,IAAK,CACpC,MAAM4qB,EAAcN,EAAaK,EAAO3qB,GAAG9N,UAAY,EAIvD,GAHAq4B,EAAaK,GAAeL,EAAaK,IAAgB,GACzDL,EAAaK,GAAal0B,KAAK,CAAExE,QAASy4B,EAAO3qB,GAAG9N,UACpDw4B,EAAgBr5B,IAAIu5B,GAChBF,EAAgBnU,KAAO,EAAIvW,EAC3B,MAER,CACA,GAAS,GAALvI,EACA+yB,EAAwB/9B,MAAM6D,KAAKo6B,QAElC,IAAKG,GAAUL,EAAuBE,GACvC,MAER,CACA,OAAOH,CACX,CACA,SAASO,GAAY54B,EAAS64B,GAC1B,MAAM/8B,EAAQmxB,EAAShxB,IAAI48B,EAAK74B,GAChC,IACI,OAAOsS,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASg9B,GAAwB94B,GAC7B,MAAMlE,EAAQmxB,EAAShxB,IAAI,WAAY+D,GACvC,IACI,MAAM,aAAE+4B,GAAiBj9B,EACzB,GAAIi9B,EAAc,CACd,MAAMC,EAAcC,KAAKF,GACnBG,EAAU,IAAIpwB,YAAYkwB,EAAYv8B,QACtC08B,EAAK,IAAIC,SAASF,GACxB,IAAK,IAAI3zB,EAAI,EAAGA,EAAIyzB,EAAYv8B,OAAQ8I,IACpC4zB,EAAGE,SAAS9zB,EAAGyzB,EAAY/d,WAAW1V,IAE1C,OAAO,IAAIT,aAAao0B,GAAS,EACrC,CACA,OAAO5mB,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASw9B,GAAwBt5B,GAC7B,IAAIlE,EAAQmxB,EAAShxB,IAAI,WAAY+D,IAAYitB,EAAShxB,IAAI,WAAY+D,GAC1E,IACI,MAAM,aAAE+4B,GAAiBj9B,EAIzB,OAHIi9B,IACAj9B,EAAQm9B,KAAKF,IAEVzmB,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASy9B,GAAmBv5B,GACxB,IAAIlE,EAAQmxB,EAAShxB,IAAI,WAAY+D,GACrC,IACI,MAAM,aAAE+4B,GAAiBj9B,EAIzB,OAHIi9B,IACAj9B,EAAQm9B,KAAKF,GAAc96B,MAAM,OAE9BqU,WAAWxW,EAAM,IAAM,GAClC,CACA,MACI,MACJ,CACJ,CACA,SAAS68B,GAAUa,EAAOC,GACtB,GAAID,EAAM/8B,QAAUg9B,EAAMpV,KACtB,OAAO,EAEX,IAAK,IAAI9e,EAAI,EAAGA,EAAIi0B,EAAM/8B,OAAQ8I,IAC9B,IAAKk0B,EAAMv6B,IAAIs6B,EAAMj0B,IACjB,OAAO,EAGf,OAAO,CACX,CACA,SAASm0B,GAAyB15B,GAC9B,MAAM25B,EAAa1M,EAAShxB,IAAI,iBAAkB+D,GAClD,OAAO25B,EAAaA,EAA+B,mBAAI,CAC3D,CAwCA,SAvCA,SAA+B13B,GAC3B,MAAM23B,EAnHV,SAAsB33B,GAClB,MAAM43B,EAAc53B,EAASC,KAAKlC,IAC9B,MAAM,qBAAE6D,GAAyBopB,EAAShxB,IAAI,mBAAoB+D,IAAY,CAAC,EAC/E,MAAO,CAAEA,UAAS6D,uBAAsB,IAE5C,IAAKg2B,EAAYzR,OAAOpX,GAASA,EAAKnN,uBAClC,OAAO,KAEX,MAAM+1B,EAAiB7B,GAAQ8B,EAAa,wBACtCtB,EAAY98B,OAAO4B,KAAKu8B,GACxBE,EAAcF,EAAerB,EAAU,IAAI97B,OACjD,OAAoB,IAAhBq9B,EACO,KAEevB,EAAUnQ,OAAOla,GAAM0rB,EAAe1rB,GAAGzR,SAAWq9B,IAIvEF,EAFI,IAGf,CAgG2BG,CAAa93B,GACpC,IAAK23B,EACD,MAAO,CAAEI,cAAe,CAAC/3B,GAAWg4B,aAAc,MAEtD,MAAMC,EAAO,CACT,6BACA,kBACA,cACA,WACA,aACA,uBACA,uBACA,kBACA,yBAEEC,EAAW,CACZn6B,GAAY44B,GAAY54B,EAASk6B,EAAK,IACtCl6B,GAAY44B,GAAY54B,EAASk6B,EAAK,IACtCl6B,GAAY44B,GAAY54B,EAASk6B,EAAK,IACtCl6B,GAAY44B,GAAY54B,EAASk6B,EAAK,IACtCl6B,GAAY44B,GAAY54B,EAASk6B,EAAK,IACvCpB,GACAQ,GACAC,GACAG,IAEJ,IAAK,IAAIn0B,EAAI,EAAGA,EAAI40B,EAAS19B,OAAQ8I,IAAK,CACtC,MAAM8yB,EAAeH,GAAU0B,EAAgBO,EAAS50B,IACxD,GAAI8yB,EAAc,CAKd,MAAO,CAAE2B,cAJUv+B,OAAO4B,KAAKg7B,GAC1Bn2B,IAAI2F,OAAOyK,YACXwF,MAAK,CAACC,EAAGhF,IAAMgF,EAAIhF,IACS7Q,KAAKlG,GAAQq8B,EAAar8B,GAAKkG,KAAK8O,GAASA,EAAKhR,YAC3Di6B,aAAcC,EAAK30B,GAC/C,CACJ,CACA,MAAO,CAAEy0B,cAAe,CAAC/3B,GAAWg4B,aAAc,KACtD,ECzJA,SALA,SAA8Bh4B,GAC1B,MAAQ+3B,cAAeI,EAAU,aAAEH,GAAiB,GAAsBh4B,GAE1E,MAAO,CAAEo4B,gBADeD,EAAW39B,OAAS,EAClB29B,aAAYH,eAC1C,E,gBCLe,SAASK,GAAWzxB,EAAOwU,GACtC,MAAMkd,EAAc1xB,EAAMpM,QACpB,aAAE6gB,EAAY,iBAAEC,EAAgB,MAAEE,GAAUJ,EAClD,GAAmC,OAA/BA,EAAkBrjB,UAAsC,iBAAVyjB,EAC9C,IAAK,IAAIlY,EAAI,EAAGA,EAAIg1B,EAAah1B,IAC7BsD,EAAMtD,GAAKkY,GAAS5U,EAAMtD,GAAK+X,EAAeC,QAIlD,IAAK,IAAIhY,EAAI,EAAGA,EAAIg1B,EAAah1B,IAC7BsD,EAAMtD,GAAKsD,EAAMtD,GAAK+X,EAAeC,EAG7C,OAAO1U,CACX,C,gBCdO,SAAS2xB,GAAKC,EAAKC,EAAKC,GAC3B,OAAO7hC,KAAKa,IAAIb,KAAKkS,IAAI0vB,EAAKD,GAAME,EACxC,CAKA,YCAe,SAAS,GAAO5iC,EAAUkI,GAErC,KADuB,EAAA8zB,GAAA,IAAkBh8B,EAASixB,SAE9C,MAAM,IAAI/uB,MAAM,0DAEpB,GAAIlC,aAAoB,MACc,IAAlCA,EAASy3B,cAAc/yB,OACvB,MAAM,IAAIxC,MAAM,wCAEpB,MAAM,SAAE0M,EAAQ,MAAEyK,EAAK,YAAEwpB,GAAgB36B,EACzC,GAAIlI,aAAoB,MAiBrB,SAAsBA,EAAU4O,EAAUyK,EAAOwpB,GAAc,GAClE,MAAM3a,EAAmB2a,GACnB,eAAEnY,EAAc,iBAAEE,EAAgB,eAAEC,IAAmB,EAAAiY,GAAA,GAA4B9iC,EAAU4O,EAAUsZ,GAC7G,IAAK2C,EACD,OAEJ,MAAM,WAAE9F,EAAU,yBAAEN,EAAwB,OAAEF,GAAWsG,GACnD,WAAEnG,EAAU,gBAAEnB,EAAe,SAAEmO,GAAanN,GAC5C,cAAEwe,EAAa,YAAEpM,IAAgB,EAAAqM,GAAA,GAAsBte,EAAYgN,EAAU3M,EAAYxB,EAAiBkB,EAA0BpL,GAC1IrZ,EAASijC,UAAU,CACfve,WAAYqe,EACZrR,SAAUiF,IAEd32B,EAASD,SACT,MAAMmjC,EAAmBtY,EAAmBvR,EACtC8pB,EAA0B,CAC5Bv0B,WACA5O,WACAqZ,QACA6pB,mBACAtY,mBACAF,iBACA0Y,eAAgBpjC,EAASqjC,sBAExBH,EAAmBxY,GAAkBwY,EAAmB,IACzDljC,EAASqjC,qBACT,EAAAC,EAAA,GAAarN,EAAA,EAAa,EAAA1C,OAAOgQ,qCAAsCJ,IAGvE,EAAAG,EAAA,GAAarN,EAAA,EAAa,EAAA1C,OAAOiQ,uBAAwBL,EAEjE,CA/CQM,CAAazjC,EAAU4O,EAAUyK,EAAOwpB,OAEvC,CACD,MAAMtN,EAAev1B,EAAS23B,yBAC9B,GAAIpC,EAAelc,EACfrZ,EAASy3B,cAAc/yB,OAAS,GAChC6wB,EAAelc,EAAQ,EAAG,CAC1B,MAAMqqB,EAAY,CACdnO,eACAxpB,UAAWsN,IAEf,EAAAiqB,EAAA,GAAarN,EAAA,EAAa,EAAA1C,OAAOoQ,2BAA4BD,EACjE,CACA1jC,EAAS4jC,OAAOvqB,EAAOnR,EAAQ27B,gBAAiB37B,EAAQ47B,KAC5D,CACJ,CC7BAhH,eAAeiH,GAAY9S,EAAS/oB,EAAU,CAAC,GAC3C,MAAM,WAAEgd,EAAU,gBAAE2e,EAAe,SAAEj1B,GAAa1G,EAC5C9I,GAAiB,EAAA48B,GAAA,IAAkB/K,GACzC,IAAK7xB,EACD,MAAM,IAAI8C,MAAM,6BAEpB,MAAM,SAAElC,GAAaZ,GACb8lB,WAAY8e,EAAiB,eAAEhf,GAK3C,SAA4BhlB,EAAU6jC,GAClC,GAAI7jC,aAAoBi8B,GAAA,EACpB,MAAO,CACHjX,eAAgBhlB,EAASy3B,cAAc/yB,OACvCwgB,WAAY2e,EACN7jC,EAASikC,wBACTjkC,EAAS23B,0BAGvB,MAAO,CACH3S,eAAgBhlB,EAASkkC,oBACzBhf,WAAYllB,EAASm6B,gBAE7B,CAlB8DgK,CAAmBnkC,EAAU6jC,GACjFO,EAkBV,SAA8Bpf,EAAgBE,GAC1C,MAAMmf,EAAiBrf,EAAiB,EACxC,OAAO,GAAKE,EAAY,EAAGmf,EAC/B,CArB6BC,CAAqBtf,EAAgBE,GAE9D,GAAOllB,EAAU,CAAEqZ,MADL+qB,EAAmBJ,EACPH,kBAAiBj1B,YAC/C,CCVA,SAAS21B,GAAgBC,EAAoBxrB,EAAW9Q,EAAU,CAAC,GAC/D,MAAMu8B,EAAmBrP,EAAA,GAAM7M,UAAUic,GACzC,IAAKC,EACD,MAAM,IAAIviC,MAAM,6BAA6BsiC,qBAEjD,MAAM,SAAEx5B,EAAQ,QAAEY,EAAO,UAAEG,EAAWJ,WAAY+4B,GAAkBD,GAC9D,KAAErd,EAAI,KAAEC,EAAI,KAAEsd,EAAI,KAAEC,EAAI,KAAEC,EAAI,KAAEC,GAAS9rB,EACzC+rB,EAAa,CACfhkC,KAAKa,IAAIwlB,EAAMC,GACftmB,KAAKa,IAAI+iC,EAAMC,GACf7jC,KAAKa,IAAIijC,EAAMC,IAEbE,GAAyB,EAAAC,EAAA,GAAsBR,EAAiBte,UAAW4e,GAC3Ep5B,EAAa,CACf5K,KAAK6e,IAAIyH,EAAOD,GAAQ,EACxBrmB,KAAK6e,IAAIglB,EAAOD,GAAQ,EACxB5jC,KAAK6e,IAAIklB,EAAOD,GAAQ,IAEtB,aAAEl6B,GAAiBzC,EACnBg9B,EAAmB,CACrBl6B,WACAW,aACAC,UACAC,OAAQm5B,EACRj5B,YACApB,eACA1B,WAAmC,iBAAvB0B,GAAcC,KACpB,IAAImC,aAAapB,EAAW,GAAKA,EAAW,GAAKA,EAAW,SAC5D7J,GAEJqjC,GAAY,KAAAC,oBAAkB,EAAApI,EAAA,KAAUkI,GACxCG,EAAgBF,EAAUr8B,aAAaw8B,6BACvCC,EAAqB55B,EAAW,GAAKA,EAAW,GAChD65B,EAAqBd,EAAa,GAAKA,EAAa,GACpDe,EAAgBhB,EAAiB37B,aAAaw8B,6BACpD,IAAK,IAAI3yB,EAAI,EAAGA,EAAIhH,EAAW,GAAIgH,IAC/B,IAAK,IAAIrR,EAAI,EAAGA,EAAIqK,EAAW,GAAIrK,IAAK,CACpC,MAAMokC,GAAgB,EAAAT,EAAA,GAAsBE,EAAUhf,UAAW,CAC7D,EACA7kB,EACAqR,IAEEgzB,GAAuB,EAAAC,EAAA,GAAsBnB,EAAiBte,UAAWuf,GACzEG,EAA0BF,EAAqB,GAAKH,EACtDG,EAAqB,GAAKjB,EAAa,GACvCiB,EAAqB,GACnBG,EAAUL,EAAcjhC,MAAMqhC,EAAyBA,EAA0Bl6B,EAAW,IAC5Fo6B,EAA2BpzB,EAAI4yB,EAAqBjkC,EAAIqK,EAAW,GACzE05B,EAAcrhC,IAAI8hC,EAASC,EAC/B,CAGJ,OADAZ,EAAUr8B,aAAak9B,2BAA2BX,GAC3CF,CACX,CCxDA,SAASc,GAA0B9f,EAAW5B,GAC1C,MAAM,OAAE2hB,EAAM,gBAAE3iB,GAAoBgB,EAC9B4hB,GAAY,EAAAP,EAAA,GAAgCzf,EAAW,CAAC,EAAG,EAAG,IAC9DigB,EAAiB,YAAY,cAAeF,GAC5CG,EAAmB,YAAY,cAAe9iB,GAC9C+iB,EAAiB,WAAW,cAAeF,EAAgBC,GAC3DE,EAAe,SAAS,eAAe,EAAAX,EAAA,GAAgCzf,EAAWigB,GAAiBD,GACnGK,EAAiB,SAAS,eAAe,EAAAZ,EAAA,GAAgCzf,EAAWkgB,GAAmBF,GAC7G,eAAeI,EAAcA,GAC7B,eAAeC,EAAgBA,GAE/B,MAAO,CACHF,iBACAF,iBACAC,mBACAI,aALiB,WAAW,cAAeF,EAAcC,GAMzDD,eACAC,iBAER,C,2BCrBO,SAASE,GAA2Bz9B,EAAY0C,EAAYg7B,EAAWC,GAC1E,MAAOlmC,EAAOC,EAAQkmC,GAAal7B,EAC7Bm7B,EAAoBpmC,EAAQC,EAClC,IAAIyX,EAAM,EACN2uB,EAAQ,EACRh0B,EAAQ,EACZ,MAAOi0B,EAAIC,EAAIC,GAAMP,EAAUx8B,IAAIpJ,KAAKkkB,OACxC,IAAK,IAAItS,EAAIu0B,EAAKN,EAAQj0B,GAAKu0B,EAAKN,EAAQj0B,IACxC,KAAIA,EAAI,GAAKA,GAAKk0B,GAGlB,IAAK,IAAIvlC,EAAI2lC,EAAKL,EAAQtlC,GAAK2lC,EAAKL,EAAQtlC,IACxC,KAAIA,EAAI,GAAKA,GAAKX,GAGlB,IAAK,IAAIS,EAAI4lC,EAAKJ,EAAQxlC,GAAK4lC,EAAKJ,EAAQxlC,IAAK,CAC7C,GAAIA,EAAI,GAAKA,GAAKV,EACd,SAEJ,MACMqD,EAAQkF,EADA0J,EAAIm0B,EAAoBxlC,EAAIZ,EAAQU,GAElDgX,GAAOrU,EACPgjC,GAAShjC,EAAQA,EACjBgP,GACJ,CAGR,GAAc,IAAVA,EAAa,CACb,MAAMo0B,EAAcD,EAAKJ,EAAoBG,EAAKvmC,EAAQsmC,EAC1D,GAAIG,GAAe,GAAKA,EAAcl+B,EAAWvE,OAAQ,CAErD,MAAO,CAAE0iC,KADWn+B,EAAWk+B,GACHE,OAAQ,EAAGt0B,MAAO,EAClD,CAEI,MAAO,CAAEq0B,KAAM,EAAGC,OAAQ,EAAGt0B,MAAO,EAE5C,CACA,MAAMq0B,EAAOhvB,EAAMrF,EACbu0B,EAAWP,EAAQh0B,EAAQq0B,EAAOA,EAExC,MAAO,CAAEA,OAAMC,OADAtmC,KAAKwmC,KAAKxmC,KAAKkS,IAAI,EAAGq0B,IACdv0B,QAC3B,CCuDA,MAAMy0B,GAAsB,CAACxnC,EAAU4O,IChGvC,SAA8B5O,EAAU4O,EAAU2Z,GAC9C,IAAKA,EACD,MAAM,IAAIrmB,MAAM,4DAEpB,GAAIlC,EAASiC,SACT,OAAOjC,EAASiC,SAEpB,GAAIjC,EAAS8zB,WAAY,CAErB,KADAllB,EAAWA,GAAY5O,EAASwqB,iBACdjC,EACd,OAGJ,OADeA,EAAU3Z,GACX5D,SAASy8B,QAC3B,CACA,MAAM,IAAIvlC,MAAM,wBACpB,CDgFoDwlC,CAAqB1nC,EAAU4O,EAAUwmB,EAAA,GAAM7M,U,+BEhGpF,SAASof,EAA0BtZ,GAC9C,IAAKA,EACD,OAEJ,MAAM/B,EAAO+B,EAAoBC,UACjC,IAAK,IAAIhiB,EAAQ,EAAGA,EAAQggB,EAAMhgB,IAAS,CACvC,MAAMiiB,EAAa,GACnBF,EAAoBG,aAAaliB,EAAOiiB,GACxCA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BF,EAAoBI,aAAaniB,EAAOiiB,EAC5C,CACJ,C,+CCbA,SAASqZ,EAA6BC,EAAMC,EAAMjY,GAC9C,OAAO9uB,KAAK6e,IAAIioB,EAAOC,IAASjY,CACpC,CAYA,SAASkY,EAAahkC,GAClB,MAAwB,iBAAVA,CAClB,CACA,SAASikC,EAAkBjkC,GACvB,OAAQA,GACa,iBAAVA,GACP,WAAYA,GACY,iBAAjBA,EAAMW,QACbX,EAAMW,OAAS,GACK,iBAAbX,EAAM,EACrB,CACe,SAAS04B,EAAQ9M,EAAIC,EAAIC,EAAY,MAChD,cAAWF,UAAcC,GAAa,OAAPD,GAAsB,OAAPC,IAG1CmY,EAAapY,IAAOoY,EAAanY,GAC1BgY,EAA6BjY,EAAIC,EAAIC,MAE5CmY,EAAkBrY,KAAOqY,EAAkBpY,KA7BnD,SAAwBqY,EAAMC,EAAMrY,EAAY,MAC5C,GAAIoY,EAAKvjC,SAAWwjC,EAAKxjC,OACrB,OAAO,EAEX,IAAK,IAAI8I,EAAI,EAAGA,EAAIy6B,EAAKvjC,OAAQ8I,IAC7B,IAAKo6B,EAA6BK,EAAKz6B,GAAI06B,EAAK16B,GAAIqiB,GAChD,OAAO,EAGf,OAAO,CACX,CAoBesY,CAAexY,EAAIC,EAAIC,GAGtC,C,6CACA,MAAMuY,EAAY70B,GAAmB,iBAANA,GAAkBA,EAAIA,GAAGpJ,IAAMoJ,EAAEpJ,IAAIi+B,IAAa70B,EAC3EqM,EAAOrM,GAAmB,iBAANA,EAAiBxS,KAAK6e,IAAIrM,GAAKA,GAAGpJ,IAAMoJ,EAAEpJ,IAAIyV,GAAOrM,EACzE80B,EAAkB,CAAC1Y,EAAIC,EAAIC,OAAY/tB,IAAc26B,EAAQ9M,EAAIyY,EAASxY,GAAKC,GAC/EyY,EAAa,CAAC3Y,EAAIC,EAAIC,OAAY/tB,IAAc26B,EAAQ7c,EAAI+P,GAAK/P,EAAIgQ,GAAKC,E,6OCvChF,MAAM0Y,E,MAAW,gBAIV,SAASC,EAAcpkC,GAC1B,MAAMqkC,EAASF,EAASG,UAAUtkC,EAAK,IAIvC,OAHAqkC,EAAOC,UAAY,IAAIC,IACZH,EAAc,GAAGpkC,KAAQukC,EAAMnZ,KAAK,QAExCiZ,CACX,CACO,SAASC,KAAatkC,GACzB,OAAOokC,EAAcpkC,EAAKorB,KAAK,KACnC,CAZsB,oBAAX6B,SACPA,OAAOxH,IAAM0e,GAYV,MAAMK,EAAUJ,EAAc,QACxBK,EAAUD,EAAQF,UAAU,QAC5BI,EAAWF,EAAQF,UAAU,SAC7BK,EAAYH,EAAQF,UAAU,oBAC9BM,EAAQJ,EAAQF,UAAU,MAC1BO,EAAcL,EAAQF,UAAU,YAChCQ,EAAsBR,EAAU,cAAe,SAC/CS,EAAsBT,EAAU,cAAe,Q,8DCrB7C,SAASU,EAAmBl/B,GACvC,MAAMkyB,EAAWlyB,EAAS,IACpB,oBAAEsB,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE4B,EAAyB,gBAAE3B,IAAqB,IAAArH,KAAI,mBAAoBk4B,GACnIiN,EAAS,GACTC,GAAe,IAAAplC,KAAI,eAAgBk4B,GACzC,IAAIhe,EACJ,GAAIkrB,EAAc,CACd,MAAM,YAAEhnC,EAAW,aAAEC,GAAiB+mC,EAEtC,GADAlrB,EAAiBkrB,GAAclrB,eAC3B5b,MAAMC,QAAQH,GACd,IAAK,IAAIkL,EAAI,EAAGA,EAAIlL,EAAYoC,OAAQ8I,IACpC67B,EAAO58B,KAAK,CACRnK,YAAaA,EAAYkL,GACzBjL,aAAcA,EAAaiL,UAKnC67B,EAAO58B,KAAK,CACRnK,YAAaA,EACbC,aAAcA,GAG1B,MAEI8mC,EAAO58B,KAAK,CACRnK,iBAAaR,EACbS,kBAAcT,IAGtB,MAAM,SAAEG,EAAQ,kBAAEo6B,IAAsB,IAAAn4B,KAAI,sBAAuBk4B,IAC7D,wBAAEpwB,EAAuB,aAAEY,EAAY,oBAAEX,EAAmB,QAAEnJ,EAAO,KAAEC,IAAU,IAAAmB,KAAI,mBAAoBk4B,GAC/G,MAAO,CACHmN,cAAen+B,EACfo+B,WAAYn+B,EACZo+B,gBAAiBl+B,EACjBm+B,QAASp+B,EACTq+B,0BAA2Bz8B,EAC3B08B,oBAAqBp+B,EACrBi8B,SAAUxlC,EACV4nC,wBAAyB79B,EACzB89B,aAAcl9B,EACdkB,oBAAqB7B,EACrB89B,QAASjnC,EACTknC,KAAMjnC,EACNsmC,SACAY,eAAgB7rB,EAChB8rB,kBAAmB7N,EAE3B,C,qKCjDA,SAAS8N,EAAsBC,EAAIC,EAAInS,GACnC,MAAOoS,EAAIC,EAAIC,GAAMJ,GACdtgB,EAAIH,EAAI8gB,GAAMJ,GACdK,EAAGC,EAAGC,EAAGC,GAAK3S,EACflY,EAAI8J,EAAKwgB,EACTtvB,EAAI2O,EAAK4gB,EACTnL,EAAIqL,EAAKD,EACTM,GAAM,GAAKJ,EAAIJ,EAAKK,EAAIJ,EAAKK,EAAIJ,EAAKK,IAAOH,EAAI1qB,EAAI2qB,EAAI3vB,EAAI4vB,EAAIxL,GAIvE,MAAO,CAHGpf,EAAI8qB,EAAIR,EACRtvB,EAAI8vB,EAAIP,EACRnL,EAAI0L,EAAIN,EAEtB,CACA,SAASrS,EAAc4S,EAAQ34B,EAAO44B,GAAa,GAC/C,MAAON,EAAGC,EAAGC,GAAKG,EACZF,EAAIH,EAAIt4B,EAAM,GAAKu4B,EAAIv4B,EAAM,GAAKw4B,EAAIx4B,EAAM,GAClD,GAAI44B,EAAY,CACZ,MAAMtmC,EAAS3D,KAAKwmC,KAAKmD,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAC7C,MAAO,CAACF,EAAIhmC,EAAQimC,EAAIjmC,EAAQkmC,EAAIlmC,EAAQmmC,EAAInmC,EACpD,CACA,MAAO,CAACgmC,EAAGC,EAAGC,EAAGC,EACrB,CACA,SAASI,EAAuBC,EAAYC,EAAaC,GACrD,MAAOC,EAAIC,EAAIC,EAAIC,GAAMN,GAClBO,EAAIC,EAAIC,EAAIC,GAAMT,GAClBU,EAAIC,EAAIC,EAAIC,GAAMZ,EACnBa,EAAK,gBAAgBZ,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDG,EAAK,gBAAgBV,EAAII,EAAII,EAAIV,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDI,EAAK,gBAAgBd,EAAII,EAAII,EAAIL,EAAII,EAAII,EAAIT,EAAII,EAAII,GACrDK,EAAK,gBAAgBf,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIN,EAAII,EAAII,GAI3D,MAAO,CAHG,iBAAiBE,GAAM,iBAAiBD,GACxC,iBAAiBE,GAAM,iBAAiBF,GACxC,iBAAiBG,GAAM,iBAAiBH,GAEtD,CACA,SAAS7T,EAAqBF,EAAO9lB,EAAOi6B,GAAS,GACjD,MAAO3B,EAAGC,EAAGC,EAAGC,GAAK3S,GACd92B,EAAGE,EAAGqR,GAAKP,EACZk6B,EAAY5B,EAAItpC,EAAIupC,EAAIrpC,EAAIspC,EAAIj4B,EAAIk4B,EACpC/qB,EAAW/e,KAAK6e,IAAI0sB,GAAavrC,KAAKwmC,KAAKmD,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAErE,OADayB,EAAStrC,KAAKwrC,KAAKD,GAAa,GAC/BxsB,CAClB,C,yEC1CO,SAAS0sB,EAAqBrmB,EAAWje,GAC5C,MAAM,eAAEukC,EAAc,SAAEznC,EAAQ,UAAEgU,EAAS,aAAE0zB,GAAe,GAAUxkC,EACtE,IAAIe,EACJ,GAAIkd,EAAUhd,cACVF,EAAakd,EAAUhd,oBAEtB,CACD,MAAMwjC,EAAUxmB,EAAUymB,eAAeC,aACzC,GAAIF,EACA1jC,EAAa0jC,EAAQG,cAEpB,CACD,MAAM,aAAEhkC,GAAiBqd,EAAUjiB,IAAI,iBAAmB,CAAC,EACvD4E,IACAG,EAAaH,EAAaw8B,6BAElC,CACJ,CACA,MAAM35B,EAAawa,EAAUQ,gBACvBomB,EAAmB,CACrB,CAAC,EAAGphC,EAAW,IACf,CAAC,EAAGA,EAAW,IACf,CAAC,EAAGA,EAAW,KAGbqhC,EASH,UAAkC,UAAE7mB,EAAS,OAAEkE,EAAM,WAAEphB,EAAU,eAAEwjC,EAAc,SAAEznC,IACtF,OAAQioC,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASjjB,GAC7C,SAAE5U,GAAa0Q,EACfxa,EAAawa,EAAUQ,gBACvBC,GAAe,OAAuBT,GACtConB,EAAW,CAAC,EAAG,EAAG,GAClBC,EAAY/3B,GACdxM,EAAWvE,OAASiH,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAC7D8hC,EAAY9hC,EAAW,GAAK6hC,EAC5BE,EAAY/hC,EAAW,GAAK8hC,EAC5BT,EAAgB,GACtB,IAAK,IAAI72B,EAAIk3B,EAAMl3B,GAAKm3B,EAAMn3B,IAAK,CAC/Bo3B,EAAS,GAAKp3B,EACd,MAAMw3B,EAASx3B,EAAIu3B,EACnB,IAAK,IAAI33B,EAAIo3B,EAAMp3B,GAAKq3B,EAAMr3B,IAAK,CAC/Bw3B,EAAS,GAAKx3B,EACd,MAAM63B,EAAUD,EAAS53B,EAAI03B,EAC7B,IAAK,IAAIjgC,EAAIy/B,EAAMz/B,GAAK0/B,EAAM1/B,IAAK,CAC/B+/B,EAAS,GAAK//B,EACd,MAAMqgC,EAAWjnB,EAAa2mB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMjhC,EAAQshC,EAAUpgC,EAAIggC,EAC5B,IAAIzpC,EAEAA,EADAypC,EAAY,EACJ,CACJvkC,EAAWqD,GACXrD,EAAWqD,EAAQ,GACnBrD,EAAWqD,EAAQ,IAIfrD,EAAWqD,GAEvB0gC,EAAcvgC,KAAK,CACf1I,QACAuI,QACAihC,WACAM,SAAUA,EAASrpC,UAEvBQ,EAAS,CAAEjB,QAAOuI,QAAOihC,WAAUM,YACvC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,CAtD0Bc,CAAyB,CAC3C3nB,YACAkE,OAHWrR,GAAa+zB,EAIxB9jC,aACAwjC,iBACAznC,aAEJ,OAAO0nC,EAAeM,OAAgBlrC,CAC1C,CA+CO,SAASisC,GAAqC,aAAEjlC,EAAY,OAAEuhB,EAAM,UAAElE,EAAS,eAAEsmB,EAAc,SAAEznC,EAAQ,aAAE0nC,IAC9G,OAAQO,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASjjB,EAC7CzD,GAAe,OAAuBT,GACtConB,EAAW,CAAC,EAAG,EAAG,GAClBP,EAAgB,GACtB,IAAK,IAAI72B,EAAIk3B,EAAMl3B,GAAKm3B,EAAMn3B,IAAK,CAC/Bo3B,EAAS,GAAKp3B,EACd,IAAK,IAAIJ,EAAIo3B,EAAMp3B,GAAKq3B,EAAMr3B,IAAK,CAC/Bw3B,EAAS,GAAKx3B,EACd,IAAK,IAAIvI,EAAIy/B,EAAMz/B,GAAK0/B,EAAM1/B,IAAK,CAC/B+/B,EAAS,GAAK//B,EACd,MAAMqgC,EAAWjnB,EAAa2mB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMjhC,EAAQxD,EAAauO,QAAQk2B,GAC7BxpC,EAAQ+E,EAAaklC,WAAW1hC,GAClCogC,GACAM,EAAcvgC,KAAK,CACf1I,QACAuI,QACAihC,SAAU,IAAIA,GACdM,SAAUA,EAASrpC,UAG3BQ,IAAW,CAAEjB,QAAOuI,QAAOihC,WAAUM,YACzC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,C,8DC7Ge,SAAShK,EAAsBte,EAAYgN,EAAU3M,EAAYxB,EAAiBkB,EAA0BwpB,GACvH,MAAM,IAAErsC,EAAG,IAAEqR,EAAG,QAAErM,GAAYme,EACxBmpB,EAAwB,cAC9B,SAASA,EAAuBxc,EAAUhN,GAC1C,MAAMypB,EAAQptC,KAAKkkB,OAAOhS,EAAMrR,GAAO6iB,GAEjCkG,GADY/jB,EAAUhF,IAAQqR,EAAMrR,GACJusC,EACtC,IAAIC,EAAartC,KAAKkkB,MAAM0F,GACxBoY,EAAgB,CAChBre,EAAW,GACPnB,EAAgB,GAAKoH,EAAqBlG,EAC9CC,EAAW,GACPnB,EAAgB,GAAKoH,EAAqBlG,EAC9CC,EAAW,GACPnB,EAAgB,GAAKoH,EAAqBlG,GAElD2pB,GAAcH,EACVG,EAAaD,EACbC,EAAaD,EAERC,EAAa,IAClBA,EAAa,GAEjB,MAAMC,EAAqBD,EAAa3pB,EACxCse,EAAgB,CACZA,EAAc,GAAKxf,EAAgB,GAAK8qB,EACxCtL,EAAc,GAAKxf,EAAgB,GAAK8qB,EACxCtL,EAAc,GAAKxf,EAAgB,GAAK8qB,GAO5C,MAAO,CAAEtL,gBAAepM,YALJ,CAChBoM,EAAc,GAAKmL,EAAsB,GACzCnL,EAAc,GAAKmL,EAAsB,GACzCnL,EAAc,GAAKmL,EAAsB,IAGjD,C,oFCjCe,SAASI,EAA0BpkC,EAAUiV,GACxD,MAAQrT,qBAAsBkT,EAA6B,wBAAEhT,GAA6B,MAAa,mBAAoB9B,EAAS,IACpI,IAAKiV,EAAgB,CACjB,MAAMF,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHmT,EAAiB,cACjB,WAAWA,EAAgBF,EAAcC,EAC7C,CACA,MAAMqvB,EAA6C,YAA9BrkC,EAAS,GAAGhE,MAAM,KAAK,GACtCke,GAAW,OAAgCla,GACjD,IAAIskC,EACJ,SAASnvB,EAAYpX,GACjB,MAAM,qBAAE6D,GAAyB,MAAa,mBAAoB7D,GAC5DqX,EAAiB,cAEvB,OADA,SAASA,EAAgBN,EAA+BlT,GACjD,SAASwT,EAAgBH,EACpC,CACA,GAAKovB,EAWA,CACD,MAAM/uB,EAAqB,CACvBtV,EAAS,GACTA,EAASnJ,KAAK+Q,MAAM5H,EAASxF,OAAS,KAE1C8pC,EAAiBtkC,EACUmV,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IACZ,GAC3CgvB,EAAe58B,SAEvB,KAtBmB,CACf,MAAMiO,EAAqB3V,EAASC,KAAKlC,IAE9B,CACH6X,SAFaT,EAAYpX,GAGzBA,cAGR4X,EAAmBE,MAAK,CAACC,EAAGhF,IAAMA,EAAE8E,SAAWE,EAAEF,WACjD0uB,EAAiB3uB,EAAmB1V,KAAK6V,GAAMA,EAAE/X,SACrD,CAaA,MAAQ6D,qBAAsBD,GAAW,MAAa,mBAAoB2iC,EAAe,IAMzF,MALe,CACXpqB,WACAvY,SACA2iC,iBAGR,C,+BClDA,SAASC,EAAyBC,GAC9B,MAAMpiB,EAAOoiB,EAAiBpgB,UACxB7P,EAAS,GACf,IAAK,IAAInS,EAAQ,EAAGA,EAAQggB,EAAMhgB,IAAS,CACvC,MAAMiiB,EAAa,GACnBmgB,EAAiBlgB,aAAaliB,EAAOiiB,GACrC9P,EAAOhS,KAAK8hB,EAChB,CACA,OAAO9P,CACX,CACA,SAASkwB,EAAyBD,EAAkBE,GAC3CA,GAAOlqC,SAGZgqC,EAAiBxzB,kBACjB0zB,EAAM7pC,SAAS8pC,IACXH,EAAiBvzB,eAAe0zB,EAAK,IAE7C,C,4ICjBO,SAAS7V,EAAqBh5B,EAAU8uC,GAC3C,MAAQ3oB,UAAW4oB,GAAiB/uC,EAASw5B,eACvCwV,EAAahvC,EAASkzB,cAAc4b,GAC1C,OAAO,OAAsBC,EAAcC,EAC/C,C,+BCLe,SAAS/J,EAAsB9e,EAAW8oB,GACrD,OAAO9oB,EAAUS,aAAaqoB,EAClC,C,+CCFe,SAASrJ,EAAsBzf,EAAW7C,GAGrD,OAFwB6C,EAAUkV,aAAa/X,GACjBnZ,IAAIpJ,KAAKkkB,MAE3C,CACO,SAASiqB,EAAgC/oB,EAAW7C,GACvD,OAAO6C,EAAUkV,aAAa/X,EAClC,C,uDCPA,SAAS6rB,EAAuCC,EAAiB9vC,GAC7D,MAAM+J,EAAY/J,EAAMwJ,aAAaK,gBACrC,IAAKimC,EAAgBxC,aACjB,OAEJ,MAAM3jC,EAAammC,EACdxC,eACAC,aACAC,UACL,GAAIxtC,EAAMY,OAASZ,EAAMuO,KAAM,CAC3B,MAAMwhC,EAAe,IAAIviC,WAAWxN,EAAMwD,QAAUxD,EAAMyD,KAAO,GACjE,IAAK,IAAIyK,EAAI,EAAGA,EAAIlO,EAAMwD,QAAUxD,EAAMyD,KAAMyK,IAC5C6hC,EAAiB,EAAJ7hC,GAASnE,EAAc,EAAJmE,GAChC6hC,EAAiB,EAAJ7hC,EAAQ,GAAKnE,EAAc,EAAJmE,EAAQ,GAC5C6hC,EAAiB,EAAJ7hC,EAAQ,GAAKnE,EAAc,EAAJmE,EAAQ,GAEhDlO,EAAMuO,MAAO,EACbvO,EAAM4J,aAAe,IAAMmmC,EAC3BpmC,EAAWjF,IAAIqrC,EACnB,MAEIpmC,EAAWjF,IAAIqF,GAEnB+lC,EAAgBE,UACpB,C,kICtBA,SAASC,EAAc5M,EAAKC,GAGxB,MAAO,CAAEtgC,YAFWvB,KAAK6e,IAAIgjB,EAAOD,GAAO,EAErBpgC,cADAogC,EAAMC,EAAO,GAAK,EAE5C,CACA,SAAS4M,EAAeltC,EAAaC,EAAc6b,EAAiB,IAAmBQ,QACnF,GAAIR,IAAmB,IAAmBQ,OACtC,MAAO,CACHoD,MAAOzf,EAAe,IAAOD,EAAc,GAAK,EAChD2f,MAAO1f,EAAe,IAAOD,EAAc,GAAK,GAGnD,GAAI8b,IAAmB,IAAmBqxB,aAC3C,MAAO,CACHztB,MAAOzf,EAAeD,EAAc,EACpC2f,MAAO1f,EAAeD,EAAc,GAGvC,GAAI8b,IAAmB,IAAmBsxB,gBAAiB,CAG5D,MAAO,CACH1tB,OAHW,OAAM,IAAMzf,EAAcD,GAIrC2f,OAHW,OAAM,IAAM1f,EAAcD,GAK7C,CAEI,MAAM,IAAIJ,MAAM,2BAExB,C,keC5BA,MAAM,OAAEytC,EAAM,QAAEC,EAAO,QAAEC,GAAY,EAAAC,WCA7BH,OAAM,UAAS,UAAS,GAAK,EAAAG,U,kBCArC,MCAQH,OAAM,UAAS,UAAS,GAAK,EAAAG,U,4HCArC,MAAM,gBAAEC,GAAoB,EAAAC,MAAA,OCA5B,MAAQD,gBAAe,GAAK,EAAAC,MAAA,OCA5B,MAAQD,gBAAe,GAAK,EAAAC,MAAA,O,cCA5B,MAAM,gBAAEC,EAAe,iBAAEC,GAAqB,EAAAF,MAAA,OCA9C,MAAQD,gBAAe,GAAK,EAAAC,MAAA,O,kDCF5B,MAAM,uCAAEG,GAA2C,EAAAC,U,yECD/C,E,sDACJ,SAAW7c,GACPA,EAAqB,aAAI,gCACzBA,EAAqB,aAAI,+BAC5B,CAHD,CAGG,IAAW,EAAS,CAAC,ICAxB,MAAM,eAAE8c,GAAmB,EAAAL,OACnB1M,aAAY,GAAK,YAEQ,IAAIhuB,I,wBCLjB,E,+DCDpB,SAASg7B,EAAuBxnC,EAAcynC,GAC1C,MAAM/N,EAAc15B,EAAa0nC,sBAC3BC,EAAc,IAAI1jC,aAAay1B,GACrC,IAAK,MAAMkO,KAAwBH,EAAiB,CAChD,MAAMtnC,EAAaH,EAAa6nC,4BAA4BD,GAC5D,IAAK,IAAIljC,EAAI,EAAGA,EAAIg1B,EAAah1B,IAC7BijC,EAAYjjC,IAAMvE,EAAWuE,EAErC,CACA,OAAOijC,CACX,CAUK,EAAAT,MAAA,kBAAwBY,IAMxB,EAAAZ,MAAA,kBAAwBa,QAMxB,EAAAb,MAAA,kBAAwBc,SChCtB,SAAS5/B,EAASqB,EAAQw+B,GAC7B,MAAMC,EAAa,EAAND,EACb,GAAIC,EAAOz+B,EAAO7N,OACd,OAAO,gBAAgB6N,EAAOy+B,GAAOz+B,EAAOy+B,EAAO,GAAIz+B,EAAOy+B,EAAO,GAE7E,CACO,SAASC,EAAwBC,GACpC,MAAMC,EAAYD,EAASE,WAAWtE,UACtC,IAAIiE,EAAM,EACV,MAAMM,EAAe,IAAI/7B,IACzB,KAAOy7B,EAAMI,EAAUzsC,QAAQ,CAC3B,MAAM4sC,EAAcH,EAAUJ,KACxBQ,EAAU,GAChB,IAAK,IAAI/jC,EAAI,EAAGA,EAAI8jC,EAAa9jC,IAC7B+jC,EAAQ9kC,KAAK0kC,EAAUJ,EAAMvjC,IAEjC6jC,EAAartC,IAAIutC,EAAQ,GAAIA,GAC7BR,GAAOO,CACX,CACA,MAAME,EAAW,GACXC,EAAqBtnC,IACvB,IAAK,MAAOlG,EAAKF,KAAUoG,EAAI4iB,UAC3B,QAAcjrB,IAAViC,EACA,OAAOE,EAGf,OAAQ,CAAC,EAEb,IAAIytC,EAAaD,EAAkBJ,GACnC,MAAuB,IAAhBK,GAAmB,CACtB,MAAMC,EAAU,CAACD,GACjB,KAAOL,EAAalqC,IAAIuqC,IAAa,CACjC,MAAME,EAAYP,EAAantC,IAAIwtC,GAAY,GAC3CL,EAAalqC,IAAIyqC,IACjBD,EAAQllC,KAAKmlC,GAEjBP,EAAa/pC,OAAOoqC,GACpBA,EAAaE,CACjB,CACAJ,EAAS/kC,KAAKklC,GACdD,EAAaD,EAAkBJ,EACnC,CACA,OAAOG,EAAS9sC,OAAS8sC,OAAW1vC,CACxC,CACO,SAAS+vC,EAAkBX,GAC9B,MAAMY,EAAkBb,EAAwBC,GAChD,IAAKY,EACD,OAEJ,MAAMC,EAAgBb,EAASc,YAAYlF,UAC3C,OAAOgF,EAAgB3nC,KAAK8nC,GAAmBA,EAAe9nC,KAAKmC,GAAU4E,EAAS6gC,EAAezlC,MACzG,C,yEC1CyB4lC,EAAA,EAA0BC,MAG5BC,EAAA,E,SCVvB,MAAQ7e,OAAM,GAAK,EAAAyc,MCFnB,SAASqC,EAAiCryC,GACtC,GAAIA,aAAoB,EAAAsyC,eACpB,OAOR,SAAgCtyC,GAC5B,MAAM,WAAEiJ,EAAU,MAAEvI,EAAK,OAAEC,GAAW,0CAAsCX,IACpE4B,IAAK0L,EAAe2F,IAAK1F,GAAkB,sBAAkBtE,GACrE,MAAO,CACHA,aACAqE,gBACAC,gBACA7M,QACAC,SACAoC,KAAMrC,EACNoC,QAASnC,EAEjB,CAnBe4xC,CAAuBvyC,GAElC,GAAIA,aAAoB,EAAAi8B,cACpB,OAiBR,SAA+Bj8B,GAC3B,MAAMmmB,EAAYnmB,EAASw5B,gBACrB,WAAEvwB,GAAekd,GACfvkB,IAAK0L,EAAe2F,IAAK1F,GAAkB,sBAAkBtE,GAC/DvI,EAAQylB,EAAUxa,WAAW,GAC7BhL,EAASwlB,EAAUxa,WAAW,IAC9B,KAAE5I,EAAI,QAAED,EAAO,MAAE5C,GAAUF,EAASk8B,sBAC1C,MAAO,CACHjzB,aACAvI,QACAC,SACA2M,gBACAC,gBACAxK,OACAD,UACA5C,QAER,CAlCesyC,CAAsBxyC,GAEjC,MAAM,IAAIkC,MAAM,yBACpB,C,kBCLA,MAAM,sBAAE0jC,GAA0B,Y,uDCFnB,SAAS6M,GAAmBC,EAAYzhB,EAAS0hB,GAC5DD,EAAW1hC,KAAKykB,MAAQkd,GACxB,KAAAC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYC,YAC/D,C,QC6BoB,EAAA1C,UAAA,Y,2CCjCpB,MAAM,GACF,WAAA7sC,CAAYwvC,GACRjvC,KAAKkvC,eAAiB,GACtBlvC,KAAKmvC,cAAe,EACpBnvC,KAAK2M,QAAU,EACf3M,KAAKkvC,eAAiB,GACtBlvC,KAAKovC,YAAcH,GAAOI,YAAc,GACxCrvC,KAAKsvC,iBAAmBL,GAAOM,kBAAmB,EAClDvvC,KAAKwvC,QAAUP,GAAOQ,SAAU,EAChCzvC,KAAKmvC,cAAe,CACxB,CACA,iBAAIO,GACA,OAAO1vC,KAAKkvC,cAChB,CACA,oBAAIS,GACA,OAAO3vC,KAAKkvC,eAAetuC,MAC/B,CACA,cAAIyuC,GACA,OAAOrvC,KAAKovC,WAChB,CACA,cAAIC,CAAWA,GACPrvC,KAAKsvC,kBAAoBtvC,KAAKovC,cAAgBC,IAGlDrvC,KAAKovC,YAAcC,EACnBrvC,KAAKzE,aAAc,EACvB,CACA,mBAAIg0C,GACA,OAAOvvC,KAAKsvC,gBAChB,CACA,UAAIG,GACA,OAAOzvC,KAAKwvC,OAChB,CACA,UAAIC,CAAOA,GACHzvC,KAAKwvC,UAAYC,IAGrBzvC,KAAKwvC,QAAUC,EACfzvC,KAAKzE,aAAc,EACvB,CACA,QAAIq0C,GAEA,OADA5vC,KAAK6vC,UACE7vC,KAAK8vC,KAChB,CACA,UAAIlvC,GAEA,OADAZ,KAAK6vC,UACE7vC,KAAK2M,OAChB,CACA,eAAIpR,GACA,OAAOyE,KAAKmvC,YAChB,CACA,eAAI5zC,CAAYA,GACZyE,KAAKmvC,aAAe5zC,CACxB,CACA,gBAAAw0C,GACI,OAAO,CACX,CACA,eAAAC,CAAgB1hC,GACZtO,KAAKkvC,eAAevmC,KAAK,CAAC2F,EAAM,GAAIA,EAAM,KAC1CtO,KAAKzE,aAAc,CACvB,CACA,gBAAA00C,CAAiBxhC,GACbA,EAAOxN,SAASqN,GAAUtO,KAAKgwC,gBAAgB1hC,IACnD,CACA,kBAAA4hC,CAAmBC,GACf,MAAMC,EAAcpwC,KAAKqwC,kBAAkBF,IACnCz0C,MAAOkyC,EAAY57B,IAAKs+B,GAAaF,EAAY3hC,OACnD8hC,EAAoBtzC,KAAK+Q,MAAMmiC,GAC/BK,EAAexwC,KAAKywC,eAAeF,GACnCvJ,EAAImJ,EAAIlzC,KAAK+Q,MAAMuiC,GACnBG,EAAkB,CACpB9C,EAAW,GAAK5G,GAAKsJ,EAAS,GAAK1C,EAAW,IAC9CA,EAAW,GAAK5G,GAAKsJ,EAAS,GAAK1C,EAAW,KAE5C96B,EAAc9S,KAAKkvC,eAAelsC,QAAQwtC,EAAad,cAAcnJ,IAAM,EAGjF,OAFAvmC,KAAKkvC,eAAej8B,OAAOH,EAAa,EAAG49B,GAC3C1wC,KAAKzE,aAAc,EACZ,CACHiN,MAAOsK,EACPxE,MAAOoiC,EAEf,CACA,yBAAAC,CAA0BnoC,GACtB,MAAMooC,EAAmB5wC,KAAKwvC,QAAU,EAAI,EAI5C,OAHkBhnC,GAAS,GACvBA,EAAQxI,KAAKkvC,eAAetuC,QAC5BZ,KAAKkvC,eAAetuC,OAASgwC,IAIjC5wC,KAAKkvC,eAAej8B,OAAOzK,EAAO,GAClCxI,KAAKzE,aAAc,GACZ,EACX,CACA,kBAAAs1C,GACI7wC,KAAKkvC,eAAiB,GACtBlvC,KAAKzE,aAAc,CACvB,CACA,gBAAAu1C,CAAiBriC,GACbzO,KAAK6wC,qBACL7wC,KAAKiwC,iBAAiBxhC,EAC1B,CACA,kBAAAsiC,CAAmBvoC,EAAOwoC,GACtB,GAAIxoC,EAAQ,GAAKA,GAASxI,KAAKkvC,eAAetuC,OAC1C,MAAM,IAAIxC,MAAM,uBAEpB4B,KAAKkvC,eAAe1mC,GAAS,IAAIwoC,GACjChxC,KAAKzE,aAAc,CACvB,CACA,gBAAA01C,GACI,OAAOjxC,KAAKkvC,eAAe7oC,KAAK6qC,GAAiB,CAC7CA,EAAa,GACbA,EAAa,KAErB,CACA,sBAAAC,CAAuB7iC,GACnB,MAAMohC,EAAgB1vC,KAAKkvC,eAC3B,IAAIkC,EAAiBz6B,IACjB06B,GAAqB,EACzB,IAAK,IAAI3nC,EAAI,EAAG4nC,EAAM5B,EAAc9uC,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACtD,MAAMwnC,EAAexB,EAAchmC,GAC7BgZ,EAAKpU,EAAM,GAAK4iC,EAAa,GAC7BvuB,EAAKrU,EAAM,GAAK4iC,EAAa,GAC7BK,EAAc7uB,EAAKA,EAAKC,EAAKA,EAC/B4uB,EAAcH,IACdA,EAAiBG,EACjBF,EAAoB3nC,EAE5B,CACA,MAAO,CACHlB,MAAO6oC,EACP/iC,OAA8B,IAAvB+iC,OACDrzC,EACA,IAAI0xC,EAAc2B,IACxBr1B,SAAU/e,KAAKwmC,KAAK2N,GAE5B,CACA,oCAAAI,CAAqCljC,EAAOmjC,GACxC,MAAMC,EAAsB1xC,KAAKmxC,uBAAuB7iC,GACxD,OAAOojC,EAAoB11B,UAAYy1B,EACjCC,OACA1zC,CACV,CACA,eAAA2zC,CAAgBrjC,GACZtO,KAAK6vC,UACL,MAAM+B,EAAwB5xC,KAAK6xC,sCAAsCvjC,GACzE,IAAKsjC,EAAsBhxC,OACvB,OAGJ,IAAIkxC,EADJF,EAAsB31B,MAAK,CAAC81B,EAAKC,IAAQD,EAAIE,gBAAkBD,EAAIC,kBAEnE,IAEIC,EACAC,EAHAC,GAAiC,EACjCC,EAAiB17B,IAGrB,IAAK,IAAIjN,EAAI,EAAGA,EAAIkoC,EAAsBhxC,OAAQ8I,IAAK,CACnD,MAAM4oC,EAAuBV,EAAsBloC,GACnD,GAAI4oC,EAAqBL,gBAAkBI,EACvC,SAEJ,MAAM,kBAAE9B,EAAiB,aAAEC,GAAiB8B,GACtC,aAAE/E,GAAiBiD,EACzB,IAAK,IAAIv+B,EAAI,EAAGA,EAAIs7B,EAAa3sC,OAAQqR,IAAK,CAC1C,MAAMm+B,EAAc7C,EAAat7B,IACzB3D,MAAOikC,EAAcN,gBAAiBO,GAAuBC,EAAKrC,YAAYsC,2BAA2BtC,EAAY3hC,OAAO/S,MAAO00C,EAAY3hC,OAAOuD,IAAK1D,GAC/JkkC,EAAqBH,IACrBF,EAAqB/B,EACrBgC,EAAgC7B,EAChC2B,EAAsBI,EAAqB9B,aAC3CsB,EAAeS,EACfF,EAAiBG,EAEzB,CACJ,CAKA,MAAO,CACHlkC,MAAOwjC,EACPa,OAHMP,GAHwBD,EAAmBS,2BACjDH,EAAKnkC,MAAMukC,gBAAgBV,EAAmB1jC,OAAO/S,MAAOo2C,IAC1BI,EAAoBtxC,OAKtDob,SAAU/e,KAAKwmC,KAAK4O,GAE5B,CACA,kCAAAS,CAAmCxkC,GAC/B,MAAMykC,EAAa,IAAI/yC,KAAKkvC,gBAI5B,GAHIlvC,KAAKwvC,SACLuD,EAAWpqC,KAAK3I,KAAKkvC,eAAe,KAEnC6D,EAAWnyC,OACZ,OAEJ,IAAIkxC,EACAO,EAAiB17B,IACjBi3B,EAAamF,EAAW,GAC5B,IAAK,IAAIrpC,EAAI,EAAG4nC,EAAMyB,EAAWnyC,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACnD,MAAM4mC,EAAWyC,EAAWrpC,IACpB4E,MAAOikC,EAAcN,gBAAiBO,GAAuBC,EAAKrC,YAAYsC,2BAA2B9E,EAAY0C,EAAUhiC,GACnIkkC,EAAqBH,IACrBP,EAAeS,EACfF,EAAiBG,GAErB5E,EAAa0C,CACjB,CACA,MAAO,CACHhiC,MAAOwjC,EACP91B,SAAU/e,KAAKwmC,KAAK4O,GAE5B,CACA,iBAAAW,GAEI,OADAhzC,KAAK6vC,UACE7vC,KAAKizC,gCAAgCjzC,KAAKywC,eACrD,CACA,wBAAAyC,CAAyBC,EAAqBC,GAC1C,GAAIpzC,KAAKwvC,QACL,MAAO,GAEXxvC,KAAK6vC,UACL,MAAM6B,EAAsB1xC,KAAKwxC,qCAAqC2B,EAAqBC,GACrFC,EAA6C,IAA/B3B,GAAqBlpC,MACnC8qC,EAAuBtzC,KAAKuzC,wBAAwBJ,EAAqBE,GAC/E,OAAOC,GAAsB1yC,OACvBZ,KAAKizC,gCAAgCK,GACrC,EACV,CACA,gBAAAE,CAAiBllC,EAAOmjC,GACpBzxC,KAAK6vC,UACL,MAAM4D,EAAgBzzC,KAAK0zC,iCAAiCplC,EAAOmjC,GAC7DkC,EAAiBlC,EAAUA,EACjC,IAAK,IAAI/nC,EAAI,EAAGA,EAAI+pC,EAAc7yC,OAAQ8I,IAAK,CAC3C,MAAM,aAAE6jC,GAAiBkG,EAAc/pC,GACvC,IAAK,IAAIuI,EAAI,EAAGA,EAAIs7B,EAAa3sC,OAAQqR,IAAK,CAC1C,MAAMm+B,EAAc7C,EAAat7B,GAEjC,GADwBwgC,EAAKrC,YAAYwD,uBAAuBxD,EAAY3hC,OAAO/S,MAAO00C,EAAY3hC,OAAOuD,IAAK1D,IAC3FqlC,EACnB,OAAO,CAEf,CACJ,CACA,OAAO,CACX,CACA,aAAAE,CAAcvlC,GACVtO,KAAK6vC,UAEL,GADsB7vC,KAAKkvC,eACTtuC,OAAS,EACvB,OAAO,EAEX,MAAM6yC,EAAgB,IAAIzzC,KAAKywC,gBACzBqD,EAAsB9zC,KAAK+zC,iDAC7BD,GACAL,EAAc9qC,KAAKmrC,GAEvB,IAAIE,EAAmB,EACvB,IAAK,IAAItqC,EAAI,EAAGA,EAAI+pC,EAAc7yC,OAAQ8I,IAAK,CAC3C,MAAM8mC,EAAeiD,EAAc/pC,IAC3BkmC,KAAMqE,GAAiBzD,EAI/B,KAHiCliC,EAAM,IAAM2lC,EAAa1wB,MACtDjV,EAAM,IAAM2lC,EAAapT,MACzBvyB,EAAM,GAAK2lC,EAAanT,MAExB,SAEJ,MAAM,aAAEyM,GAAiBiD,EACzB,IAAK,IAAI9mC,EAAI,EAAGA,EAAI6jC,EAAa3sC,OAAQ8I,IAAK,CAC1C,MAAM0mC,EAAc7C,EAAa7jC,IACzBkmC,KAAMsE,GAAoB9D,EAIlC,GAHgC9hC,EAAM,IAAM4lC,EAAgB3wB,MACxDjV,EAAM,IAAM4lC,EAAgBrT,MAC5BvyB,EAAM,GAAK4lC,EAAgBpT,KACF,CACzB,MAAQplC,MAAO6qC,EAAIv0B,IAAKmiC,GAAO/D,EAAY3hC,OACrC2lC,EAAiB7N,EAAG,KAAO4N,EAAG,GAC9BE,GAAkB/lC,EAAM,GAAKi4B,EAAG,KAAO4N,EAAG,GAAK5N,EAAG,KAAQ4N,EAAG,GAAK5N,EAAG,IAAMA,EAAG,GACpFyN,GACII,GAAkB9lC,EAAM,IAAM+lC,EAAgB,EAAI,CAC1D,CACJ,CACJ,CACA,OAAOL,EAAmB,GAAM,CACpC,CACA,OAAAnE,GACI,IAAK7vC,KAAKmvC,aACN,OAEJ,MAAMsE,EAAgBzzC,KAAKs0C,kBAC3B,IAAI1zC,EAAS,EACT0iB,EAAO3M,IACPkqB,EAAOlqB,IACP4M,GAAQ5M,IACRmqB,GAAQnqB,IACZ,IAAK,IAAIjN,EAAI,EAAG4nC,EAAMmC,EAAc7yC,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACtD,MAAQkmC,KAAMqE,EAAcrzC,OAAQ2zC,GAAmBd,EAAc/pC,GACrE4Z,EAAOA,GAAQ2wB,EAAa3wB,KAAOA,EAAO2wB,EAAa3wB,KACvDud,EAAOA,GAAQoT,EAAapT,KAAOA,EAAOoT,EAAapT,KACvDtd,EAAOA,GAAQ0wB,EAAa1wB,KAAOA,EAAO0wB,EAAa1wB,KACvDud,EAAOA,GAAQmT,EAAanT,KAAOA,EAAOmT,EAAanT,KACvDlgC,GAAU2zC,CACd,CACAv0C,KAAKywC,eAAiBgD,EACtBzzC,KAAK8vC,MAAQ,CAAExsB,OAAMud,OAAMtd,OAAMud,QACjC9gC,KAAK2M,QAAU/L,EACfZ,KAAKmvC,cAAe,CACxB,CACA,+BAAA8D,CAAgCQ,GAC5BzzC,KAAK6vC,UACL,MAAM2E,EAAiB,GASvB,OARAf,EAAcxyC,SAAQ,EAAGssC,gBAAgBkH,KACrClH,EAAatsC,SAAQ,CAACmvC,EAAasE,KACT,IAAlBD,GAAwC,IAAjBC,GACvBF,EAAe7rC,KAAK,IAAIynC,EAAY3hC,OAAO/S,QAE/C84C,EAAe7rC,KAAK,IAAIynC,EAAY3hC,OAAOuD,KAAK,GAClD,IAECwiC,CACX,CACA,qCAAA3C,CAAsCvjC,GAClCtO,KAAK6vC,UACL,MAAM8E,EAA+B,IAC7BlE,eAAgBgD,GAAkBzzC,KAC1C,IAAK,IAAI0J,EAAI,EAAGA,EAAI+pC,EAAc7yC,OAAQ8I,IAAK,CAC3C,MAAM8mC,EAAeiD,EAAc/pC,GAC7BuoC,EAAkBQ,EAAK7C,KAAKgE,uBAAuBpD,EAAaZ,KAAMthC,GAC5EqmC,EAA6BhsC,KAAK,CAC9B4nC,kBAAmB7mC,EACnB8mC,eACAyB,mBAER,CACA,OAAO0C,CACX,CACA,gCAAAjB,CAAiCplC,EAAOmjC,GACpCzxC,KAAK6vC,UACL,MAAM8D,EAAiBlC,EAAUA,EACjC,GAAIgB,EAAK7C,KAAKgE,uBAAuB5zC,KAAK4vC,KAAMthC,GAASqlC,EACrD,MAAO,GAEX,MAAMiB,EAAwB50C,KAAK6xC,sCAAsCvjC,GACnEumC,EAA2B,GACjC,IAAK,IAAInrC,EAAI,EAAG4nC,EAAMsD,EAAsBh0C,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CAC9D,MAAM,aAAE8mC,EAAcyB,gBAAiB6C,GAA4BF,EAAsBlrC,GACrForC,GAA2BnB,GAC3BkB,EAAyBlsC,KAAK6nC,EAEtC,CACA,OAAOqE,CACX,CACA,iBAAAxE,CAAkBF,GACdnwC,KAAK6vC,UACL,MAAMU,EAAoBtzC,KAAK+Q,MAAMmiC,GAC/BnJ,EAAImJ,EAAII,EACRC,EAAexwC,KAAKywC,eAAeF,IACnC,aAAEhD,GAAiBiD,EACnBuE,EAAcvE,EAAa5vC,OAASomC,EAC1C,IAAK,IAAIt9B,EAAI,EAAGA,EAAI6jC,EAAa3sC,OAAQ8I,IAAK,CAC1C,MAAM0mC,EAAc7C,EAAa7jC,GAC3BsrC,EAAY5E,EAAYwC,2BAA6BxC,EAAYxvC,OACvE,GAAIm0C,GAAe3E,EAAYwC,4BAC3BmC,GAAeC,EACf,OAAO5E,CAEf,CACJ,CACA,8CAAA2D,GACI,GAAI/zC,KAAKyvC,OACL,OAEJ,MAAMC,EAAgB1vC,KAAKkvC,eACrB+F,EAAoBvF,EAAc,GAClCwF,EAAkBxF,EAAcA,EAAc9uC,OAAS,GACvDu0C,EAAqB,CACvB1mC,OAAQ,CACJ/S,MAAO,IAAIu5C,GACXjjC,IAAK,IAAIkjC,IAEbtF,KAAM,CACFtsB,KAAMrmB,KAAKa,IAAIm3C,EAAkB,GAAIC,EAAgB,IACrDrU,KAAM5jC,KAAKa,IAAIm3C,EAAkB,GAAIC,EAAgB,IACrD3xB,KAAMtmB,KAAKkS,IAAI8lC,EAAkB,GAAIC,EAAgB,IACrDpU,KAAM7jC,KAAKkS,IAAI8lC,EAAkB,GAAIC,EAAgB,MAG7D,MAAO,CACHtF,KAAM,CACFtsB,KAAM6xB,EAAmBvF,KAAKtsB,KAC9Bud,KAAMsU,EAAmBvF,KAAK/O,KAC9Btd,KAAM4xB,EAAmBvF,KAAKrsB,KAC9Bud,KAAMqU,EAAmBvF,KAAK9O,MAElCyM,aAAc,CAAC4H,GAEvB,ECpYJ,MAAMC,WAAoB,GACtB,uBAAA7B,CAAwBJ,EAAqBE,GACzC,MAAMgC,EAA0Br1C,KAAKs1C,uBAAyB,EACxDC,EAAqBt4C,KAAKkS,IAAI,EAAGkmC,EAA0B,GAC3DG,EAAmBnC,EACnBgC,EACAA,EAA0B,EAC1BI,EAAkBz1C,KAAK01C,qBACvBhG,EAAgB,IAAI1vC,KAAK0vC,eACzB+D,EAAgB,GACjBJ,GACD3D,EAAc/mC,KAAKwqC,GAEvB,IAAK,IAAIzpC,EAAI6rC,EAAoB7rC,GAAK8rC,EAAkB9rC,IAAK,CACzD,MAAM8mC,EAAexwC,KAAK21C,iBAAiBjsC,EAAG+rC,EAAiB/F,EAAe2D,GAC9EI,EAAc9qC,KAAK6nC,EACvB,CACA,OAAOiD,CACX,CACA,eAAAa,GACI,MAAMsB,EAAmB51C,KAAKs1C,uBACxB7B,EAAgB,IAAI/0C,MAAMk3C,GAChC,GAAIA,GAAoB,EACpB,MAAO,GAEX,MAAMH,EAAkBz1C,KAAK01C,qBAC7B,IAAIG,EAA8B,EAClC,IAAK,IAAInsC,EAAI,EAAGA,EAAIksC,EAAkBlsC,IAAK,CACvC,MAAM8mC,EAAexwC,KAAK21C,iBAAiBjsC,EAAG+rC,GAC9CjF,EAAaqF,4BAA8BA,EAC3CpC,EAAc/pC,GAAK8mC,EACnBqF,GAA+BrF,EAAa5vC,MAChD,CACA,OAAO6yC,CACX,CACA,oBAAA6B,CAAqB5F,EAAgB1vC,KAAK0vC,cAAeD,EAASzvC,KAAKyvC,QACnE,OAAOA,EACDC,EAAc9uC,OACd3D,KAAKkS,IAAI,EAAGugC,EAAc9uC,OAAS,EAC7C,CACA,SAAAk1C,CAAU3F,EAAGsF,EAAiB/F,EAAgB1vC,KAAK0vC,cAAeD,EAASzvC,KAAKyvC,QAC5E,MAAMmG,EAAmB51C,KAAKs1C,qBAAqB5F,EAAeD,GAC5DsG,EAAO94C,KAAK+Q,MAAMmiC,GACxB,IAAII,EAAoBwF,EAAOH,EAC/B,MAAM5O,EAAImJ,EAAI4F,EAEd,GADqCxF,EAAoB,GAAKA,GAAqBqF,EACjD,CAC9B,IAAI51C,KAAKyvC,OAKL,OAJAc,GACKqF,EAAmBrF,GAAqBqF,CAKrD,CACA,MAAM,GAAEtP,EAAE,GAAEC,EAAE,GAAE4N,EAAE,GAAE6B,GAAOh2C,KAAKi2C,uBAAuB1F,EAAmBb,EAAeD,GACnFyG,EAAKlP,EAAIA,EACTmP,EAAMD,EAAKlP,EACXoP,EAAU,gBAAgB,EAAGpP,EAAGkP,EAAIC,GACpCE,EAAU,mBAAmB,cAAeD,EAASX,GAC3D,MAAO,CACH,SAASY,EAAS,gBAAgB/P,EAAG,GAAIC,EAAG,GAAI4N,EAAG,GAAI6B,EAAG,KAC1D,SAASK,EAAS,gBAAgB/P,EAAG,GAAIC,EAAG,GAAI4N,EAAG,GAAI6B,EAAG,KAElE,CACA,sBAAAC,CAAuB1F,EAAmBb,EAAgB1vC,KAAK0vC,cAAeD,EAASzvC,KAAKyvC,QACxF,MAAMmG,EAAmB51C,KAAKs1C,qBAAqB5F,EAAeD,GAE5D6G,EADU/F,EACU,EACpBgG,EAAU9G,GAFAc,EAEoB,GAAKqF,EAFzBrF,EAEsD,EAChEiG,EAAUD,EAAU,EACpBhQ,EAAKmJ,EAJKa,GAKV4D,EAAKzE,EAAc6G,GACzB,IAAIjQ,EACA0P,EAeJ,OAbI1P,EADAgQ,GAAW,EACN5G,EAAc4G,GAGd7G,EACCC,EAAcA,EAAc9uC,OAAS,GACrC6xC,EAAKnkC,MAAMmoC,OAAOtC,EAAI5N,GAG5ByP,EADAQ,EAAU9G,EAAc9uC,OACnB8uC,EAAc8G,GAGd/G,EAASC,EAAc,GAAK+C,EAAKnkC,MAAMmoC,OAAOlQ,EAAI4N,GAEpD,CAAE7N,KAAIC,KAAI4N,KAAI6B,KACzB,CACA,gBAAAU,CAAiBnG,EAAmBkF,EAAiB/F,EAAgB1vC,KAAK0vC,cAAeD,EAASzvC,KAAKyvC,QACnG,MAAMmG,EAAmB51C,KAAKs1C,qBAAqB5F,EAAeD,GAC5DkH,EAAkB32C,KAAKqvC,WAAa,EACpCuH,EAAM,EAAID,EAEhB,IAAIE,EADStG,EACK,EACbd,GAAUc,IAAsBqF,EAAmB,IACpDiB,GAnGQ,MAqGZ,MAAMtJ,EAAe,GACrB,IAAIK,EACA0C,EACAsC,EAA6B,EACjC,IAAK,IAAIlpC,EAAI,EAAGymC,EATHI,EASa7mC,GAAKitC,EAAiBjtC,IAAKymC,GAAKyG,EAAK,CAC3DzG,EAAIA,EAAI0G,EAAOA,EAAO1G,EACtB,MAAM7hC,EAAQtO,KAAK81C,UAAU3F,EAAGsF,EAAiB/F,EAAeD,GAChE,IAAK/lC,EAAG,CACJkkC,EAAat/B,EACb,QACJ,CACAgiC,EAAWhiC,EACX,MAAMoU,EAAK4tB,EAAS,GAAK1C,EAAW,GAC9BjrB,EAAK2tB,EAAS,GAAK1C,EAAW,GAC9BhtC,EAAS3D,KAAKwmC,KAAK/gB,GAAM,EAAIC,GAAM,GACnCitB,EAAO,CACTtsB,KAAMsqB,EAAW,IAAM0C,EAAS,GAAK1C,EAAW,GAAK0C,EAAS,GAC9D/sB,KAAMqqB,EAAW,IAAM0C,EAAS,GAAK1C,EAAW,GAAK0C,EAAS,GAC9DzP,KAAM+M,EAAW,IAAM0C,EAAS,GAAK1C,EAAW,GAAK0C,EAAS,GAC9DxP,KAAM8M,EAAW,IAAM0C,EAAS,GAAK1C,EAAW,GAAK0C,EAAS,IAElE/C,EAAa5kC,KAAK,CACd8F,OAAQ,CACJ/S,MAAOkyC,EACP57B,IAAKs+B,GAETV,OACAhvC,SACAgyC,+BAEJhF,EAAa0C,EACbsC,GAA8BhyC,CAClC,CACA,OAAO2sC,CACX,CACA,gBAAAoI,CAAiBpF,EAAmBkF,EAAkBz1C,KAAK01C,qBAAsBhG,EAAgB1vC,KAAK0vC,cAAeD,EAASzvC,KAAKyvC,QAC/H,MAAM,GAAEnJ,EAAE,GAAEC,EAAE,GAAE4N,EAAE,GAAE6B,GAAOh2C,KAAKi2C,uBAAuB1F,EAAmBb,EAAeD,GACnFlC,EAAevtC,KAAK02C,iBAAiBnG,EAAmBkF,EAAiB/F,EAAeD,GAC9F,IAAIqH,EAAqB,EACrBxzB,EAAO3M,IACPkqB,EAAOlqB,IACP4M,GAAQ5M,IACRmqB,GAAQnqB,IAQZ,OAPA42B,EAAatsC,SAAQ,EAAG2uC,KAAMmH,EAAan2C,OAAQo2C,MAC/C1zB,EAAOrmB,KAAKa,IAAIwlB,EAAMyzB,EAAYzzB,MAClCud,EAAO5jC,KAAKa,IAAI+iC,EAAMkW,EAAYlW,MAClCtd,EAAOtmB,KAAKkS,IAAIoU,EAAMwzB,EAAYxzB,MAClCud,EAAO7jC,KAAKkS,IAAI2xB,EAAMiW,EAAYjW,MAClCgW,GAAsBE,CAAa,IAEhC,CACHtH,cAAe,CAAEpJ,KAAIC,KAAI4N,KAAI6B,MAC7BpG,KAAM,CAAEtsB,OAAMud,OAAMtd,OAAMud,QAC1BlgC,OAAQk2C,EACRjB,4BAA6B,EAC7BtI,eAER,EC/JJ,MAAM0J,GAAmB,oBAAoB,cAAe,gBAAgB,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAI,GACrI,MAAMC,WAAgB9B,GAClB,kBAAAM,GACI,OAAOuB,EACX,ECLJ,MAAME,WAAuB/B,GACzB,WAAA31C,CAAYwvC,GACRmI,MAAMnI,GACNjvC,KAAKq3C,OAASpI,GAAOzyC,OAAS,GAC9BwD,KAAKs3C,YAAcrI,GAAOsI,aAAc,CAC5C,CACA,SAAI/6C,GACA,OAAOwD,KAAKq3C,MAChB,CACA,SAAI76C,CAAMA,GACFwD,KAAKs3C,aAAet3C,KAAKq3C,SAAW76C,IAGxCwD,KAAKq3C,OAAS76C,EACdwD,KAAKzE,aAAc,EACvB,CACA,cAAIg8C,GACA,OAAOv3C,KAAKs3C,WAChB,CACA,kBAAA5B,GACI,MAAQl5C,MAAOg7C,GAAMx3C,KACfy3C,EAAK,EAAID,EACf,MAAO,CACH,EAAG,EAAG,EAAG,GACRA,EAAG,EAAGA,EAAG,EACVC,EAAID,EAAI,EAAG,EAAIC,GAAKD,GACnBA,EAAG,EAAIA,EAAGA,EAAI,EAAGA,EAE1B,EC5BJ,MAAME,WAAyBP,GAC3B,WAAA13C,GACI23C,MAAM,CAAE56C,MAAO,GAAK+6C,YAAY,GACpC,ECHJ,MAAMI,WAAqBR,GACvB,WAAA13C,GACI23C,MAAM,CAAE/H,WAAY,EAAGE,iBAAiB,EAAM/yC,MAAO,EAAG+6C,YAAY,GACxE,E,gBCFJ,MAAMK,WAAgB,MAClB,WAAAn4C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,EACrB,CACA,iBAAAE,CAAkBC,GACdj4C,KAAKk4C,cAAcD,EACvB,CACA,iBAAAE,CAAkBF,GACdj4C,KAAKk4C,cAAcD,EACvB,CACA,aAAAC,CAAcD,GACV,MAAM,QAAE9qB,EAAO,YAAEirB,GAAgBH,EAAI3lB,OAC/Bh3B,GAAiB,IAAA48B,mBAAkB/K,GACnCkrB,EAAmBD,EAAYE,MACrC,GAA4B,IAAxBD,EAAiB,IACO,IAAxBA,EAAiB,IACO,IAAxBA,EAAiB,GACjB,OAEJ,MAAM53B,EAASnlB,EAAeY,SAASwkB,aACjC,WAAEE,EAAU,SAAEgN,GAAanN,EAC3B83B,EAAkB,CACpB3qB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,IAE7BG,EAAoB,CACtB53B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,IAErC/8C,EAAeY,SAASijC,UAAU,CAC9Bve,WAAY43B,EACZ5qB,SAAU2qB,IAEdj9C,EAAeY,SAASD,QAC5B,EAEJ27C,GAAQa,SAAW,M,gBCpCnB,MAAMC,WAA4B,MAC9B,WAAAj5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXksC,uBAAwB,KAG5BvB,MAAMS,EAAWC,GACjB93C,KAAK44C,iBAAmB,IAAIpnC,IAC5BxR,KAAK64C,uBAAwB,EAC7B74C,KAAK84C,qBAAwBb,IACzB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EAGfy9C,EAFa78C,EAAS88C,kBACH7iC,MACJmM,YAErB,KAD0B,sBAAuBy2B,GAAU,6BAA8BA,GAErF,OAAO,EAEX,MAAME,EAAyBF,EAAOG,oBActC,OAbKl5C,KAAK64C,wBACNE,EAAOI,kBAA2C,EAAzBF,GACzBj5C,KAAK64C,uBAAwB,EACR,OAAjB74C,KAAKo5C,SACLhsB,SAAStE,oBAAoB,UAAW9oB,KAAKo5C,SAEjDp5C,KAAKo5C,QAAU,KACXL,EAAOI,kBAAkBF,GACzB/8C,EAASD,SACT+D,KAAK64C,uBAAwB,CAAK,EAEtCzrB,SAAS3E,iBAAiB,UAAWzoB,KAAKo5C,QAAS,CAAEC,MAAM,MAExD,CAAI,EAEfr5C,KAAKs5C,kBAAoB,KACH,IAAAC,cAAav5C,KAAKw5C,aAAaC,cAGrDz5C,KAAK05C,gBAAkB,KACnB,MAAMC,EAA2B,KACP35C,KAAKs5C,oBACbr4C,SAAQ,EAAGisB,aAAYhB,wBACjC,IAAKlsB,KAAK44C,iBAAiBv1C,IAAI6pB,GAAa,CACxC,MAAM,SAAEhxB,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAAsB,CAAEhwB,SAAU,MAC1F,IAAKA,EACD,OAEJ,MAAM,QAAEixB,GAAYjxB,EACd29C,EAAiB,IAAIC,gBAAe,KACtC,MAAM3sB,GAAU,IAAAysB,wBAAuB1sB,EAAYhB,GACnD,IAAKiB,EACD,OAEJ,MAAM,SAAEjxB,GAAaixB,EACf4sB,EAAmB79C,EAASm9B,sBAClCn9B,EAASg0B,cACTh0B,EAAS69B,oBAAoBggB,GAC7B79C,EAASD,QAAQ,IAErB49C,EAAeG,QAAQ7sB,GACvBntB,KAAK44C,iBAAiB14C,IAAIgtB,EAAY2sB,EAC1C,IACF,EAENF,IACA35C,KAAKi6C,uBAA0BhC,IACvBA,EAAI3lB,OAAOknB,cAAgBx5C,KAAKw5C,aAChCG,GACJ,EAEJ,EAAAxnB,YAAY1J,iBAAiB,EAAAgH,OAAOyqB,yBAA0Bl6C,KAAKi6C,uBAAuB,EAE9Fj6C,KAAKm6C,kBAAoB,KACrBn6C,KAAK44C,iBAAiB33C,SAAQ,CAAC44C,EAAgB3sB,KAC3C2sB,EAAeO,aACfp6C,KAAK44C,iBAAiBp1C,OAAO0pB,EAAW,IAExCltB,KAAKi6C,yBACL,EAAA9nB,YAAYrJ,oBAAoB,EAAA2G,OAAOyqB,yBAA0Bl6C,KAAKi6C,wBACtEj6C,KAAKi6C,uBAAyB,KAClC,EAEJj6C,KAAKq6C,aAAe,CAACn+C,EAAUo+C,EAAaC,EAAMz9C,KAC9C,MAAM09C,EAAYt+C,EAASu+C,qBACrBrY,EAASoY,EAAUE,YACnB95B,EAAa45B,EAAUG,gBACvB/sB,EAAW4sB,EAAUI,cACrB/nB,EAAc,CAAC,EAAG,EAAG,GACrBoM,EAAgB,CAAC,EAAG,EAAG,GACvB4b,EAAY,CAAC,EAAG,EAAG,GACnBp+C,EAAY,cAAc,IAAIwM,aAAa,KACjD,eAAexM,EAAWA,EAAW69C,GACrC,YAAY79C,EAAWA,EAAWK,EAAOy9C,GACzC,eAAe99C,EAAWA,EAAW,EAChC69C,EAAY,IACZA,EAAY,IACZA,EAAY,KAEjB,mBAAmBznB,EAAajF,EAAUnxB,GAC1C,mBAAmBwiC,EAAere,EAAYnkB,GAC9C,cAAcA,GACd,YAAYA,EAAWA,EAAWK,EAAOy9C,GACzC,mBAAmBM,EAAWzY,EAAQ3lC,GACtCP,EAASijC,UAAU,CACfvR,SAAUiF,EACVuP,OAAQyY,EACRj6B,WAAYqe,GACd,EAENj/B,KAAKg4C,kBAAoBh4C,KAAKk4C,cAAc1nC,KAAKxQ,MACjDA,KAAKm4C,kBAAoBn4C,KAAKk4C,cAAc1nC,KAAKxQ,KACrD,CACA,aAAAk4C,CAAcD,GACV,MAAM,QAAE9qB,EAAO,cAAE2tB,EAAa,WAAEC,GAAe9C,EAAI3lB,OAC7C0oB,EAAsBF,EAAcr/C,OACpCw/C,EAAmBF,EAAWt/C,QAC9B,uBAAEk9C,GAA2B34C,KAAKyM,cAClCnR,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,YAClB9jB,EAAQuwB,EAAQ+tB,YAChBr+C,EAASswB,EAAQguB,aACjBC,EAAqB,CACvBJ,EAAoB,GAAKp+C,EACzBo+C,EAAoB,GAAKn+C,GAEvBw+C,EAA6B,CAC/BJ,EAAiB,GAAKr+C,EACtBq+C,EAAiB,GAAKp+C,GAEpB+Z,EAAS,CAAS,GAARha,EAAsB,GAATC,GACvBy9C,EAAcp+C,EAASkzB,cAAcxY,GAErC0kC,GAAS,EAAMr+C,KAAK6e,IADA,MAC6B,EACjDy/B,EAAK,CAACF,EAA2B,GAAI,EAAG,GACxCG,EAAK,CAACJ,EAAmB,GAAI,EAAG,GAChCK,EAAOF,EAAG,IAAM,EAChBG,EAAOF,EAAG,IAAM,EAChBG,EAAMF,EAAOH,EAAQ,EAAIr+C,KAAKwmC,KAAK6X,EAAQG,GAC3CG,EAAMF,EAAOJ,EAAQ,EAAIr+C,KAAKwmC,KAAK6X,EAAQI,GAC3CG,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAMC,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAM97B,EAAM,UAAY67B,EAAKC,GAC7B,GAAI7+C,KAAK6e,IAAIkE,GAAO,KAAQ,CACxB,MAAM+7B,GAAU,EACZ9+C,KAAK++C,KAAK,iBAAmBh8B,GAAM,EAAK,IACxC/iB,KAAKwrC,KAAK2S,EAAmB,GAAKC,EAA2B,IAC7D1C,EACEsD,EAAQx7B,EAAO2hB,OACf8Z,EAAMz7B,EAAOhB,gBACb08B,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAW,CAAC,EAAG,EAAG,GACxB,YAAcH,EAAOC,EAAKC,GAC1B,gBAAkBA,GAClB,YAAcD,EAAKC,EAAQC,GAC3B,gBAAkBA,GAClB,gBAAkBH,GAClBj8C,KAAKq6C,aAAan+C,EAAUo+C,EAAa8B,EAAUL,GACnD,MAAMM,GAAUhB,EAA2B,GAAKD,EAAmB,IAC/DzC,EACJ34C,KAAKq6C,aAAan+C,EAAUo+C,EAAa6B,EAAQE,GACjDngD,EAASD,QACb,CACJ,EAEJy8C,GAAoBD,SAAW,kBC5K/B,MAAM6D,WAAwB,MAC1B,WAAA78C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjB93C,KAAKu8C,qCAAuC,CAACp3C,EAAY0C,KACrD,MAAM20C,EAAmBv/C,KAAK+Q,MAAMnG,EAAW,GAAK,GAC9C40C,EAAc50C,EAAW,GAAKA,EAAW,GAC/C,IAAI60C,EACA91C,EACAzB,aAAsB8D,cACtByzC,EAAgB,EAChB91C,EAAwBqC,cAEnB9D,aAAsB6D,YAC3B0zC,EAAgB,EAChB91C,EAAwBoC,YAEnB7D,aAAsB+D,aAC3BwzC,EAAgB,EAChB91C,EAAwBsC,aAEnB/D,aAAsBgE,aAC3BuzC,EAAgB,EAChB91C,EAAwBuC,YAE5B,MAEMwzC,EAAQ,IAAI/1C,EAFHzB,EAAWy3C,OACPJ,EAAmBC,EAAcC,EACQD,IACtD,IAAEttC,EAAG,IAAErR,GAAQkC,KAAK68C,WAAWF,EAAOF,GAC5C,OAAOttC,EAAMrR,CAAG,CAExB,CACA,iBAAAk6C,CAAkBC,GACdj4C,KAAKm4C,kBAAkBF,EAC3B,CACA,iBAAAE,CAAkBF,GACd,MAAM,QAAE9qB,EAAO,YAAEirB,GAAgBH,EAAI3lB,OAC/Bh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB,IAAIwP,EAAUoT,EAAOC,EAAOhgB,EAAU2+C,EAAUC,EAC5Cx+C,GAAc,EAClB,MAAMy+C,EAAa9gD,EAAS+oB,gBAC5B,GAAI/oB,aAAoB,EAAAsyC,eAAgB,CACpC1jC,EAAW5O,EAASwqB,cACpBq2B,EACI,EAAAzQ,UAAA,yBAAmCxhC,KACpCoT,QAAOC,SAAU6+B,EAAW/+B,UAC/B,MAAM6F,EAAS,EAAAwN,MAAM7M,UAAU3Z,GAC/B,IAAKgZ,EACD,MAAM,IAAI1lB,MAAM,oBAAsB0M,GAE1C3M,EAAW2lB,EAAO5c,SAASy8B,SAC3BplC,EAAculB,EAAOm5B,SAAWr9C,OAAO4B,KAAKsiB,EAAOm5B,SAASr8C,OAAS,CACzE,KACK,KAAIo8C,EAAW/+B,SAQhB,MAAM,IAAI7f,MAAM,gCARU,CAC1BD,EAAWjC,EAASiC,WACjB+f,QAAOC,SAAU6+B,EAAW/+B,UAC/B,MAAM,SAAEwO,EAAW,CAAEC,QAAQ,IAAYxwB,EAASw5B,kBAAoB,CAAC,EACvEn3B,EACIkuB,EAASC,aAAgD1uB,IAAtCyuB,EAASjL,mBAAmBI,KACvD,CAGA,CAEIk7B,EAnED,OAkEC3+C,GAAmBI,EACRyB,KAAKk9C,oBAAoB,CAChCC,kBAAmB/E,EAAY38C,OAC/ByiB,QACAC,QACAg9B,aAAchuB,EAAQguB,aACtB58C,cACArC,WACA4O,aAIO9K,KAAKo9C,YAAY,CACxBlhD,WACAihD,kBAAmB/E,EAAY38C,OAC/BqP,WACAoT,QACAC,UAGJ2+B,EAAS5+B,OAAS4+B,EAAS3+B,QAG/BjiB,EAASi0B,cAAc,CACnBlS,SAAU6+B,IAEd5gD,EAASD,SACLC,aAAoB,EAAAsyC,gBACpBuO,EAA6B97C,SAASqkB,IAC9BppB,IAAaopB,GACbA,EAAGrpB,QACP,IAIZ,CACA,mBAAAihD,EAAoB,kBAAEC,EAAiB,MAAEj/B,EAAK,MAAEC,EAAK,aAAEg9B,EAAY,SAAEj/C,EAAQ,SAAE4O,EAAQ,YAAEvM,IACrF,IAAI8+C,EAzGe,EA2GfA,EADA9+C,EACa,EAAI48C,EAIbn7C,KAAKs9C,+BAA+BphD,EAAU4O,IA/GnC,EAsHnB,OAFAqT,GAFeg/B,EAAkB,GACRE,EAGlB,CAAEn/B,QAAOC,MADhBA,EAAQ5f,EAActB,KAAKkS,IAAIgP,EAAO,IAAOA,EAEjD,CACA,WAAAi/B,EAAY,SAAElhD,EAAQ,kBAAEihD,EAAiB,SAAEryC,EAAQ,MAAEoT,EAAK,MAAEC,IACxD,MAAMk/B,EAAar9C,KAAKs9C,+BAA+BphD,EAAU4O,IAzH9C,EA2HbyyC,EAAUJ,EAAkB,GAAKE,EACjCG,EAAUL,EAAkB,GAAKE,EACvC,IAAI,YAAE7+C,EAAW,aAAEC,GAAiB,EAAA6tC,UAAA,0BAAoCpuB,EAAOC,GAC/E3f,GAAe++C,EACf9+C,GAAgB++C,EAChBh/C,EAAcvB,KAAKkS,IAAI3Q,EAAa,GACpC,MAAMi/C,EAAiBvhD,EAAS+oB,gBAAgBkhB,eAChD,OAAO,EAAAmG,UAAA,2BAAqC9tC,EAAaC,EAAcg/C,EAC3E,CACA,8BAAAH,CAA+BphD,EAAU4O,GACrC,IAAI4yC,EACJ,GAAI5yC,EAAU,CACV,MAAMyU,EAAc,EAAA+R,MAAM7M,UAAU3Z,IAC9B,aAAE9F,GAAiB9I,EAASw5B,eAE5BioB,EADuB34C,EAAa44C,qBACUzhB,QAAO,CAAC0hB,EAAKC,IACtD,CAAC7gD,KAAKa,IAAI+/C,EAAI,GAAIC,GAAQ7gD,KAAKkS,IAAI0uC,EAAI,GAAIC,KACnD,CAACnnC,KAAWA,MACT+uB,EAAanmB,GAAarY,UAAUw+B,WACpCqY,EAAuBrY,EAAa,GAAKA,EAAa/uB,IAC5D+mC,EAAoBzgD,KAAKa,IAAI6/C,EAAwBI,EACzD,MAEIL,EAAoB19C,KAAKg+C,kCAAkC9hD,GAE/D,MAAM46B,EAAQ4mB,EAnJc,KAoJ5B,OAAO5mB,EAAQ,EAAI75B,KAAKkkB,MAAM2V,GAASA,CAC3C,CACA,iCAAAknB,CAAkC9hD,GAC9B,MAAM,UAAEmmB,EAAS,aAAErd,GAAiB9I,EAASw5B,eAC7C,GAAI1wB,GAAc0gB,SAAU,CACxB,MAAM5Z,EAAQ9G,EAAa0gB,WAC3B,OAAO5Z,EAAM,GAAKA,EAAM,EAC5B,CACA,MAAMjE,EAAawa,EAAUQ,gBAC7B,GAAIR,EAAUqD,SAAU,CACpB,MAAMu4B,EAAiB57B,EAAUqD,WACjC,OAAOu4B,EAAe,GAAKA,EAAe,EAC9C,CACA,IAAI94C,EAUA2G,EAHJ,GALI3G,EADAkd,EAAUhd,cACGgd,EAAUhd,gBAGVgd,EAAUymB,eAAeC,aAAaC,UAEjC,IAAlBnhC,EAAW,GACX,OAAO7H,KAAKu8C,qCAAqCp3C,EAAY0C,GAGjE,GAAI1C,EAAWugB,SACX5Z,EAAQ3G,EAAWugB,eAElB,CACD,MAAM,IAAE5nB,EAAG,IAAEqR,GAAQnP,KAAK68C,WAAW13C,EAAYA,EAAWvE,QAC5DkL,EAAQ,CAAChO,EAAKqR,EAClB,CACA,OAAOrD,EAAM,GAAKA,EAAM,EAC5B,CACA,UAAA+wC,CAAWF,EAAOF,GACd,IAAI3+C,EAAM6Y,IACNxH,GAAOwH,IACX,IAAK,IAAIjN,EAAI,EAAGA,EAAI+yC,EAAa/yC,IAAK,CAClC,MAAMw0C,EAAQvB,EAAMjzC,GAChBw0C,EAAQpgD,IACRA,EAAMogD,GAENA,EAAQ/uC,IACRA,EAAM+uC,EAEd,CACA,MAAO,CAAE/uC,MAAKrR,MAClB,EAEJw+C,GAAgB7D,SAAW,c,eC5L3B,MAAM0F,WAA8B,MAChC,WAAA1+C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX2xC,eAAgB,MAGpBhH,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACfrzC,aAAa,EACbkjD,aAAa,EACbv3C,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,qBAEJ2G,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,KAGZo/B,YAAa,CAAC,KAGtB,QAAchQ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eASzE,OARA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,uBAEJ7+C,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,SACjD/+C,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,GACjB,QAAiB1P,EAAW2Q,gBAC5B,EAAAJ,EAAA,GAAsCN,IACtC,KAAAW,4BAA2B5Q,GAC3B5uC,KAAKy/C,uBAAuB7Q,EAAYzhB,EAAQ,EAEpDntB,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,UAC3C,KAAE7xC,GAAS0hC,GACX,cAAEkM,GAAkB/rB,EACpBzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEuyB,EAAa,cAAEtwB,GAAkB9zB,EAAeY,SAClDsjB,EAAWs7B,EAAcxC,OACzB,OAAE7pC,GAAWvB,EAAKyxC,QAExBlwC,EAD6B,GACE,IAAI+Q,GACnC,MAAMyX,EAAmByoB,EAAcjxC,EAAO,IACxCsoB,EAAiB2oB,EAAcjxC,EAAO,IACtCuoB,EAAoB,CACtBD,EAAe,GACfE,EAAiB,IAEf0oB,EAAgB,CAClB1oB,EAAiB,GACjBF,EAAe,IAEbK,EAAmBhI,EAAc4H,GACjCE,EAAe9H,EAAcuwB,GACnClxC,EAAO,GAAK2oB,EACZ3oB,EAAO,GAAKyoB,EACZ0X,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,QAAevgD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE+xC,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAEJ,IAAKvkD,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,MAAMQ,EAAS,GAAGvB,SACZwB,EAAe,KACrB,IAAAC,UAAYX,EAAkBd,EAAewB,EAAcL,EAAkB,GAAIA,EAAkB,GAAI,CACnGtkD,QACAwkD,WACAD,aACDG,GACHR,GAAe,CACnB,CACA,OAAOA,CAAY,EAEvBtgD,KAAKy/C,uBAAyB,CAAC7Q,EAAYzhB,KACvC,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACf+mB,EAAY,EAA6CnmB,IACzD,KAAEgR,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DuyC,EAAcP,EAAkB,GAChCQ,EAAYR,EAAkB,GACpC,IAAIS,EAAOlkD,KAAKa,IAAImjD,EAAY,GAAIC,EAAU,IAC1CvsC,EAAM1X,KAAKa,IAAImjD,EAAY,GAAIC,EAAU,IACzCtkD,EAAQK,KAAK6e,IAAImlC,EAAY,GAAKC,EAAU,IAC5CrkD,EAASI,KAAK6e,IAAImlC,EAAY,GAAKC,EAAU,IACjDC,EAAO,EAAA7U,UAAA,KAAe6U,EAAM,EAAG9+B,EAAUzlB,OACzC+X,EAAM,EAAA23B,UAAA,KAAe33B,EAAK,EAAG0N,EAAUxlB,QACvCD,EAAQK,KAAK+Q,MAAM/Q,KAAKa,IAAIlB,EAAOK,KAAK6e,IAAIuG,EAAUzlB,MAAQukD,KAC9DtkD,EAASI,KAAK+Q,MAAM/Q,KAAKa,IAAIjB,EAAQI,KAAK6e,IAAIuG,EAAUxlB,OAAS8X,KACjE,MAAMysC,EC1LlB,SAAgC/+B,EAAW/kB,EAAGE,EAAGZ,EAAOC,GACpD,MAAMwkD,EAAY,GAClB,IAAI74C,EAAQ,EACZ,MAAMjD,EAAY8c,EAAUld,WAC5B,IAAIm8C,EAASjwC,EAAKkwC,EAClB,GAAIl/B,EAAUjmB,MACV,IAAKiV,EAAM,EAAGA,EAAMxU,EAAQwU,IACxB,IAAKkwC,EAAS,EAAGA,EAAS3kD,EAAO2kD,IAAU,CACvCD,EAA2D,IAA/CjwC,EAAM7T,GAAK6kB,EAAUrjB,SAAWuiD,EAASjkD,IACrD,MAAMkkD,EAAMj8C,EAAU+7C,GAChBG,EAAQl8C,EAAU+7C,EAAU,GAC5BI,EAAOn8C,EAAU+7C,EAAU,GACjCD,EAAU74C,KAAW,MAASg5C,EAAM,MAASC,EAAQ,MAASC,CAClE,MAIJ,IAAKrwC,EAAM,EAAGA,EAAMxU,EAAQwU,IACxB,IAAKkwC,EAAS,EAAGA,EAAS3kD,EAAO2kD,IAC7BD,GAAWjwC,EAAM7T,GAAK6kB,EAAUrjB,SAAWuiD,EAASjkD,GACpD+jD,EAAU74C,KAAWjD,EAAU+7C,GAI3C,OAAOD,CACX,CDiKuC,CAAmCh/B,EAAWplB,KAAKkkB,MAAMggC,GAAOlkD,KAAKkkB,MAAMxM,GAAM/X,EAAOC,GAC7G8kD,EE3LlB,SAA6BC,EAAgBC,EAAWC,GACpD,MAAM/2B,EAAY62B,EAAehhD,OACjC,IAAI9C,EAAMgkD,EACN3yC,EAAM0yC,EACNvtC,EAAM,EACV,GAAIyW,EAAY,EACZ,MAAO,CACHjtB,MACAqR,MACAm0B,MAAOue,EAAYC,GAAa,GAGxC,IAAK,IAAIt5C,EAAQ,EAAGA,EAAQuiB,EAAWviB,IAAS,CAC5C,MAAMu5C,EAAMH,EAAep5C,GAC3B1K,EAAMb,KAAKa,IAAIA,EAAKikD,GACpB5yC,EAAMlS,KAAKkS,IAAIA,EAAK4yC,GACpBztC,GAAOytC,CACX,CACA,MAAO,CACHjkD,MACAqR,MACAm0B,KAAMhvB,EAAMyW,EAEpB,CFoK+B,CAAgCq2B,EAAoB/+B,EAAU7Y,cAAe6Y,EAAU5Y,oBAChEzL,IAAtCgC,KAAKyM,cAAc2xC,iBACnBp+C,KAAKyM,cAAc2xC,eAAiB,IAExC,MAAM5/C,EAAcvB,KAAKkS,IAAIlS,KAAK6e,IAAI6lC,EAAWxyC,IAAMwyC,EAAW7jD,KAAMkC,KAAKyM,cAAc2xC,gBACrF3/C,EAAekjD,EAAWre,KAC1Bma,EAAiBvhD,EAAS+oB,gBAAgBkhB,eAC1CloB,EAAW,EAAAquB,UAAA,2BAAqC9tC,EAAaC,EAAcg/C,GACjFvhD,EAASi0B,cAAc,CAAElS,aACzB/hB,EAASD,QAAQ,EAErB+D,KAAKiL,OAAS,IACH,KAEXjL,KAAKgiD,gBAAkB,IACZ,KAEXhiD,KAAKiiD,qBAAuB,IACjB,KAEXjiD,KAAKkiD,uBAAyB,IACnB,KAEXliD,KAAKmiD,gBAAkB,IACZ,KAEXniD,KAAKoiD,kBAAoB,IACd,IAEf,EAEJjE,GAAsB1F,SAAW,oBGxNjC,MAAM4J,WAAwB,MAC1B,WAAA5iD,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX7N,QAAQ,EACR0jD,qBAAqB,EACrBtiB,MAAM,KAGVoX,MAAMS,EAAWC,GACjB93C,KAAKuiD,OAAS,CAClB,CACA,kBAAAC,CAAmBvK,GACfj4C,KAAKyiD,QAAQxK,EACjB,CACA,iBAAAE,CAAkBF,GACdj4C,KAAKk4C,cAAcD,EACvB,CACA,iBAAAD,CAAkBC,GACdj4C,KAAKk4C,cAAcD,EACvB,CACA,aAAAC,CAAcD,GACVj4C,KAAK0iD,YAAYzK,EACrB,CACA,WAAAyK,CAAYzK,GACR,MAAM,YAAEG,EAAW,WAAElrB,EAAU,kBAAEhB,GAAsB+rB,EAAI3lB,QACrD,SAAEp2B,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAClD,oBAAEo2B,EAAmB,OAAE1jD,EAAM,KAAEohC,GAAShgC,KAAKyM,cAC7Ck2C,EAAcvK,EAAY38C,OAAO,GACvC,IAAIqP,EACA5O,aAAoB,EAAAsyC,iBACpB1jC,EAAW5O,EAASwqB,eAExB,MAAMk8B,EAAiB5iD,KAAK6iD,kBAAkB3mD,GACxCqmD,EAASI,EAAc3iD,KAAKuiD,OAClC,GAAKK,EAGL,GAAI3lD,KAAK6e,IAAIymC,IAAWK,EAAgB,CACpC,MAAME,EAAqB7lD,KAAKkkB,MAAMohC,EAASK,GAC/C,EAAAtW,UAAA,OAAiBpwC,EAAU,CACvBqZ,MAAO3W,GAAUkkD,EAAqBA,EACtCh4C,WACAi1B,gBAAiBuiB,EACjBtiB,KAAMA,IAEVhgC,KAAKuiD,OAASA,EAASK,CAC3B,MAEI5iD,KAAKuiD,OAASA,CAEtB,CACA,OAAAE,CAAQxK,GACJ,MAAM,MAAE8K,EAAK,QAAE51B,GAAY8qB,EAAI3lB,QACzB,UAAErqB,GAAc86C,GAChB,OAAEnkD,GAAWoB,KAAKyM,eAClB,SAAEvQ,IAAa,IAAAg8B,mBAAkB/K,GACjC5X,EAAQtN,GAAarJ,GAAU,EAAI,GACzC,EAAA0tC,UAAA,OAAiBpwC,EAAU,CACvBqZ,QACAwqB,gBAAiB//B,KAAKyM,cAAc61C,oBACpCtiB,KAAMhgC,KAAKyM,cAAcuzB,KACzBl1B,SAAU5O,aAAoB,EAAA8mD,mBACxB9mD,EAASwqB,mBACT1oB,EACN+gC,YAAa/+B,KAAKyM,cAAcsyB,aAExC,CACA,iBAAA8jB,CAAkB3mD,GACd,MAAM,QAAEixB,GAAYjxB,EACdglB,EAAiBhlB,EAASkkC,oBAChC,OAAOnjC,KAAKkS,IAAI,EAAGge,EAAQ81B,aAAehmD,KAAKkS,IAAI+R,EAAgB,GACvE,EAEJmhC,GAAgB5J,SAAW,c,gBCxE3B,MAAMyK,WAAyB,MAC3B,WAAAzjD,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjB93C,KAAKwiD,mBAAsBvK,IACvB,MAAM,QAAE9qB,EAAO,MAAE41B,GAAU9K,EAAI3lB,OACzBh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,OAAEsD,GAAWoB,KAAKyM,cAClB3P,EAA0B,GAAlBimD,EAAM96C,WAAkBrJ,GAAU,EAAI,GACpDoB,KAAKmjD,SAASjnD,EAAUY,EAAM,EAElCkD,KAAKg4C,kBAAoBh4C,KAAKk4C,cAAc1nC,KAAKxQ,MACjDA,KAAKm4C,kBAAoBn4C,KAAKk4C,cAAc1nC,KAAKxQ,KACrD,CACA,aAAAk4C,CAAcD,GACV,MAAM,QAAE9qB,EAAO,cAAE2tB,EAAa,YAAEsI,GAAgBnL,EAAI3lB,OAC9C+wB,EAAoBvI,EAAcxC,MAClCgL,EAAkBF,EAAY9K,MAC9Bh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,YAGlB6iC,EAAe,CAAS,GAFhBp2B,EAAQ+tB,YAEsB,GAD7B/tB,EAAQguB,cAEjBb,EAAcp+C,EAASkzB,cAAcm0B,GAC3C,IAAIzmD,GAAQ,EAAA0mD,GAAA,GAAkB,CAACF,EAAiBhJ,GAAc,CAACA,EAAa+I,IAC5E,MAAM,gBAAE5jC,GAAoBgB,EACtBoL,EAAK,SAAS,cAAeyuB,EAAagJ,GAC1Cx3B,EAAK,SAAS,cAAewuB,EAAa+I,GAC1CI,EAAQ,WAAW,cAAe53B,EAAIC,GACxC,SAASrM,EAAiBgkC,GAAS,IACnC3mD,GAASA,GAETkP,OAAOwQ,MAAM1f,IAGjBkD,KAAKmjD,SAASjnD,EAAUY,EAC5B,CACA,QAAAqmD,CAASjnD,EAAUY,GACf,MAAM,gBAAE2iB,EAAe,OAAE2iB,GAAWlmC,EAASwkB,YAC7C,GAAIxkB,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAMU,GAAc5mD,EAAQ,KAAO,IAAOG,KAAKC,GAAM,IAC/CymD,EAAS,cAAc,IAAI16C,aAAa,KAC9C,YAAY06C,EAAQA,EAAQD,EAAUjkC,GACtC,MAAMmkC,EAAgB,mBAAmB,cAAexhB,EAAQuhB,GAChEznD,EAASijC,UAAU,CAAEiD,OAAQwhB,GACjC,KACK,CACD,MAAM,SAAE7mD,GAAab,EAASm9B,sBAC9Bn9B,EAAS69B,oBAAoB,CACzBh9B,UAAWA,EAAWD,EAAQ,KAAO,KAE7C,CACAZ,EAASD,QACb,EAEJinD,GAAiBzK,SAAW,eC1D5B,MAAMoL,WAAiB,MACnB,WAAApkD,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXq3C,cAAc,EACdC,aAAc,KACdC,aAAc,IACdC,aAAa,EACbC,KAAK,EACLtlD,QAAQ,KAGZw4C,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,IACzB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,EAC7BpgB,EAAWs7B,EAAcxC,MAEzB73B,GADiB,IAAAyX,mBAAkB/K,GACXjxB,SAASwkB,aACjC,WAAEE,GAAeH,EACvBzgB,KAAKmkD,qBAAuB3kC,EAC5B,IAAI4kC,EAAS,gBAAgBxjC,EAAW,GAAKpB,EAAS,GAAIoB,EAAW,GAAKpB,EAAS,GAAIoB,EAAW,GAAKpB,EAAS,IAGhH,OAFA4kC,EAAS,eAAe,cAAeA,GACvCpkD,KAAKokD,OAASA,GACP,CAAK,EAEhBpkD,KAAKqkD,sBAAyBpM,IAC1B,IAAKj4C,KAAKyM,cAAcw3C,YACpB,OAAOjkD,KAAK84C,qBAAqBb,EACrC,EAEJj4C,KAAKskD,wBAA0B,CAACrM,EAAK/7C,EAAUukB,EAAQ8jC,GAAQ,KAC3D,MAAM,QAAEp3B,EAAO,YAAEirB,GAAgBH,EAAI3lB,OAC/BiwB,EAASgC,EACTtM,EAAI3lB,OAAOkyB,cAAc/oD,OACzB28C,EAAY38C,OAAO,GACnB+sB,EAAO,CAAC2E,EAAQ+tB,YAAa/tB,EAAQguB,eACrC,cAAEsJ,EAAa,WAAE7jC,EAAU,SAAEgN,GAAanN,EAE1CpO,EAAIkwC,GADQ,EAAI/5B,EAAK,KACKxoB,KAAKyM,cAAc7N,QAAU,EAAI,GAC3D8lD,GAAsB,EAAMryC,GAAKoyC,EACvC,IAAIE,EAAkB/jC,EAClBgkC,EAAgBh3B,EACpB,IAAK5tB,KAAKyM,cAAcq3C,aAAc,CAClC,MAAMe,EAAyB,cAAcjkC,EAAY5gB,KAAKmkD,sBAC9DS,EAAgB,iBAAiB,cAAeh3B,EAAU5tB,KAAKokD,QAASS,EAAyBxyC,GACjGsyC,EAAkB,iBAAiB,cAAe/jC,EAAY5gB,KAAKokD,QAASS,EAAyBxyC,EACzG,CACA,MAAMgQ,EAAYnmB,EAASw5B,eAC3B,IAAI5tB,EAAU,CAAC,EAAG,EAAG,GACjBua,IACAva,EAAUua,EAAUva,SAExB,MAAM,aAAEi8C,EAAY,aAAEC,GAAiBhkD,KAAKyM,cACtCu6B,EAAI7Z,EAAQguB,aAAerzC,EAAQ,GAAK,GACxCtL,EAAQwqC,EAAI0d,EAClB,IAAII,EAAsBJ,EACtBK,GAAoB,EACpB1iC,IACI7lB,EAAQunD,GACRe,EAAsB9d,EAAI+c,EAC1BgB,GAAoB,GAEfvoD,GAASwnD,IACdc,EAAsB9d,EAAIgd,EAC1Be,GAAoB,IAG5B7oD,EAASijC,UAAU,CACfslB,cAAeK,EACflkC,WAAYmkC,EAAoBnkC,EAAa+jC,EAC7C/2B,SAAUm3B,EAAoBn3B,EAAWg3B,GAC3C,EAEN5kD,KAAKglD,2BAA6B,CAAC/M,EAAK/7C,EAAUukB,EAAQ8jC,GAAQ,KAC9D,MAAM,QAAEp3B,EAAO,YAAEirB,GAAgBH,EAAI3lB,OAC/BiwB,EAASgC,EACTtM,EAAI3lB,OAAOkyB,cAAc/oD,OACzB28C,EAAY38C,OAAO,GACnB+sB,EAAO,CAAC2E,EAAQ+tB,YAAa/tB,EAAQguB,eACrC,SAAEvtB,EAAQ,WAAEhN,EAAU,gBAAEnB,GAAoBgB,EAC5CzE,EAAW,6BAA+B4R,EAAUhN,GACpDqkC,EAAYhoD,KAAKwmC,KAAKznB,GAAYwM,EAAK,GACvC08B,EAAwB,EACzBzlC,EAAgB,IAChBA,EAAgB,IAChBA,EAAgB,IAEfpN,EAAIrS,KAAKyM,cAAc7N,OACvB2jD,EAAS0C,EACT1C,EAAS0C,EACf,IAAIE,EAAM9yC,EAAI6yC,EAAsB,GACpCt3B,EAAS,IAAMu3B,EACfvkC,EAAW,IAAMukC,EACjBA,EAAM9yC,EAAI6yC,EAAsB,GAChCt3B,EAAS,IAAMu3B,EACfvkC,EAAW,IAAMukC,EACjBA,EAAM9yC,EAAI6yC,EAAsB,GAChCt3B,EAAS,IAAMu3B,EACfvkC,EAAW,IAAMukC,EACjBjpD,EAASijC,UAAU,CAAEvR,WAAUhN,cAAa,EAEhD5gB,KAAKmkD,qBAAuB,CAAC,EAAG,EAAG,GACnCnkD,KAAKokD,OAAS,CAAC,EAAG,EAAG,GACjBpkD,KAAKyM,cAAcw3C,YACnBjkD,KAAKg4C,kBAAoBh4C,KAAKolD,eAAe50C,KAAKxQ,MAGlDA,KAAKg4C,kBAAoBh4C,KAAKk4C,cAAc1nC,KAAKxQ,MAErDA,KAAKm4C,kBAAoBn4C,KAAKk4C,cAAc1nC,KAAKxQ,KACrD,CACA,cAAAolD,CAAenN,GAGX,GAFmBA,EAAI3lB,OAClB+yB,kBACUzkD,OAAS,EAAG,CACvB,MAAM,QAAEusB,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OACjCh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,YAClBlB,EAAWs7B,EAAcxC,OACzB,WAAE13B,GAAeH,EACvBzgB,KAAKmkD,qBAAuB3kC,EAC5B,IAAI4kC,EAAS,gBAAgBxjC,EAAW,GAAKpB,EAAS,GAAIoB,EAAW,GAAKpB,EAAS,GAAIoB,EAAW,GAAKpB,EAAS,IAChH4kC,EAAS,eAAe,cAAeA,GACvCpkD,KAAKokD,OAASA,EACV3jC,EAAO6kC,mBACPtlD,KAAKskD,wBAAwBrM,EAAK/7C,EAAUukB,GAAQ,GAGpDzgB,KAAKglD,2BAA2B/M,EAAK/7C,EAAUukB,GAAQ,GAE3DvkB,EAASD,QACb,CACI+D,KAAKyM,cAAcy3C,KACnBlkD,KAAKulD,aAAatN,EAE1B,CACA,aAAAC,CAAcD,GACV,MAAM,QAAE9qB,GAAY8qB,EAAI3lB,OAClBh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,YACpBD,EAAO6kC,mBACPtlD,KAAKskD,wBAAwBrM,EAAK/7C,EAAUukB,GAG5CzgB,KAAKglD,2BAA2B/M,EAAK/7C,EAAUukB,GAEnDvkB,EAASD,QACb,CACA,YAAAspD,CAAatN,GACT,MAAM,QAAE9qB,EAAO,YAAEirB,GAAgBH,EAAI3lB,OAC/Bh3B,GAAiB,IAAA48B,mBAAkB/K,GACnCkrB,EAAmBD,EAAYE,MAC/B73B,EAASnlB,EAAeY,SAASwkB,aACjC,WAAEE,EAAU,SAAEgN,GAAanN,EAC3B83B,EAAkB,CACpB3qB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,IAE7BG,EAAoB,CACtB53B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,IAErC/8C,EAAeY,SAASijC,UAAU,CAC9Bve,WAAY43B,EACZ5qB,SAAU2qB,IAEdj9C,EAAeY,SAASD,QAC5B,EAEJ4nD,GAASpL,SAAW,OC7KpB,MAAM+M,WAA2B,MAC7B,WAAA/lD,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXg5C,kBAAmB,MAGvBrO,MAAMS,EAAWC,EACrB,CACA,kBAAA4N,CAAmBzN,GACf,MAAM,QAAE9qB,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OACjCh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EAChCwP,EAAW5O,EAASwqB,cAC1B,IAAK5b,EACD,MAAM,IAAI1M,MAAM,0HAEpB,IAAIunD,GAAgBhvC,IACpB,MAMMivC,GAAiB,IAAAC,mCAAkC3pD,EAAU4+C,EAAcxC,MAAOxtC,GAN1E,CAACg7C,EAAWx3C,KACtB,GAAIw3C,EAAYH,EAEZ,OADAA,EAAeG,EACRx3C,CACX,IAGJ,IAAKs3C,IAAmBA,EAAehlD,OACnC,OAEJ,MAAM,kBAAE6kD,EAAiB,YAAEjM,GAAgBx5C,KAAKyM,cAC9BkN,EAAgB4Z,eAAeze,QAAQwQ,IACrD,GAAImgC,GAAmBziD,QAAQsiB,EAAGjc,KAAO,EACrC,OAAO,EAEX,MAAM08C,GAAiB,IAAAC,yBAAwB1gC,EAAGjc,GAAIsQ,EAAgBtQ,IACtE,SAAImwC,GAAeA,IAAgBuM,GAAgB18C,GAGvC,IAENpI,SAAS/E,IACXA,aAAoB,EAAAsyC,eACpBtyC,EAAS+pD,YAAYL,GAGrBx1C,QAAQC,KAAK,yFACjB,GAER,EAEJm1C,GAAmB/M,SAAW,qB,mDCtC9B,MAAM,mBAAEyN,IAAuB,EAAAC,UAC/B,SAASC,KACL,MAAO,gBACX,CACA,SAASC,KACL,OAAO,CACX,CACA,SAASC,KACL,OAAO,CACX,CACA,SAASC,KACL,OAAO,CACX,CACA,MAAMC,GACI,EADJA,GAEM,EAFNA,GAGI,EAGV,MAAMC,WAAuB,MACzB,WAAAhnD,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,SAC5BtrC,cAAe,CACXi6C,QAAQ,EACRC,oBAAoB,EACpBC,yBAA0B,CACtB9jB,OAAQ,EACRxlC,EAAG,KACHE,EAAG,MAEPqpD,QAAS,CACLC,SAAS,EACTC,QAAS,IAEbC,aAAc,EACdC,mBAAmB,EACnBC,8BAA+B,GAC/BC,kCAAmC,GACnCC,uBAAwB,EAAAlb,MAAA,WAAiBmb,wBACzCC,OAAQ,CACJR,SAAS,EACTjvC,QAAS,GACTmvC,aAAc,MAItB5P,MAAMS,EAAWC,GACjB93C,KAAKunD,WAAa,CAAC,EAAG,EAAG,GACzBvnD,KAAKwnD,mBAAqB,EAAGt7B,oBAAmBgB,iBAC5C,MAAM5xB,GAAiB,IAAAs+C,wBAAuB1sB,EAAYhB,GAC1D,IAAK5wB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,SAAE9N,GAAaZ,GACpC,QAAE6xB,GAAYjxB,GACd,SAAE0xB,EAAQ,WAAEhN,EAAU,gBAAEnB,GAAoBvjB,EAASwkB,YAC3D,IAAI6/B,EAAcvgD,KAAKynD,gBAAgBnsD,GACvCilD,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,GAChEA,GAAa3/C,SACb,IAAA8mD,kBAAiBnH,EAAY,GAAGhB,eAEpC,MAAM3Q,EAAa,CACf6P,aAAa,EACbv3C,SAAU,CACNygD,eAAgB,IAAI/5B,GACpBg6B,iBAAkB,IAAIhnC,GACtB5W,sBACAyuC,SAAUz4C,KAAK0+C,eAEnBxxC,KAAM,CACFyxC,QAAS,CACLkJ,eAAgB,GAChBC,oBAAqB,GACrBP,WAAYvnD,KAAKunD,YAErBQ,gBAAiB,KACjBC,kBAAmB,GACnB96B,eAIR,OADA,IAAA+6B,eAAcrZ,EAAYzhB,GACnB,CACH8Z,OAAQxnB,EACRnR,MAAOpS,EAASkzB,cAAc,CAC1BlzB,EAAST,OAAOy/C,YAAc,EAC9Bh/C,EAAST,OAAO0/C,aAAe,IAEtC,EAELn7C,KAAKs5C,kBAAoB,KACH,IAAAC,cAAav5C,KAAKw5C,aAAaC,cAGrDz5C,KAAKkoD,gBAAkB,KACnB,MAAMzO,EAAgBz5C,KAAKs5C,oBAC3B,IAAK,MAAM6O,KAAgB1O,EAAe,CACtC,MAAM,WAAEvsB,EAAU,kBAAEhB,GAAsBi8B,EACpC7sD,GAAiB,IAAAs+C,wBAAuB1sB,EAAYhB,GACpDhwB,EAAWZ,EAAeY,SAC1BksD,GAAW,EACXC,GAAY,EACZC,GAAgB,EAChBC,GAAgB,EAChB75B,GAAiB,EACvBxyB,EAASg0B,YAAY,CACjBk4B,WACAC,YACAC,gBACAC,gBACA75B,mBAEJxyB,EAASssD,qBACT,MAAM,QAAEr7B,GAAYjxB,EACpB,IAAIqkD,EAAcvgD,KAAKynD,gBAAgBnsD,GACvCilD,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,GAChEA,EAAY3/C,SACZ,IAAA8mD,kBAAiBnH,EAAY,GAAGhB,eAEpCrjD,EAASD,QACb,CACA+D,KAAKyoD,mBAAmBhP,EAAc,EAE1Cz5C,KAAK0oD,kBAAoB,KACrB,MAAMjP,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKyoD,mBAAmBhP,EAAc,EAE1Cz5C,KAAKyoD,mBAAsBhP,IACvB,IAAKA,EAAc74C,QAAmC,IAAzB64C,EAAc74C,OAEvC,YADAwP,QAAQC,KAAK,oEAGjB,MAAOs4C,EAAeC,EAAgBC,GAAiBpP,GAC/CxS,OAAQ6hB,EAASx6C,MAAOy6C,GAAW/oD,KAAKwnD,mBAAmBmB,IAC3D1hB,OAAQ+hB,EAAS16C,MAAO26C,GAAWjpD,KAAKwnD,mBAAmBoB,GACnE,IAAIM,EAAU,CAAC,EAAG,EAAG,GACjBC,EAAS,cACTN,IACG5hB,OAAQiiB,EAAS56C,MAAO66C,GACvBnpD,KAAKwnD,mBAAmBqB,KAG5B,SAASM,EAAQJ,EAAQE,GACzB,WAAWE,EAAQA,EAAQ,IAC3B,WAAWD,EAASJ,EAASE,IAEjC,MAAM5hB,EAAa,iCAA6B0hB,EAASC,GACnD1hB,EAAc,iCAA6B2hB,EAASC,GACpD3hB,EAAa,iCAA6B4hB,EAASC,GACnD5B,EAAa,0CAAsCngB,EAAYC,EAAaC,GAClFtnC,KAAKopD,cAAc7B,EAAW,EAElCvnD,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpBs6B,EAAYvO,EAAcxC,MAC1Bh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKspD,MAAMhuD,EAAgB+tD,GAC3B,MAAM9I,EAAcvgD,KAAKynD,gBAAgBnsD,GACnCiuD,EAAsBvpD,KAAKwgD,wCAAwCtkD,EAASixB,QAASozB,IACrF,KAAErzC,GAASq8C,EAAoB,IAC/B,eAAE1B,GAAmB36C,EAAKyxC,QAC1B6K,EAAkB,GACxB,IAAK,IAAI9/C,EAAI,EAAGA,EAAIm+C,EAAejnD,OAAS,IAAK8I,EAAG,CAChD,MAAM+/C,EAAgB5B,EAAen+C,GAAG,GAClCggD,EAAuB1pD,KAAK2pD,8BAA8BF,EAAcpgD,IACxEugD,EAA6B5pD,KAAK6pD,oCAAoCJ,EAAcpgD,IACrFqgD,GAAyBE,IAG9BJ,EAAgB7gD,KAAK8gD,EAAcpgD,IACnCK,IACJ,CAMA,OALAwD,EAAK86C,kBAAoB,IAAIwB,GAC7Bt8C,EAAKyxC,QAAQoJ,gBAAkBvB,GAC/BvO,EAAIiH,kBACJ,KAAAD,mBAAkB9xB,GAClBntB,KAAKmiD,gBAAgBh1B,GACdo8B,EAAoB,EAAE,EAEjCvpD,KAAKiL,OAAS,KACVmF,QAAQ2V,IAAI,sBAAsB,EAEtC/lB,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,KAChC,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzBz+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,gBAAgB,EAExBl/C,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,MACnD/pD,KAAKgqD,eAAe78B,EAASyhB,EAAYkb,EAAc,GAK/D9pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,EAAYqb,KAC1C,MAAMl7B,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzBz+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,gBAAgB,EAExBl/C,KAAKkqD,iBAAoBjS,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACtBY,EAAWZ,EAAeY,SAC1BqkD,EAAcvgD,KAAKynD,gBAAgBnsD,GAEnC6uD,EAD0BnqD,KAAKwgD,wCAAwCrzB,EAASozB,GACnC,GACnD,IAAK4J,EACD,OAEJ,MAAMC,EAAgBluD,EAASwkB,YACzB2pC,EAAoBF,EAAmBjjD,SAASygD,eAChD2C,EAAsB,CAAC,EAAG,EAAG,GACnC,eAAiBF,EAAcx8B,SAAUy8B,EAAmBC,GAC5D,MAAMC,EAAsBJ,EAAmBjjD,SAAS0gD,iBAClD4C,EAAwB,CAAC,EAAG,EAAG,GACrC,eAAiBJ,EAAcxpC,WAAY2pC,EAAqBC,GAChEL,EAAmBjjD,SAASygD,eAAiB,IAAIyC,EAAcx8B,UAC/Du8B,EAAmBjjD,SAAS0gD,iBAAmB,IACxCwC,EAAcxpC,YAErB,MAAM8oC,EAAuB1pD,KAAK2pD,8BAA8BztD,EAASmN,IACnEugD,EAA6B5pD,KAAK6pD,oCAAoC3tD,EAASmN,IACrF,IAAK,oBAAgB+gD,EAAcx8B,SAAUy8B,EAAmB,OAC5DX,GACAE,EAA4B,CAC5B,IAAIa,GAAa,EAC6B,oBAAgBH,EAAqBE,EAAuB,QAEtGC,GAAa,GAEjB,MAAMC,EAAwBztD,KAAK6e,IAAI,UAAYwuC,EAAqBF,EAAc3qC,kBAAoB,IACrGgrC,GAAeC,IAChB1qD,KAAKunD,WAAW,IAAM+C,EAAoB,GAC1CtqD,KAAKunD,WAAW,IAAM+C,EAAoB,GAC1CtqD,KAAKunD,WAAW,IAAM+C,EAAoB,IAC1C,IAAA9qB,cAAa,EAAArN,YAAa,EAAA1C,OAAOk7B,8BAA+B,CAC5DnR,YAAax5C,KAAKw5C,YAClB+N,WAAYvnD,KAAKunD,aAG7B,CACA,GAAIvnD,KAAKyM,cAAco6C,SAASC,QAAS,EACnB,IAAAd,yBAAwB9pD,EAASmN,GAAIsQ,EAAgBtQ,IAElEuhD,iBACA91C,QAAQzL,GAAOA,IAAOnN,EAASmN,KACnBpI,SAASisB,IACtBltB,KAAK6qD,4BAA4B39B,EAAYvT,EAAgB,GAErE,CACA,MACMklC,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAD1C,IAE/B,EAAAS,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAK8qD,cAAiB7S,IAClBj4C,KAAKkoD,iBAAiB,EAE1BloD,KAAK+qD,kBAAoB,CAAC9S,EAAK+S,KAC3B,MAAM,QAAE79B,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OACjCw3B,EAAehP,EAAcr/C,OACnC,IAAIwvD,GAAmB,EACvB,IAAK,IAAIvhD,EAAI,EAAGA,EAAIshD,EAAwBpqD,OAAQ8I,IAAK,CACrD,MAAMklC,EAAaoc,EAAwBthD,GAC3C,IAAI,KAAAwhD,oBAAmBtc,EAAW2Q,eAC9B,SAEJ,MAAM,KAAEryC,EAAI,YAAEuxC,GAAgB7P,EAC9B,IAAK1hC,EAAKyxC,QACN,SAEJ,MAAMwM,EAA0Bj+C,EAAKyxC,QAAQoJ,gBACvCqD,EAA4Bl+C,EAAK86C,mBAAqB96C,EAAK86C,kBAAkBpnD,OAAS,EACtF,IAAIsM,EAAK86C,mBACT,GACN96C,EAAK86C,kBAAoB,GACzB96C,EAAKyxC,QAAQoJ,gBAAkB,KAE/B,IAAIsD,GAAO,EAEPA,IAHyBrrD,KAAKsrD,wBAAwBn+B,EAASyhB,EAAYkb,EAAc,IAMlF9pD,KAAKgqD,eAAe78B,EAASyhB,EAAYkb,EAAc,GAE/BuB,IAAS5M,IACR4M,GAAQ5M,GAExC7P,EAAW6P,aAAeA,EAC1BwM,GAAmB,GAEd/9C,EAAKyxC,QAAQoJ,kBAAoBoD,GACrCnrD,KAAKurD,0BAA0Br+C,EAAK86C,kBAAmBoD,KACxDH,GAAmB,EAE3B,CACA,OAAOA,CAAgB,EAE3BjrD,KAAKwgD,wCAA0C,CAACrzB,EAASozB,KACrD,IAAKA,IAAgBA,EAAY3/C,OAC7B,MAAO,GAEX,MAAMtF,GAAiB,IAAA48B,mBAAkB/K,IACnC,WAAED,GAAe5xB,EACjBkwD,EAAgCjL,EAAYzrC,QAAQ85B,GAAeA,EAAW1hC,KAAKggB,aAAeA,IACxG,OAAOs+B,CAA6B,EAExCxrD,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,EAAQ,gBAAEyd,GAAoBre,GAChC,QAAE6xB,GAAYjxB,EACdqkD,EAAcvgD,KAAKynD,gBAAgBnsD,GACnCmlB,EAASvkB,EAASwkB,YAElBypC,EAD0BnqD,KAAKwgD,wCAAwCrzB,EAASozB,GACnC,GACnD,IAAKA,GAAa3/C,SAAWupD,GAAoBj9C,KAC7C,OAAOozC,EAEX,MAAMf,EAAgB4K,EAAmB5K,eACnC,YAAErE,EAAW,aAAEC,GAAiBj/C,EAAST,OACzCgwD,EAAuBxuD,KAAKwmC,KAAKyX,EAAcA,EAAcC,EAAeA,GAC5EuQ,EAA2BzuD,KAAKa,IAAIo9C,EAAaC,GACjDjuC,EAAOi9C,EAAmBj9C,KAC1By+C,EAAwBzvD,EAASwjD,cAAc1/C,KAAKunD,YACpDqE,EAA2B5rD,KAAK6rD,+CAA+CvwD,EAAgBilD,GAC/FuL,EAAiB,GACjBC,EAAY,CAAC,EAAG,EAAG7Q,EAAaC,GACtCyQ,EAAyB3qD,SAAS2tC,IAC9B,MAAM,KAAE1hC,GAAS0hC,EACjB1hC,EAAKyxC,QAAQ4I,WAAavnD,KAAKunD,WAC/B,MAAMkC,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD8+B,EAAcvC,EAAc/oC,YAC5BurC,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IAC7E6iD,EAAkClsD,KAAK6pD,oCAAoCJ,EAAcpgD,IACzF8iD,EAAuCnsD,KAAKosD,yCAAyC3C,EAAcpgD,KACnG,YAAE6xC,EAAW,aAAEC,GAAiBsO,EAAchuD,OAC9C4wD,EAA4BpvD,KAAKwmC,KAAKyX,EAAcA,EAAcC,EAAeA,GACjFmR,EAAoB,CACR,GAAdpR,EACe,GAAfC,GAEEoR,EAA2B9C,EAAcr6B,cAAck9B,GACvDrkD,EAAY,CAAC,EAAG,EAAG,GACzB,YAAcwY,EAAOhB,gBAAiBusC,EAAYvsC,gBAAiBxX,GACnE,gBAAkBA,GAClB,qBAAuBA,EAAWokD,GAClC,MAAMG,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAYD,EAA0BtkD,EAAWukD,GACjD,MAAMC,EAAc,CAAC,EAAG,EAAG,GAC3B,eAAiBF,EAA0BtkD,EAAWwkD,GACtD,MAAMC,EAAexwD,EAASwjD,cAAc8M,GACtCG,EAA4BzwD,EAASwjD,cAAc6M,GACnDK,EAA6B,cACnC,cAAcA,EAA4BF,EAAcC,GACxD,eAAeC,EAA4BA,GAC3C,MAAMC,EAA6B,cACnC,WAAWA,EAA4BD,EAAmD,IAAvBnB,GACnE,MAAMqB,EAA4B,cAClC,WAAWA,EAA2BF,EAAuD,GAA3BlB,GAClE,MAAMqB,EAA8B,cACpC,WAAWA,EAA6BH,EAAuD,GAA3BlB,GACpE,MAAMsB,EAA8B,cAC9BC,EAAYjtD,KAAKyM,cAAcy6C,8BACrC,WAAW8F,EAA6BJ,EAAgE,IAApChB,EAAyBhrD,OAAeqsD,EAAY,GACxH,MAAMC,EAAkB,cAClBC,EAAkB,cAClBC,EAAoB,cACpBC,EAAmB,cACzB,IAAIC,EAAiB,WAAW3B,GAC3BO,GAAoCD,IACrCqB,EAAiB,WAAWX,IAEhC,SAASO,EAAiBI,EAAgBN,GAC1C,SAASG,EAAiBG,EAAgBT,GAC1C,cAAcO,EAAmBE,EAAgBN,GACjD,cAAcK,EAAkBC,EAAgBT,IAChD,EAAAU,GAAA,GAAgBL,EAAiBC,EAAiBpB,IAClD,EAAAwB,GAAA,GAAgBH,EAAmBC,EAAkBtB,GACrD,MAAMyB,EAAe,cACrB,cAAcA,EAAc7B,EAAuBmB,GACnD,MAAMW,EAAe,cACrB,SAASA,EAAc9B,EAAuBmB,GAC9C,IAAIY,EAAwB,WAAW/B,IAClCO,GACDC,IACAuB,EAAwB,WAAWf,IAEvC,IAAIgB,EAAuB,IAAI3tD,KAAKunD,aAC/B2E,GACDC,IACAwB,EAAuB,IAAIpB,IAE/B,MAAMqB,EAA4B,CAAC,EAAG,EAAG,GACzC,eAAiBpB,EAAaC,EAAamB,GAC3C,gBAAkBA,GAClB,MAAM,gBAAEnuC,GAAoBgB,GACtB,OAAEotC,GAAW,KACd9qC,kBACA/lB,OAAO,GAAIyiB,GACVquC,EAAiC,CAAC,EAAG,EAAG,GAC9C,mBAAmBA,EAAgCF,EAA2BC,GAC9E,MAAME,EAAqBtE,EAAcuE,mBACnCC,EAA6B,IAC5BH,GAEP,qBAAuBG,EAA4BF,GACnD,MAAMG,EAAwB,CAAC,EAAG,EAAG,GACrC,UAAYP,EAAsBM,EAA4BC,GAC9D,MAAMC,EAAyBjyD,EAASwjD,cAAcwO,GAChDE,EAA8B,cACpC,cAAcA,EAA6BV,EAAuBS,GAClE,MAAME,EAAiB,cACvB,cAAcA,EAAgBX,EAAuBb,GACrD,SAASwB,EAAgBA,EAAgBD,GACzC,MAAME,EAAiB,cACvB,SAASA,EAAgBZ,EAAuBb,GAChD,SAASyB,EAAgBA,EAAgBF,IACzC,EAAAb,GAAA,GAAgBc,EAAgBC,EAAgBvC,GAChD,MAAMwC,EAAmB,cACzB,SAASA,EAAkBb,EAAuBb,GAClD,cAAc0B,EAAkBA,EAAkBH,GAClD,MAAMI,GAAkB,cACxB,cAAcA,GAAiBd,EAAuBb,GACtD,cAAc2B,GAAiBA,GAAiBJ,IAChD,EAAAb,GAAA,GAAgBgB,EAAkBC,GAAiBzC,GACnD,MAAM0C,GAAc,cACdC,GAAc,cACdC,GAAgB,cAChBC,GAAe,cACrB,cAAcH,GAAaf,EAAuBX,GAClD,SAAS0B,GAAaA,GAAaL,GACnC,SAASM,GAAahB,EAAuBX,GAC7C,SAAS2B,GAAaA,GAAaN,GACnC,cAAcO,GAAejB,EAAuBX,GACpD,cAAc4B,GAAeA,GAAeP,GAC5C,SAASQ,GAAclB,EAAuBX,GAC9C,cAAc6B,GAAcA,GAAcR,GAC1CtC,EAAenjD,KAAK,CAChB8gD,EACAyD,EACAC,EACAC,EACAC,EACAgB,EACAC,EACAC,EACAC,GACAhB,EACAC,EACAgB,GACAC,GACAC,GACAC,IACF,IAEN,MAAMC,EAAc,GACdC,EAAc,GACdC,EAAgB/uD,KAAKgvD,uBAAuB9yD,EAASmN,IACrDjN,OAA0B4B,IAAlB+wD,EAA8BA,EAAgB,qBAoL5D,GAnLAjD,EAAe7qD,SAAQ,CAACguD,EAAMC,KAC1B,MAAMzF,EAAgBwF,EAAK,GACrBF,EAAgB/uD,KAAKgvD,uBAAuBvF,EAAcpgD,IAC1DqgD,EAAuB1pD,KAAK2pD,8BAA8BF,EAAcpgD,IACxEugD,EAA6B5pD,KAAK6pD,oCAAoCJ,EAAcpgD,KACtFrJ,KAAKyM,cAAc66C,QAAQR,QACzBqI,EAAkCnvD,KAAKosD,yCAAyC3C,EAAcpgD,KAChGrJ,KAAKyM,cAAc66C,QAAQR,QACzBsI,EAAqBliD,EAAK86C,kBAAkBtqC,MAAMrU,GAAOA,IAAOogD,EAAcpgD,KACpF,IAAIjN,OAA0B4B,IAAlB+wD,EAA8BA,EAAgB,qBACtDpO,EAAY,EAChB,MAAM0O,EAA8C,OAAjCniD,EAAKyxC,QAAQoJ,iBAC5B76C,EAAKyxC,QAAQoJ,kBAAoBvB,IACjC4I,EACAC,IACA1O,EAAY,KAEhB,IAAI2O,EAAU,GAAGJ,IAmBjB,GAlBIxF,GAAwBE,GACxB0F,EAAU,GAAGJ,QACb,IAAAK,UAAYlP,EAAkBd,EAAe+P,EAASL,EAAK,GAAIA,EAAK,GAAI,CACpE7yD,QACAukD,cAEJ2O,EAAU,GAAGJ,QACb,IAAAK,UAAYlP,EAAkBd,EAAe+P,EAASL,EAAK,GAAIA,EAAK,GAAI,CACpE7yD,QACAukD,gBAIJ,IAAA4O,UAAYlP,EAAkBd,EAAe+P,EAASL,EAAK,GAAIA,EAAK,GAAI,CACpE7yD,QACAukD,cAGJ+I,EAAsB,CACtBttD,OACsB4B,IAAlB+wD,EAA8BA,EAAgB,qBAClD,MAAMS,EAAmBtiD,EAAKyxC,QAAQoJ,kBAAoBvB,GACpDiJ,EAAkB,CAACR,EAAK,GAAIA,EAAK,KACjCS,EAAoB,CACtBxzD,EAASkzB,cAAc6/B,EAAK,IAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAEHU,EAAoB,CACtBzzD,EAASkzB,cAAc6/B,EAAK,KAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAETJ,EAAYlmD,KAAK+mD,EAAmBC,GACpC,MAAMC,EAA6B1iD,EAAKyxC,QAAQoJ,kBAAoBvB,GAC9DqJ,EAAuB,CAACZ,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAKA,EAAK,KAC3Da,EAA8B,CAChC5zD,EAASkzB,cAAc6/B,EAAK,KAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAEHc,EAA8B,CAChC7zD,EAASkzB,cAAc6/B,EAAK,KAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAEHe,EAAgC,CAClC9zD,EAASkzB,cAAc6/B,EAAK,KAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAEHgB,EAA+B,CACjC/zD,EAASkzB,cAAc6/B,EAAK,KAC5BxF,EACAwF,EAAK,GACLA,EAAK,IAETH,EAAYnmD,KAAKmnD,EAA6BC,EAA6BC,EAA+BC,GAC1G,IAAIjJ,EAAehnD,KAAKyM,cAAcu6C,cACjChnD,KAAKyM,cAAcw6C,kBAAoB15B,OAAOD,iBAAmB,GAClEzV,EAAU,EAKd,GAJI7X,KAAKyM,cAAc66C,QAAQR,UAC3BE,EAAehnD,KAAKyM,cAAc66C,OAAON,aACzCnvC,EAAU7X,KAAKyM,cAAc66C,OAAOzvC,UAEnCw3C,GAAcrvD,KAAKyM,cAAc66C,QAAQR,WACzC0I,IACAI,GACDhG,GACAuF,EAAiC,CACjC,IAAIe,EAAY,GAAGhB,QACnB,IAAAiB,aAAe9P,EAAkBd,EAAe2Q,EAAWT,EAAiB,CACxErzD,QACA4qD,eACAnvC,UACA/Q,KAAM,WAEVopD,EAAY,GAAGhB,QACf,IAAAiB,aAAe9P,EAAkBd,EAAe2Q,EAAWL,EAAsB,CAC7EzzD,QACA4qD,eACAnvC,UACA/Q,KAAM,QAEd,MACK,GAAIuoD,IACJG,IACAI,GACDhG,EAA4B,CAC5B,MAAMsG,EAAY,GAAGhB,KACrB,IAAAiB,aAAe9P,EAAkBd,EAAe2Q,EAAWT,EAAiB,CACxErzD,QACA4qD,eACAnvC,UACA/Q,KAAM,UAEd,MACK,GAAIsoD,IACJI,IACAI,GACDT,EAAiC,CACjC,MAAMe,EAAY,GAAGhB,KACrB,IAAAiB,aAAe9P,EAAkBd,EAAe2Q,EAAWL,EAAsB,CAC7EzzD,QACA4qD,eACAnvC,UACA/Q,KAAM,QAEd,MACK,GAAI0oD,GAAoB5F,EAA4B,CACrD,MAAMsG,EAAY,GAAGhB,IACflI,EAAehnD,KAAKyM,cAAcu6C,cACnChnD,KAAKyM,cAAcw6C,kBACd15B,OAAOD,iBACP,IACV,IAAA6iC,aAAe9P,EAAkBd,EAAe2Q,EAAWT,EAAiB,CACxErzD,QACA4qD,eACAl1C,KAAM1V,EACN0K,KAAM,UAEd,MACK,GAAI8oD,GACLR,GACAD,EAAiC,CACjC,MAAMnI,EAAehnD,KAAKyM,cAAcu6C,cACnChnD,KAAKyM,cAAcw6C,kBACd15B,OAAOD,iBACP,IACV,IAAA6iC,aAAe9P,EAAkBd,EAAe+P,EAASO,EAAsB,CAC3EzzD,QACA4qD,eACAl1C,KAAM1V,EACN0K,KAAM,QAEd,CAC2B2iD,EAAcuE,mBAChB,IAAOmB,IAC5BG,EAAU,GAAGJ,UACb,IAAAK,UAAYlP,EAAkBd,EAAe+P,EAASL,EAAK,GAAIA,EAAK,GAAI,CACpE7yD,QACAQ,MAAO,EACPgkD,SAAU,CAAC,EAAG,KAElB0O,EAAU,GAAGJ,UACb,IAAAK,UAAYlP,EAAkBd,EAAe+P,EAASL,EAAK,GAAIA,EAAK,GAAI,CACpE7yD,QACAQ,MAAOqyD,EACPrO,SAAU,CAAC,EAAG,KAG1B,KAEJN,GAAe,EACfpzC,EAAKyxC,QAAQkJ,eAAiBgH,EAC9B3hD,EAAKyxC,QAAQmJ,oBAAsBgH,EAC/B9uD,KAAKyM,cAAck6C,mBAAoB,CACvC,MAAM,yBAAEC,GAA6B5mD,KAAKyM,cAGpC2jD,EAA4B,CAC9BlV,GAHY0L,GAA0ByJ,SAAW,KAIjDlV,GAHYyL,GAA0B0J,SAAW,MAK/CC,EAAe3J,GAA0B2J,cAAuC,IAAvB9E,EACzD+E,EAAY,KAClB,IAAAC,YAAcpQ,EAAkBd,EAAeiR,EAAWJ,EAA2BG,EAAc,CAAEn0D,QAAO0V,KAAM1V,GACtH,CACA,OAAOkkD,CAAY,EAEvBtgD,KAAKynD,gBAAmBnsD,IACpB,MAAM,SAAEY,GAAaZ,EACfilD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAexiD,EAASixB,UAAY,GACtEtT,EAAc7Z,KAAKs5C,oBAAoBjzC,KAAI,EAAG6mB,gBAAiBA,IAC/DyjC,EAAuBpQ,EAAYzrC,QAAQ85B,IAC7C,MAAM,KAAE1hC,GAAS0hC,EACjB,OAAO/0B,EAAYgB,SAAS3N,EAAKggB,WAAW,IAEhD,OAAOyjC,CAAoB,EAE/B3wD,KAAK4wD,aAAe,KAChB,MAAMnX,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKyoD,mBAAmBhP,EAAc,EAE1Cz5C,KAAKurD,0BAA4B,CAACsF,EAAoBC,IAC9CD,EAAmBjwD,SAAWkwD,EAAmBlwD,SAGrDiwD,EAAmB5vD,SAASoI,IACxB,IAAI0nD,GAAY,EAChB,IAAK,IAAIrnD,EAAI,EAAGA,EAAIonD,EAAmBlwD,SAAU8I,EAC7C,GAAIL,IAAOynD,EAAmBpnD,GAAI,CAC9BqnD,GAAY,EACZ,KACJ,CAEJ,IAAkB,IAAdA,EACA,OAAO,CACX,KAEG,GAEX/wD,KAAKgxD,gDAAkD,CAAC11D,EAAgBilD,KACpE,MAAM,WAAErzB,EAAU,gBAAEvT,EAAe,SAAEzd,GAAaZ,EAC5CswD,EAA2BrL,EAAYzrC,QAAQ85B,GAAeA,EAAW1hC,KAAKggB,aAAeA,IACnG,IAAK0+B,IAA6BA,EAAyBhrD,OACvD,MAAO,GAEX,MAAM6f,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,SAAEmO,GAAanN,EAChCwwC,EAAgCrF,EAAyB92C,QAAQ85B,IACnE,MAAM,WAAE1hB,GAAe0hB,EAAW1hC,KAE5BgkD,EADiBv3C,EAAgByU,YAAYlB,GACbxM,YACtC,QAAS,oBAAgBwwC,EAAezxC,gBAAiBA,EAAiB,MAAS,oBAAgByxC,EAAetjC,SAAUA,EAAU,GAAG,IAE7I,OAAOqjC,CAA6B,EAExCjxD,KAAKmxD,mCAAqC,CAAC71D,EAAgB81D,EAAqB7Q,KAC5E,MAAM,gBAAE5mC,GAAoBre,GACtB,KAAE4R,GAASkkD,EACXl1D,EAAWyd,EAAgByU,YAAYlhB,EAAKggB,YAC5CmkC,EAA4B9Q,EAAYzrC,QAAQ85B,IAClD,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YAEvD,OAAqC,IADHltB,KAAK2pD,8BAA8BF,EAAcpgD,GAC1C,IAE7C,IAAKgoD,IAA8BA,EAA0BzwD,OACzD,MAAO,GAEX,MAAM6f,EAASvkB,EAASwkB,YAClBjB,EAAkBgB,EAAOhB,gBAC/B,gBAAkBA,GAClB,MAAM6xC,EAAmDD,EAA0Bv8C,QAAQ85B,IACvF,MAAM,WAAE1hB,GAAe0hB,EAAW1hC,KAE5B8+C,EADgBryC,EAAgByU,YAAYlB,GAChBxM,YAC5B6wC,EAAuBvF,EAAYvsC,gBAEzC,OADA,gBAAkB8xC,GACV,oBAAgB9xC,EAAiB8xC,EAAsB,MAC3D,oBAAgB9wC,EAAO2hB,OAAQ4pB,EAAY5pB,OAAQ,IAAM,IAEjE,OAAOkvB,CAAgD,EAE3DtxD,KAAK6rD,+CAAiD,CAACvwD,EAAgBilD,KACnE,MAAM,gBAAE5mC,EAAe,SAAEzd,GAAaZ,EAEhCmkB,EADSvjB,EAASwkB,YACOjB,gBAC/B,gBAAkBA,GAClB,MAAM+xC,EAA8CjR,EAAYzrC,QAAQ85B,IACpE,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD++B,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IACnF,OAAQnN,IAAautD,IACa,IAA9BwC,CAAmC,IAErCwF,EAA6C,GACnD,IAAK,IAAI/nD,EAAI,EAAGA,EAAI8nD,EAA4C5wD,SAAU8I,EAAG,CACzE,MAAMklC,EAAa4iB,EAA4C9nD,IACzD,WAAEwjB,GAAe0hB,EAAW1hC,KAE5B8+C,EADgBryC,EAAgByU,YAAYlB,GAChBxM,YAC5B6wC,EAAuBvF,EAAYvsC,gBAEzC,GADA,gBAAkB8xC,GACd,oBAAgB9xC,EAAiB8xC,EAAsB,MACvD,uBAAmB9xC,EAAiB8xC,EAAsB,KAC1D,SAEJ,IAAIG,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7wD,SAAU+wD,EAAI,CAC3E,MAAM/iB,EAAa6iB,EAA2CE,IACxD,WAAEzkC,GAAe0hB,EAAW1hC,KAE5B0kD,EADkBj4C,EAAgByU,YAAYlB,GACZxM,YACpC,oBAAgBkxC,EAAgBnyC,gBAAiBusC,EAAYvsC,gBAAiB,MAC9E,oBAAgBmyC,EAAgBhkC,SAAUo+B,EAAYp+B,SAAU,KAChE8jC,GAAc,EAEtB,CACKA,GACDD,EAA2C9oD,KAAKimC,EAExD,CACA,MAAMijB,EAAiDtR,EAAYzrC,QAAQ85B,IACvE,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD++B,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IACnF,OAAQnN,IAAautD,IACa,IAA9BwC,CAAmC,IAE3C,IAAK,IAAIviD,EAAI,EAAGA,EAAImoD,EAA+CjxD,SAAU8I,EAAG,CAC5E,MAAMklC,EAAaijB,EAA+CnoD,IAC5D,WAAEwjB,GAAe0hB,EAAW1hC,KAE5B8+C,EADgBryC,EAAgByU,YAAYlB,GAChBxM,YAC5B6wC,EAAuBvF,EAAYvsC,gBAEzC,GADA,gBAAkB8xC,GACd,oBAAgB9xC,EAAiB8xC,EAAsB,MACvD,uBAAmB9xC,EAAiB8xC,EAAsB,KAC1D,SAEJ,IAAIG,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7wD,SAAU+wD,EAAI,CAC3E,MAAM/iB,EAAa6iB,EAA2CE,IACxD,WAAEzkC,GAAe0hB,EAAW1hC,KAE5B0kD,EADkBj4C,EAAgByU,YAAYlB,GACZxM,YACpC,oBAAgBkxC,EAAgBnyC,gBAAiBusC,EAAYvsC,gBAAiB,MAC9E,oBAAgBmyC,EAAgBhkC,SAAUo+B,EAAYp+B,SAAU,KAChE8jC,GAAc,EAEtB,CACKA,GACDD,EAA2C9oD,KAAKimC,EAExD,CACA,MAAMgd,EAA2B5rD,KAAKgxD,gDAAgD11D,EAAgBilD,GACtG,IAAK,IAAI72C,EAAI,EAAGA,EAAIkiD,EAAyBhrD,SAAU8I,EAAG,CACtD,MAAMklC,EAAagd,EAAyBliD,GAC5C,GAAI+nD,EAA2CxqC,MAAMkG,GAAYA,IAAYyhB,IACzE,SAEJ,MAAM,WAAE1hB,GAAe0hB,EAAW1hC,KAE5B8+C,EADgBryC,EAAgByU,YAAYlB,GAChBxM,YAC5B6wC,EAAuBvF,EAAYvsC,gBAEzC,GADA,gBAAkB8xC,GACd,oBAAgB9xC,EAAiB8xC,EAAsB,MACvD,uBAAmB9xC,EAAiB8xC,EAAsB,KAC1D,SAEJ,IAAIG,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7wD,SAAU+wD,EAAI,CAC3E,MAAM/iB,EAAa6iB,EAA2CE,IACxD,WAAEzkC,GAAe0hB,EAAW1hC,KAE5B0kD,EADkBj4C,EAAgByU,YAAYlB,GACZxM,YACpC,oBAAgBkxC,EAAgBnyC,gBAAiBusC,EAAYvsC,gBAAiB,MAC9E,oBAAgBmyC,EAAgBhkC,SAAUo+B,EAAYp+B,SAAU,KAChE8jC,GAAc,EAEtB,CACKA,GACDD,EAA2C9oD,KAAKimC,EAExD,CACA,OAAO6iB,CAA0C,EAErDzxD,KAAK8xD,oCAAsC,CAAC51D,EAAUutD,KAClD,MAAMsI,EAAY71D,EAAS81D,kBACrBC,EAAiBxI,EAAcuI,kBACrC,OAAQD,EAAUnxD,SAAWqxD,EAAerxD,QACxCmxD,EAAUxlC,OAAOljB,GAAO4oD,EAAep3C,SAASxR,IAAK,EAE7DrJ,KAAKspD,MAAQ,CAAChuD,EAAgB+tD,KAC1B,KAAMzJ,uBAAwB,EAC9B,MAAM,SAAE1jD,EAAQ,gBAAEyd,GAAoBre,EAChCilD,EAAcvgD,KAAKynD,gBAAgBnsD,GACnCia,EAAQ,CAAC,EAAG,EAAG,GACrB,eAAiB8zC,EAAWrpD,KAAKunD,WAAYhyC,GAC7C,MACM28C,EAD2BlyD,KAAKgxD,gDAAgD11D,EAAgBilD,GACxCzrC,QAAQ85B,IAClE,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjDilC,EAAYnyD,KAAK8xD,oCAAoC51D,EAAUutD,GACrE,OAAQzpD,KAAK2pD,8BAA8BF,EAAcpgD,KACrDrJ,KAAK6pD,oCAAoCJ,EAAcpgD,KACvD8oD,CAAU,IAElB,OAA4C,IAAxCD,EAA6BtxD,QAC7B,KAAMg/C,uBAAwB,GACvB,IAEX5/C,KAAKoyD,0CAA0Cz4C,EAAiBu4C,EAA8B38C,GAC9F,KAAMqqC,uBAAwB,GACvB,EAAI,EAEf5/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAyB5/C,KAAKyM,cAAc66C,QAAQR,QAC1D35B,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB/uB,KAAK++C,SAASnQ,WAAW1hC,KAAKyxC,QAAQoJ,gBAAkB,KACxD/nD,KAAK++C,SAASnQ,WAAW1hC,KAAK86C,kBAAoB,GAClDhoD,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK++C,SAAW,KAChB,MACMF,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAD1C,IAE/B,EAAAS,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKk4C,cAAiBD,IAClB,MAAMlpB,EAAckpB,EAAI3lB,OAClB/c,EAAQwZ,EAAYqpB,YAAYE,MACtC,GAAIr7C,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,KACrB,OAEJ,MAAM,QAAE4X,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,EAChCilD,EAAcvgD,KAAKynD,gBAAgBnsD,GAEnC6uD,EAD0BnqD,KAAKwgD,wCAAwCrzB,EAASozB,GACnC,GACnD,IAAK4J,EACD,OAEJ,MAAM,QAAExL,GAAYwL,EAAmBj9C,MACjC,cAAE4tC,GAAkB7C,EAAI3lB,OACxBw3B,EAAehP,EAAcr/C,OACnC,GAAIkjD,EAAQoJ,kBAAoBvB,GAAgB,CAC5C,MACM0L,EAD2BlyD,KAAKgxD,gDAAgD11D,EAAgBilD,GACxCzrC,QAAQ85B,IAClE,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD++B,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IAC7E6iD,EAAkClsD,KAAK6pD,oCAAoCJ,EAAcpgD,IAC/F,OAAsC,IAA9B4iD,IACgC,IAApCC,GACA/B,EAAmBj9C,KAAK86C,kBAAkBtqC,MAAMrU,GAAOA,IAAOogD,EAAcpgD,IAAI,IAExFrJ,KAAKoyD,0CAA0Cz4C,EAAiBu4C,EAA8B38C,EAClG,MACK,GAAIopC,EAAQoJ,kBAAoBvB,GAAkB,CACnD,MACM0L,EAD2BlyD,KAAKgxD,gDAAgD11D,EAAgBilD,GACxCzrC,QAAQ85B,IAClE,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD++B,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IAC7E6iD,EAAkClsD,KAAK6pD,oCAAoCJ,EAAcpgD,IAC/F,OAAsC,IAA9B4iD,IACgC,IAApCC,CAAyC,IAE3CmG,EAAO,cACPC,EAAO,cACP17C,EAAS,CACX5W,KAAKunD,WAAW,GAChBvnD,KAAKunD,WAAW,GAChBvnD,KAAKunD,WAAW,IAEdhE,EAAernD,EAASwjD,cAAc9oC,GACtC27C,EAAmBxjC,EAAY+rB,cAAcr/C,OAC7C+2D,EAAsB,cAC5B,SAASA,EAAqBD,EAAkBxjC,EAAYqpB,YAAY38C,QACxE,SAAS42D,EAAMG,EAAqBjP,GACpC,SAAS+O,EAAMC,EAAkBhP,GACjC,IAAIzmD,EAAQ,WAAWu1D,EAAMC,GACzBtyD,KAAKyyD,aAAalP,EAAciP,EAAqBD,KACrDz1D,IAAU,GAEdA,EAAQG,KAAKkkB,MAAc,IAARrkB,GAAe,IAClC,MAAM41D,EAAex2D,EAASwkB,YAAYjB,iBACpC,OAAEouC,GAAW,KACd8E,kBACAh2D,UAAUia,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACvC5Z,OAAOF,EAAO41D,GACd/1D,WAAWia,EAAO,IAAKA,EAAO,IAAKA,EAAO,IACzCg8C,EAAoB,GAC1BV,EAA6BjxD,SAAS2tC,IAClC,MAAM,KAAE1hC,GAAS0hC,EACjB1hC,EAAKyxC,QAAQ4I,WAAa3wC,EAC1B,MAAM6yC,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjDzM,EAASgpC,EAAc/oC,aACvB,OAAE0hB,EAAM,SAAExU,EAAQ,WAAEhN,GAAeH,EACzC2hB,EAAO,IAAMxU,EAAS,GACtBwU,EAAO,IAAMxU,EAAS,GACtBwU,EAAO,IAAMxU,EAAS,GACtB,mBAAmBhN,EAAYA,EAAYitC,GAC3C,mBAAmBjgC,EAAUA,EAAUigC,GACvC,mBAAmBzrB,EAAQA,EAAQyrB,GACnCzrB,EAAO,IAAMxU,EAAS,GACtBwU,EAAO,IAAMxU,EAAS,GACtBwU,EAAO,IAAMxU,EAAS,GACtB67B,EAActqB,UAAU,CACpBvR,WACAwU,SACAxhB,eAEJgyC,EAAkBjqD,KAAK8gD,EAAcpgD,GAAG,IAE5CsQ,EAAgBK,gBAAgB44C,EACpC,MACK,GAAIjU,EAAQoJ,kBAAoBvB,GAAgB,CACjD,MACMqM,EAD2B7yD,KAAKgxD,gDAAgD11D,EAAgBilD,GAChDzrC,QAAQ85B,IAC1D,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YACjD++B,EAA4BjsD,KAAK2pD,8BAA8BF,EAAcpgD,IAC7E8iD,EAAuCnsD,KAAKosD,yCAAyC3C,EAAcpgD,IACzG,OAAsC,IAA9B4iD,IACqC,IAAzCE,GACAhC,EAAmBj9C,KAAK86C,kBAAkBtqC,MAAMrU,GAAOA,IAAOogD,EAAcpgD,IAAI,IAExF,GAAoC,IAAhCwpD,EAAqBjyD,OACrB,OAEJ,MAAMsxD,EAA+BlyD,KAAKmxD,mCAAmC71D,EAAgBu3D,EAAqB,GAAItS,GAChHuS,EAAe,GACrBA,EAAanqD,KAAKzM,EAASmN,IAC3B6oD,EAA6BjxD,SAAS2tC,IAClC,MAAM,KAAE1hC,GAAS0hC,EACX6a,EAAgB9vC,EAAgByU,YAAYlhB,EAAKggB,YAEjD+Z,EADSwiB,EAAc/oC,YACPjB,gBAChBszC,EAAU,UAAYx9C,EAAO0xB,GAC7B+rB,EAAiB,IAAI/rB,GAE3B,GADA,qBAAuB+rB,EAAgBD,GACnC91D,KAAK6e,IAAIk3C,EAAe,IAAM,MAC9B/1D,KAAK6e,IAAIk3C,EAAe,IAAM,MAC9B/1D,KAAK6e,IAAIk3C,EAAe,IAAM,KAAM,CACpC,MAAMC,EAAMh2D,KAAKwmC,KAAKuvB,EAAe,GAAKA,EAAe,GACrDA,EAAe,GAAKA,EAAe,GACnCA,EAAe,GAAKA,EAAe,IACjCE,EAAenkC,EAAYgsB,WAAWzC,MACtCrwC,EAAY,CAAC,EAAG,EAAG,GACnBkrD,EAAgB,CAClBnzD,KAAKunD,WAAW,GAChBvnD,KAAKunD,WAAW,GAChBvnD,KAAKunD,WAAW,IAGpB,IADmCvnD,KAAK6pD,oCAAoCJ,EAAcpgD,IACzD,CAC7B,MAAM,eAAEw+C,GAAmB7nD,KAAK++C,SAASnQ,WAAW1hC,KAAKyxC,QACnDyU,EAA8BvL,EAAe/yC,QAAQxG,GAAUA,EAAM,GAAGyS,MAAQ0oC,EAAcpgD,KACpG,GAA2C,IAAvC+pD,EAA4BxyD,OAAc,CAC1C,MAAMmoD,EAAS7sD,EAASkzB,cAAcgkC,EAA4B,GAAG,IAC/DnK,EAAS/sD,EAASkzB,cAAcgkC,EAA4B,GAAG,IACrE,UAAYrK,EAAQE,EAAQkK,GAC5B,qBAAuBA,EAAe,GAC1C,CACJ,CACA,eAAiBD,EAAcC,EAAelrD,GAC9C,MAAMorD,EAAmB,UAAYprD,EAAWg/B,GAC1CqsB,EAAqB,IAAIrsB,GAC/B,qBAAuBqsB,EAAoBD,GAC3C,MAAME,EAA+B,CACjCD,EAAmB,GACnBA,EAAmB,GACnBA,EAAmB,IAEvB,eAAeC,EAA8BA,GAC7C,MAAMC,EAA2B,CAC7BR,EAAe,GACfA,EAAe,GACfA,EAAe,IAEnB,eAAeQ,EAA0BA,GACzC,IAAIzF,EAAqBtE,EAAcuE,mBACnC,uBAAmBuF,EAA8BC,EAA0B,MAC3EzF,GAAsBkF,EAGtBlF,GAAsBkF,EAE1BlF,EAAqB9wD,KAAK6e,IAAIiyC,GAC9BA,EAAqB9wD,KAAKkS,IAAI+2C,GAAmBuN,uBAAwB1F,GAC5D/tD,KAAK0zD,wBAAwBvJ,EAAoBL,EAAc,EAAGL,KAE3EsE,EAAqB7H,GAAmBuN,yBAE1B,IAAAzN,yBAAwByD,EAAcpgD,GAAIsQ,EAAgBtQ,IACvCsqD,gBAAgB3zD,KAAK0+C,eACvCkV,iBAAiBnK,EAAesE,GACnD+E,EAAanqD,KAAK8gD,EAAcpgD,GACpC,KAEJsQ,EAAgBK,gBAAgB84C,EACpC,GAEJ9yD,KAAK0zD,wBAA0B,CAAC9kB,EAAYkb,EAAcC,EAAW8J,KACjE,MAAM,KAAE3mD,GAAS0hC,GACX,eAAEiZ,GAAmB36C,EAAKyxC,QAChC,IAAK,IAAIj1C,EAAI,EAAGA,EAAIm+C,EAAejnD,OAAS,IAAK8I,EAAG,CAChD,MAAM+/C,EAAgB5B,EAAen+C,GAAG,GACxC,GAAI+/C,EAAcpgD,KAAOwqD,EAAaxqD,GAClC,SAGJ,IAD6BrJ,KAAK2pD,8BAA8BF,EAAcpgD,IAE1E,SAEJ,MAAMyqD,EAAe,CACjBp4D,MAAO,CACH4B,EAAGuqD,EAAen+C,GAAG,GAAG,GACxBlM,EAAGqqD,EAAen+C,GAAG,GAAG,IAE5BsI,IAAK,CACD1U,EAAGuqD,EAAen+C,GAAG,GAAG,GACxBlM,EAAGqqD,EAAen+C,GAAG,GAAG,KAG1BqqD,EAAmB,mBAA4B,CAACD,EAAap4D,MAAM4B,EAAGw2D,EAAap4D,MAAM8B,GAAI,CAACs2D,EAAa9hD,IAAI1U,EAAGw2D,EAAa9hD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACtKkK,EAAe,CACjBt4D,MAAO,CACH4B,EAAGuqD,EAAen+C,EAAI,GAAG,GAAG,GAC5BlM,EAAGqqD,EAAen+C,EAAI,GAAG,GAAG,IAEhCsI,IAAK,CACD1U,EAAGuqD,EAAen+C,EAAI,GAAG,GAAG,GAC5BlM,EAAGqqD,EAAen+C,EAAI,GAAG,GAAG,KAG9BuqD,EAAmB,mBAA4B,CAACD,EAAat4D,MAAM4B,EAAG02D,EAAat4D,MAAM8B,GAAI,CAACw2D,EAAahiD,IAAI1U,EAAG02D,EAAahiD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KAC5K,GAAIiK,GAAoBhK,GAAakK,GAAoBlK,EACrD,OAAO,EAEXrgD,GACJ,CACA,OAAO,CAAK,EAEhB1J,KAAKgvD,uBACDnX,EAAUprC,eAAeynD,uBACrB9N,GACRpmD,KAAK2pD,8BACD9R,EAAUprC,eAAe0nD,8BACrB9N,GACRrmD,KAAK6pD,oCACDhS,EAAUprC,eAAe2nD,oCACrB9N,GACRtmD,KAAKosD,yCACDvU,EAAUprC,eAAe4nD,yCACrB9N,EACZ,CACA,eAAA7M,GACI,MAAMD,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKs0D,mCAAmC7a,GACxCz5C,KAAKu0D,iCAAiC9a,GACtCz5C,KAAKyoD,mBAAmBhP,EAC5B,CACA,gBAAA+a,GACI,MAAM/a,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKyoD,mBAAmBhP,EAC5B,CACA,gBAAAgb,GACI,MAAMhb,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKyoD,mBAAmBhP,EAC5B,CACA,iBAAAU,GACI,MAAMV,EAAgBz5C,KAAKs5C,oBAC3Bt5C,KAAKs0D,mCAAmC7a,GACxCA,EAAcx4C,SAAQ,EAAGirB,oBAAmBgB,iBACxC,MAAM5xB,GAAiB,IAAAs+C,wBAAuB1sB,EAAYhB,GAC1D,IAAK5wB,EACD,OAEJ,MAAMilD,EAAcvgD,KAAKynD,gBAAgBnsD,GACrCilD,GAAa3/C,QACb2/C,EAAYt/C,SAAS2tC,KACjB,IAAA8Y,kBAAiB9Y,EAAW2Q,cAAc,GAElD,GAER,CACA,aAAA6J,CAAc7B,EAAY74B,GAAiB,GACvC1uB,KAAKunD,WAAaA,EAClB,MAAM9N,EAAgBz5C,KAAKs5C,qBAC3B,EAAA6F,EAAA,GAAsC1F,EAAcpzC,KAAI,EAAG6mB,gBAAiBA,KACvEwB,IACD,IAAA8Q,cAAa,EAAArN,YAAa,EAAA1C,OAAOk7B,8BAA+B,CAC5DnR,YAAax5C,KAAKw5C,YAClB+N,WAAYvnD,KAAKunD,YAG7B,CACA,uBAAA+D,CAAwBn+B,EAASyhB,EAAYkb,EAAcC,GACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB,IAAIgT,EAAQtO,KAAK00D,iCAAiCx4D,EAAU0yC,EAAYkb,EAAcC,GACtF,OAAc,OAAVz7C,EACOA,GAEXA,EAAQtO,KAAK20D,sCAAsCz4D,EAAU0yC,EAAYkb,EAAcC,GACzE,OAAVz7C,EACOA,OADX,EAGJ,CACA,kCAAAgmD,CAAmC7a,GAC/BA,EAAcx4C,SAAQ,EAAGisB,aAAYhB,wBACjC,MAAM,SAAEhwB,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAClD,QAAEiB,GAAYjxB,EACpBixB,EAAQrE,oBAAoB,EAAAojB,MAAA,OAAapS,2BAA4B95B,KAAK4wD,aAAa,GAE/F,CACA,gCAAA2D,CAAiC36C,GAC7BA,EAAU3Y,SAAQ,EAAGisB,aAAYhB,wBAC7B,MAAM,SAAEhwB,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAClD,QAAEiB,GAAYjxB,EACpBixB,EAAQ1E,iBAAiB,EAAAyjB,MAAA,OAAapS,2BAA4B95B,KAAK4wD,aAAa,GAE5F,CACA,2BAAA/F,CAA4B39B,EAAYvT,GACpC,MAAMzd,EAAWyd,EAAgByU,YAAYlB,IACvC,YAAEguB,EAAW,aAAEC,GAAiBj/C,EAAST,OACzCm5D,EAAmB14D,EAASwjD,cAAc1/C,KAAKunD,YAC/CrD,EAAMlkD,KAAKyM,cAAco6C,QAAQE,QACjC8N,EAAqB,CACvBD,EAAiB,GACjBA,EAAiB,IAcrB,GAZIA,EAAiB,GAAK,EACtBC,EAAmB,GAAK3Q,EAEnB0Q,EAAiB,GAAK1Z,IAC3B2Z,EAAmB,GAAK3Z,EAAcgJ,GAEtC0Q,EAAiB,GAAK,EACtBC,EAAmB,GAAK3Q,EAEnB0Q,EAAiB,GAAKzZ,IAC3B0Z,EAAmB,GAAK1Z,EAAe+I,GAEvC2Q,EAAmB,KAAOD,EAAiB,IAC3CC,EAAmB,KAAOD,EAAiB,GAC3C,OAEJ,MAAME,EAAoB54D,EAASkzB,cAAcylC,GAC3Cxc,EAAmB,CACrByc,EAAkB,GAAK90D,KAAKunD,WAAW,GACvCuN,EAAkB,GAAK90D,KAAKunD,WAAW,GACvCuN,EAAkB,GAAK90D,KAAKunD,WAAW,IAErC9mC,EAASvkB,EAASwkB,aAClB,WAAEE,EAAU,SAAEgN,GAAanN,EAC3B83B,EAAkB,CACpB3qB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,IAE7BG,EAAoB,CACtB53B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,IAErCn8C,EAASijC,UAAU,CACfve,WAAY43B,EACZ5qB,SAAU2qB,IAEdr8C,EAASD,QACb,CACA,gBAAA23D,CAAiB13D,EAAU8oB,GACvB,IAAI+vC,EACJ,MAAM,kCAAE5N,GAAsCnnD,KAAKyM,cAC/C06C,GACAA,EAAkCvmD,OAAS,IAC3Cm0D,EAAY5N,GAEhB,IAAI6N,EAAiBh1D,KAAKyM,cAAc26C,uBACpCpiC,IAAkBkhC,GAAmBuN,yBACrCuB,EAAiB,EAAA9oB,MAAA,WAAiB+oB,WAGtC/4D,EAASg5D,aAAaF,EAAgBD,GADpB,GAElB74D,EAAS03D,iBAAiB5uC,EAAe+vC,EAC7C,CACA,YAAAtC,CAAav2C,EAAGhF,EAAGokB,GACf,OAAQpkB,EAAE,GAAKgF,EAAE,KAAOof,EAAE,GAAKpf,EAAE,KAAOhF,EAAE,GAAKgF,EAAE,KAAOof,EAAE,GAAKpf,EAAE,IAAM,CAC3E,CACA,yCAAAk2C,CAA0Cz4C,EAAiBu4C,EAA8B38C,GACrF28C,EAA6BjxD,SAAS2tC,IAClC5uC,KAAKm1D,iCAAiCx7C,EAAiBi1B,EAAYr5B,EAAM,GAEjF,CACA,gCAAA4/C,CAAiCx7C,EAAiBi1B,EAAYr5B,GAC1D,MAAM,KAAErI,GAAS0hC,EACX1yC,EAAWyd,EAAgByU,YAAYlhB,EAAKggB,YAC5CzM,EAASvkB,EAASwkB,YAClBumB,EAASxmB,EAAOhB,gBAChBszC,EAAU,UAAYx9C,EAAO0xB,GAC7B+rB,EAAiB,IAAI/rB,GAE3B,GADA,qBAAuB+rB,EAAgBD,GACnC91D,KAAK6e,IAAIk3C,EAAe,IAAM,MAC9B/1D,KAAK6e,IAAIk3C,EAAe,IAAM,MAC9B/1D,KAAK6e,IAAIk3C,EAAe,IAAM,KAAM,CACpC,MAAM/zB,EAAgB,CAAC,EAAG,EAAG,GACvBpM,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAYpS,EAAOG,WAAYoyC,EAAgB/zB,GAC/C,UAAYxe,EAAOmN,SAAUolC,EAAgBngC,GAC7C32B,EAASijC,UAAU,CACfve,WAAYqe,EACZrR,SAAUiF,IAEd32B,EAASD,QACb,CACJ,CACA,gCAAAy4D,CAAiCx4D,EAAU0yC,EAAYkb,EAAcC,GACjE,MAAM,KAAE78C,GAAS0hC,GACX,eAAEiZ,GAAmB36C,EAAKyxC,QAChC,IAAK,IAAIj1C,EAAI,EAAGA,EAAIm+C,EAAejnD,OAAQ8I,IAAK,CAC5C,MAAM4E,EAAQu5C,EAAen+C,GAAG,GAC1B+/C,EAAgB5B,EAAen+C,GAAG,GAExC,IAD6B1J,KAAK2pD,8BAA8BF,EAAcpgD,IAE1E,SAGJ,IADmCrJ,KAAK6pD,oCAAoCJ,EAAcpgD,IAEtF,SAEJ,MAAM+rD,EAA6Bl5D,EAASwjD,cAAcpxC,GAC1D,GAAI,cAAcw7C,EAAcsL,GAA8BrL,EAK1D,OAJA78C,EAAKyxC,QAAQoJ,gBAAkBvB,GAC/BxmD,KAAK++C,SAAW,CACZnQ,cAEGtgC,CAEf,CACA,OAAO,IACX,CACA,qCAAAqmD,CAAsCz4D,EAAU0yC,EAAYkb,EAAcC,GACtE,MAAM,KAAE78C,GAAS0hC,GACX,oBAAEkZ,GAAwB56C,EAAKyxC,QACrC,IAAK,IAAIj1C,EAAI,EAAGA,EAAIo+C,EAAoBlnD,OAAQ8I,IAAK,CACjD,MAAM4E,EAAQw5C,EAAoBp+C,GAAG,GAC/B+/C,EAAgB3B,EAAoBp+C,GAAG,GAE7C,IAD6B1J,KAAK2pD,8BAA8BF,EAAcpgD,IAE1E,SAGJ,IADwCrJ,KAAKosD,yCAAyC3C,EAAcpgD,IAEhG,SAEJ,MAAM+rD,EAA6Bl5D,EAASwjD,cAAcpxC,GAC1D,GAAI,cAAcw7C,EAAcsL,GAA8BrL,EAM1D,OALA78C,EAAKyxC,QAAQoJ,gBAAkBvB,GAC/Bt5C,EAAK86C,kBAAoB,CAACyB,EAAcpgD,IACxCrJ,KAAK++C,SAAW,CACZnQ,cAEGtgC,CAEf,CACA,OAAO,IACX,CACA,cAAA07C,CAAe78B,EAASyhB,EAAYkb,EAAcC,GAC9C,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,YAAE4/C,EAAW,aAAEC,GAAiBj/C,EAAST,OACzCgwD,EAAuBxuD,KAAKwmC,KAAKyX,EAAcA,EAAcC,EAAeA,IAC5E,KAAEjuC,GAAS0hC,GACX,eAAEiZ,GAAmB36C,EAAKyxC,SAC1B,oBAAEmJ,GAAwB56C,EAAKyxC,QAC/B6K,EAAkB,GACxB,IAAK,IAAI9/C,EAAI,EAAGA,EAAIm+C,EAAejnD,OAAS,IAAK8I,EAAG,CAChD,MAAM+/C,EAAgB5B,EAAen+C,GAAG,GAClCggD,EAAuB1pD,KAAK2pD,8BAA8BF,EAAcpgD,IACxEugD,EAA6B5pD,KAAK6pD,oCAAoCJ,EAAcpgD,IAC1F,IAAKqgD,IAAyBE,EAC1B,SAEJ,MAAMkK,EAAe,CACjBp4D,MAAO,CACH4B,EAAGuqD,EAAen+C,GAAG,GAAG,GACxBlM,EAAGqqD,EAAen+C,GAAG,GAAG,IAE5BsI,IAAK,CACD1U,EAAGuqD,EAAen+C,GAAG,GAAG,GACxBlM,EAAGqqD,EAAen+C,GAAG,GAAG,KAG1BqqD,EAAmB,mBAA4B,CAACD,EAAap4D,MAAM4B,EAAGw2D,EAAap4D,MAAM8B,GAAI,CAACs2D,EAAa9hD,IAAI1U,EAAGw2D,EAAa9hD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACtKkK,EAAe,CACjBt4D,MAAO,CACH4B,EAAGuqD,EAAen+C,EAAI,GAAG,GAAG,GAC5BlM,EAAGqqD,EAAen+C,EAAI,GAAG,GAAG,IAEhCsI,IAAK,CACD1U,EAAGuqD,EAAen+C,EAAI,GAAG,GAAG,GAC5BlM,EAAGqqD,EAAen+C,EAAI,GAAG,GAAG,KAG9BuqD,EAAmB,mBAA4B,CAACD,EAAat4D,MAAM4B,EAAG02D,EAAat4D,MAAM8B,GAAI,CAACw2D,EAAahiD,IAAI1U,EAAG02D,EAAahiD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACxKiK,GAAoBhK,GAAakK,GAAoBlK,KACrDP,EAAgB7gD,KAAK8gD,EAAcpgD,IACnC6D,EAAKyxC,QAAQoJ,gBAAkBvB,IAEnC98C,GACJ,CACA,IAAK,IAAIA,EAAI,EAAGA,EAAIo+C,EAAoBlnD,OAAS,IAAK8I,EAAG,CACrD,MAAM+/C,EAAgB3B,EAAoBp+C,GAAG,GAC7C,GAAI8/C,EAAgB9rC,MAAMrU,GAAOA,IAAOogD,EAAcpgD,KAClD,SAEJ,MAAMqgD,EAAuB1pD,KAAK2pD,8BAA8BF,EAAcpgD,IACxE8lD,EAAkCnvD,KAAKosD,yCAAyC3C,EAAcpgD,IACpG,IAAKqgD,IAAyByF,EAC1B,SAEJ,MAAMkG,EAAqBvN,EAAoBp+C,GAAG,GAC5C4rD,EAAqBxN,EAAoBp+C,GAAG,GAC5C65C,EAAe,cACrB,SAASA,EAAc8R,EAAoBC,GAC3C,WAAW/R,EAAcA,EAAc,IACvC,MAAMqJ,EAA6B,cACnC,cAAcA,EAA4ByI,EAAoB9R,GAC9D,eAAeqJ,EAA4BA,GAC3C,MAAMI,EAA8B,cACpC,WAAWA,EAA6BJ,EAAmD,IAAvBnB,GACpE,MAAM8J,EAA0B,cAC1BC,EAA0B,cAChC,SAASD,EAAyBhS,EAAcyJ,GAChD,cAAcwI,EAAyBjS,EAAcyJ,GACrD,MAAM8G,EAAe,CACjBp4D,MAAO,CACH4B,EAAGi4D,EAAwB,GAC3B/3D,EAAG+3D,EAAwB,IAE/BvjD,IAAK,CACD1U,EAAG+3D,EAAmB,GACtB73D,EAAG63D,EAAmB,KAGxBtB,EAAmB,mBAA4B,CAACD,EAAap4D,MAAM4B,EAAGw2D,EAAap4D,MAAM8B,GAAI,CAACs2D,EAAa9hD,IAAI1U,EAAGw2D,EAAa9hD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACtKkK,EAAe,CACjBt4D,MAAO,CACH4B,EAAGk4D,EAAwB,GAC3Bh4D,EAAGg4D,EAAwB,IAE/BxjD,IAAK,CACD1U,EAAGg4D,EAAmB,GACtB93D,EAAG83D,EAAmB,KAGxBrB,EAAmB,mBAA4B,CAACD,EAAat4D,MAAM4B,EAAG02D,EAAat4D,MAAM8B,GAAI,CAACw2D,EAAahiD,IAAI1U,EAAG02D,EAAahiD,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACxKiK,GAAoBhK,GAAakK,GAAoBlK,KACrDP,EAAgB7gD,KAAK8gD,EAAcpgD,IACnC6D,EAAKyxC,QAAQoJ,gBAAkB,MAEnCr+C,GACJ,CAKA,OAJAwD,EAAK86C,kBAAoB,IAAIwB,GAC7BxpD,KAAK++C,SAAW,CACZnQ,cAEG1hC,EAAKyxC,QAAQoJ,kBAAoBvB,EAC5C,EAEJC,GAAehO,SAAW,aAC1B,MCh7CMgd,GAAsB,mBAC5B,MAAMC,WAAoB,MACtB,WAAAj2D,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXkpD,YAAa,GACbC,aAAc,IACdC,cAAe,OAGnBze,MAAMS,EAAWC,GACjB93C,KAAK81D,iBAAkB,EACvB91D,KAAK84C,qBAAwBb,IACzB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,cAAE2tB,GAAkB/rB,EAC7BzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC,KAAMY,aAAoB,EAAAi8B,eACtB,MAAM,IAAI/5B,MAAM,4CAEpB,MAAMmI,EAAoBvG,KAAK+1D,sBAAsB75D,GACrD,IAAKqK,EACD,MAAM,IAAInI,MAAM,qFAEpB,MAAMygD,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAazE,OAZA1+C,KAAK++C,SAAW,CACZx4C,oBACAs4C,sBACAvjD,iBACAqe,kBACAmhC,iBAEJ96C,KAAKg2D,+BACLh2D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,IAC/B,CAAI,EAEf7+C,KAAKqkD,sBAAyBpM,IAC1Bj4C,KAAK84C,qBAAqBb,EAAI,EAElCj4C,KAAKg2D,6BAA+B,KAChC,MAAM,eAAE16D,EAAc,kBAAEiL,EAAiB,oBAAEs4C,EAAmB,gBAAEllC,EAAe,cAAEmhC,GAAmB96C,KAAK++C,UACnG,SAAE7iD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACd+5D,EAAqB/5D,EAAS+oB,iBAC5BloB,SAAUm5D,GAA6Bh6D,EAASm9B,uBAChD59B,OAAQ06D,EAAW7d,MAAO94B,GAAas7B,EAC/C,IAAIsb,EAEJ,GADAA,EAAqBjpC,EAAQkpC,cAAc,gBAChB,OAAvBD,EAA6B,CAC7B,MAAME,EAAiBlpC,SAASC,cAAc,OAC9CipC,EAAeC,UAAUjzD,IAAI,eAC7BgzD,EAAe5oC,MAAM8oC,QAAU,QAC/BF,EAAe5oC,MAAM9wB,MAAQ,GAAGoD,KAAKyM,cAAcmpD,iBACnDU,EAAe5oC,MAAM7wB,OAAS,GAAGmD,KAAKyM,cAAcopD,kBACpDS,EAAe5oC,MAAME,SAAW,WAChCwoC,EAAqBE,EACGnpC,EAAQkpC,cAAc,qBAC9BvoC,YAAYwoC,GAC5B,MAAMjoC,EAAgB,CAClBnB,WAAYuoC,GACZ3uD,KAAM,EAAAolC,MAAA,aAAmB1d,MACzBrB,QAASipC,GAEbz8C,EAAgBgV,cAAcN,EAClC,CACA+nC,EAAmB1oC,MAAM/Y,IAASwhD,EAAU,GAAKn2D,KAAKyM,cAAcopD,cAAgB,EAArD,KAC/BO,EAAmB1oC,MAAMyzB,KAAUgV,EAAU,GAAKn2D,KAAKyM,cAAcmpD,aAAe,EAApD,KAChC,MAAMa,EAAkB98C,EAAgByU,YAAYqnC,IACpDgB,EAAgBr8B,SAAS,CAAC7zB,IAAoBxB,MAAK,KAC/C,GAAI/E,KAAK81D,gBACL,OAEJW,EAAgBtmC,cAAc8lC,GAC9BQ,EAAgB18B,oBAAoB,CAChCh9B,SAAUm5D,IAEd,MAAM,cAAEzR,GAAkBvoD,EAASwkB,aAC7B,WAAEE,EAAU,SAAEgN,EAAQ,gBAAEnO,GAAoBg3C,EAAgB/1C,YAC5D1E,EAAW/e,KAAKwmC,KAAKxmC,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,GAC7D3wB,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,GACtC3wB,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,IACpC4qB,EAAoB,CACtBh5B,EAAS,GACTA,EAAS,GACTA,EAAS,IAEP+4B,EAAkB,CACpBC,EAAkB,GAAKx8B,EAAWyD,EAAgB,GAClD+4B,EAAkB,GAAKx8B,EAAWyD,EAAgB,GAClD+4B,EAAkB,GAAKx8B,EAAWyD,EAAgB,IAEtDg3C,EAAgBt3B,UAAU,CACtBslB,cAAeA,GAAiB,EAAIzkD,KAAKyM,cAAckpD,aACvD/0C,WAAY43B,EACZ5qB,SAAU2qB,IAEdke,EAAgBx6D,QAAQ,IAE5Bm6D,EAAmB1oC,MAAM8oC,QAAU,SACnC,EAAArX,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKk4C,cAAiBD,IAClB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,YAAE8lB,EAAW,QAAEjrB,EAAO,cAAE2tB,GAAkB/rB,EAC1CspB,EAAmBD,EAAYE,MAC/B6d,EAAYrb,EAAcr/C,OAC1BH,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACtBm7D,EAAkB98C,EAAgByU,YAAYqnC,IAC9Ca,EAAiBnpC,EAAQkpC,cAAc,gBAC7C,IAAKC,EACD,OAEJA,EAAe5oC,MAAM/Y,IAASwhD,EAAU,GAAKn2D,KAAKyM,cAAcopD,cAAgB,EAArD,KAC3BS,EAAe5oC,MAAMyzB,KAAUgV,EAAU,GAAKn2D,KAAKyM,cAAcmpD,aAAe,EAApD,KAC5B,MAAM,WAAEh1C,EAAU,SAAEgN,GAAa6oC,EAAgB/1C,YAC3C63B,EAAkB,CACpB3qB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,GAC/BzqB,EAAS,GAAKyqB,EAAiB,IAE7BG,EAAoB,CACtB53B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,GACjCz3B,EAAW,GAAKy3B,EAAiB,IAErCoe,EAAgBt3B,UAAU,CACtBve,WAAY43B,EACZ5qB,SAAU2qB,IAEdke,EAAgBx6D,QAAQ,EAE5B+D,KAAK22D,iBAAoB1e,IACrB,MAAM,QAAE9qB,GAAY8qB,EAAI3lB,OAClBh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EAC5Bqe,EAAgBiW,eAAe6lC,IAC/B,MAAMmB,EAAkBzpC,EAAQkpC,cAAc,qBACxCD,EAAqBQ,EAAgBP,cAAc,gBACzDO,EAAgBC,YAAYT,GAC5Bp2D,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK81D,iBAAkB,CAAI,EAE/B91D,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9B5/C,KAAK81D,iBAAkB,EACvB3oC,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAK22D,kBAC/CxpC,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAK22D,kBAClDxpC,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAK22D,kBAChDxpC,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAK22D,kBAClDxpC,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAK22D,kBACrDxpC,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAK22D,kBACnDxpC,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,CAE1E,CACA,qBAAA6d,CAAsB75D,GAClB,MAAMioB,EAAWnkB,KAAK82D,YAAY56D,GAClC,IAAIqK,EAIJ,OAHIrK,aAAoB,EAAAi8B,gBACpB5xB,EAAoB4d,EAAS/hB,MAAM,YAAY,IAE5CmE,CACX,EAEJmvD,GAAYjd,SAAW,U,wCCnKvB,MAEQhpB,OAAQsnC,IAAa,EAAA7qB,MACvB8qB,GAAkB7gD,GAAUA,EAAM4K,MAAQ5K,EAAM2K,aACtD,IAAIm2C,IACJ,SAAWA,GACPA,EAAgD,oBAAI,qBACvD,CAFD,CAEGA,KAA+BA,GAA6B,CAAC,IAChE,MACMC,GAAqB,EAAI,EAAA/Q,UAAA,QAC/B,MAAMgR,WAA4B,aACrBn3D,KAAKo3D,QAAUH,EAA4B,CACpD,WAAAx3D,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACR2Q,gBAAiB,CACbv0B,OAAQ,IACRw0B,WAAY,EACZC,eAAgB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,GAC9C1Q,QAAS,CACLC,SAAS,EACT0Q,QAAS,KAGjBC,QAAS,CACLC,oBAAqB,CACjBC,OAAQ,sBACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAcC,UAC3BC,YAAa,EAAAC,iBAAiBC,aAOlD9gB,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EAChCkkB,EAAWs7B,EAAcxC,MACzB6d,EAAYrb,EAAcr/C,QACxB47D,gBAAiBc,GAAWn4D,KAAKyM,eACnC,OAAEq2B,EAAM,WAAEw0B,EAAU,QAAEzQ,GAAYsR,EAClCC,EAAqBp4D,KAAKq4D,uBAAuBlC,EAAWrzB,GAC5DriB,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFmd,EAAgB,qBAChB+Y,EAAoB,qBACpBtuD,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf2Q,gBACAd,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,qBAEJ2G,KAAM,CACFqrD,iBAAkBr8D,EAASmN,GAC3BivD,oBACAhB,aACAkB,oBAAoB,EACpB7Z,QAAS,CACLlwC,OAAQ2pD,EACRK,kBAAmB,QAI/Bz4D,KAAK04D,uBAAuBC,eAAe/pB,EAAY,CACnD0pB,oBACAM,qBAAsBt9D,EACtBsyB,SAAUuoC,EACVrzB,SACAw0B,aACAzQ,QAAS,CACLC,QAASD,EAAQC,QACjB0Q,QAAS3Q,EAAQ2Q,QACjBt2D,SAAWgM,IACP,MAAM2rD,EAAmBjqB,EAAW1hC,KAAKyxC,QAAQlwC,QACzChT,OAAQq9D,GAAgB5rD,EAAKqI,MACrC,IAAK,IAAI7L,EAAI,EAAG4nC,EAAMunB,EAAiBj4D,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACzD,MAAM4E,EAAQuqD,EAAiBnvD,GAC/B4E,EAAM,IAAMwqD,EAAY,GACxBxqD,EAAM,IAAMwqD,EAAY,GACxBlqB,EAAWrzC,aAAc,CAC7B,OAIZ,IAAA0sD,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAGzE,OAFAzG,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKm6C,kBAAoB,KACrBn6C,KAAK04D,uBAAuBK,WACR,IAAAC,qBACR/3D,SAAS2tC,IACbA,EAAW1nC,SAASuxC,WAAaz4C,KAAK0+C,gBACtC,IAAAgJ,kBAAiB9Y,EAAW2Q,cAChC,GACF,EAENv/C,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAM,KAAE78C,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EACpBwqD,EAAYvY,EAAkB,GAC9BwY,EAAexY,EAAkB,GACjCyY,EAAazY,EAAkB,GAC/B5d,EAAoD,GAA3C7lC,KAAK6e,IAAIo9C,EAAa,GAAKD,EAAU,IAC9CriD,EAAS,CACXuiD,EAAW,GAAKr2B,EAChBm2B,EAAU,GAAKn2B,GAEbs2B,GAAc,KAAAC,uBAAsB,CAACziD,EAAQkzC,IACnD,OAAI7sD,KAAK6e,IAAIs9C,EAAct2B,GAAsB,EAAZinB,CAGzB,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,wBAEJ,KAAAI,mBAAkB9xB,GAClBntB,KAAKmiD,gBAAgBh1B,IACrB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,MAAM,OAAEhwC,GAAWvB,EAAKyxC,QAClB4a,EAAc9qD,EAAO+D,WAAW9D,GAAMA,IAAM4qD,IAC5Cza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,eAEJv5D,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACjB1hC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,GACjB,EAAAa,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKy5D,kBAAqBxhB,IACtBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,YAAE8lB,GAAgBrpB,EAClB+pC,EAAc1gB,GAAa38C,QAAU,CAAC,EAAG,EAAG,IAC5C,WAAEmzC,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,UAC3C,OAAEtwC,GAAWmgC,EAAW1hC,KAAKyxC,QACnClwC,EAAOxN,SAASqN,IACZA,EAAM,IAAMwqD,EAAY,GACxBxqD,EAAM,IAAMwqD,EAAY,EAAE,IAE9BlqB,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAK25D,oBAAuB1hB,IACxBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,GAAgBv5D,KAAK++C,UACxD,KAAE7xC,GAAS0hC,EACjB,QAAoB5wC,IAAhBu7D,EAA2B,CAC3B,MAAM,YAAEnhB,GAAgBrpB,EAClB+pC,EAAc1gB,EAAY38C,OACjByR,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAMwqD,EAAY,GACxBxqD,EAAM,IAAMwqD,EAAY,EAAE,IAE9BlqB,EAAWrzC,aAAc,CAC7B,MAEIyE,KAAK45D,YAAY3hB,GACjBrJ,EAAWrzC,aAAc,GAE7B,EAAA4jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAK45D,YAAe3hB,IAChB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,WAAEsc,GAAe5uC,KAAK++C,UACtB,KAAE7xC,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EACpBwqD,EAAYvY,EAAkB,GAC9BwY,EAAexY,EAAkB,GACjCyY,EAAazY,EAAkB,GAC/B5d,EAAoD,GAA3C7lC,KAAK6e,IAAIo9C,EAAa,GAAKD,EAAU,IAC9CY,EAAe,CACjBV,EAAW,GAAKr2B,EAChBm2B,EAAU,GAAKn2B,IAEb,cAAEgY,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCs+D,GAAY,KAAAV,uBAAsB,CACpCQ,EACAC,IAEEE,EAAwBh6D,KAAKq4D,uBAAuBwB,EAAcE,GACxEtrD,EAAO,GAAKurD,EAAsB,GAClCvrD,EAAO,GAAKurD,EAAsB,GAClCvrD,EAAO,GAAKurD,EAAsB,GAClCvrD,EAAO,GAAKurD,EAAsB,EAAE,EAExCh6D,KAAKiL,OAAUkiB,IACX,IAAKntB,KAAKs+C,UACN,OAEJt+C,KAAKs+C,WAAY,EACjBt+C,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aAAa,EAEnCv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAEXC,EAAcA,GAAazrC,QAAQ85B,GAAeA,EAAW1hC,KAAKqrD,mBAC9Dr8D,EAASmN,KACb,MAAMkgD,EAAsBvpD,KAAKwgD,wCAAwCrzB,EAASozB,GAClF,IAAKgJ,GAAqB3oD,OACtB,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6/C,EAAoB3oD,OAAQ8I,IAAK,CACjD,MAAMklC,EAAa2a,EAAoB7/C,IACjC,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,kBAAE0pB,EAAiB,WAAEhB,EAAU,QAAE3Y,GAAYzxC,GAC7C,OAAEuB,EAAM,kBAAEgqD,GAAsB9Z,EACtC8B,EAAelB,cAAgBA,EACbv/C,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GAC5C5uC,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GAD3D,MAEMxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8R,EAAoBjyC,EACpBwqD,EAAYvY,EAAkB,GAC9BwY,EAAexY,EAAkB,GACjCyY,EAAazY,EAAkB,GAC/B5d,EAAoD,GAA3C7lC,KAAK6e,IAAIo9C,EAAa,GAAKD,EAAU,IAC9CriD,EAAS,CACXuiD,EAAW,GAAKr2B,EAChBm2B,EAAU,GAAKn2B,GAEnB,IAAK5mC,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,KAAAC,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM0kD,EAAS,GAAGvB,oBACZiR,EAAY,KAClB,IAAAC,YAAcpQ,EAAkBd,EAAeiR,EAAW55C,EAAQksB,EAAQ,CACtE1mC,QACAukD,UAAW,GACZG,GACH,MAAM2V,EAAkBz2D,KAAK04D,uBAAuBtqC,YAAYkqC,GAChE7B,EAAgB7oC,SAAWhX,EAC3B6/C,EAAgB3zB,OAASA,EACzB2zB,EAAgBa,WAAaA,EAC7Bb,EAAgB4D,SAChB/Z,GAAe,CACnB,CACA,OAAOA,CAAY,EAEvBtgD,KAAKq4D,uBAAyB,CAACiC,EAAiBC,IACrC,CACH,CAACD,EAAgB,GAAIA,EAAgB,GAAKC,EAAc,GACxD,CAACD,EAAgB,GAAKC,EAAcD,EAAgB,GAAI,GACxD,CAACA,EAAgB,GAAIA,EAAgB,GAAKC,EAAc,GACxD,CAACD,EAAgB,GAAKC,EAAcD,EAAgB,GAAI,IAGhEt6D,KAAK04D,uBAAyB8B,GAA+BC,aACjE,CACA,mBAAA/C,CAAoBzf,EAAKrJ,GACrB,MAAM,QAAEzhB,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OACjCh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACbG,OAAQuvC,GAAgB8P,EAC1B8b,EAAkBzpC,EAAQkpC,cAAc,4BACxCqE,EAAoB9rB,EAAW1hC,KAAKoqD,WAEpCqD,EAAW36D,KAAK46D,4BAA4BF,GAAoBG,SAC5C78D,IAAlB68D,IACAjsB,EAAW1hC,KAAKoqD,WAAatrD,OAAOyK,WAAWokD,GAC/CjsB,EAAWrzC,aAAc,GAJZo/D,EAASG,cAAcjE,YAAY8D,GAOpDz+D,EAASD,QAAQ,IAErB2D,OAAOm7D,OAAOJ,EAASjtC,MAAO,CAC1ByzB,KAAM,GAAGnW,EAAY,OACrBr2B,IAAK,GAAGq2B,EAAY,SAExB4rB,EAAgB9oC,YAAY6sC,GAC5BA,EAASK,OACb,CACA,2BAAAJ,CAA4BF,EAAmBO,GAC3C,MAAM,eAAE1D,GAAmBv3D,KAAKyM,cAAc4qD,gBACxCsD,EAAWvtC,SAASC,cAAc,UA6BxC,OA5BAstC,EAASnyC,KAAO,EAChB5oB,OAAOm7D,OAAOJ,EAASjtC,MAAO,CAC1B9wB,MAAO,OACPgxB,SAAU,aAEd,CAAC,YAAa,UAAW,YAAa,SAAS3sB,SAASi6D,IACpDP,EAASlyC,iBAAiByyC,GAAYjjB,GAAQA,EAAIkjB,mBAAkB,IAExER,EAASlyC,iBAAiB,UAAWwvB,IACjCA,EAAIkjB,kBACJF,EAAiBN,EAAS16D,MAAM,IAEpC06D,EAASlyC,iBAAiB,WAAYwvB,MACZA,EAAImjB,SAAyB,KAAdnjB,EAAIojB,QACV,WAA3BpjB,EAAI93C,KAAKm7D,iBAETrjB,EAAIkjB,kBACJF,IACJ,IAEJ1D,EAAet2D,SAASq2D,IACpB,MAAMiE,EAASnuC,SAASC,cAAc,UACtCkuC,EAAO5pC,MAAQ2lC,EACfiE,EAAOC,MAAQ,eAAelE,EAAW58B,QAAQ,KACjD6gC,EAAOt7D,MAAQq3D,EACfiE,EAAOE,gBAAkBnE,IAAeoD,EACxCC,EAASr3D,IAAIi4D,EAAO,IAEjBZ,CACX,EAEJ,MAAMH,GACF,WAAA/6D,GACIO,KAAK24D,eAAiB,CAAC/pB,EAAYuZ,KAC/B,MAAM,kBAAEmQ,EAAiB,qBAAEM,EAAoB,SAAEhrC,EAAQ,OAAEkV,EAAM,WAAEw0B,EAAU,QAAEzQ,GAAasB,GACpFjsD,SAAUw/D,GAAmB9C,GAC7BzrC,QAASwuC,GAAkBD,EAC7BjF,EAAkB,IAAImF,GAAwB,CAChDtD,oBACAM,uBACA91B,SACAlV,WACA0pC,aACAzQ,YAQJ,OANA7mD,KAAK67D,+BAA+BF,GACpC37D,KAAK87D,qBAAqB57D,IAAIu2D,EAAgBvpC,WAAY,CACtD0hB,aACA6nB,kBACAsF,oBAAqB5T,IAElBsO,CAAe,EAE1Bz2D,KAAKg8D,2BAA8B/jB,IAC/B,MAAM,WAAErJ,GAAeqJ,EAAI3lB,OA9aJ,oBA+anBsc,EAAW1nC,SAASuxC,UAGxBz4C,KAAKi8D,gBAAgBrtB,EAAW1hC,KAAKorD,kBAAkB,EAE3Dt4D,KAAKk8D,uBAA0BjkB,IAC3B,MAAQ/qB,WAAYqrC,EAAgB,QAAEp0D,GAAY8zC,EAAI3lB,OAChD6pC,EAA6Bn8D,KAAKo8D,iDAAiD7D,IACnF,SAAEr8D,IAAa,IAAAmgE,+BAA8B9D,GAC/Cr8D,EAASogE,yBACTt8D,KAAKu8D,OAAOhE,GAEhB4D,EAA2Bl7D,SAAQ,EAAG2tC,iBAClCA,EAAW1nC,SAASX,kBAAoBpC,EACxCyqC,EAAWrzC,aAAc,CAAI,GAC/B,EAENyE,KAAKw8D,wBAA2BvkB,IAC5B,MAAM,kBAAE/rB,EAAmBgB,WAAYqrC,GAAqBtgB,EAAI3lB,OAE1DopC,GADkB,IAAAvvC,oBAAmBD,GACJkC,YAAYmqC,IAC3C94C,gBAAiBg9C,GAA2Bf,EAAeh7C,YAChC1gB,KAAKo8D,iDAAiD7D,GAC9Dt3D,SAAQ,EAAG2tC,iBAClC,MAAM,gBAAEnvB,GAAoBmvB,EAAW1nC,SAGvC,KAFmBjK,KAAK6e,IAAI,SAAS2D,EAAiBg9C,IAClDvF,IAEA,OAEJ,MAAM,QAAEvY,GAAY/P,EAAW1hC,KACzBwvD,EAAuBhB,EAAetsC,cAAc,CAAC,EAAG,IACxDutC,EAAwB,SAAS,cAAeD,EAAsB/d,EAAQlwC,OAAO,IACrFmuD,EAAY,SAASD,EAAuBF,GAC5CI,EAAa,WAAW,cAAeJ,EAAwBG,GACrE,IAAK,IAAIlzD,EAAI,EAAG4nC,EAAMqN,EAAQlwC,OAAO7N,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACvD,MAAM4E,EAAQqwC,EAAQlwC,OAAO/E,GAC7B4E,EAAM,IAAMuuD,EAAW,GACvBvuD,EAAM,IAAMuuD,EAAW,GACvBvuD,EAAM,IAAMuuD,EAAW,EAC3B,CACAjuB,EAAWrzC,aAAc,CAAI,GAC/B,EAENyE,KAAK87D,qBAAuB,IAAItqD,IAChCxR,KAAK88D,aACT,CACA,kBAAOrC,GAIH,OAHAD,GAA+BuC,WAC3BvC,GAA+BuC,YAC3B,IAAIvC,GACLA,GAA+BuC,UAC1C,CACA,WAAA3uC,CAAYkqC,GACR,OAAOt4D,KAAK87D,qBAAqB17D,IAAIk4D,IAAoB7B,eAC7D,CACA,OAAAsC,GACI/4D,KAAKg9D,wBACLh9D,KAAKi9D,mBACT,CACA,eAAAhB,CAAgB3D,GACZ,MAAM4E,EAA0Bl9D,KAAK87D,qBAAqB17D,IAAIk4D,GAC9D,GAAI4E,EAAyB,CACzB,MAAM,gBAAEzG,GAAoByG,GACpBhhE,SAAUw/D,GAAmBjF,EAAgBmC,sBAC7CzrC,QAASwuC,GAAkBD,EACnC17D,KAAKm9D,kCAAkCxB,GACvClF,EAAgBsC,UAChB/4D,KAAK87D,qBAAqBt4D,OAAO80D,EACrC,CACJ,CACA,iBAAA2E,GAC+Bv+D,MAAM6D,KAAKvC,KAAK87D,qBAAqBt6D,QAC7CP,SAASq3D,GAAsBt4D,KAAKi8D,gBAAgB3D,IAC3E,CACA,gDAAA8D,CAAiD7D,GAE7C,OADmC75D,MAAM6D,KAAKvC,KAAK87D,qBAAqBnhD,UACtC7F,QAAO,EAAG2hD,sBACxC,MAAM,SAAEv6D,GAAau6D,EAAgBmC,qBACrC,OAAO18D,EAASmN,KAAOkvD,CAAgB,GAE/C,CACA,MAAAgE,CAAOhE,GACsBv4D,KAAKo8D,iDAAiD7D,GAC9Dt3D,SAAQ,EAAGw1D,kBAAiB7nB,aAAYmtB,0BACrD/7D,KAAKi8D,gBAAgBxF,EAAgBvpC,YACrC,MAAMkwC,GAAoB,IAAAf,+BAA8B9D,GACxDv4D,KAAK24D,eAAe/pB,EAAY,IACzBmtB,EACHnD,qBAAsB,IACfwE,IAET,GAEV,CACA,kBAAAC,GACI,EAAAlrC,YAAY1J,iBAAiB,SAAU60C,mBAAoBt9D,KAAKg8D,2BACpE,CACA,qBAAAgB,GACI,EAAA7qC,YAAYrJ,oBAAoB,SAAUw0C,mBAAoBt9D,KAAKg8D,2BACvE,CACA,8BAAAH,CAA+B1uC,GAC3BA,EAAQ1E,iBAAiBsuC,GAAS5qB,gBAAiBnsC,KAAKk8D,wBACxD,MAAMqB,EAAmBtlB,IACrB,MAAQ/qB,WAAYqrC,GAAqBtgB,EAAI3lB,OAC7CtyB,KAAKu8D,OAAOhE,EAAiB,EAEjCprC,EAAQ1E,iBAAiBsuC,GAASyG,uBAAwBD,GAC1D,MAAME,EAAoBxlB,IACtB,MAAQ/qB,WAAYqrC,GAAqBtgB,EAAI3lB,OAC7CtyB,KAAKu8D,OAAOhE,EAAiB,EAEjCprC,EAAQ1E,iBAAiBsuC,GAASj9B,2BAA4B2jC,GAC9DtwC,EAAQ1E,iBAAiBsuC,GAAS3qB,iBAAkBpsC,KAAKw8D,yBACzDrvC,EAAQowC,gBAAkBA,EAC1BpwC,EAAQswC,iBAAmBA,CAC/B,CACA,iCAAAN,CAAkChwC,GAC9BA,EAAQrE,oBAAoBiuC,GAAS5qB,gBAAiBnsC,KAAKk8D,wBAC3D/uC,EAAQrE,oBAAoBiuC,GAAS3qB,iBAAkBpsC,KAAKw8D,yBAC5DrvC,EAAQrE,oBAAoBiuC,GAASyG,uBAAwBrwC,EAAQowC,iBACrEpwC,EAAQrE,oBAAoBiuC,GAASj9B,2BAA4B3M,EAAQswC,yBAClEtwC,EAAQowC,uBACRpwC,EAAQswC,gBACnB,CACA,WAAAX,GACI98D,KAAKq9D,oBACT,EAEJ,MAAMzB,GACF,WAAAn8D,EAAY,kBAAE64D,EAAiB,qBAAEM,EAAoB,OAAE91B,EAxjBnB,IAwjB2D,SAAElV,EAAW,CAAC,EAAG,GAAE,WAAE0pC,EAAU,QAAEzQ,IAC5H7mD,KAAK09D,gBAAkB,KACvB19D,KAAK29D,iBAAmB,KACxB39D,KAAK49D,kBAAoB,KACzB59D,KAAK69D,kBAAmB,EACxB79D,KAAK89D,QAAU,EACf99D,KAAK+9D,UAAW,EAChB/9D,KAAKg+D,aAAc,EACnBh+D,KAAKi+D,YAAc3F,GAAqB,qBACxCt4D,KAAKk+D,sBAAwBtF,EAC7B54D,KAAKm+D,SAAWtX,EAChB7mD,KAAK8iC,OAASA,EACd9iC,KAAK4tB,SAAWA,EAChB5tB,KAAKs3D,WAAaA,EAClBt3D,KAAKo+D,SAAU,EACfp+D,KAAKq+D,0BAA4Br+D,KAAKq+D,0BAA0B7tD,KAAKxQ,MACrEA,KAAKs+D,wBAA0Bt+D,KAAKs+D,wBAAwB9tD,KAAKxQ,MACjEA,KAAKu+D,uBAAyBv+D,KAAKu+D,uBAAuB/tD,KAAKxQ,MAC/DA,KAAKw+D,mBAAqBx+D,KAAKw+D,mBAAmBhuD,KAAKxQ,MACvDA,KAAKy+D,sBAAwB,EAAAC,EAAA,GAAS1+D,KAAK2+D,gBAAgBnuD,KAAKxQ,MAAO,GACvEA,KAAK88D,aACT,CACA,wBAAIlE,GACA,OAAO54D,KAAKk+D,qBAChB,CACA,cAAIhxC,GACA,OAAOltB,KAAKi+D,WAChB,CACA,UAAIn7B,GACA,OAAO9iC,KAAK89D,OAChB,CACA,UAAIh7B,CAAOA,GACH7lC,KAAK6e,IAAI9b,KAAK89D,QAAUh7B,GAAU,OAClC9iC,KAAK89D,QAAUh7B,EACf9iC,KAAK+9D,UAAW,EAExB,CACA,MAAA1D,GACI,MAAM,OAAEv3B,EAAM,SAAElV,EAAQ,QAAEwwC,GAAYp+D,MAChC,SAAE9D,GAAa8D,KAAK09D,iBACpB,QAAEvwC,GAAYjxB,EACdssB,EAAO,EAAIsa,GACVxlC,EAAGE,GAAKowB,EACX5tB,KAAK+9D,WACL/9D,KAAKy+D,uBACLz+D,KAAK+9D,UAAW,GAEpBn+D,OAAOm7D,OAAO5tC,EAAQO,MAAO,CACzB8oC,QAAS4H,EAAU,QAAU,SAC7BxhE,MAAO,GAAG4rB,MACV3rB,OAAQ,GAAG2rB,MACX24B,MAAUre,EAAJ,KACNnuB,KAASmuB,EAAJ,KACLrmC,UAAW,aAAaa,QAAQE,SAEhCwC,KAAK69D,mBACL79D,KAAK4+D,iBACL1iE,EAASD,SAEjB,CACA,OAAA88D,GACI,MAAM,SAAE78D,GAAa8D,KAAK09D,iBACpB,QAAEvwC,GAAYjxB,EACdyd,EAAkBzd,EAASiwB,qBACjCnsB,KAAKg9D,sBAAsB7vC,GAC3BxT,EAAgBiW,eAAe1zB,EAASmN,IACpC8jB,EAAQ0xC,YACR1xC,EAAQ0xC,WAAWhI,YAAY1pC,EAEvC,CACA,sBAAAoxC,CAAuBtmB,GACnB,MAAQ2lB,kBAAmBkB,GAAqB9+D,MAC1C,YAAEw5C,EAAW,SAAEf,EAAQ,KAAEsmB,EAAI,oBAAEC,GAAwB/mB,EAAI3lB,OACjE,GAAItyB,KAAK29D,kBAAkBt0D,KAAOmwC,EAGlC,OAAQulB,GACJ,KAAK,EAAA/yB,UAAUH,OACXizB,EAAiBG,cAAcxmB,EAAUumB,GACzC,MACJ,KAAK,EAAAhzB,UAAUF,QACXgzB,EAAiBI,eAAezmB,GAChC,MACJ,KAAK,EAAAzM,UAAUD,QACX+yB,EAAiBK,eAAe1mB,GAChC,MACJ,KAAK,EAAAzM,UAAUozB,SACXN,EAAiBO,gBAAgB5mB,GACjC,MACJ,QACI,MAAM,IAAIr6C,MAAM,qBAAqB2gE,MAEjD,CACA,oBAAAO,CAAqBhJ,GACjB,MAAMp6D,EAAWo6D,EAAeD,cAAc,qBACxC56D,EAAS66D,EAAeD,cAAc,uBAC5Cn6D,EAASwxB,MAAM6xC,aAAe,UAC9B9jE,EAAOiyB,MAAM6xC,aAAe,SAChC,CACA,mBAAAC,GACI,MAAMlJ,EAAiBlpC,SAASC,cAAc,QACxC,OAAEyV,GAAW9iC,KACbwoB,EAAgB,EAATsa,EAcb,OAbAwzB,EAAeC,UAAUjzD,IAhqBP,uBAiqBlB1D,OAAOm7D,OAAOzE,EAAe5oC,MAAO,CAChC8oC,QAAS,QACT55D,MAAO,GAAG4rB,MACV3rB,OAAQ,GAAG2rB,MACXoF,SAAU,WACV6xC,SAAU,SACVF,aAAc,MACdG,UAAW,aACXve,MAAUre,EAAJ,KACNnuB,KAASmuB,EAAJ,KACLrmC,UAAW,gCAER65D,CACX,CACA,iCAAAqJ,CAAkCzjE,EAAUu6D,EAAiBa,GACzD,MAAM,cAAE7S,GAAkBvoD,EAASwkB,YAEnC,OAAO+jC,GAAiB,EAAI6S,IADRb,EAAgBh7D,OAAOmkE,YAAc1jE,EAAST,OAAOmkE,YAE7E,CACA,gBAAAC,CAAiB3jE,GACb,MAAO,aAAcA,CACzB,CACA,iBAAA4jE,CAAkB5jE,GACd,MAAO,eAAgBA,CAC3B,CACA,gBAAA6jE,CAAiBrE,EAAgBjF,GAC7B,MAAMuJ,EAAetE,EAAe76C,YAC9Bo/C,EAAqB,GAAGxJ,EAAgBptD,eACxC62D,GAAkB,IAAAla,yBAAwB0V,EAAeryD,GAAIqyD,EAAexvC,mBAC5E4yC,EAAmBoB,EAAgBv4C,MAAMs4C,GAAqBxnB,IAChE,MAAM0nB,EAAeD,EAAgBvM,gBAAgBlb,GAGrD,OAFyB0nB,aAAwB,SAC3CA,aAAwBhJ,GACP,IAW3B,OATA2H,EAAiBsB,YAAY3J,EAAgBptD,GAAIotD,EAAgBvqC,mBACjE8zC,EAAalrD,OAAOkiD,IAAgB/1D,SAASkV,KACzC,KAAAkqD,gCAA+BrgE,KAAKktB,WAAY,CAC5C,CACIozC,eAAgBnqD,EAAM2K,aACtBha,KAAM,EAAAy5D,4BAA4BC,WAExC,IAEC,CAAEN,kBAAiBpB,mBAC9B,CACA,WAAA2B,CAAY/E,EAAgBjF,GACxB,MAAMrwD,EAAWs1D,EAAe/nC,cAChC8iC,EAAgBr8B,SAASh0B,GAAUrB,MAAK,KACpC/E,KAAK69D,kBAAmB,EACxB79D,KAAKq6D,QAAQ,GAErB,CACA,aAAAqG,CAAchF,EAAgBjF,GAC1B,MACMkK,EADSjF,EAAe76C,YAEzB/L,QAAQqB,IAAW6gD,GAAe7gD,KAClC9P,KAAK8P,IAAU,CAAGrL,SAAUqL,EAAM4K,QAKvC,OAJA01C,EAAgBzmC,WAAW2wC,GAAkB57D,MAAK,KAC9C/E,KAAK69D,kBAAmB,EACxB79D,KAAKq6D,QAAQ,IAEV5D,CACX,CACA,cAAAmK,CAAelF,EAAgBpF,GAC3B,MAAQppC,WAAYorC,GAAsBt4D,KACpC2Z,EAAkB+hD,EAAevvC,sBAC/B/nB,QAASy8D,GAA0BnF,EACrCrtC,EAAgB,CAClBlB,QAASmpC,EACTppC,WAAYorC,EACZxxD,KAAM40D,EAAe50D,KACrB2nB,eAAgB,IAAKoyC,IAEzBlnD,EAAgBgV,cAAcN,GAC9B,MAAMooC,EAAmB98C,EAAgByU,YAAYkqC,GACjDt4D,KAAK6/D,iBAAiBnE,GACtB17D,KAAKygE,YAAY/E,EAAgBjF,GAE5Bz2D,KAAK8/D,kBAAkBpE,IAC5B17D,KAAK0gE,cAAchF,EAAgBjF,GAEvCz2D,KAAKs/D,qBAAqBhJ,GAC1B,MAAMwK,EAAa9gE,KAAK+/D,iBAAiBrE,EAAgBjF,GACzDz2D,KAAK29D,iBAAmBmD,EAAWZ,gBACnClgE,KAAK49D,kBAAoBkD,EAAWhC,gBACxC,CACA,yBAAAiC,CAA0B9oB,GACtBA,EAAIkjB,kBACJljB,EAAIiH,gBACR,CACA,uBAAAof,CAAwBrmB,GACpB,MAAM,QAAE9qB,GAAYntB,KAAK09D,gBAAgBxhE,SACzCkxB,SAAStE,oBAAoB,UAAW9oB,KAAKs+D,yBAC7CnxC,EAAQ1E,iBAAiB,UAAWzoB,KAAK+gE,2BACzC5zC,EAAQ1E,iBAAiB,YAAazoB,KAAK+gE,0BAC/C,CACA,yBAAA1C,CAA0BpmB,GACtB,MAAM,QAAE9qB,GAAYntB,KAAK09D,gBAAgBxhE,SACzC8D,KAAKg+D,cAAgB/lB,EAAI9vB,QAAQ64C,QAAQ,wBACzC5zC,SAAS3E,iBAAiB,UAAWzoB,KAAKs+D,yBAC1CnxC,EAAQrE,oBAAoB,UAAW9oB,KAAK+gE,2BAC5C5zC,EAAQrE,oBAAoB,YAAa9oB,KAAK+gE,0BAClD,CACA,kBAAAvC,CAAmBvmB,GACf,IAAK,KAAM2H,sBACP,OAEJ,MAAQue,SAAUtX,GAAY7mD,KAC9B,IAAK6mD,EAAQC,UAAY9mD,KAAKg+D,YAC1B,OAEJ,MAAM,cAAEljB,GAAkB7C,EAAI3lB,QACxB,SAAEp2B,GAAa8D,KAAK09D,iBACpB,cAAEtuC,GAAkBlzB,GAClBT,OAAQwlE,GAAkBnmB,GAC1BhY,OAAQo+B,GAAkBlhE,KAC5B65D,EAAe,CAACqH,EAAeA,GAC/BC,GAAO,KAAAtuB,iBAAgBgnB,EAAcoH,GACrCxvB,EAAUyvB,EAAgBra,EAAQ2Q,QACxC,GAAI2J,GAAQ1vB,EACR,OAEJ,MAAM2vB,EAAUD,EAAO1vB,EACjB4vB,EAAiB,SAAS,cAAeJ,EAAepH,GAC9D,eAAewH,EAAgBA,GAC/B,WAAWA,EAAgBA,EAAgBD,GAC3C,MAAME,EAAoB,SAAS,cAAethE,KAAK4tB,SAAUyzC,GAC3DE,EAAkBnyC,EAAcpvB,KAAK4tB,UACrC4zC,EAAcpyC,EAAckyC,GAC5BG,EAAgB,SAAS,cAAeD,EAAaD,GACrDG,EAAsB,CACxBjzD,OAAQ,CACJkzD,gBAAiB,CACblmE,OAAQuE,KAAK4tB,SACb0qB,MAAOipB,GAEX1uC,YAAa,CACTp3B,OAAQ6lE,EACRhpB,MAAOkpB,IAGfjsD,MAAO,CACH9Z,OAAQ4lE,EACR/oB,MAAOmpB,IAGf5a,EAAQ3lD,SAASwgE,EACrB,CACA,yBAAAE,CAA0Bz0C,GACtBC,SAAS3E,iBAAiB,YAAazoB,KAAKq+D,2BAA2B,GACvElxC,EAAQ1E,iBAAiB,YAAazoB,KAAK+gE,2BAC3C5zC,EAAQ1E,iBAAiB,UAAWzoB,KAAK+gE,2BACzC5zC,EAAQ1E,iBAAiB,YAAazoB,KAAK+gE,2BAC3C5zC,EAAQ1E,iBAAiB,WAAYzoB,KAAK+gE,0BAC9C,CACA,4BAAAc,CAA6B10C,GACzBC,SAAStE,oBAAoB,YAAa9oB,KAAKq+D,2BAA2B,GAC1EjxC,SAAStE,oBAAoB,UAAW9oB,KAAKs+D,yBAC7CnxC,EAAQrE,oBAAoB,YAAa9oB,KAAK+gE,2BAC9C5zC,EAAQrE,oBAAoB,UAAW9oB,KAAK+gE,2BAC5C5zC,EAAQrE,oBAAoB,YAAa9oB,KAAK+gE,2BAC9C5zC,EAAQrE,oBAAoB,WAAY9oB,KAAK+gE,0BACjD,CACA,kBAAA1D,CAAmBlwC,GACf,EAAAgF,YAAY1J,iBAAiB,SAAUq5C,kBAAmB9hE,KAAKu+D,wBAC/DpxC,EAAQ1E,iBAAiB,SAAUs3B,WAAY//C,KAAKw+D,oBACpDrxC,EAAQ1E,iBAAiB,SAAUq3B,WAAY9/C,KAAKw+D,oBACpDx+D,KAAK4hE,0BAA0Bz0C,EACnC,CACA,qBAAA6vC,CAAsB7vC,GAClB,EAAAgF,YAAYrJ,oBAAoB,SAAUg5C,kBAAmB9hE,KAAKu+D,wBAClEpxC,EAAQ1E,iBAAiB,SAAUs3B,WAAY//C,KAAKw+D,oBACpDrxC,EAAQ1E,iBAAiB,SAAUq3B,WAAY9/C,KAAKw+D,oBACpDx+D,KAAK6hE,6BAA6B10C,EACtC,CACA,WAAA2vC,GACI,MAAQoB,sBAAuBtF,GAAyB54D,MAChD9D,SAAUw/D,GAAmB9C,GAC7Bn9D,OAAQsmE,GAAiBrG,EAC3BpF,EAAiBt2D,KAAKw/D,sBAC5BuC,EAAalD,WAAW/wC,YAAYwoC,GACpCt2D,KAAKq9D,mBAAmB/G,GACxBt2D,KAAK4gE,eAAelF,EAAgBpF,GACpCt2D,KAAK09D,iBAAkB,IAAAxlC,mBAAkBo+B,EAC7C,CACA,qBAAA0L,CAAsBtG,EAAgBjF,GAClC,MAAMj3C,EAAWk8C,EAAetsC,cAAcpvB,KAAK4tB,UAC7C62B,EAAgBzkD,KAAK2/D,kCAAkCjE,EAAgBjF,EAAiBz2D,KAAKs3D,aAC7F,WAAE12C,EAAU,SAAEgN,EAAQ,gBAAEnO,GAAoBg3C,EAAgB/1C,YAC5D1E,EAAW/e,KAAKwmC,KAAKxmC,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,GAC7D3wB,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,GACtC3wB,KAAKy5D,IAAI91C,EAAW,GAAKgN,EAAS,GAAI,IACpC4qB,EAAoB,CACtBh5B,EAAS,GACTA,EAAS,GACTA,EAAS,IAEP+4B,EAAkB,CACpBC,EAAkB,GAAKx8B,EAAWyD,EAAgB,GAClD+4B,EAAkB,GAAKx8B,EAAWyD,EAAgB,GAClD+4B,EAAkB,GAAKx8B,EAAWyD,EAAgB,IAEtDg3C,EAAgBt3B,UAAU,CACtBslB,gBACA7jC,WAAY43B,EACZ5qB,SAAU2qB,GAElB,CACA,mBAAA0pB,CAAoBvG,EAAgBjF,GAChCA,EAAgByL,gBAAgBxG,EAAe7nC,yBACnD,CACA,cAAA+qC,GACI,MAAQ1iE,SAAUw/D,GAAmB17D,KAAKk+D,uBAClChiE,SAAUu6D,GAAoBz2D,KAAK09D,gBACrCyE,EAAmBzG,EAAez2C,gBACtBwxC,EAAgB/gC,iBAIlC+gC,EAAgBtmC,cAAcgyC,GAC9BniE,KAAKgiE,sBAAsBtG,EAAgBjF,GACvCz2D,KAAK6/D,iBAAiBnE,IACtB17D,KAAKiiE,oBAAoBvG,EAAgBjF,GAE7Cz2D,KAAKgiE,sBAAsBtG,EAAgBjF,GAC3CA,EAAgBx6D,SACpB,CACA,eAAA0iE,GACI,MAAM,SAAEziE,GAAa8D,KAAK09D,gBACFxhE,EAASiwB,qBACjBi2C,QACpB,EAEJjL,GAAoB1e,SAAW,kB,eCr5B/B,MAAQ74B,QAAO,IAAK,EAAAumC,UACpB,MAAMkc,WAAuBC,GAAA17B,EACzB,WAAAnnC,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX8rD,iBAAkB,GAClBgK,6BAA6B,EAC7BC,mBAAmB,KAGvBprB,MAAMS,EAAWC,GACjB93C,KAAK++C,SAAW,KAChB/+C,KAAKyiE,MAAQ,KACT,MACM9oD,GADmB,IAAA+oD,uBACgB,GACzC,IAAK/oD,EACD,OAEJ,IAAIC,EAAYD,EAAgB4Z,eAChC3Z,GAAY,IAAA+oD,gCAA+B/oD,EAAW5Z,KAAK0+C,eAC3D,MAAMgd,EAAiB/hD,EAAgByU,YAAYpuB,KAAKyM,cAAc8rD,kBACtE,IAAKmD,GAAgBhmC,eACjB,OAEJ,MAAM,QAAEvI,GAAYuuC,GACd,OAAEt5B,EAAM,gBAAE3iB,GAAoBi8C,EAAeh7C,YAC7CkiD,EAAqC,2CAAuClH,GAClF,IAAI9sB,EAAa5uC,KAAK++C,UAAUnQ,WAChC,MAAM5kC,EAAsB0xD,EAAeld,yBAC3C,GAAK5P,EAqBD5uC,KAAK++C,SAASnQ,WAAW1hC,KAAKyxC,QAAQlwC,OAClCm0D,MAtBS,CACb,MAAMpJ,EAAgB,CAClB/a,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,kBAAmB,MAEvB2G,KAAM,CACFyxC,QAAS,CACLlwC,OAAQm0D,MAIpB,IAAA3a,eAAcuR,EAAersC,GAC7ByhB,EAAa4qB,CACjB,CAKAx5D,KAAK++C,SAAW,CACZwZ,iBAAkBmD,EAAeryD,GACjCsQ,kBACAi1B,eAEJ,EAAAuQ,EAAA,GAAsCvlC,EACjC9E,QAAQ5Y,GAAaA,EAASmN,KAAOqyD,EAAeryD,KACpDhD,KAAKnK,GAAaA,EAASmN,KAAI,EAExCrJ,KAAKy0D,iBAAmB,KACpBz0D,KAAKyiE,OAAO,EAEhBziE,KAAK6iE,uBAAyB,KAC1B7iE,KAAKyiE,OAAO,EAEhBziE,KAAKkqD,iBAAoBjS,IACrBj4C,KAAKyiE,OAAO,EAEhBziE,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,MAAQnkD,SAAU+vB,GAAmB3wB,EACrC,IAAK0E,KAAK++C,SACN,OAAO,EAEX,MAAM,WAAEnQ,EAAU,iBAAE2pB,GAAqBv4D,KAAK++C,SAC9C,IAAIuB,GAAe,EACnB,MAAQpkD,SAAUw/D,IAAmB,IAAAW,+BAA8B9D,IAAqB,CAAC,EACzF,IAAKmD,EACD,OAAOpb,EAEX,GAAIob,EAAeryD,KAAO4iB,EAAe5iB,GACrC,OAAOi3C,EAEX,IAAK1R,IAAeA,GAAY1hC,MAAMyxC,SAASlwC,OAC3C,OAAO6xC,EAEX,GAAItgD,KAAKyM,cAAc81D,6BACnB7G,EAAeld,2BACXvyB,EAAeuyB,yBACnB,OAAO8B,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAElCy5D,EAAUl0B,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GACzC4gB,EAAWuf,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAC1C6gB,EAAasf,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAC5Cs0D,EAAcn0B,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,IAC7C,WAAEmS,EAAU,gBAAEnB,EAAe,OAAE2iB,GAAWnW,EAAevL,aACvDjB,gBAAiBujD,GAA0BtH,EAAeh7C,YAClE,GAAI1gB,KAAKijE,WAAWxjD,EAAiBujD,GACjC,OAAO1iB,EAEX,MAAM4iB,EAAsB,iCAA6BzjD,EAAiBmB,GACpEuiD,EAAY,CAACL,EAASxzC,EAAYD,EAAU0zC,GAC5CK,EAAY,CAACN,EAASzzC,EAAUC,EAAYyzC,GAClD,IAAIM,EAAgBF,EAChBG,EAAe,cAAc,cAAeH,EAAU,GAAIA,EAAU,IACxEG,EAAe,eAAe,cAAeA,GAC7C,IAAIC,EAAc,cAAc,cAAeJ,EAAU,GAAIA,EAAU,IACvEI,EAAc,eAAe,cAAeA,GAC5C,MAAMC,EAAY,WAAW,cAAeF,EAAcC,GAC1D,GAAIvjE,KAAKijE,WAAWO,EAAW/jD,GAC3B,OAAO6gC,EAEPtgD,KAAKyjE,gBAAgBH,EAAc7jD,KACnC4jD,EAAgBD,GAEpB,MAAMM,EAAiB,yCAAqCL,EAAc,GAAIA,EAAc,GAAIH,GAC1FS,EAAe,yCAAqCN,EAAc,GAAIA,EAAc,GAAIH,IACxF,cAAE3jB,GAAkB3Q,EAC1B6R,EAAelB,cAAgBA,EAC/B,MAAMoB,EAAY3gD,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GACvDgS,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8X,EAAS1mD,KAAKi6D,SAAS,SAAUxZ,EAAgB7R,GACvD,IAAI8R,EAAoB,CAACgjB,EAAgBC,GAAct9D,KAAKiyC,GAAUrsB,EAAeyzB,cAAcpH,KAInG,GAHIt4C,KAAKyM,cAAc+1D,oBACnB9hB,EAAoB1gD,KAAK4jE,oBAAoB33C,EAAgBy3C,EAAgBjkD,EAAiB2iB,EAAQuhC,EAAcjjB,IAEpHA,EAAkB9/C,OAAS,EAC3B,OAAO0/C,EAEX,MAAMQ,EAAS,GAAGvB,SASlB,OAPA,IAAAgQ,UAAYlP,EAAkBd,EADd,IACsCmB,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO+jD,EACPC,WACA8F,UACD5F,GACHR,GAAe,EACRA,CAAY,EAEvBtgD,KAAKyjE,gBAAkB,CAACI,EAAMC,KAC1B,MAAM9jD,EAAM,SAAS6jD,EAAMC,GAC3B,OAAO7mE,KAAK6e,IAAIkE,GAAO,EAAO,CAEtC,CACA,mBAAA4jD,CAAoB33C,EAAgBy3C,EAAgBjkD,EAAiB2iB,EAAQuhC,EAAcjjB,GAC/Dz0B,EAAeE,qBAAvC,MACMhI,EAAWnkB,KAAK82D,YAAY7qC,GAC5B83C,EAAc/jE,KAAKgkE,mBAAmB7/C,GACtC5d,EAAoBvG,KAAKu+C,qBAAqBtyB,EAAgBy3C,EAAgBjkD,EAAiB2iB,GACrG,GAAI77B,GAAqBw9D,EACrB,IACI,MAAM,UAAE1hD,EAAS,WAAExa,GAAek8D,GAC3BE,EAAmBC,EAAoBC,EAAuBC,GAAyB,CAC1F/hD,EAAUS,aAAa,CAAC,EAAG,EAAG,IAC9BT,EAAUS,aAAa,CAACjb,EAAW,GAAK,EAAG,EAAG,IAC9Cwa,EAAUS,aAAa,CACnBjb,EAAW,GAAK,EAChBA,EAAW,GAAK,EAChB,IAEJwa,EAAUS,aAAa,CAAC,EAAGjb,EAAW,GAAK,EAAG,KAChDxB,KAAKiyC,GAAU,+BAA2B/xC,EAAmB+xC,MACxD+rB,EAAqBC,GAAqB,CAC7CZ,EACAC,GACFt9D,KAAKiyC,GAAU,+BAA2B/xC,EAAmB+xC,KAC/DoI,EAAoB,CAChB,CAACujB,EAAmBC,GACpB,CAACA,EAAoBC,GACrB,CAACC,EAAsBD,GACvB,CAACF,EAAmBG,IAEnB/9D,KAAI,EAAE3K,EAAOsW,KAAShS,KAAKukE,uBAAuB7oE,EAAOsW,EAAKqyD,EAAqBC,KACnFxvD,QAAQxG,GAAUA,GAAStO,KAAKwkE,UAAUl2D,EAAOzG,KACjDxB,KAAKiI,IACN,MAAMgqC,EAAQ,+BAA2B/xC,EAAmB+H,GAC5D,OAAO2d,EAAeyzB,cAAcpH,EAAM,GAElD,CACA,MAAOmsB,GACHr0D,QAAQ2V,IAAI0+C,EAChB,CAEJ,OAAO/jB,CACX,CACA,sBAAA6jB,CAAuBG,EAAYC,EAAUC,EAAYC,GACrD,MAAO7+C,EAAIH,GAAM6+C,GACVv+C,EAAIF,GAAM0+C,GACVG,EAAIC,GAAMH,GACVI,EAAIC,GAAMJ,EACXK,EAAKj/C,EAAKJ,EACVs/C,EAAKn/C,EAAKG,EACVi/C,EAAKj/C,EAAKN,EAAKG,EAAKC,EACpBo/C,EAAKJ,EAAKF,EACVO,EAAKR,EAAKE,EACVO,EAAKP,EAAKD,EAAKD,EAAKG,EAC1B,GAAIhoE,KAAK6e,IAAIopD,EAAKI,EAAKD,EAAKF,GAAM,GAC9B,OAIJ,MAAO,EAFIA,EAAKI,EAAKD,EAAKF,IAAOF,EAAKI,EAAKD,EAAKF,IACrCE,EAAKD,EAAKF,EAAKK,IAAOL,EAAKI,EAAKD,EAAKF,GAEpD,CACA,UAAAlC,CAAWY,EAAMC,GACb,OAAO7mE,KAAK6e,IAAI,SAAS+nD,EAAMC,IAAS,EAAI,EAChD,CACA,SAAAU,CAAUl2D,EAAOzG,GACb,OAAQyG,EAAM,IAAM,GAChBA,EAAM,IAAMzG,EAAW,IACvByG,EAAM,IAAM,GACZA,EAAM,IAAMzG,EAAW,EAC/B,EAEJw6D,GAAe5pB,SAAW,iBAC1B,MChOQ74B,QAAO,IAAK,EAAAumC,UACpB,MAAMqf,WAAwBlD,GAAA17B,EAC1B,WAAAnnC,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXg5D,eAAgB,MAGpBruB,MAAMS,EAAWC,GACjB93C,KAAKy0D,iBAAmB,KACpBz0D,KAAKyiE,OAAO,EAEhBziE,KAAK05C,gBAAkB,KACnB15C,KAAKyiE,OAAO,EAEhBziE,KAAKyiE,MAAQ,KACT,MAAMgD,EAAiBzlE,KAAKyM,cAAcg5D,eAC1C,IAAKA,GAAgB7kE,OAEjB,YADAwP,QAAQC,KAAK,gEAGjB,MAAM1J,EAAmB,EAAAyqB,SAAA,IAAa,mBAAoBq0C,EAAe,IACzE,IAAK9+D,EAED,YADAyJ,QAAQC,KAAK,iEAGjB,MAAM,oBAAElI,GAAwBxB,EAC1B8yC,GAAgB,IAAAF,cAAav5C,KAAKw5C,aAAaC,cACrD,IAAKA,GAAe74C,OAEhB,YADAwP,QAAQC,KAAK,uCAGjB,MAAMkwC,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAev2C,GACvD,IAAKo4C,GAAa3/C,OAAQ,CACtB,MAAM8kE,EAAYD,EAAep/D,KAAKgD,GAC3BrJ,KAAK2lE,0BAA0Bt8D,KAEpCmwD,EAAgB,CAClB/a,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACf10C,oBAAqB7B,EACrB5B,kBAAmB,MAEvB2G,KAAM,CACF04D,aAAc,IAAIp0D,IAClBk0D,eAGR,IAAAzd,eAAcuR,EAAerxD,EACjC,EACA,EAAAg3C,EAAA,GAAsC1F,EAAcpzC,KAAI,EAAG6mB,gBAAiBA,IAAY,EAE5FltB,KAAK2lE,0BAA6BxhE,IAC9B,MAAM,qBAAE6D,EAAoB,KAAE/I,EAAI,QAAED,EAAO,WAAE4J,EAAU,cAAEC,EAAa,gBAAEnL,EAAe,mBAAEC,GAAwB,EAAAyzB,SAAA,IAAa,mBAAoBjtB,GAC5I2+D,EAAU,IAAI96D,GACdqnB,EAAW,IAAIrnB,GACfsnB,EAAa,IAAItnB,GACjB+6D,EAAc,IAAI/6D,GACxB,iBAAiBqnB,EAAUrnB,EAAsBa,EAAe7J,EAAUrB,GAC1E,iBAAiB2xB,EAAYtnB,EAAsBY,EAAY3J,EAAOvB,GACtE,iBAAiBqlE,EAAazzC,EAAYzmB,EAAe7J,EAAUrB,GAGnE,MAAO,CAAEwlE,UAFS,CAACL,EAASxzC,EAAYD,EAAU0zC,GAE9BK,UADF,CAACN,EAASzzC,EAAUC,EAAYyzC,GACnB,EAEnC/iE,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,MAAMolB,EAAiBzlE,KAAKyM,cAAcg5D,eAC1C,IAAInlB,GAAe,EACnB,IAAKmlB,GAAgB7kE,OACjB,OAAO0/C,EAEX,MAAQpkD,SAAU+vB,EAAc,oBAAEjiB,GAAwB1O,EAE1D,GADuB2wB,EAAe0H,cACnB/yB,OAAS,EACxB,OAAO0/C,EAEX,MAAMC,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAe10C,GACvD,IAAKu2C,GAAa3/C,OACd,OAAO0/C,EAEX,MAAM1R,EAAa2R,EAAY,IACzB,cAAEhB,GAAkB3Q,GACpB,WAAEhuB,EAAU,gBAAEnB,GAAoBwM,EAAevL,YACjD+/B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAElCw8D,EAAiB7lE,KAAK8lE,iBAAiBL,EAAe,IAC5D,GAAIzlE,KAAKijE,WAAWxjD,EAAiBomD,GACjC,OAAOvlB,EAEX,MAAM4iB,EAAsB,iCAA6BzjD,EAAiBmB,GACpE8kD,EAAY92B,EAAW1hC,KAAKw4D,UAC5BE,EAAeh3B,EAAW1hC,KAAK04D,aACrC,IAAK,IAAIl8D,EAAI,EAAGA,EAAI+7D,EAAe7kE,OAAQ8I,IAAK,CAC5C,MAAM,UAAEy5D,EAAS,UAAEC,GAAcsC,EAAUh8D,GACrCq8D,EAAaH,EAAaxlE,IAAI6rB,EAAe5iB,KAC/CrJ,KAAKgmE,uBAAuBJ,EAAc35C,EAAe5iB,IAC7D,IAAK08D,EAAWE,eAAev8D,GAAI,CAC/B,IAAI25D,EAAgBF,EAChBG,EAAe,cAAc,cAAeH,EAAU,GAAIA,EAAU,IACxEG,EAAe,eAAe,cAAeA,GACzCtjE,KAAKyjE,gBAAgBH,EAAc7jD,KACnC4jD,EAAgBD,GAEpB2C,EAAWE,eAAev8D,GAAK25D,EAC/B0C,EAAWG,gBAAgBx8D,GAAK,yCAAqC25D,EAAc,GAAIA,EAAc,GAAIH,GACzG6C,EAAWI,cAAcz8D,GAAK,yCAAqC25D,EAAc,GAAIA,EAAc,GAAIH,EAC3G,CACA,MAAMQ,EAAiBqC,EAAWG,gBAAgBx8D,GAC5Ci6D,EAAeoC,EAAWI,cAAcz8D,GAC9C+2C,EAAelB,cAAgBA,EAC/B,MAAMoB,EAAY3gD,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GACvDgS,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8X,EAAS1mD,KAAKi6D,SAAS,SAAUxZ,EAAgB7R,GACjD8R,EAAoB,CAACgjB,EAAgBC,GAAct9D,KAAKiyC,GAAUrsB,EAAeyzB,cAAcpH,KAC/FwI,EAAS,GAAGvB,SACZ+P,EAAU,GAAG5lD,KACnB,IAAA6lD,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO+jD,EACPC,WACA8F,UACD5F,EACP,CAEA,OADAR,GAAe,EACRA,CAAY,EAEvBtgD,KAAKgmE,uBAAyB,CAACJ,EAAcv8D,KACzCu8D,EAAa1lE,IAAImJ,EAAI,CACjB48D,eAAgB,GAChBC,gBAAiB,GACjBC,cAAe,KAEZP,EAAaxlE,IAAIiJ,IAE5BrJ,KAAKyjE,gBAAkB,CAACI,EAAMC,KAC1B,MAAM9jD,EAAM,SAAS6jD,EAAMC,GAC3B,OAAO7mE,KAAK6e,IAAIkE,GAAO,EAAO,CAEtC,CACA,UAAAijD,CAAWY,EAAMC,GACb,OAAO7mE,KAAK6e,IAAI,SAAS+nD,EAAMC,IAAS,EAAI,EAChD,CACA,gBAAAgC,CAAiB3hE,GACb,MAAM,wBAAE+D,GAA4B,EAAAkpB,SAAA,IAAa,mBAAoBjtB,GAC/DgX,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrH,OAAO,WAAW,cAAeiT,EAAcC,EACnD,EAEJoqD,GAAgB/sB,SAAW,cCzJ3B,MAAM2tB,WAAqC9D,GAAA17B,EACvC,WAAAnnC,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CrrC,cAAe,CACXoL,QAAS,MAGbu/B,MAAMS,EAAWC,GACjB93C,KAAKyiE,MAAQ,KACT,MAAMhpB,GAAgB,IAAAF,cAAav5C,KAAKw5C,aAAaC,cACrD,IAAKA,GAAe74C,OAEhB,YADAwP,QAAQC,KAAKrQ,KAAK0+C,cAAgB,4BAGtC,MAAMiK,GAAgB,IAAAx8B,oBAAmBstB,EAAc,GAAGvtB,oBAAoBkC,YAAYqrB,EAAc,GAAGvsB,YAC3G,IAAKy7B,EACD,OAEJ,MAAMxgD,EAAsBwgD,EAAcnK,yBACpC+B,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAev2C,GACvD,IAAKo4C,GAAa3/C,OAAQ,CACtB,MAAMylE,EAAuB,IAAI70D,KAsEjD,SAAmD60D,EAAsB5sB,GACrEA,EAAcx4C,SAAQ,EAAGisB,aAAYhB,wBACjC,MAAMhwB,GAAW,IAAAiwB,oBAAmBD,IAAoBkC,YAAYlB,GACpEo5C,GAAqDD,EAAsBnqE,EAAS,GAE5F,CA1EgBqqE,CAA0CF,EAAsB5sB,GAChE,MAAM+f,EAAgB,CAClB/a,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACf10C,oBAAqB7B,EACrB5B,kBAAmB,MAEvB2G,KAAM,CACFm5D,0BAGR,IAAApe,eAAcuR,EAAerxD,EACjC,EACA,EAAAg3C,EAAA,GAAsC1F,EAAcpzC,KAAI,EAAG6mB,gBAAiBA,IAAY,EAE5FltB,KAAKy0D,iBAAmB,KACpBz0D,KAAKyiE,OAAO,EAEhBziE,KAAKkqD,iBAAoBjS,IACrBj4C,KAAKyiE,OAAO,EAEhBziE,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,MAAM,SAAEnkD,EAAQ,oBAAE8N,GAAwB1O,EAC1C,IAAIglD,GAAe,EACnB,MAAMC,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAe10C,GACvD,IAAKu2C,GAAa3/C,OACd,OAAO0/C,EAEX,MAAM1R,EAAa2R,EAAY,IACzB,cAAEhB,GAAkB3Q,EACpBy3B,EAAuBz3B,EAAW1hC,KAAKm5D,qBAC7CC,GAAqDD,EAAsBnqE,GAC3E,MAAMsqE,EAAetqE,EAAS2kB,YACxB4lD,EAAUC,GAAWxqE,GA8B3B,OA7BAsqE,EAAavlE,SAAS8U,IAClB,IAAKA,GAAY4wD,eACb,OAEJ,MAAMC,EAAqBP,EAAqBjmE,IAAI2V,EAAWgL,KAC/D,IAAK6lD,EACD,OAEJ,IAAKA,EAAmBxmE,IAAIqmE,GACxB,OAEJ,IAAII,EAAc,EAClB,MAAM,eAAEC,EAAc,MAAE1qE,GAAUwqE,EAAmBxmE,IAAIqmE,GACzD,IAAK,IAAI/8D,EAAI,EAAGA,EAAIo9D,EAAelmE,OAAQ8I,IAAK,CAC5C,MACMq9D,EADcD,EAAep9D,GACFrD,KAAKiI,GAAUpS,EAASwjD,cAAcpxC,KACjElK,EAAU,CACZhI,MAAOA,EACP4qE,UAAW5qE,EACX6qE,YAAajnE,KAAKyM,cAAcoL,QAChCqvD,WAAW,EACXvmB,UAAW,GAETwmB,EAAcpxD,EAAWgL,IAAM,IAAM8lD,GAC3C,IAAAO,UAAS/mB,EAAkBd,EAAe4nB,EAAaJ,EAAc3iE,GACrEyiE,GACJ,KAEJvmB,GAAe,EACRA,CAAY,CAE3B,EAQJ,SAASgmB,GAAqDD,EAAsBnqE,GAChF,MAAMsqE,EAAetqE,EAAS2kB,YACxB4lD,EAAUC,GAAWxqE,GAC3BsqE,EAAavlE,SAAS8U,IAClB,IAAKA,GAAY4wD,eACb,OAEJ,IAAIU,EAAsBhB,EAAqBjmE,IAAI2V,EAAWgL,KAK9D,GAJKsmD,IACDA,EAAsB,IAAI71D,IAC1B60D,EAAqBnmE,IAAI6V,EAAWgL,IAAKsmD,KAExCA,EAAoBjnE,IAAIqmE,GAAU,CACnC,MACMK,EAAiB,EADN/wD,EAAW4wD,eAAeW,iBAE3C,IAAKR,EACD,OAEJ,MACM1qE,EAUlB,SAAuBmrE,GACnB,SAASC,EAAuBC,GAC5B,IAAIC,EAAkBzqE,KAAK+Q,MAAkB,IAAZy5D,GAAiBpoD,SAAS,IAI3D,OAH+B,IAA3BqoD,EAAgB9mE,SAChB8mE,EAAkB,IAAMA,GAErBA,CACX,CACA,MAAQ,IACJF,EAAuBD,EAAW,IAClCC,EAAuBD,EAAW,IAClCC,EAAuBD,EAAW,GAC1C,CAtB0BI,CADK5xD,EAAWI,MAAMoB,cAAcqwD,YAElDP,EAAoBnnE,IAAIumE,EAAS,CAAEK,iBAAgB1qE,SACvD,IAER,CACA,SAASsqE,GAAWxqE,GAChB,MAAM,gBAAEujB,GAAoBvjB,EAASwkB,YAC/BU,EAAallB,EAAS23B,yBAC5B,MAAO,GAAG33B,EAASmN,MCpIhB,SAAuBiF,EAAOu5D,EAAW,GAC5C,OAAQpxD,WAAWnI,EAAM,IAAIosB,QAAQmtC,GACjC,IACApxD,WAAWnI,EAAM,IAAIosB,QAAQmtC,GAC7B,IACApxD,WAAWnI,EAAM,IAAIosB,QAAQmtC,GAC7B,GACR,CD6H6BC,CAAcroD,MAAoB2B,GAC/D,CA0CAglD,GAA6B3tB,SAAW,2BEpKxC,MAAMsvB,WAAyBzF,GAAA17B,EAC3B,WAAAnnC,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BC,iBAAkB,EAClBC,cAAc,EACdC,eAAe,KAGnB/wB,MAAMS,EAAWC,GACjB93C,KAAKs+C,WAAY,EACjBt+C,KAAKooE,sBAAuB,EAC5BpoE,KAAKqoE,mBAAqB,KAC1BroE,KAAKsoE,4BAA8B,KACnCtoE,KAAKuoE,uBAAyB,KAC9BvoE,KAAKwoE,uBAAwB,EAC7BxoE,KAAK+qD,kBAAqB9S,IACtB,MAAM,OAAE3lB,GAAW2lB,GACb,QAAE9qB,EAAO,cAAE2tB,GAAkBxoB,EACnCtyB,KAAKsoE,4BAA8BxtB,EAAcxC,MACjDt4C,KAAKuoE,uBAAyBztB,EAAcr/C,OAC5CuE,KAAKqoE,mBAAqBl7C,EAC1B,MAAMyhB,EAAa5uC,KAAKyoE,oBAAoBt7C,GAC5C,OAAmB,OAAfyhB,GACA5uC,KAAK0oE,wBAAwB5tB,EAAcxC,MAAOnrB,IAC3C,IAEXntB,KAAK2oE,yBAAyBx7C,EAASyhB,IAChC,EAAK,EAEhB5uC,KAAK0oE,wBAA0B,CAAClpD,EAAU2N,KACtC,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACzC,IAAK7xB,EACD,MAAM,IAAI8C,MAAM,4BAEpB,MAAM,SAAElC,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EACpC,IAAKhB,IAAoB2iB,EACrB,MAAM,IAAIhkC,MAAM,oBAEpB,MAAMmI,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,qBAEJ2G,KAAM,CACFykB,MAAO,GACPgtB,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,IACbi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,QAOxC,IADoB,IAAArS,gBAAe1wD,KAAK0+C,cAAevxB,GACvCvsB,OAAS,EACrB,OAAO,KAGX,GAAqB,QADA,IAAAqnD,eAAcrZ,EAAYzhB,GAE3C,OAEJ,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAAe,IACxF,EAAAS,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKkqD,iBAAoBjS,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,eAAE47C,EAAc,OAAEtoD,GAAWsO,EAEtC7yB,GADiB,IAAAg8B,mBAAkB/K,GACTjxB,SAChC,GAAIixB,IAAYntB,KAAKqoE,mBACjB,OAEJ,MAAMW,EAAgBD,EAAenoD,WAC/BqoD,EAAexoD,EAAOhB,gBACtBwf,EAAgBxe,EAAOG,WACvB4pC,EAAwB,CAAC,EAAG,EAAG,GAErC,GADA,eAAiBvrB,EAAe+pC,EAAexe,GACU,IAArDA,EAAsBruB,QAAO,CAACjgB,EAAGhF,IAAMgF,EAAIhF,GAAG,GAC9C,OAEJ,MAAMgyD,EAAa,UAAY1e,EAAuBye,GACtD,GAAIhsE,KAAK6e,IAAIotD,GAAc,IACvB,OAEJ,IAAKlpE,KAAKuoE,uBACN,OAEJ,MAAM/G,EAActlE,EAASkzB,cAAcpvB,KAAKuoE,wBAChDvoE,KAAKsoE,4BAA8B9G,EACnCxhE,KAAK2oE,yBAAyBx7C,EAASntB,KAAKyoE,oBAAoBt7C,GAAS,EAE7EntB,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,EAAQ,oBAAE8N,GAAwB1O,EACpC6tE,EAAsBnpE,KAAKqoE,qBAAuBnsE,EAASixB,QAC7DntB,KAAKyM,cAAcy7D,eAAiBiB,GACpCnpE,KAAKopE,oBAAoBltE,GAE7B,MAAM,QAAEixB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,QAAE+P,GAAYzxC,GACd,OAAEuB,GAAWkwC,EACnB,IAAKY,EACD,OAAOe,EAEXG,EAAelB,cAAgBA,EAC/B,MAAM8pB,EAAgB5yD,WAAWzW,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,IACtE+R,EACA0oB,EAEAzoB,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GACrD,GAAIngC,EAAO,GAAGwY,MAAMvX,GAAM8M,MAAM9M,KAC5B,OAAO4wC,EAEX,MAAMI,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE,IAAKxS,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,MAAM+pB,EAAgB,CAClBnrD,MAAO,QACPorD,MAAO,QACPrrD,MAAO,QACPijC,KAAM,SAEH7jD,EAAGE,GAAKkjD,EAAkB,GAC3B8oB,EAAcL,EAAsB,GAAK,EACzCM,EAAaN,EAAsB,EAAI,GAC7C,IAAA5Z,UAASlP,EAAkBd,EAAe+pB,EAAcnrD,MAAO,CAAC7gB,EAAGE,GAAKgsE,EAAc,EAAIC,IAAc,CAACnsE,EAAGE,EAAIgsE,EAAc,GAAI,CAAEptE,QAAOwkD,WAAUD,eACrJ,IAAA4O,UAASlP,EAAkBd,EAAe+pB,EAAcprD,MAAO,CAAC5gB,EAAGE,GAAKgsE,EAAc,EAAIC,IAAc,CAACnsE,EAAGE,EAAIgsE,EAAc,GAAI,CAAEptE,QAAOwkD,WAAUD,eACrJ,IAAA4O,UAASlP,EAAkBd,EAAe+pB,EAAcC,MAAO,CAACjsE,GAAKksE,EAAc,EAAIC,GAAajsE,GAAI,CAACF,EAAIksE,EAAc,EAAGhsE,GAAI,CAAEpB,QAAOwkD,WAAUD,eACrJ,IAAA4O,UAASlP,EAAkBd,EAAe+pB,EAAcnoB,KAAM,CAAC7jD,GAAKksE,EAAc,EAAIC,GAAajsE,GAAI,CAACF,EAAIksE,EAAc,EAAGhsE,GAAI,CAAEpB,QAAOwkD,WAAUD,cACpJL,GAAe,CACnB,CACA,OAAOA,CAAY,EAEvBtgD,KAAKwoE,sBAAwBxoE,KAAKyM,cAAc07D,aACpD,CACA,eAAAzuB,GAEI,GADA15C,KAAKwoE,sBAAwBxoE,KAAKyM,cAAc07D,eAC3CnoE,KAAKwoE,sBACN,OAEJ,MAAM3uD,GAAc,IAAA0/B,cAAav5C,KAAKw5C,aAAaC,cACnD,IAAK5/B,EACD,OAEoBA,EAAYxT,KAAKqJ,IAAM,IAAAkqC,wBAAuBlqC,EAAEwd,WAAYxd,EAAEwc,qBACtEjrB,SAASksB,IACjBA,IACA,KAAA8xB,mBAAkB9xB,EAAQjxB,SAASixB,QACvC,GAER,CACA,iBAAAgtB,GACI,IAAKn6C,KAAKwoE,sBACN,OAEJ,MAAM3uD,GAAc,IAAA0/B,cAAav5C,KAAKw5C,aAAaC,cACnD,IAAK5/B,EACD,OAEoBA,EAAYxT,KAAKqJ,IAAM,IAAAkqC,wBAAuBlqC,EAAEwd,WAAYxd,EAAEwc,qBACtEjrB,SAASksB,IACjBA,IACA,KAAAmyB,oBAAmBnyB,EAAQjxB,SAASixB,QACxC,GAER,CACA,mBAAAs7C,CAAoBt7C,GAChB,MAAMozB,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACvD,IAAKozB,EAAY3/C,OACb,OAAO,KAGX,OADyB2/C,EAAY,EAEzC,CACA,wBAAAooB,CAAyBx7C,EAASyhB,GAC9B,MAAMpvB,EAAWxf,KAAKsoE,4BACtB,IAAK9oD,EACD,OAEJ,IAAKovB,EAAW1hC,MAAMyxC,SAASlwC,OAC3B,OAEJmgC,EAAW1hC,KAAKyxC,QAAQlwC,OAAS,CAAC,IAAI+Q,IACtCovB,EAAWrzC,aAAc,EACzB,MAAMsjD,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAAe,IACjE,IAAAxmB,mBAAkB/K,KAIzC,EAAAgyB,EAAA,GAAsCN,EAC1C,CACA,uCAAA2B,CAAwCrzB,EAASozB,GAC7C,KAAMA,aAAuB7hD,QAAiC,IAAvB6hD,EAAY3/C,OAC/C,MAAO,GAEX,MAAMguC,EAAa2R,EAAY,GACzBrkD,GAAW,IAAAg8B,mBAAkB/K,IAAUjxB,SAC7C,IAAKA,EACD,MAAO,GAEX,MAAMukB,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,WAAEmB,GAAeH,EACxC,IAAKhB,IAAoBmB,EACrB,MAAO,GAEX,MAAMnS,EAASmgC,EAAW1hC,MAAMyxC,SAASlwC,OACzC,KAAMA,aAAkB/P,QAA4B,IAAlB+P,EAAO7N,OACrC,MAAO,GAEX,MAAM4e,EAAW/Q,EAAO,GAClB2lB,EAAQ,EAAAkY,UAAA,qBAA+B7sB,EAAiBmB,GAE9D,OADiB,EAAA0rB,UAAA,4BAAsClY,EAAO5U,GAC5Cxf,KAAKyM,cAAcw7D,iBAAmB,CAACr5B,GAAc,EAC3E,CACA,mBAAAw6B,CAAoBltE,GAChB,MAAMwtE,EAAuB1pE,KAAKsoE,4BAClC,GAAKoB,IAAwBA,EAAqBziD,MAAMvX,GAAM8M,MAAM9M,KAGpE,GAAIxT,aAAoB,EAAAi8B,cAAe,CACnC,MAAMwxC,EAAe,EAAAr9B,UAAA,kCAA4Co9B,EAAsBxtE,GACvF,GAAqB,OAAjBytE,EACA,OAEAA,IAAiBztE,EAAS23B,0BAC1B33B,EAASgmE,gBAAgByH,EAEjC,MACK,GAAIztE,aAAoB,EAAAsyC,eAAgB,CACzC,MAAM,WAAE5tB,EAAU,gBAAEnB,GAAoBvjB,EAASwkB,YACjD,IAAKE,IAAenB,EAChB,OAEJ,MAAM2U,EAAQ,EAAAkY,UAAA,qBAA+B7sB,EAAiBmB,GACxDgpD,EAAkB,EAAAt9B,UAAA,4BAAsClY,EAAOs1C,GAAsB,GAC3F,GAAIzsE,KAAK6e,IAAI8tD,GAAmB,GAC5B,OAEJ,MAAMC,EAAsB,eAAe,cAAe,mBAAmBpqD,IACvEqqD,EAAoB,WAAW,cAAeD,EAAqBD,GACnE3qC,EAAgB,SAAS,cAAe,mBAAmBre,GAAakpD,GAE9E,IADmB,EACH,CACZ5tE,EAASijC,UAAU,CAAEve,WAAYqe,IACjC,MAAMtlB,EAAkBzd,EAASiwB,qBAC7BxS,GACAA,EAAgBowD,eAAe7tE,EAASmN,GAEhD,CACJ,CACJ,EAEJ0+D,GAAiBtvB,SAAW,mBAC5B,MC7SMuxB,GAA2B,GACjC,MAAMC,WAAyB3H,GAAA17B,EAC3B,WAAAnnC,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CrrC,cAAe,CACXygB,WAAY,GACZg9C,cAAe,YAGnB9yB,MAAMS,EAAWC,GACjB93C,KAAK++C,SAAW,KAChB/+C,KAAKyiE,MAAQ,KACT,MACM9oD,GADmB,IAAA+oD,uBACgB,GACzC,IAAK/oD,EACD,OAEJ,MAAME,GAAc,IAAA0/B,cAAav5C,KAAKw5C,aAAaC,cACnD,IAAK5/B,EACD,OAEJ,MAAMswD,EAAkBtwD,EAAYxT,KAAKqJ,IAAM,IAAAkqC,wBAAuBlqC,EAAEwd,WAAYxd,EAAEwc,qBACtF,IAAI,SAAEhwB,GAAaiuE,EAAgB,GACnC,MAAM,oBAAEngE,GAAwBmgE,EAAgB,GAQhD,GAPInqE,KAAKyM,cAAcygB,YACnBi9C,EAAgBlpE,SAASksB,IACjBA,EAAQjxB,SAASmN,IAAMrJ,KAAKyM,cAAcygB,aAC1ChxB,EAAWixB,EAAQjxB,SACvB,KAGHA,EACD,OAEJ,MAAM,OAAEkmC,EAAM,gBAAE3iB,GAAoBvjB,EAASwkB,YACvC0pD,EAA+B,2CAAuCluE,GAC5E,IAAI0yC,EAAa5uC,KAAK++C,UAAUnQ,WAChC,MAAM2R,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAexiD,EAASixB,SAC5DozB,EAAY3/C,SACZguC,EAAa2R,EAAYzrC,QAAQu1D,GAAmBA,EAAen9D,KAAKggB,YAAchxB,EAASmN,KAAI,IAEvG8gE,EAAgBlpE,SAASksB,IACrB,MAAM,SAAEjxB,GAAaixB,EACrB,IAAK68C,GAAyBnvD,SAAS3e,EAASmN,IAAK,CACjD,MAAMmwD,EAAgB,CAClBtyD,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,kBAAmB,MAEvB2G,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,2CAAuCvS,IAEnDgxB,WAAYhxB,EAASmN,KAG7B2gE,GAAyBrhE,KAAKzM,EAASmN,KACvC,IAAA4+C,eAAcuR,EAAet9D,EAASixB,SACtCyhB,EAAa4qB,CACjB,KAEAx5D,KAAK++C,UAAUnQ,YACf5uC,KAAK++C,SAASnQ,WAAW1hC,KAAKggB,YAAchxB,EAASmN,KACrDrJ,KAAK++C,SAASnQ,WAAW1hC,KAAKyxC,QAAQlwC,OAClC27D,EACJpqE,KAAK++C,SAASnQ,WAAW1hC,KAAKggB,WAAahxB,EAASmN,IAExDrJ,KAAK++C,SAAW,CACZ7iD,WACAyd,kBACAi1B,aACH,EAEL5uC,KAAKy0D,iBAAmB,KACpBz0D,KAAKyiE,OAAO,EAEhBziE,KAAKkqD,iBAAoBjS,IACrBj4C,KAAKyM,cAAcygB,WAAa+qB,EAAI3lB,OAAOpF,WAC3CltB,KAAKyiE,OAAO,EAEhBziE,KAAKsqE,iBAAmB,CAACC,EAAoBC,EAAqBC,KAC9D,MAAMC,EAAa,CACf,KAAO,IAAM,IAAM,IAAM,IAAM,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,GAEjE,IAAIC,EASJ,OAPIA,EADY,OAAZF,GAAiC,UAAZA,EACFC,EAAW51D,QAAQ81D,GAAcA,EAAiC,GAArBL,GAC5DK,EAAiC,GAArBL,IAGGG,EAAW51D,QAAQ81D,GAAcA,EAAkC,GAAtBJ,GAC5DI,EAAkC,GAAtBJ,IAEbG,EAAiB,EAAE,EAE9B3qE,KAAK6qE,qBAAuB,CAACnqB,EAAmB+pB,KAC5C,MAAMK,EAAqB,CACvBC,OAAQ,CACJ,CAAC,GAAI,IACL,CAAC,GAAI,KAETp2D,IAAK,CACD,CAAC,EAAG,IACJ,CAAC,EAAG,KAERwsC,KAAM,CACF,CAAC,EAAG,GACJ,CAAC,GAAI,IAETooB,MAAO,CACH,CAAC,EAAG,GACJ,EAAE,GAAI,KAuBd,MAAO,CACHyB,SArBa,CACb,CACItqB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,GAC1D/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,IAE9D,CACI/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,GAC1D/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,KAe9DQ,SAZa,CACb,CACIvqB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,GAC1D/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,IAE9D,CACI/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,GAC1D/pB,EAAkB,GAAG,GAAKoqB,EAAmBL,GAAU,GAAG,KAMjE,EAELzqE,KAAKkrE,uBAAyB,CAACN,EAAWH,EAAUlrB,EAAe4rB,EAAUC,KACzE,IAAIC,EACY,UAAZZ,GAAoC,OAAZA,EACxBY,EAAkBD,EAAU,GAAG,GAAKD,EAAS,GAAG,GAE/B,QAAZV,GAAkC,SAAZA,IAC3BY,EAAkBD,EAAU,GAAG,GAAKD,EAAS,GAAG,IAEpD,MAAMG,EAAU,GACVC,EAAW,GACXC,EAAkB,GACxB,IAAIC,EAAmBb,EACnBA,GAAa,KACba,EAAmBb,EAAY,IAEnC,MAAMc,EAAcL,EAAkBI,EACtC,IAAK,IAAI/hE,EAAI,EAAGA,EAAI+hE,EAAmB,EAAG/hE,IAAK,CAC3C,MAAMiiE,EAAiB,CACnBZ,OAAQ,CACJ,CAACW,GAAehiE,EAAI,GAAI,GACxB,CAACgiE,GAAehiE,EAAI,GAAI,IAE5BiL,IAAK,CACD,CAAC+2D,GAAehiE,EAAI,GAAI,GACxB,CAACgiE,GAAehiE,EAAI,IAAK,IAE7By3C,KAAM,CACF,CAAC,EAAGuqB,GAAehiE,EAAI,IACvB,EAAE,EAAGgiE,GAAehiE,EAAI,KAE5B6/D,MAAO,CACH,CAAC,EAAGmC,GAAehiE,EAAI,IACvB,CAAC,EAAGgiE,GAAehiE,EAAI,MAG/B4hE,EAAQ3iE,KAAK,GAAG42C,SAAqB71C,KACrC6hE,EAAS5iE,KAAK,OAAOe,MAChBA,EAAI,GAAK,GAAK,EACf8hE,EAAgB7iE,KAAK,CACjB,CACIwiE,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,IAEjD,CACIU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,MAKrDe,EAAgB7iE,KAAK,CACjB,CACIwiE,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,IAEjD,CACIU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,KAI7D,CACA,MAAO,CAAEa,UAASC,WAAUC,kBAAiB,EAEjDxrE,KAAK4rE,6BAA+B,CAAChB,EAAWH,EAAUoB,KACtD,IAAIC,EACAxI,EAAe,cAAc,cAAeuI,EAAS,GAAIA,EAAS,IACtEvI,EAAe,eAAe,cAAeA,GAC7C,IAAIC,EAAc,cAAc,cAAesI,EAAS,GAAIA,EAAS,IACrEtI,EAAc,eAAe,cAAeA,GAC5C,MAAMwI,EAAmB,CACrBhB,OAAQ,CAACc,EAAS,GAAIA,EAAS,IAC/Bl3D,IAAK,CAACk3D,EAAS,GAAIA,EAAS,IAC5BtC,MAAO,CAACsC,EAAS,GAAIA,EAAS,IAC9B1qB,KAAM,CAAC0qB,EAAS,GAAIA,EAAS,KAE3BG,EAAW,SACR,cAAeD,EAAiBtB,GAAU,GAAIsB,EAAiBtB,GAAU,IAC7EpkE,KAAKqD,GAAMA,EAAI,IACd4D,EAASs9D,EACX,EACA3tE,KAAKwmC,KAAKxmC,KAAKy5D,IAAI4M,EAAa,GAAI,GAChCrmE,KAAKy5D,IAAI4M,EAAa,GAAI,GAC1BrmE,KAAKy5D,IAAI4M,EAAa,GAAI,IAalC,MAZgB,OAAZmH,GAAiC,UAAZA,EACrBqB,EAAmB,CACf,cAAc,cAAeE,EAAUzI,EAAYl9D,KAAKqD,GAAMA,EAAI4D,KAClE,SAAS,cAAe0+D,EAAUzI,EAAYl9D,KAAKqD,GAAMA,EAAI4D,MAGhD,QAAZm9D,GAAkC,SAAZA,IAC3BqB,EAAmB,CACf,SAAS,cAAeE,EAAU1I,EAAaj9D,KAAKqD,GAAMA,EAAI4D,KAC9D,cAAc,cAAe0+D,EAAU1I,EAAaj9D,KAAKqD,GAAMA,EAAI4D,OAGpEw+D,CAAgB,EAE3B9rE,KAAKisE,8BAAgC,CAACC,EAAYxrB,EAAmByrB,EAAcC,EAAc3B,KAC7F,IAAI4B,EACJ,GAAgB,OAAZ5B,GAAiC,UAAZA,EAAsB,CAC3C,MAAM6B,EAAwB5rB,EAAkB,GAAG,GAAKA,EAAkB,GAAG,GAC7E2rB,EAAyB,CACrB,CAACH,EAAWtvE,MAAQ,EAAI0vE,EAAwB,EAAGH,EAAatvE,QAChE,CAACqvE,EAAWtvE,MAAQ,EAAI0vE,EAAwB,EAAGH,EAAatvE,QAExE,MACK,GAAgB,QAAZ4tE,GAAkC,SAAZA,EAAqB,CAChD,MAAM6B,EAAwB5rB,EAAkB,GAAG,GAAKA,EAAkB,GAAG,GAC7E2rB,EAAyB,CACrB,CAACD,EAAaxvE,MAAOsvE,EAAWrvE,OAAS,EAAIyvE,EAAwB,GACrE,CAACF,EAAaxvE,MAAOsvE,EAAWrvE,OAAS,EAAIyvE,EAAwB,GAE7E,CACA,OAAOD,CAAsB,EAEjCrsE,KAAKusE,mBAAqB,CAACL,EAAYM,EAAqBC,EAAmBhC,KAC3E,MAAMiC,EAAaF,EAAsBvvE,KAAKa,IAAI,IAAMouE,EAAWtvE,OAC7D+vE,EAAaF,EAAoBxvE,KAAKa,IAAI,IAAMouE,EAAWrvE,QAC3D+vE,EAAiB,CACnB7B,OAAQ,EAAE4B,GAAaD,GACvB/3D,IAAK,CAACg4D,EAAYD,GAClBvrB,KAAM,CAACwrB,EAAYD,GACnBnD,MAAO,EAAEoD,GAAaD,IAEpBG,EAAe,CACjB9B,OAAQ,CAACmB,EAAWrvE,OAAQqvE,EAAWtvE,OACvC+X,IAAK,CAAC,EAAGu3D,EAAWtvE,OACpBukD,KAAM,CAAC+qB,EAAWrvE,OAAQ,GAC1B0sE,MAAO,CAAC2C,EAAWrvE,OAAQqvE,EAAWtvE,QAE1C,MAAO,CACHC,OAAQgwE,EAAapC,GAAU,GAAKmC,EAAenC,GAAU,GAC7D7tE,MAAOiwE,EAAapC,GAAU,GAAKmC,EAAenC,GAAU,GAC/D,CAET,CACA,gBAAArqB,CAAiB9kD,EAAgB+kD,GAC7B,IAAKrgD,KAAK++C,WAAa/+C,KAAK++C,SAAS7iD,SACjC,OAEJ,MAAMuuE,EAAWzqE,KAAKyM,cAAcy9D,eAC9B,SAAEhuE,GAAaZ,EAEfszC,GADc,IAAA8hB,gBAAe1wD,KAAK0+C,cAAexiD,EAASixB,SACjCrY,QAAQu1D,GAAmBA,EAAen9D,KAAKggB,YAAchxB,EAASmN,KAAI,GACnG5N,EAASH,EAAeY,SAAST,OACjC6kD,GAAe,EACrB,IAAKpkD,EACD,OAAOokD,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAElC6iE,EAAa,CACftvE,MAAOnB,EAAOmB,MAAQ2wB,OAAOD,kBAAoB,EACjDzwB,OAAQpB,EAAOoB,OAAS0wB,OAAOD,kBAAoB,GAEjDw1C,EAAUl0B,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GACzC4gB,EAAWuf,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAC1C6gB,EAAasf,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAC5Cs0D,EAAcn0B,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAC7C00D,EAAY,CAACL,EAASxzC,EAAYD,EAAU0zC,GAC5CwH,EAAqB,cAAcj7C,EAAYyzC,GAC/CyH,EAAsB,cAAc1H,EAASxzC,GAC7C88C,EAAepsE,KAAKusE,mBAAmBL,EAAY,IAAM,IAAMzB,GAC/D0B,EAAensE,KAAKusE,mBAAmBL,EAAY,IAAM,IAAMzB,GAC/DG,EAAY5qE,KAAKsqE,iBAAiBC,EAAoBC,EAAqBC,GAC3E/pB,EAAoB1gD,KAAK4rE,6BAA6BhB,EAAWH,EAAUtH,GAAW98D,KAAKiyC,GAAUp8C,EAASwjD,cAAcpH,KAC5H+zB,EAAyBrsE,KAAKisE,8BAA8BC,EAAYxrB,EAAmByrB,EAAcC,EAAc3B,GACvHqC,EAAa9sE,KAAK6qE,qBAAqBwB,EAAwB5B,IAC/D,cAAElrB,GAAkB3Q,EAC1B6R,EAAelB,cAAgBA,EAC/B,MAAMoB,EAAY3gD,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GACvDgS,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8X,EAAS1mD,KAAKi6D,SAAS,SAAUxZ,EAAgB7R,GACjDm+B,EAAU,GAAGxtB,eAEnB,IAAAgQ,UAAYlP,EAAkBd,EADT,IACsC8sB,EAAuB,GAAIA,EAAuB,GAAI,CAC7GjwE,QACAQ,MAAO+jD,EACPC,WACA8F,UACDqmB,GACH,MAAMC,EAAa,GAAGztB,UAEtB,IAAAgQ,UAAYlP,EAAkBd,EADV,IACsCutB,EAAW9B,SAAS,GAAI8B,EAAW9B,SAAS,GAAI,CACtG5uE,QACAQ,MAAO+jD,EACPC,WACA8F,UACDsmB,GACH,MAAMC,EAAc,GAAG1tB,WAEvB,IAAAgQ,UAAYlP,EAAkBd,EADT,IACsCutB,EAAW7B,SAAS,GAAI6B,EAAW7B,SAAS,GAAI,CACvG7uE,QACAQ,MAAO+jD,EACPC,WACA8F,UACDumB,GACH,MAAMC,EAAqB,CACvBnC,OAAQ,EAAE,IAAK,IACfp2D,IAAK,EAAE,IAAK,IACZwsC,KAAM,EAAE,IAAK,IACbooB,MAAO,EAAE,IAAK,KAEZ4D,EAAwB,CAC1Bd,EAAuB,GAAG,GAAKa,EAAmBzC,GAAU,GAC5D4B,EAAuB,GAAG,GAAKa,EAAmBzC,GAAU,IAE1D2C,EAAeptE,KAAKqtE,cAAczC,IAClC,QAAEU,EAAO,SAAEC,EAAQ,gBAAEC,GAAoBxrE,KAAKkrE,uBAAuBN,EAAWH,EAAUlrB,EAAeutB,EAAW9B,SAAU8B,EAAW7B,UAC/I,IAAK,IAAIvhE,EAAI,EAAGA,EAAI6hE,EAAS3qE,OAAQ8I,KACjC,IAAA6lD,UAAYlP,EAAkBd,EAAegsB,EAAS7hE,GAAI8hE,EAAgB9hE,GAAG,GAAI8hE,EAAgB9hE,GAAG,GAAI,CACpGtN,QACAQ,MAAO+jD,EACPC,WACA8F,UACD4kB,EAAQ5hE,IAWf,OARA,IAAA4jE,aAAejtB,EAAkBd,EADjB,QACyC6tB,EAAc,CAACD,EAAsB,GAAIA,EAAsB,IAAK,CACzHI,WAAY,+CACZC,SAAU,OACV5sB,SAAU,MACVD,UAAW,IACX+F,QAAQ,EACRtqD,MAAOA,IAEJkkD,CACX,CACA,aAAA+sB,CAAczC,GACV,IAAI6C,EACAC,EACA9C,GAAa,IACb6C,EAAwB7C,EAAY,GACpC8C,EAAiB,QAGjBD,EAAwB7C,EACxB8C,EAAiB,OAGrB,MADkB,CAACD,EAAsBpuD,WAAW5B,OAAOiwD,GAE/D,EAEJzD,GAAiBxxB,SAAW,e,wCC/X5B,MAAMk1B,WAAqB,MACvB,WAAAluE,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXmhE,WAAY,EACZC,oBAAqB,CACjB,oBACA,yCAEJC,UAAW,SACXC,mBAAoB,uBAGxB32B,MAAMS,EAAWC,GACjB93C,KAAKguE,iBAAmB,IAAIx8D,IAC5BxR,KAAKiuE,UAAW,EAChBjuE,KAAKkuE,WAAa,CACdC,oBAAqB,KACrBtvB,oBAAqB,GACrBuvB,sBAAsB,EACtBC,oBAAgBrwE,GAEpBgC,KAAK84C,qBAAwBb,IACzB,MAAMrY,EAAYqY,EAAI3lB,OAChBnF,EAAUyS,EAAUzS,QAG1B,GAFAntB,KAAKsuE,kBAAkBr2B,GACvBj4C,KAAKuuE,mBAAmB3uC,GACoB,OAAxC5/B,KAAKkuE,WAAWC,oBAMpB,OAHAnuE,KAAKiuE,UAAW,GAChB,KAAAhvB,mBAAkB9xB,GAClBntB,KAAKwuE,eAAerhD,IACb,CAAI,EAEfntB,KAAK+qD,kBAAqB9S,IAClBj4C,KAAK++D,OAAS,EAAA/yB,UAAUH,QACxB7rC,KAAKsuE,kBAAkBr2B,GACvBj4C,KAAKyuE,aAAax2B,IAGlBj4C,KAAKkuE,WAAWG,oBAAiBrwE,CACrC,EAEJgC,KAAK0uE,YAAez2B,IAChB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,EACdu4B,EAASn4D,KAAKyM,cACdnR,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAKiuE,UAAW,EAChBjuE,KAAK2uE,iBAAiBxhD,IACtB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,kBAAEjB,EAAiB,WAAEgB,GAAe5xB,EAEpC6kE,GADY,IAAAna,yBAAwB94B,EAAYhB,GACvBynC,gBAAgBwE,EAAO4V,oBAEhDa,EADc5uE,KAAK6uE,sCAAsC1hD,GAC1BzP,MAAMkxB,GAAeA,EAAW2Q,gBAAkBv/C,KAAKkuE,WAAWC,sBACnGhO,EAAa1zD,cAAcqiE,iBAC3BF,EAAiBrzE,aAAc,IAEnC,KAAAuzC,2BAA0B8/B,EAAkBzhD,EAAS,EAAA4hB,YAAYggC,eAAe,EAEpF/uE,KAAKgvE,aAAgB/2B,IACjB,MAAMrY,EAAYqY,EAAI3lB,OAChBnF,EAAUyS,EAAUzS,QAC1BntB,KAAKyuE,aAAax2B,GAClB,MAAMsI,EAAcvgD,KAAK6uE,sCAAsC1hD,GACzDyhD,EAAmBruB,EAAY7iC,MAAMkxB,GAAeA,EAAW2Q,gBAAkBv/C,KAAKkuE,WAAWC,sBACvG,IAAK5tB,GAAa3/C,SAAWZ,KAAKiuE,SAC9B,OAEJ,MAAMx/D,EAASmgE,EAAiB1hE,KAAK2gC,QAAQohC,SAC7CjvE,KAAKkvE,OAAOtvC,EAAWnxB,EAAO,EAElCzO,KAAKmvE,eAAeC,GAAA,EAAmBC,UAAWD,GAAA,GAClDpvE,KAAKsvE,aAAatvE,KAAKyM,cAAcqhE,UACzC,CACA,cAAAqB,CAAeE,EAAWE,GACtB,MAAMC,EAAQ,IAAID,EAClBvvE,KAAKguE,iBAAiB9tE,IAAImvE,EAAWG,EACzC,CACA,MAAAN,CAAOtvC,EAAWnxB,GACd,MAAM0pD,EAASn4D,KAAKyM,cACd0gB,EAAUyS,EAAUzS,QACpB7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfm0E,EAAczvE,KAAKguE,iBAAiB5tE,IAAIJ,KAAK0vE,eACnD1vE,KAAK2vE,WAAa,CACdC,WAAYhwC,EAAUkb,cAAcxC,MACpCu3B,iBAAkBjwC,EAAUkb,cAAcr/C,OAC1CgT,SACAqhE,WAAYL,EAAYM,cAAc5X,EAAOyV,YAC7CzgD,QAASA,GAEb,MAAM6iD,EAAgBP,EAAYQ,YAAY/zE,EAAU8D,KAAK2vE,iBACjC3xE,IAAxBgyE,EAAcE,OACdlwE,KAAKmwE,iBAAiBH,EAE9B,CACA,iCAAAI,CAAkC1mE,EAAG+E,EAAQ4hE,EAAsBP,GAC/D,MAAM,QAAE3iD,GAAYntB,KAAK2vE,WACnBr0E,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfg1E,EAAkBC,GAAa7mE,EAAI,EAAG+E,EAAO7N,QAC7C4vE,EAAqBt0E,EAASwjD,cAAcjxC,EAAO/E,IACnD+mE,EAAkBv0E,EAASwjD,cAAcjxC,EAAO6hE,IACzB,EAAAhiE,MAAA,gBAAsBkiE,EAAoBC,GAC5CX,GACvBO,EAAqB1nE,KAAKe,EAElC,CACA,YAAA+kE,CAAax2B,GACT,MAAMrY,EAAYqY,EAAI3lB,OAChBnF,EAAUyS,EAAUzS,QACpB7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,EACtC0E,KAAKkuE,WAAWrvB,oBAAsB,CAAC3iD,EAASmN,IAChD,MAAMk3C,EAAcvgD,KAAK6uE,sCAAsC1hD,GAC/D,IAAKozB,GAAa3/C,OACd,OAEJ,MAAMguE,EAAmBruB,EAAY7iC,MAAMkxB,GAAeA,EAAW2Q,gBAAkBv/C,KAAKkuE,WAAWC,sBAEvG,GADAnuE,KAAKkuE,WAAWG,eAAiBzuC,EAAUkb,cAAcr/C,OACrDuE,KAAKiuE,SACLW,EAAiBnwB,aAAc,MAE9B,CACD,MAAMgxB,EAAczvE,KAAKguE,iBAAiB5tE,IAAIJ,KAAK0vE,eAC7C5lB,EAAelqB,EAAUkb,cAAcr/C,OAC7Cg0E,EAAYiB,eAAe5mB,EAAc5tD,EAAU0yE,EACvD,EACA,EAAAzvB,EAAAnY,GAAsChnC,KAAKkuE,WAAWrvB,oBAC1D,CACA,qCAAAgwB,CAAsC1hD,GAClC,MAAMgrC,EAASn4D,KAAKyM,cACdnR,GAAiB,IAAA48B,mBAAkB/K,IACnC,kBAAEjB,EAAiB,WAAEgB,GAAe5xB,EACpCq1E,EAAwB,GAExBxQ,GADY,IAAAna,yBAAwB94B,EAAYhB,GACvBynC,gBAAgBwE,EAAO4V,oBAOtD,OANA5V,EAAO0V,oBAAoB5sE,SAAS8sE,IAChC,MAAMxtB,GAAc,QAAewtB,EAAoB5gD,GACnDozB,GACAowB,EAAsBhoE,QAAQ43C,EAClC,IAEG4f,EAAa3f,wCAAwCrzB,EAASwjD,EACzE,CACA,iBAAArC,CAAkBr2B,GACMj4C,KAAKguE,iBAAiB5tE,IAAIJ,KAAK0vE,eACvCpB,kBAAkBr2B,EAClC,CACA,gBAAAk4B,CAAiBH,GACb,MAAMK,EAAuBrwE,KAAK4wE,qBAAqBZ,GACvD,IAAIa,EAAmB,EACvB,IAAK,IAAInnE,EAAI,EAAGA,EAAI2mE,GAAsBzvE,OAAQ8I,IAAK,CACnD,MAAMoJ,EAAcu9D,EAAqB3mE,GAAK,EAAImnE,EAClD7wE,KAAK8wE,qBAAqBh+D,GAC1B+9D,GACJ,CACJ,CACA,oBAAAD,CAAqBZ,GACjB,MAAM,OAAEvhE,EAAM,WAAEqhE,GAAe9vE,KAAK2vE,WAC9BU,EAAuB,GAC7B,IAAK,IAAI3mE,EAAIsmE,EAAcE,MAAOxmE,GAAKsmE,EAAcntE,KAAM6G,IACvD1J,KAAKowE,kCAAkC1mE,EAAG+E,EAAQ4hE,EAAsBP,GAE5E,OAAOO,CACX,CACA,oBAAAS,CAAqBh+D,GACjB,MAAM,OAAErE,GAAWzO,KAAK2vE,WACxB,GAAI78D,EAAcrE,EAAO7N,OAAS,GAC9BZ,KAAKkuE,WAAWE,qBAChB,OAEJ,MAAMqB,EAAczvE,KAAKguE,iBAAiB5tE,IAAIJ,KAAK0vE,eAC7CqB,EAAgBj+D,EAAc,EAC9Bk+D,EAAYT,GAAaz9D,EAAarE,EAAO7N,QAE7CqwE,EADiBxB,EAAYyB,kBAAkBH,EAAeC,EAAWhxE,KAAK2vE,YAEpFlhE,EAAOwE,OAAOH,EAAa,EAAGm+D,EAClC,CACA,kBAAA1C,CAAmB3uC,GACf,MAAMuxC,EAAuBnxE,KAAKoxE,gCAAgCxxC,QACrC5hC,IAAzBmzE,IAGJnxE,KAAKkuE,WAAWC,oBAAsBgD,EAC1C,CACA,+BAAAC,CAAgCxxC,GAC5B,MAAM,QAAEzS,GAAYyS,EACdtkC,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACf68D,EAASn4D,KAAKyM,cACd8zC,EAAcvgD,KAAK6uE,sCAAsC1hD,GAC/D,IAAKozB,GAAa3/C,OACd,OAEJ,MAAMmmE,EAAennC,EAAUkb,cAAcr/C,OACvCulE,EAAU,CACZhlD,SAAUrF,IACV06D,eAAWrzE,EACXuhD,mBAAevhD,GAEnB,IAAK,IAAI0L,EAAI,EAAGA,EAAI62C,GAAa3/C,OAAQ8I,IAAK,CAC1C,GAAI62C,EAAY72C,GAAG4nE,WAAa/wB,EAAY72C,GAAG6nE,UAC3C,SAEJ,MAAMC,GAAmB,EAAAC,GAAA,GAAuBv1E,EAAUqkD,EAAY72C,GAAIq9D,IAChD,IAAtByK,IAGAA,EAAmBxQ,EAAQhlD,WAC3BglD,EAAQhlD,SAAWw1D,EACnBxQ,EAAQqQ,UAAY3nE,EACpBs3D,EAAQzhB,cAAgBgB,EAAY72C,GAAG61C,eAE/C,CAKA,OAJAv/C,KAAKkuE,WAAWE,sBACX7tB,EAAYygB,EAAQqQ,WAAWnkE,KAAK2gC,QAAQ4B,OACjD0oB,EAAO4V,mBACHxtB,EAAYygB,EAAQqQ,WAAWnqE,SAASuxC,SACrCuoB,EAAQzhB,aACnB,CACA,cAAAivB,CAAerhD,GACXA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAK0uE,aAC/CvhD,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAK0uE,aAClDvhD,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKgvE,cACjD7hD,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAK0uE,aAChDvhD,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAK0uE,aAChDvhD,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKgvE,aACrD,CACA,gBAAAL,CAAiBxhD,GACbA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAK0uE,aAClDvhD,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAK0uE,aACrDvhD,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKgvE,cACpD7hD,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAK0uE,aACnDvhD,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAK0uE,aACnDvhD,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKgvE,aACxD,CACA,YAAAM,CAAaxB,GACT9tE,KAAK0vE,cACD1vE,KAAKguE,iBAAiB5tE,IAAI0tE,IAAcsB,GAAA,EAAmBC,SACnE,CACA,gBAAAjvB,CAAiB9kD,EAAgB+kD,GAC7B,MAAM,SAAEnkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACd2iD,EAAsB7+C,KAAKkuE,WAAWrvB,oBAC5C,IAAK7+C,KAAKkuE,WAAWG,gBACjBruE,KAAK++D,OAAS,EAAA/yB,UAAUH,SACvBgT,EAAoBhkC,SAAS3e,EAASmN,IACvC,OAEJ,MAAMk3C,EAAcvgD,KAAK6uE,sCAAsC1hD,GAC/D,IAAKozB,GAAa3/C,OACd,OAEJ,MAAM6/C,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAIjN,GAAQ,QAAiB,QAASqkD,EAAgB,EAAAixB,sBAAsBC,QAAS3xE,KAAK++D,MACtF/+D,KAAKiuE,WACL7xE,GAAQ,QAAiB,QAASqkD,EAAgB,EAAAixB,sBAAsBE,YAAa5xE,KAAK++D,OAE1E/+D,KAAKguE,iBAAiB5tE,IAAIJ,KAAK0vE,eACvCmC,YAAYxxB,EAAkBrgD,KAAKkuE,WAAWG,eAAgB,CACtEjyE,SAER,EAEG,MAAMm0E,GAAe,CAAC7mE,EAAG9I,KACpB8I,EAAI9I,GAAUA,EAE1B+sE,GAAal1B,SAAW,eACxB,MC7RMq5B,GAGC,CAAC,EAAG,EAAG,GAGd,MAAMC,WAAyB,MAC3B,WAAAtyE,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXxE,UAAW6pE,GACXn5B,uBAAwB,MAG5BvB,MAAMS,EAAWC,EACrB,CACA,kBAAA0K,CAAmBvK,GACf,MAAM,QAAE9qB,EAAO,MAAE41B,GAAU9K,EAAI3lB,OACzBh3B,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,UAAE2M,EAAS,uBAAE0wC,GAA2B34C,KAAKyM,cAC7CgU,EAASvkB,EAASwkB,aAClB,OAAE0hB,EAAM,SAAExU,EAAQ,WAAEhN,GAAeH,GACjCxY,UAAWs6C,GAAWQ,GACvB7f,EAAIC,EAAIC,GAAMxiB,GACdoxD,EAAIC,EAAIC,GAAMjqE,EACfnL,EAASylD,GAAU5J,EAAyB17C,KAAKC,IAAO,IACxD21B,EAAc,CAAC,EAAG,EAAG,GACrBoM,EAAgB,CAAC,EAAG,EAAG,GACvB4b,EAAY,CAAC,EAAG,EAAG,GACnBp+C,EAAY,cAAc,IAAIwM,aAAa,KACjD,eAAexM,EAAWA,EAAW,CAACymC,EAAIC,EAAIC,IAC9C,YAAY3mC,EAAWA,EAAWK,EAAO,CAACk1E,EAAIC,EAAIC,IAClD,eAAez1E,EAAWA,EAAW,EAAEymC,GAAKC,GAAKC,IACjD,mBAAmBvQ,EAAajF,EAAUnxB,GAC1C,mBAAmBwiC,EAAere,EAAYnkB,GAC9C,cAAcA,GACd,YAAYA,EAAWA,EAAWK,EAAO,CAACk1E,EAAIC,EAAIC,IAClD,mBAAmBr3B,EAAWzY,EAAQ3lC,GACtCP,EAASijC,UAAU,CACfvR,SAAUiF,EACVuP,OAAQyY,EACRj6B,WAAYqe,IAEhB/iC,EAASD,QACb,EAEJ81E,GAAiBt5B,SAAW,yB,gBCtC5B,MAAM05B,WAAkB,aACXnyE,KAAKy4C,SAAW,OAAS,CAClC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACR0rB,mBACAC,sBACArK,2BAA2B,KAG/B5wB,MAAMS,EAAWC,GACjB93C,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAEikD,GAAkB3Q,EACpBtgC,EAAQsgC,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GACvC2mD,EAA6Bl5D,EAASwjD,cAAcpxC,GAE1D,GADa,cAAcw7C,EAAcsL,GAC9BrL,EACP,OAAO,EAEX,MAAMuoB,EAAWnlD,EAAQkpC,cAAc,OACvC,IAAKic,EACD,OAAO,EAEX,MAAMC,EAAYD,EAASjc,cAAc,0BAA0B9W,OACnE,IAAKgzB,EACD,OAAO,EAEX,MAAMC,EAAmBD,EACnBE,EAAOD,EAAiBE,UACxBj2E,EAAY+1E,EAAiBG,aAAa,aAChD,IAAIC,EAAa,EACbC,EAAa,EACjB,GAAIp2E,EAAW,CACX,MAAMq2E,EAAUr2E,EAAUoP,MAAM,sCAC5BinE,IACAF,EAAan8D,WAAWq8D,EAAQ,IAChCD,EAAap8D,WAAWq8D,EAAQ,IAExC,CACA,MAAMx1E,EAAIm1E,EAAKn1E,EAAIs1E,EACbp1E,EAAIi1E,EAAKj1E,EAAIq1E,EAKnB,OAJe/oB,EAAa,IAAMxsD,GAC9BwsD,EAAa,IAAMxsD,EAAIm1E,EAAK71E,OAC5BktD,EAAa,IAAMtsD,GACnBssD,EAAa,IAAMtsD,EAAIi1E,EAAK51E,MACnB,EAEjBmD,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACrB,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf2Q,cAAe,KACfd,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACF6lE,KAAM,GACNp0B,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,KAEhCmS,MAAO,MAGf,IAAAs2B,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAsBzE,OArBA1+C,KAAK++C,SAAW,CACZnQ,aACA4qB,eAAe,EACf3a,sBACAvxC,OAAQ,CAAC,EAAG,EAAG,IAEnB2qC,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GACtC7+C,KAAKyM,cAAc2lE,iBAAiBW,IAChC,IAAKA,EAID,OAHA,IAAArrB,kBAAiB9Y,EAAW2Q,gBAC5B,EAAAJ,EAAA,GAAsCN,QACtC7+C,KAAKs+C,WAAY,IAGrB,KAAAgB,oBAAmBnyB,GACnByhB,EAAW1hC,KAAK6lE,KAAOA,GACvB,KAAAvzB,4BAA2B5Q,IAC3B,EAAAuQ,EAAA,GAAsCN,EAAoB,IAE9D7+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,eAAe,IAC/C5qB,CAAU,EAErB5uC,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,cAAE2tB,GAAkB/rB,EACnC6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE,IAAIpxC,EAAS,CAAC,EAAG,EAAG,GACpB,GAAIwtC,GAAiBA,EAAcxC,MAAO,CACtC,MAAM06B,EAAkBl4B,EAAcxC,MAChC26B,EAAiBrkC,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GACtDnB,EAAS,CACL2lE,EAAe,GAAKD,EAAgB,GACpCC,EAAe,GAAKD,EAAgB,GACpCC,EAAe,GAAKD,EAAgB,GAE5C,CACAhzE,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAvxC,UAEJtN,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,SAChE/+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACfqsC,GACAx5D,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBAE3Cx5D,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKkzE,eACDlzE,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKk4C,cAAiBD,IAClB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,OACzB,WAAE1J,EAAU,oBAAEiQ,EAAmB,OAAEvxC,GAAWtN,KAAK++C,SAErDnQ,EAAW1hC,KAAKyxC,QAAQlwC,OAAO,GAD/BnB,EACoC,CAChCkS,EAAS,GAAKlS,EAAO,GACrBkS,EAAS,GAAKlS,EAAO,GACrBkS,EAAS,GAAKlS,EAAO,IAIW,IAAIkS,GAE5CovB,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYC,YAAY,EAE3EhvC,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAEXC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,GACpE,MAAME,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,EAC1BtgC,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAClCgyC,EAAelB,cAAgBA,EAC/B,MAAMmB,EAAoBxkD,EAASwjD,cAAcpxC,GAEjD,GADAgyC,GAAe,GACVpkD,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,IAAKryC,EAAK6lE,KACN,SAEJ,MAAM3uE,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GACrDwkC,EAAa,KACnB,IAAA9F,aAAejtB,EAAkBd,EAAe6zB,EAAY,CAAClmE,EAAK6lE,MAAOryB,EAAmB,IACrFt8C,EACHozD,QAAS,GAEjB,CACA,OAAOlX,CAAY,CAE3B,QACStgD,KAAKqzE,QAAU,CAACnmD,EAAYU,EAAUmlD,EAAM3uE,KACjD,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACf0O,EAAsB9N,EAASsiD,0BAC/B,gBAAE/+B,EAAe,OAAE2iB,GAAWlmC,EAASwkB,YACvC4yD,EAAW,IAAItzE,KACfuG,EAAoB+sE,EAAS/0B,qBAAqBriD,EAAU0xB,EAAUnO,EAAiB2iB,GACvFwM,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACF6lE,OACAp0B,QAAS,CACLlwC,OAAQ,CAACmf,KAGjB6wB,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,sBAAA64C,CAAuBjK,EAAKrJ,EAAY0qB,EAAQrP,GAAmB,CACnE,yBAAAupB,CAA0BrmD,EAASyhB,EAAY6kC,GAC3C7kC,EAAW1hC,KAAK6lE,KAAOU,EACvB,MAAM50B,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,gBACzE,EAAAS,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAC1C,CACA,eAAAumD,CAAgBC,EAAQC,EAAQ/rE,GAC5B,OAAQ,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,EAC9C,EAEJ,SAASuqE,GAAgByB,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAASzB,GAAmBnlE,EAAM0yB,EAAWi0C,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,CACA3B,GAAU15B,SAAW,QACrB,MC9TQ3W,sBAAqB,IAAK,YAClC,MAAMiyC,WAAmB,aACZ/zE,KAAKy4C,SAAW,QAAU,CACnC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXu7D,2BAA2B,EAC3BgM,aAAcC,GACdxc,QAAS,CACLzlC,KAAM,CACF2lC,OAAQ,OACRC,SAAU,CAAC,CAAEz3D,IAAK,OAEtByyB,KAAM,CACF+kC,OAAQ,OACRC,SAAU,CAAC,CAAEz3D,IAAK,WAK9Bi3C,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACrB,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM,gBAAE7+B,EAAe,OAAE2iB,EAAQxU,SAAU+5B,GAAoBzrD,EAASwkB,YAClEna,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFwM,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,IACHhL,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,KACxCi5B,SAAUz4C,KAAK0+C,cACfn4C,oBACA67B,SACAulB,kBAEJz6C,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACVma,EAAQE,GAAU/7C,EAAKyxC,QAAQlwC,OAChC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCgG,EAAO,CACTvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAIxB,OADwB,mBAA4B,CAACnlB,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACpHC,CAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACb4qB,IAAkBE,IAGtBxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACfntB,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GACtC7+C,KAAKkzE,eACD1Z,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EAAK,EAE1Bt+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,UACvF,KAAE7xC,GAAS0hC,EAEjB,GADA5uC,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACnC0a,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QAC3C8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,EAAQ,OAAE8F,GAAW1mD,KAAK6gD,mBAAmB,CACnEjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAYnE,GAXKxB,EAAK0xC,YAAYz6B,IACiB,MAAnCjX,EAAK0xC,YAAYz6B,GAAUmwD,KAOtB1lC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IAPjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBvjB,OAAQ,KACR0zE,KAAM,MAEVt0E,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAKvDY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,KAAAC,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAwkD,WACAD,aAER,CACA,MAAMG,EAAS,GAAGvB,SACZ+P,EAAU,IAQhB,IAPA,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO+jD,EACPC,WACA8F,UACD5F,GACHR,GAAe,GACVpkD,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKjX,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAM,MAAEZ,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,QACSh1E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYlB,GAAYz4E,EAAgBmT,EAAQrK,GACxIwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,EAAAjT,UAAA,SACzCp/B,KAAM,CACFyxC,QAAS,CACLlwC,WAGRgwC,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,sBAAA64C,CAAuBjK,EAAKrJ,EAAY0qB,GACpC,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,gBAAAg2B,CAAiBC,EAAMC,GACnB,MAAM1yD,EAAKyyD,EAAK,GAAKC,EAAK,GACpBzyD,EAAKwyD,EAAK,GAAKC,EAAK,GACpBxyD,EAAKuyD,EAAK,GAAKC,EAAK,GAC1B,OAAOn4E,KAAKwmC,KAAK/gB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAC9C,CACA,qBAAA4xD,CAAsB5lC,EAAYj1B,EAAiBre,GAC/C,MAAM4R,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAY7xB,EAAeY,SAC7Bm5E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,UAAE6mB,EAAS,WAAExa,GAAerM,EAC5Bm4E,EAAS,GAAsBtxD,EAAWgzD,GAC1CzB,EAAS,GAAsBvxD,EAAWizD,GAC1C32B,EAAU,CAACg1B,EAAQC,IACnB,MAAEp3E,EAAK,KAAE83E,IAAS,QAAiC94E,EAAOmjD,GAC1D/9C,EAASZ,KAAKk1E,iBAAiBG,EAAWC,GAAa94E,EACzDwD,KAAK0zE,gBAAgBC,EAAQC,EAAQ/rE,GACrC7H,KAAKooE,sBAAuB,EAG5BpoE,KAAKooE,sBAAuB,EAEhCxpB,EAAYz6B,GAAY,CACpBvjB,SACA0zE,OAER,CACA,MAAM/4E,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CACX,CACA,eAAA80B,CAAgBC,EAAQC,EAAQ/rE,GAC5B,OAAQ,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,EAC9C,EAEJ,SAASosE,GAAoB/mE,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,OAAEvjB,EAAM,KAAE0zE,GAASmB,EACzB,GAAI70E,SAA2C4b,MAAM5b,GACjD,OAGJ,MADkB,CAAC,GAAG,wBAAoBA,MAAW0zE,IAEzD,CACA,MCrcQxyC,sBAAqB,IAAK,YAClC,MAAM4zC,WAAmB,aACZ11E,KAAKy4C,SAAW,QAAU,CACnC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXu7D,2BAA2B,EAC3BgM,aAAc,MAGlB58B,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,GACtC,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM,gBAAE7+B,EAAe,OAAE2iB,EAAQxU,SAAU+5B,GAAoBzrD,EAASwkB,YAClEna,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFwM,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,IACHhL,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,KACxCi5B,SAAUz4C,KAAK0+C,cACfn4C,oBACA67B,SACAulB,kBAEJz6C,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACVma,EAAQE,GAAU/7C,EAAKyxC,QAAQlwC,OAChC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCgG,EAAO,CACTvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAIxB,OADwB,mBAA4B,CAACnlB,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACpHC,CAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IACK,IAAA+K,mBAAkB/K,IACzC,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACxB0E,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,GAAkBl0E,KAAK++C,UACvE,KAAE7xC,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACV,IAAAvgC,mBAAkB/K,GAMzC,OALA,EAAAgyB,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QAC3C8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,EAAQ,OAAE8F,GAAW1mD,KAAK6gD,mBAAmB,CACnEjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE,IAAIwrD,EAYJ,GAXKhtD,EAAK0xC,YAAYz6B,IACiB,MAAnCjX,EAAK0xC,YAAYz6B,GAAUmwD,KAOtB1lC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IAPjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBvjB,OAAQ,KACR0zE,KAAM,MAEVt0E,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,MAKvD,KAAA6+D,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAwkD,WACAD,aAER,CACA,MAAMg1B,EAAY,IAOlB,IANA,IAAAC,YAAcv1B,EAAkBd,EAAeo2B,EAAWj1B,EAAkB,GAAIA,EAAkB,GAAI,CAClGtkD,QACAQ,MAAO+jD,EACPC,SAAUA,IAEdN,GAAe,GACVpkD,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKjX,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,sBAAA9yB,CAAuBjK,EAAKrJ,EAAY0qB,GACpC,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,gBAAA22B,CAAiBV,EAAMC,GACnB,MAAM1yD,EAAK0yD,EAAK,GAAKD,EAAK,GACpBxyD,EAAKyyD,EAAK,GAAKD,EAAK,GACpBvyD,EAAKwyD,EAAK,GAAKD,EAAK,GAC1B,OAAU,GAANzyD,EACU,GAANC,EACO1lB,KAAK6e,IAAI8G,GAGT,EAGA,GAAND,EACE1lB,KAAK6e,IAAI8G,GAEL,GAANA,EACE3lB,KAAK6e,IAAI6G,QADf,CAGT,CACA,qBAAA6xD,CAAsB5lC,EAAYj1B,EAAiBre,GAC/C,MAAM4R,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAY7xB,EAAeY,SAC7Bm5E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,UAAE6mB,EAAS,WAAExa,GAAerM,EAC5Bm4E,EAAS,GAAsBtxD,EAAWgzD,GAC1CzB,EAAS,GAAsBvxD,EAAWizD,GAC1C32B,EAAU,CAACg1B,EAAQC,IACnB,MAAEp3E,EAAK,KAAE83E,IAAS,QAAiC94E,EAAOmjD,GAC1D9hD,EAASmD,KAAK61E,iBAAiBR,EAAWC,GAAa94E,EACvDs5E,EAAU91E,KAAK0zE,gBAAgBC,EAAQC,EAAQ/rE,GACrD7H,KAAKooE,qBAAuB0N,EAC5Bl3B,EAAYz6B,GAAY,CACpBtnB,SACAy3E,OAER,CACA,MAAM/4E,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CACX,CACA,eAAA80B,CAAgBC,EAAQC,EAAQ/rE,GAC5B,OAAQ,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,EAC9C,EAEJ,SAAS,GAAoBqF,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,OAAEtnB,EAAM,KAAEy3E,GAASmB,EACzB,GAAI54E,SAA2C2f,MAAM3f,GACjD,OAGJ,MADkB,CAAC,GAAG,wBAAoBA,MAAWy3E,IAEzD,C,gBCraA,MAAQxyC,sBAAqB,IAAK,YAClC,MAAMi0C,WAAkB,aACX/1E,KAAKy4C,SAAW,OAAS,QACzBz4C,KAAKg2E,cAAgB,CAC1Bj+B,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAc,GACdhtB,aAAc,KAEnB,CACH,WAAAvnD,CAAYo4C,EAAY,CAAC,EAAGC,GACxBV,MAAMS,EAAW,MAAeo+B,kBAAkBF,GAAUC,cAAel+B,IAC3E93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM1P,EAAc5uC,KAAgB,YAAEk2E,4BAA4Bh6E,EAAU,CACxEgR,KAAM,CACFyxC,QAAS,CAAElwC,OAAQ,CAAC,IAAI+Q,SAGhC,IAAAyoC,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAUzE,OATA1+C,KAAK++C,SAAW,CACZnQ,aACA4qB,eAAe,EACf3a,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,WAAE7xB,EAAU,gBAAEvT,IAAoB,IAAAue,mBAAkB/K,GAC1DntB,KAAKm2E,oBAAsB,CACvBjpD,aACAhB,kBAAmBvS,EAAgBtQ,IAEvCrJ,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACfqsC,GACAx5D,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBAE3Cx5D,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKkzE,eACDlzE,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,OACzB,WAAE1J,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACjB5uC,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvCtsD,EAAKyxC,QAAQlwC,OAAO,GAAK,IAAI+Q,GAC7BovB,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,GACzB61C,EAAgB3Q,EAAW2Q,cAC3BryC,EAAO0hC,EAAW1hC,KAClBoB,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAC5BiyC,EAAoBxkD,EAASwjD,cAAcpxC,GACjDmyC,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,GAAc3gD,KAAK6gD,mBAAmB,CACjDjS,aACA6R,mBAKJ,GAHKvzC,EAAK0xC,cACN1xC,EAAK0xC,YAAc,CAAC,GAEnB1xC,EAAK0xC,YAAYz6B,IACmB,OAArCjX,EAAK0xC,YAAYz6B,GAAUlkB,OAQ1B,GAAI2uC,EAAWrzC,cAChByE,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,GACpDY,aAAoB,EAAAsyC,gBAAgB,CACpC,MAAM,kBAAEjoC,GAAsBqoC,EAAW1nC,SACzC,IAAK,MAAMid,KAAYjX,EAAK0xC,YACxB,GAAIz6B,EAASnjB,WAAW,WAAY,CACd2Y,EAAgBy8D,oBACC14D,MAAM4H,IACrC,MAAM+wD,EAAqB,yBAAqB9vE,GAC1CitB,EAAclO,EAAGkO,YAAY6iD,GAC7BC,EAAkB,yBAAqBhxD,EAAGia,qBAChD,OAAO/L,GAAe8iD,IAAoBD,CAAkB,YAGrDnpE,EAAK0xC,YAAYz6B,EAEhC,CAER,OAzBAjX,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVn7B,MAAO,KACPvI,MAAO,MAEXD,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,EAAgB,EAAAyzC,YAAYymC,cAsBxF,IAAKt5E,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,MAAM8Z,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB,CAAC1Z,GAAoB,CAAEtkD,QAAOukD,YAAWqG,aAAchnD,KAAKyM,cAAcu6C,eAC1I1G,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WACT,SAEJ,MAAM8mD,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,GAAIswD,EAAW,CACX,MAAMtH,EAAwB,CAC1BzsB,EAAkB,GAAK,EACvBA,EAAkB,GAAK,GAErB61B,EAAU,KAChB,IAAAjJ,aAAejtB,EAAkBd,EAAeg3B,EAAS9B,EAAW,CAACtH,EAAsB,GAAIA,EAAsB,IAAK/oE,EAC9H,CACJ,CACA,OAAOk8C,CAAY,CAE3B,CACA,eAAA0B,CAAgB70B,EAASyhB,EAAYkb,EAAcC,GAC/C,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,EACXtgC,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAC5B2mD,EAA6Bl5D,EAASwjD,cAAcpxC,GAC1D,OAAO,cAAcw7C,EAAcsL,GAA8BrL,CACrE,CACA,oBAAA9H,GAAyB,QAChBjiD,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,OAAE2iB,EAAM,SAAEkxC,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYc,GAAWz6E,EAAgBmT,EAAQrK,GAC/IwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACFyxC,QAAS,CACLlwC,WAGRgwC,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,uBAAAiiD,CAAwBn+B,EAASyhB,EAAYkb,EAAcC,GACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,EACXtgC,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAC5B2mD,EAA6Bl5D,EAASwjD,cAAcpxC,GAE1D,IAAa,IADA,cAAcw7C,EAAcsL,GAA8BrL,EAEnE,OAAOz7C,CAEf,CACA,sBAAA4zC,CAAuBjK,EAAKrJ,GACxB,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,qBAAAs1B,CAAsB5lC,EAAYj1B,EAAiBre,EAAgBk7E,EAAa,EAAAznC,YAAYymC,cACxF,MAAMtoE,EAAO0hC,EAAW1hC,MAClB,kBAAEgf,EAAiB,SAAEhwB,GAAaZ,GAClC,QAAE6xB,GAAYjxB,EACdsjB,EAAWtS,EAAKyxC,QAAQlwC,OAAO,IAC/B,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrB+sE,EAAoB,CACtBl4E,aAAa,EAAAm4E,GAAA,GAAoBx6E,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpE/K,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAEwa,EAAS,SAAEnb,EAAQ,aAAElC,GAAiBxJ,EACpD2C,EAAW+I,EAASy8B,SAC1B,IAAIizC,EAAM,GAAsBv0D,EAAW7C,GAE3C,GADAo3D,EAAM,WAAWA,EAAKA,GAClB,kCAA8BA,EAAK/uE,GAAa,CAChD7H,KAAKooE,sBAAuB,EAC5B,IAQIyO,EARA52E,EAAQ+E,EAAa8xE,cAAcF,GACvC,GAAIzyD,EAASnjB,WAAW,YAAa,CACjC,MAAMmD,EAAUggB,EAAS/hB,MAAM,YAAY,GACrCupB,EAAW,yBAAqBxnB,GAEhCjI,EADY,qCAAiCyvB,GACxB,GAC3BirD,EAAI,GAAK16E,EAAS23B,wBACtB,CAEA,GAAiB,OAAb11B,EAAmB,CACnB,MAAM44E,GAAoB,QAAgCv7E,EAAO,CAC7Do7E,IAEEI,EAA0BD,EAAkBp8D,OAAO4R,OAAOtsB,GAAoB,OAAVA,IAC1EA,EAAS+2E,EAA0BD,EAAkBp8D,OAAS1a,EAC9D42E,EAAeG,EACTD,EAAkBE,MAClB,KACV,MAEIJ,GAAe,EAAAK,EAAA,GAAmB/4E,EAAUywC,EAAW1nC,SAASX,kBAAmBkwE,GAEvF73B,EAAYz6B,GAAY,CACpB3b,MAAOouE,EACP32E,QACA0jC,SAAUxlC,EACV04E,eAER,MAEI72E,KAAKooE,sBAAuB,EAC5BxpB,EAAYz6B,GAAY,CACpB3b,MAAOouE,EACPjzC,SAAUxlC,EAGtB,CACA,MAAM5C,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAASqpD,GAE5C53B,CACX,EAEJ,SAAS,GAAoB1xC,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,MAAE3b,EAAK,MAAEvI,EAAK,aAAE42E,GAAiBpB,EACvC,QAAcz3E,IAAViC,IAAwBuI,EACxB,OAEJ,MAAMisE,EAAY,GAElB,GADAA,EAAU9rE,KAAK,IAAIH,EAAM,OAAOA,EAAM,OAAOA,EAAM,OAC/CvI,aAAiBvB,OAASm4E,aAAwBn4E,MAClD,IAAK,IAAIgL,EAAI,EAAGA,EAAIzJ,EAAMW,OAAQ8I,IAC9B+qE,EAAU9rE,KAAK,GAAG,wBAAoB1I,EAAMyJ,OAAOmtE,EAAantE,WAIpE+qE,EAAU9rE,KAAK,GAAG,wBAAoB1I,MAAU42E,KAEpD,OAAOpC,CACX,CACA,YCnWA,MAAM0C,WAAsB,UACfn3E,KAAKy4C,SAAW,WAAa,CACtC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAc,MAGlB58B,MAAMS,EAAWC,GACjB93C,KAAKo3E,sBAAyBn/B,IAC1B,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFwM,EAAa,CACfrzC,aAAa,EACbkjD,aAAa,EACb8yB,WAAW,EACXrqE,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,oBAAqB9N,EAASsiD,yBAC9Bj4C,qBAEJ2G,KAAM,CACFykB,MAAO,GACPgtB,QAAS,CAAElwC,OAAQ,CAAC,IAAI+Q,KACxBo/B,YAAa,CAAC,IAGhBC,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAUzE,OATA1+C,KAAK++C,SAAW,CACZnQ,aACA4qB,eAAe,EACf3a,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKq3E,uBAA0Bp/B,GACpBj4C,KAAKo3E,sBAAsBn/B,GAEtCj4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,EACrB,IAAK0E,KAAK++C,SACN,OAAOuB,EAEX,MAAMC,EAAcvgD,KAAKwgD,wCAAwCtkD,EAASixB,QAAS,CAACntB,KAAK++C,SAASnQ,aAClG,IAAK2R,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAElCulC,EAAa5uC,KAAK++C,SAASnQ,WAC3B2Q,EAAgB3Q,EAAW2Q,cAC3BryC,EAAO0hC,EAAW1hC,KAClBoB,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAC5BiyC,EAAoBxkD,EAASwjD,cAAcpxC,GACjDmyC,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,GAAU4D,KAAK6gD,mBAAmB,CACtCjS,aACA6R,mBAcJ,GAZKvzC,EAAK0xC,YAAYz6B,IACmB,OAArCjX,EAAK0xC,YAAYz6B,GAAUlkB,MAQtB2uC,EAAWrzC,aAChByE,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,IARxD4R,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVn7B,MAAO,KACPvI,MAAO,MAEXD,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAKvDY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,GAGX,IAAA6P,aAAe9P,EAAkBd,EADV,IACyC,CAACmB,GAAoB,CAAEtkD,UACvFkkD,GAAe,EACf,MAAMm0B,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,GAAIswD,EAAW,CACX,MAAMtH,EAAwB,CAC1BzsB,EAAkB,GAAK,EACvBA,EAAkB,GAAK,GAErB61B,EAAU,KAChB,IAAAjJ,aAAejtB,EAAkBd,EAAeg3B,EAAS9B,EAAW,CAACtH,EAAsB,GAAIA,EAAsB,IAAKntE,KAAKmzE,sBAAsB1yB,EAAgB7R,GACzK,CACA,OAAO0R,CAAY,CAE3B,EAEJ,SAAS,GAAoBpzC,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,MAAE3b,EAAK,MAAEvI,EAAK,aAAE42E,GAAiBpB,EACvC,QAAcz3E,IAAViC,EACA,OAEJ,MAAMw0E,EAAY,GAGlB,OAFAA,EAAU9rE,KAAK,IAAIH,EAAM,OAAOA,EAAM,OAAOA,EAAM,OACnDisE,EAAU9rE,KAAK,GAAG1I,EAAMy6B,QAAQ,MAAMm8C,KAC/BpC,CACX,C,gDC5GA,MAAQ3yC,sBAAqB,IAAK,YAClC,MAAMw1C,WAA0B,aACnBt3E,KAAKy4C,SAAW,eAAiB,CAC1C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BuP,gBAAgB,EAChBC,kBAAmB,EACnBxD,aAAc,GACdyD,gBAAiB,GAAAC,wBAGrBtgC,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MAEzBh9C,GADYw/C,EAAcr/C,QACT,IAAAy8B,mBAAkB/K,KACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFykB,MAAO,GACPgtB,QAAS,CACLiqB,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5Bt0D,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERi5C,kBAAmB,MAEvB7Z,YAAa,CAAC,EACd+4B,gBAAiBz7E,EAAS07E,iBAGlC,IAAA3vB,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAvE,YAAa96B,EACbg6C,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DmpE,GAAgB,KAAAC,yBAAwBp3B,IACvCyzB,EAAcC,GAAgByD,EAC/BE,EAAe,CACjB52B,KAAMlkD,KAAKa,IAAIq2E,EAAa,GAAIC,EAAa,IAAMrqB,EAAY,EAC/Dp1C,IAAK1X,KAAKa,IAAIq2E,EAAa,GAAIC,EAAa,IAAMrqB,EAAY,EAC9DntD,MAAOK,KAAK6e,IAAIq4D,EAAa,GAAKC,EAAa,IAAMrqB,EACrDltD,OAAQI,KAAK6e,IAAIq4D,EAAa,GAAKC,EAAa,IAAMrqB,GAEpDiuB,EAAe,CACjB72B,KAAMlkD,KAAKa,IAAIq2E,EAAa,GAAIC,EAAa,IAAMrqB,EAAY,EAC/Dp1C,IAAK1X,KAAKa,IAAIq2E,EAAa,GAAIC,EAAa,IAAMrqB,EAAY,EAC9DntD,MAAOK,KAAK6e,IAAIq4D,EAAa,GAAKC,EAAa,IAAMrqB,EACrDltD,OAAQI,KAAK6e,IAAIq4D,EAAa,GAAKC,EAAa,IAAMrqB,GAEpDkuB,EAAsBj4E,KAAKk4E,sBAAsBH,EAAcjuB,GAErE,SAD4B9pD,KAAKk4E,sBAAsBF,EAAcluB,IACzCmuB,EAGhB,EAEhBj4E,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,IAEnB,KAAAj1B,mBAAkB9xB,GAClBntB,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EACAhW,EACAjJ,EACA1lB,EACAC,EACAsjD,EANAjE,GAAgB,EAOpB,GAAI5a,EAAOuP,cACPqL,GAAgB,MAEf,CACD,MAAM,OAAEzlE,GAAWvB,EAAKyxC,SAClB,SAAEziD,IAAa,IAAAg8B,mBAAkB/K,IACjC,cAAEuyB,EAAa,cAAEtwB,GAAkBlzB,EACzCq9D,EAAc9qD,EAAO+D,WAAW9D,GAAMA,IAAM4qD,IAC5C,MAAM8e,EAAe3pE,EAAOpI,IAAIq5C,GAChCy4B,EAAuBC,EAAa7e,GACpC3kC,EAAc33B,KAAK6e,IAAIs8D,EAAa,GAAG,GAAKA,EAAa,GAAG,IAC5DvjD,EAAe53B,KAAK6e,IAAIs8D,EAAa,GAAG,GAAKA,EAAa,GAAG,IAC7D70B,EAAe,EACV60B,EAAa,GAAG,GAAKA,EAAa,GAAG,IAAM,GAC3CA,EAAa,GAAG,GAAKA,EAAa,GAAG,IAAM,GAEhD99B,EAAclrB,EAAcm0B,EAChC,CACA,MAAM1E,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA3kC,cACAC,eACAylB,cACA69B,uBACAjE,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACb4qB,IAAkBE,IAGtB15D,KAAKkzE,eACLtkC,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAC/B,EAEJ5uC,KAAKy5D,kBAAqBxhB,IACtBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCH,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAE8zB,GAAkBlzB,GACpB,WAAE0yC,EAAU,oBAAEiQ,EAAmB,YAAEvE,EAAW,cAAEkf,GAAkBx5D,KAAK++C,SAC7E/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAMjW,EAAernD,EAASwjD,cAAcpF,IACtC,KAAEptC,GAAS0hC,EACXypC,EAAKp7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpD+0B,EAAKr7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpDg1B,EAAe,CAACh1B,EAAa,GAAIA,EAAa,GAAK+0B,GACnDE,EAAY,CAACj1B,EAAa,GAAIA,EAAa,GAAK+0B,GAChDG,EAAa,CAACl1B,EAAa,GAAK80B,EAAI90B,EAAa,IACjDm1B,EAAc,CAACn1B,EAAa,GAAK80B,EAAI90B,EAAa,IACxDr2C,EAAKyxC,QAAQlwC,OAAS,CAClB2gB,EAAcmpD,GACdnpD,EAAcopD,GACdppD,EAAcqpD,GACdrpD,EAAcspD,IAElB9pC,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAAe,EAE9E/uE,KAAK25D,oBAAuB1hB,IACxBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,MAEIyE,KAAK45D,YAAY3hB,GACjBrJ,EAAWrzC,aAAc,EAE7B,MAAMD,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAK45D,YAAe3hB,IAChB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,SAAE7yB,IAAa,IAAAg8B,mBAAkB/K,IACjC,cAAEiC,EAAa,cAAEswB,GAAkBxjD,GACnC,WAAE0yC,EAAU,YAAEha,EAAW,aAAEC,EAAY,YAAE0kC,EAAW,YAAEjf,EAAW,qBAAE69B,GAA0Bn4E,KAAK++C,SAClGwE,EAAernD,EAASwjD,cAAcpF,IACtC,KAAEptC,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,SAClB,cAAE7D,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OAC1C,GAAoB,IAAhB89D,GAAqC,IAAhBA,EAAmB,CACxC,MAAMof,EAAW17E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IAC1D2V,EAAe,CACjB3V,EAAa,GACbA,EAAa,GAAKo1B,GAEhB1f,EAAY,CACd1V,EAAa,GACbA,EAAa,GAAKo1B,GAEtBlqE,EAAO,GAAK2gB,EAAc8pC,GAC1BzqD,EAAO,GAAK2gB,EAAc6pC,GAC1B,MACM2f,EAAqBhkD,EAAc,GADxBklC,EAAoB,GAAKqe,EAAqB,IAEzDhf,EAAa,CACf5V,EAAa,GAAKq1B,EAClBr1B,EAAa,IAEXs1B,EAAc,CAChBt1B,EAAa,GAAKq1B,EAClBr1B,EAAa,IAEjB90C,EAAO,GAAK2gB,EAAc+pC,GAC1B1qD,EAAO,GAAK2gB,EAAcypD,EAC9B,KACK,CACD,MAAMC,EAAW77E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IAC1D4V,EAAa,CACf5V,EAAa,GAAKu1B,EAClBv1B,EAAa,IAEXs1B,EAAc,CAChBt1B,EAAa,GAAKu1B,EAClBv1B,EAAa,IAEjB90C,EAAO,GAAK2gB,EAAc+pC,GAC1B1qD,EAAO,GAAK2gB,EAAcypD,GAC1B,MACME,EAAsBlkD,EAAe,GAD1BilC,EAAoB,GAAKqe,EAAqB,IAEzDjf,EAAe,CACjB3V,EAAa,GACbA,EAAa,GAAKw1B,GAEhB9f,EAAY,CACd1V,EAAa,GACbA,EAAa,GAAKw1B,GAEtBtqE,EAAO,GAAK2gB,EAAc8pC,GAC1BzqD,EAAO,GAAK2gB,EAAc6pC,EAC9B,GAEJj5D,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,QAAE+P,GAAYzxC,GACd,OAAEuB,EAAM,kBAAEgqD,GAAsB9Z,EACtC8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DmpE,GAAiB,KAAAC,yBAAwBp3B,IACzC,kBAAE82B,GAAsBx3E,KAAKyM,cACnC,GAAKS,EAAK0xC,YAAYz6B,IACqB,MAAvCjX,EAAK0xC,YAAYz6B,GAAU60D,UAW1B,GAAIpqC,EAAWrzC,cAChByE,KAAKu0E,+BAA+B3lC,EAAY1yC,EAAUyd,EAAiBre,GACvEY,aAAoB,EAAAsyC,gBAAgB,CACpC,MAAM,kBAAEjoC,GAAsBqoC,EAAW1nC,SACzC,IAAK,MAAMid,KAAYjX,EAAK0xC,YACxB,GAAIz6B,EAASnjB,WAAW,WAAY,CACd2Y,EAAgBy8D,oBACC14D,MAAM4H,IACrC,MAAM+wD,EAAqB,yBAAqB9vE,GAC1CitB,EAAclO,EAAGkO,YAAY6iD,GAC7BC,EAAkB,yBAAqBhxD,EAAGia,qBAChD,OAAO/L,GAAe8iD,IAAoBD,CAAkB,YAGrDnpE,EAAK0xC,YAAYz6B,EAEhC,CAER,OA5BAjX,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACN9pE,IAAK,KACLm0B,KAAM,KACNC,OAAQ,KACRy1C,SAAU,MAEdh5E,KAAKw0E,sBAAsB5lC,EAAY1yC,EAAUyd,GAsBrD,IAAKzd,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,KAAAC,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM0kD,EAAS,GAAGvB,YACZ25B,EAAa,IAMnB,IALA,8BAAe74B,EAAkBd,EAAe25B,EAAYx4B,EAAmB,CAC3EtkD,QACAwkD,WACAD,aACDG,GACC02B,EAAoB,EAAG,CAEvB,GADkBv6E,KAAKa,IAAIb,KAAK6e,IAAI+7D,EAAc,GAAG,GAAKA,EAAc,GAAG,IAAM,EAAG56E,KAAK6e,IAAI+7D,EAAc,GAAG,GAAKA,EAAc,GAAG,IAAM,GAC1H,EAAIL,EAAmB,CACnC,MAAM2B,EAAcn5E,KAAKo5E,wBAAwB14B,IACjD,IAAA+P,YAAcpQ,EAAkBd,EAAe,GAAG25B,WAAqBC,EAAa3B,EAAmB,CACnGp7E,QACAwkD,WACAD,aAER,CACJ,CACAL,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAI8zE,EACCxnE,EAAKyxC,QAAQiqB,QAAQlP,WACtBgb,GAAsB,IAAAC,wBAAuBkD,GAC7C3qE,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,IAE/B,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKw0E,sBAAwB,CAAC5lC,EAAY1yC,EAAUyd,KAChD,MAAMzM,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAYjxB,GACd,OAAEuS,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,MAC7D,gBAAE+Q,EAAe,OAAE2iB,GAAWlmC,EAASwkB,aACtCi/B,EAAe3oB,IAAsB,KAAA8gD,yBAAwBp3B,GAC9DxpB,EAAeh7B,EAASkzB,cAAcuwB,GACtCvoB,EAAmBl7B,EAASkzB,cAAc4H,IAC1C,YAAE4nB,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GACxBy2B,EAAYn+C,EACZo+C,EAAYl+C,EAClB,IAAK,IAAI1tB,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAEwa,EAAS,SAAEnb,EAAQ,aAAElC,GAAiBxJ,EACpD69E,EAAY,GAAsBh3D,EAAWgzD,GACnDgE,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpC,MAAMC,EAAa,GAAsBj3D,EAAWizD,GACpDgE,EAAW,GAAKr8E,KAAK+Q,MAAMsrE,EAAW,IACtCA,EAAW,GAAKr8E,KAAK+Q,MAAMsrE,EAAW,IACtCA,EAAW,GAAKr8E,KAAK+Q,MAAMsrE,EAAW,IACtCt5E,KAAKooE,sBAAwBpoE,KAAK0zE,gBAAgB2F,EAAWC,EAAYzxE,GACzE,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIu7E,EAAU,GAAIC,EAAW,IAClCr8E,KAAKkS,IAAIkqE,EAAU,GAAIC,EAAW,KAO3C,CANSr8E,KAAKa,IAAIu7E,EAAU,GAAIC,EAAW,IAClCr8E,KAAKkS,IAAIkqE,EAAU,GAAIC,EAAW,KAM3C,CALSr8E,KAAKa,IAAIu7E,EAAU,GAAIC,EAAW,IAClCr8E,KAAKkS,IAAIkqE,EAAU,GAAIC,EAAW,MAWzCC,EAAa,CACf3iE,OANW,EACVsgB,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GAI1CoiD,QAASv8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DqiD,QAASx8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DsiD,QAASz8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,IAEzD,WAAEuiD,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoCp6D,EAAiB2iB,EAAQizC,EAAWC,GACtGwE,EAA6B,IAAfH,GAAoC,IAAhBC,EAClCj7B,EAAU,CAAC06B,EAAWC,IACtB,MAAE98E,EAAK,SAAEw8E,IAAa,QAAiCx9E,EAAOmjD,GAC9Ds6B,EAAOh8E,KAAK6e,IAAI7e,KAAKC,IAAMy8E,EAAa,IAAMC,EAAc,IAC9Dp9E,EACAA,EACEi6E,EAAoB,CACtBl4E,aAAa,EAAAm4E,GAAA,GAAoBx6E,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpEswE,GAAe,EAAAK,EAAA,GAAmBhwE,EAASy8B,SAAUiL,EAAW1nC,SAASX,kBAAmBkwE,GAC5FvtC,EAAgBlkC,EAAa/D,QAAQjB,KAAKyM,cAAcgrE,gBAAgBsC,cAAe,CACzF7kE,YACAmN,YACA23D,WAAajwC,IAAa,KAAAkwC,gBAAeV,EAAYxvC,EAAU,CAAEmwC,MAAM,IACvEtxC,aAAc5oC,KAAKyM,cAAc8qE,iBAE/B57E,EAAQqE,KAAKyM,cAAcgrE,gBAAgB0C,gBACjDv7B,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACA31C,KAAM3nC,EAAM2nC,MAAMrjC,MAClBkP,IAAKxT,EAAMwT,KAAKlP,MAChBsjC,OAAQ5nC,EAAM4nC,QAAQtjC,MACtBm6E,WAAYz+E,EAAMqR,MAClBk8B,gBACA4wC,cACAd,WACAnC,eAER,CACA,MAAMt7E,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CAAW,EAEtB5+C,KAAK0zE,gBAAkB,CAACC,EAAQC,EAAQ/rE,IAC5B,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,GAE9C7H,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,QACSh1E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYqC,GAAmBh8E,EAAgBmT,EAAQrK,GAC/IwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACFyxC,QAAS,CACLlwC,SACAgqD,kBAAmB,MAEvB9mC,MAAO,GACPitB,YAAa,CAAC,GAElBH,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,qBAAA6uE,CAAsBmC,EAAS5P,GAC3B,MAAM+O,EAAUa,EAAQz9E,MAAQ,EAC1B68E,EAAUY,EAAQx9E,OAAS,EACjC,GAAI28E,GAAW,GAAOC,GAAW,EAC7B,OAAO,EAEX,MAAM7iE,EAAS,CAACyjE,EAAQl5B,KAAOq4B,EAASa,EAAQ1lE,IAAM8kE,GAChDvyC,EAAa,CAACujC,EAAS,GAAK7zD,EAAO,GAAI6zD,EAAS,GAAK7zD,EAAO,IAIlE,OAHmBswB,EAAW,GAAKA,EAAW,IAAOsyC,EAAUA,GAC1DtyC,EAAW,GAAKA,EAAW,IAAOuyC,EAAUA,IAC7C,CAER,CACA,uBAAAL,CAAwBkB,GACpB,MAAOvP,EAAQp2D,EAAKwsC,EAAMooB,GAAS+Q,EAC7BxX,EAAU,CAAC3hB,EAAK,GAAIxsC,EAAI,IACxBouD,EAAc,CAACwG,EAAM,GAAIwB,EAAO,IACtC,MAAO,EACFjI,EAAQ,GAAKC,EAAY,IAAM,GAC/BD,EAAQ,GAAKC,EAAY,IAAM,EAExC,EAEJ,SAAS,GAAoB71D,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,KAAE80D,EAAI,KAAE31C,EAAI,OAAEC,EAAM,IAAEp0B,EAAG,YAAE2qE,EAAW,SAAEd,EAAQ,aAAEnC,GAAiBpB,EACnEhB,EAAY,GAClB,GAAIwE,EAAM,CACN,MAAMsB,EAAWT,EACX,8BACA,SAAS,wBAAoBb,MAASD,IAC5CvE,EAAU9rE,KAAK4xE,EACnB,CAUA,OATIj3C,GACAmxC,EAAU9rE,KAAK,SAAS,wBAAoB26B,MAASuzC,KAErD1nE,GACAslE,EAAU9rE,KAAK,QAAQ,wBAAoBwG,MAAQ0nE,KAEnDtzC,GACAkxC,EAAU9rE,KAAK,YAAY,wBAAoB46B,MAAWszC,KAEvDpC,CACX,CACA,MCnrBQ3yC,sBAAqB,IAAK,YAClC,MAAM04C,WAAsB,aACfx6E,KAAKy4C,SAAW,WAAa,CACtC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BuP,gBAAgB,EAChBC,kBAAmB,EACnBxD,aAAc,GACdyD,gBAAiB,GAAAC,wBAGrBtgC,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFykB,MAAO,GACPgtB,QAAS,CACLiqB,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5Bt0D,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,MAEvB7Z,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAWzE,OAVA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA2a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Do0B,GAAS,KAAAu2B,uBAAsB3Y,GAC/B0Y,GAAc,KAAAC,uBAAsB,CACtC3Y,EAAkB,GAClBoJ,IAEJ,OAAI7sD,KAAK6e,IAAIs9C,EAAct2B,GAAUinB,EAAY,CAGrC,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,IAEnB,KAAAj1B,mBAAkB9xB,GAClBntB,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEpB,GAAI5a,EAAOuP,cACPqL,GAAgB,MAEf,CACD,MAAM,OAAEzlE,GAAWvB,EAAKyxC,QACxB4a,EAAc9qD,EAAO+D,WAAW9D,GAAMA,IAAM4qD,GAChD,CACA,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ15D,KAAKkzE,eACLtkC,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,gBAAExT,IAAoB,IAAAue,mBAAkB/K,GAC9CntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKy5D,kBAAqBxhB,IACtBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCH,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAE8zB,GAAkBlzB,GACpB,WAAE0yC,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,SAChE/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB1hC,EAAKyxC,QAAQlwC,OAAS,CAClBvB,EAAKyxC,QAAQlwC,OAAO,GACpB2gB,EAAc0qC,IAElBlrB,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAAe,EAE9E/uE,KAAK25D,oBAAuB1hB,IACxBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,MAEIyE,KAAK45D,YAAY3hB,GACjBrJ,EAAWrzC,aAAc,EAE7B,MAAMD,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAK45D,YAAe3hB,IAChB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEiC,EAAa,cAAEswB,GAAkBpkD,EAAeY,UAClD,WAAE0yC,EAAU,YAAE2qB,GAAgBv5D,KAAK++C,UACnC,KAAE7xC,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMgxC,EAAchxC,MACpD,cAAEosC,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OAC1C,GAAoB,IAAhB89D,EAAmB,CACnB,MAAMuf,EAAWhf,EAAoB,GAAKpZ,EAAkB,GAAG,GACzDi4B,EAAW7e,EAAoB,GAAKpZ,EAAkB,GAAG,GACzDmZ,EAAeC,EACf2gB,EAAY,CACd/5B,EAAkB,GAAG,GAAKo4B,EAC1Bp4B,EAAkB,GAAG,GAAKi4B,GAE9BlqE,EAAO,GAAK2gB,EAAcyqC,GAC1BprD,EAAO,GAAK2gB,EAAcqrD,EAC9B,MAEIhsE,EAAO,GAAK2gB,EAAc0qC,EAC9B,EAEJ95D,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,QAAE+P,GAAYzxC,GACd,OAAEuB,EAAM,kBAAEgqD,GAAsB9Z,EACtC8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DkI,EAAS8pC,EAAkB,GAC3B5d,GAAS,KAAAu2B,uBAAsB3Y,GAC/Bm3B,GAAgB,KAAA6C,wBAAuBh6B,IACvC,kBAAE82B,GAAsBx3E,KAAKyM,cACnC,GAAKS,EAAK0xC,YAAYz6B,IACqB,MAAvCjX,EAAK0xC,YAAYz6B,GAAU60D,UAc1B,GAAIpqC,EAAWrzC,cAChByE,KAAKu0E,+BAA+B3lC,EAAY1yC,EAAUyd,EAAiBre,GACvEY,aAAoB,EAAAsyC,gBAAgB,CACpC,MAAM,kBAAEjoC,GAAsBqoC,EAAW1nC,SACzC,IAAK,MAAMid,KAAYjX,EAAK0xC,YACxB,GAAIz6B,EAASnjB,WAAW,WAAY,CACd2Y,EAAgBy8D,oBACC14D,MAAM4H,IACrC,MAAM+wD,EAAqB,yBAAqB9vE,GAC1CitB,EAAclO,EAAGkO,YAAY6iD,GAC7BC,EAAkB,yBAAqBhxD,EAAGia,qBAChD,OAAO/L,GAAe8iD,IAAoBD,CAAkB,YAGrDnpE,EAAK0xC,YAAYz6B,EAEhC,CAER,OA/BAjX,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACN9pE,IAAK,KACLm0B,KAAM,KACNC,OAAQ,KACRy1C,SAAU,KACVl2C,OAAQ,KACR63C,WAAY,KACZC,UAAW,MAEf56E,KAAKw0E,sBAAsB5lC,EAAY1yC,EAAUyd,EAAiBre,GAsBtE,IAAKY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,KAAAC,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM0kD,EAAS,GAAGvB,WACZiR,EAAY,KAClB,IAAAC,YAAcpQ,EAAkBd,EAAeiR,EAAW55C,EAAQksB,EAAQ,CACtE1mC,QACAwkD,WACAD,aACDG,GACC02B,EAAoB,GAChB10C,EAAS,EAAI00C,IACb,IAAA/mB,YAAcpQ,EAAkBd,EAAe,GAAGiR,WAAoB55C,EAAQ4gE,EAAmB,CAC7Fp7E,QACAwkD,WACAD,cAIZL,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAI8zE,EACCxnE,EAAKyxC,QAAQiqB,QAAQlP,WACtBgb,GAAsB,IAAAC,wBAAuBkD,GAC7C3qE,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,IAE/B,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKw0E,sBAAwB,CAAC5lC,EAAY1yC,EAAUyd,EAAiBre,KACjE,MAAM4R,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAYjxB,EACd2+E,EAAiBjsC,EAAWrzC,aAC5B,OAAEkT,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,MAC7D,gBAAE+Q,EAAe,OAAE2iB,GAAWlmC,EAASwkB,aACtCi/B,EAAe3oB,IAAsB,KAAA0jD,wBAAuBh6B,GAC7DxpB,EAAeh7B,EAASkzB,cAAcuwB,GACtCvoB,EAAmBl7B,EAASkzB,cAAc4H,IAC1C,YAAE4nB,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GACxBy2B,EAAYn+C,EACZo+C,EAAYl+C,EAClB,IAAK,IAAI1tB,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAEwa,EAAS,SAAEnb,EAAQ,aAAElC,GAAiBxJ,EACpD69E,EAAY,GAAsBh3D,EAAWgzD,GACnDgE,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpC,MAAMyB,EAAY,GAAsBz4D,EAAWizD,GAInD,GAHAwF,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IACpCA,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IACpCA,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IAChC96E,KAAK0zE,gBAAgB2F,EAAWyB,EAAWjzE,GAAa,CACxD,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,KAO1C,CANS79E,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,KAM1C,CALS79E,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,MAWxCvB,EAAa,CACf3iE,OANW,EACVsgB,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GAI1CoiD,QAASv8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DqiD,QAASx8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DsiD,QAASz8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,IAEzD,WAAEuiD,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoCp6D,EAAiB2iB,EAAQizC,EAAWC,GACtGwE,EAA6B,IAAfH,GAAoC,IAAhBC,EAClCj7B,EAAU,CAAC06B,EAAWyB,IACtB,MAAEt+E,EAAK,KAAE83E,EAAI,SAAE0E,IAAa,QAAiCx9E,EAAOmjD,GACpEo8B,GAAS,QAAoBv/E,GAC7By9E,EAAOh8E,KAAK6e,IAAI7e,KAAKC,IACtBy8E,EAAan9E,EAAQ,IACrBo9E,EAAcmB,EAASv+E,EAAQ,IAC9Bi6E,EAAoB,CACtBl4E,aAAa,EAAAm4E,GAAA,GAAoBx6E,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpEswE,GAAe,EAAAK,EAAA,GAAmBhwE,EAASy8B,SAAUiL,EAAW1nC,SAASX,kBAAmBkwE,GAC5FvtC,EAAgBlkC,EAAa/D,QAAQjB,KAAKyM,cAAcgrE,gBAAgBsC,cAAe,CACzFC,WAAajwC,IAAa,KAAAkwC,gBAAeV,EAAYxvC,EAAU,CAAEmwC,MAAM,IACvEhlE,YACAmN,YACAumB,aAAc5oC,KAAKyM,cAAc8qE,iBAE/B57E,EAAQqE,KAAKyM,cAAcgrE,gBAAgB0C,gBACjDv7B,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACA31C,KAAM3nC,EAAM2nC,MAAMrjC,MAClBkP,IAAKxT,EAAMwT,KAAKlP,MAChBipC,gBACA3F,OAAQ5nC,EAAM4nC,QAAQtjC,MACtBm6E,WAAYz+E,EAAMqR,MAClB8sE,cACAd,WACAl2C,OAAQ62C,EAAa,EAAIn9E,EACzBm+E,WAAYrG,EACZsG,UAAY,EAAI39E,KAAKC,IAAMy8E,EAAa,GAAMn9E,EAC9Cq6E,eAER,MAEI72E,KAAKooE,sBAAuB,EAC5BxpB,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SAG/B,CAKA,OAJAiL,EAAWrzC,aAAc,EACrBs/E,IACA,KAAA/rC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CAAW,EAEtB5+C,KAAK0zE,gBAAkB,CAACC,EAAQC,EAAQ/rE,IAC5B,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,GAE9C7H,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,QACSh1E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYuF,GAAel/E,EAAgBmT,EAAQrK,GAC3IwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACFyxC,QAAS,CACLlwC,SACAm6D,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5BtK,kBAAmB,MAEvB9mC,MAAO,GACPitB,YAAa,CAAC,GAElBH,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,EAEP,SAAS,GAAoB6D,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,OAAE2e,EAAM,WAAE63C,EAAU,KAAE1B,EAAI,KAAE31C,EAAI,OAAEC,EAAM,IAAEp0B,EAAG,YAAE2qE,EAAW,SAAEd,EAAQ,aAAEnC,GAAkBpB,EACxFhB,EAAY,GAClB,GAAI3xC,EAAQ,CACR,MAAMk4C,EAAalB,EACb,gCACA,WAAW,wBAAoBh3C,MAAW63C,IAChDlG,EAAU9rE,KAAKqyE,EACnB,CACA,GAAI/B,EAAM,CACN,MAAMsB,EAAWT,EACX,8BACA,SAAS,wBAAoBb,MAASD,IAC5CvE,EAAU9rE,KAAK4xE,EACnB,CAUA,OATIj3C,GACAmxC,EAAU9rE,KAAK,SAAS,wBAAoB26B,MAASuzC,KAErD1nE,GACAslE,EAAU9rE,KAAK,QAAQ,wBAAoBwG,MAAQ0nE,KAEnDtzC,GACAkxC,EAAU9rE,KAAK,YAAY,wBAAoB46B,MAAWszC,KAEvDpC,CACX,CACA,YClnBA,MAAMwG,WAAsB,aACfj7E,KAAKy4C,SAAW,WAAa,CACtC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BkT,QAAS,CAAC,GAAI,IAAK,IAAK,KACxBC,UAAW,CAAC,GAAI,GAAI,OAGxB/jC,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFykB,MAAO,GACPgtB,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,QAIzB,IAAAyoC,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAUzE,OATA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA2a,eAAe,GAEnBx5D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB/nC,EAAS1a,EAASwjD,cAAcjxC,EAAO,IACvCq0B,GAAS,KAAAu2B,uBAAsB,CAACziD,EAAQkzC,IAC9C,OAAI7sD,KAAK6e,IAAIgnB,GAAUinB,CAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,wBAEJ,KAAAI,mBAAkB9xB,GAClBntB,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,KAChC,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ9qB,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,gBAAExT,IAAoB,IAAAue,mBAAkB/K,GAC9CntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKy5D,kBAAqBxhB,IACtBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCH,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,GAChC,cAAE8zB,GAAkBlzB,GACpB,WAAE0yC,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,UAC3C,KAAE7xC,GAAS0hC,EACjB1hC,EAAKyxC,QAAQlwC,OAAS,CAClB2gB,EAAc0qC,GACd1qC,EAAc0qC,IAElBlrB,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAK25D,oBAAuB1hB,IACxBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,UAC3C,KAAE7xC,GAAS0hC,GACX,YAAEwJ,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,EACzB,MAAMD,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAK45D,YAAe3hB,IAChB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEiC,EAAa,cAAEswB,GAAkBpkD,EAAeY,UAClD,WAAE0yC,GAAe5uC,KAAK++C,UACtB,KAAE7xC,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMgxC,EAAchxC,MACpD,cAAEosC,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCq9E,EAAWhf,EAAoB,GAAKpZ,EAAkB,GAAG,GACzDi4B,EAAW7e,EAAoB,GAAKpZ,EAAkB,GAAG,GACzDmZ,EAAeC,EACf2gB,EAAY,CACd/5B,EAAkB,GAAG,GAAKo4B,EAC1Bp4B,EAAkB,GAAG,GAAKi4B,GAE9BlqE,EAAO,GAAK2gB,EAAcyqC,GAC1BprD,EAAO,GAAK2gB,EAAcqrD,EAAU,EAExCz6E,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjC,MAAM,gBAAE9+C,IAAoB,IAAAue,mBAAkB/K,GAM9C,OALA,EAAAgyB,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,QAAE+P,GAAYzxC,GACd,OAAEuB,GAAWkwC,EACnB8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAGE7pC,EADoBnI,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAClC,GACjC,IAAKxS,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,IAAI+P,EAAU,GAAG/P,uBACb7jD,EAAQ,CAACkb,EAAO,GAAIA,EAAO,GAtRxB,GAuRH5E,EAAM,CAAC4E,EAAO,GAAIA,EAAO,GAvRtB,IAwRP,IAAA24C,UAASlP,EAAkBd,EAAe+P,EAAS5zD,EAAOsW,EAAK,CAC3D5V,QACAwkD,WACAD,cAEJ2O,EAAU,GAAG/P,yBACb7jD,EAAQ,CAACkb,EAAO,GA9RT,EA8R8BA,EAAO,IAC5C5E,EAAM,CAAC4E,EAAO,GA/RP,EA+R4BA,EAAO,KAC1C,IAAA24C,UAASlP,EAAkBd,EAAe+P,EAAS5zD,EAAOsW,EAAK,CAC3D5V,QACAwkD,WACAD,cAEJ,MAAMy6B,EAAkBp7E,KAAKyM,cAAc0uE,UAAU90E,KAAKg1E,GAAar7E,KAAKs7E,qBAAqBD,EAAUn/E,KAC3G,IAAK,IAAIwN,EAAI,EAAGA,EAAI0xE,EAAgBx6E,OAAQ8I,IAAK,CAC7C,MAAMo3C,EAAS,GAAGvB,YAAwB71C,IACpC8mD,EAAY,GAAGjR,YAAwB71C,KAC7C,IAAA+mD,YAAcpQ,EAAkBd,EAAeiR,EAAW55C,EAAQwkE,EAAgB1xE,GAAK,EAAG,CACtFtN,QACAwkD,WACAD,aACDG,EACP,CACA,MAAMy6B,EAAcj+E,GAAOA,EAAIL,KAAKC,GAAM,IACpCs+E,EAAex7E,KAAKyM,cAAcyuE,QAAQ70E,KAAKo1E,GAAWF,EAAWE,KAC3E,IAAK,IAAI/xE,EAAI,EAAGA,EAAI8xE,EAAa56E,OAAQ8I,IAAK,CAC1C,MAAM4lD,EAAU,GAAG/P,UAAsB71C,IACnChO,EAAQ,CACTuB,KAAKy+E,IAAIF,EAAa9xE,IAAM0xE,EAAgB,GAAM,EAAIxkE,EAAO,GAC7D3Z,KAAK0+E,IAAIH,EAAa9xE,IAAM0xE,EAAgB,GAAM,EAAIxkE,EAAO,IAE5D5E,EAAM,CACP/U,KAAKy+E,IAAIF,EAAa9xE,IAAM0xE,EAAgB,GAAM,EAAIxkE,EAAO,GAC7D3Z,KAAK0+E,IAAIH,EAAa9xE,IAAM0xE,EAAgB,GAAM,EAAIxkE,EAAO,KAElE,IAAA24C,UAASlP,EAAkBd,EAAe+P,EAAS5zD,EAAOsW,EAAK,CAC3D5V,QACAwkD,WACAD,aAER,CACAL,GAAe,CACnB,CACA,OAAOA,CAAY,CAE3B,CACA,oBAAAg7B,CAAqBM,EAAa1/E,GAC9B,MAAMqqC,EAAKrqC,EAASkzB,cAAc,CAC9BlzB,EAAST,OAAOmB,MAAQ,EACxBV,EAAST,OAAOoB,OAAS,KAEvB,OAAEulC,GAAWlmC,EAASwkB,YACtByzB,EAAK,iBAAiB,cAAe5N,EAAInE,EAAQw5C,GACjDC,EAAW3/E,EAASwjD,cAAcnZ,GAClCu1C,EAAW5/E,EAASwjD,cAAcvL,GAGxC,OAFiBl3C,KAAKwmC,KAAKxmC,KAAKy5D,IAAIolB,EAAS,GAAKD,EAAS,GAAI,GAC3D5+E,KAAKy5D,IAAIolB,EAAS,GAAKD,EAAS,GAAI,GAE5C,E,wCC3UJ,MAEME,GAAwB,CAC1B1sC,WAAY,GACZ2sC,6BAA8B,EAC9BC,6BAA8B,EAC9BC,6BAA6B,EAC7BC,6BAA6B,EAC7BC,6BAA6B,GAEjC,IAAIC,GAOAC,IANJ,SAAWD,GACPA,EAA0B,SAAI,WAC9BA,EAAwB,OAAI,SAC5BA,EAA4B,WAAI,aAChCA,EAAyB,QAAI,SAChC,CALD,CAKGA,KAAoBA,GAAkB,CAAC,IAE1C,SAAWC,GACPA,EAAmC,gBAAI,kBACvCA,EAAsC,mBAAI,oBAC7C,CAHD,CAGGA,KAAsBA,GAAoB,CAAC,IAC9C,MAAMC,WAAsBC,GAAA,SACfx8E,KAAKy4C,SAAW,WAAa,QAC7Bz4C,KAAKy8E,YAAcJ,EAAiB,QACpCr8E,KAAKo3D,QAAUklB,EAAmB,CAC3C,WAAA78E,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXu7D,2BAA2B,EAC3B8G,gBAAgB,EAChBkF,aAAc,GACd0I,+BAAgC,EAAAzkB,iBAAiBC,MACjDx5C,SAAU,CACNooC,SAAS,EACT61B,QAAS,IAEbC,OAAQ,CACJnwE,cAAe,CACX,CAAC4vE,GAAgBQ,UAAW,CACxBC,MAAO3lC,GACP36C,MAAO,IAEX,CAAC6/E,GAAgBU,YAAa,CAC1BD,MAAOplC,IAEX,CAAC2kC,GAAgBW,QAAS,CACtBF,MAAOnlC,IAEX,CAAC0kC,GAAgBnlC,SAAU,CACvB4lC,MAAO5lC,GACPilC,6BAA6B,EAC7BC,6BAA6B,EAC7BF,6BAA6B,IAGrCp1E,KAAMu1E,GAAgBU,WACtBE,oBAAoB,EACpBC,6BAA8B,CAAC,YAAa,WAEhDzlB,QAAS,CACL,CAAC6kB,GAAkBa,iBAAkB,CACjCxlB,OAAQ,0BACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAcslB,QAC3BplB,YAAa,EAAAC,iBAAiBC,SAI1C,CAACokB,GAAkBe,oBAAqB,CACpC1lB,OAAQ,6BACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAcslB,QAC3BplB,YAAa,EAAAC,iBAAiBqlB,YAOlDlmC,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKu9E,mBAAqB,KAC1Bv9E,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAQupB,SAAUsJ,GAAWhuC,EAAW1hC,KAAK0vE,OAC7C,OAAOA,EAAOppC,iBAAiBsW,EAAcC,EAAU,EAE3D/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEpB,GAAI5a,EAAOuP,cACPqL,GAAgB,MAEf,CACD,MAAM,OAAEzlE,GAAWvB,EAAKyxC,QACxB4a,EAAc9qD,EAAO+D,WAAW9D,GAAMA,IAAM4qD,GAChD,CACA,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,6BAAEgkB,GAAkCx9E,KAAK++C,UACzF,KAAE7xC,GAAS0hC,EACjBA,EAAW2kC,eAAgB,EAC3BrmE,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACnC3xB,EAAQwE,KAAKgkE,mBAAmBhkE,KAAK82D,YAAYx7D,EAAeY,YAChE,UAAEmmB,EAAS,WAAExa,GAAerM,EAClCwE,KAAKooE,qBAAuBl7D,EAAKyxC,QAAQlwC,OACpCpI,KAAKqI,GAAM,EAAA49B,UAAA,sBAAgCjqB,EAAW3T,KACtDuY,MAAMze,IAAW,EAAA8jC,UAAA,sBAAgC9jC,EAAOX,KACzD7H,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,eAEhC,MAAMi3B,EAAahd,EACb,EAAAzqB,YAAY0uC,UACZ,EAAA1uC,YAAYggC,eACb/uE,KAAKu9E,oBAQNv9E,KAAKu9E,mBAAmBh+B,cAAgB3Q,EAAW2Q,cACnDv/C,KAAKu9E,mBAAmB/G,WAAaA,GARrCx2E,KAAKu9E,mBAAqB,CACtBh+B,cAAe3Q,EAAW2Q,cAC1Bi3B,aACAgH,iCAOR,EAAAr+B,EAAA,GAAsCN,GACtC7+C,KAAKkzE,eACLlzE,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAK09E,iBAAoBzlC,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACd5uB,EAAM4uB,EAAY5uB,KAAO,IACzB,6BAAE+8E,GAAiCl9E,KAAKyM,cAAcmwE,OAE5D,IADwBM,EAA6BriE,SAAS1a,GAE1D,OAEJ,MAAM,WAAEyuC,GAAe5uC,KAAK++C,UACtB,KAAE7xC,GAAS0hC,EACjB,GAlLc,IAkLV1hC,EAAKyxC,QAAQlwC,OAAO7N,OAAxB,CAIK,CACD,MAAM+8E,EAAoBzwE,EAAKyxC,QAAQlwC,OAAO7N,OAAS,EACvDZ,KAAK49E,2BAA2BzwD,EAASyhB,EAAY+uC,EACzD,CACA1lC,EAAIiH,gBADJ,MANIl/C,KAAKiL,OAAOkiB,EAOI,EAExBntB,KAAK69E,mBAAsB5lC,IACvB,MAAM,mBAAEglC,GAAuBj9E,KAAKyM,cAAcmwE,OAClD,IAAKK,EACD,OAEJ,MAAM,QAAE9vD,GAAY8qB,EAAI3lB,QAClB,gBAAE3Y,IAAoB,IAAAue,mBAAkB/K,GACxC0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAS++B,gBAAkB7lC,EAAI3lB,OAAOwoB,cAAcr/C,QACzD,EAAA0jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAK+9E,mBAAsB9lC,IACvB,MAAM+lC,EAAc/lC,EAAInxC,OAAS,EAAA2oB,OAAOwuD,oBAClC,WAAErvC,EAAU,oBAAEiQ,GAAwB7+C,KAAK++C,UAC3C,KAAE7xC,GAAS0hC,EACjB,GAAI1hC,EAAK2gC,QAAQ4B,OACb,OAEJzvC,KAAKkzE,eACL,MAAMnkD,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,GAC3BtzB,OAAQuvC,EAAasN,MAAOpN,GAAe4P,EACnD,IAAIojC,EAAehxE,EAAKyxC,QAAQlwC,OAAO7N,QAAU,GAAKo9E,EAClDG,GAAc,EAMlB,GALIjxE,EAAKyxC,QAAQlwC,OAAO7N,QACpBZ,KAAK8yB,WAAW3F,EAASyhB,EAAY,CACjC4qB,cAA8C,IAA/BtsD,EAAKyxC,QAAQlwC,OAAO7N,SAGvCsM,EAAKyxC,QAAQlwC,OAAO7N,QAAU,EAAG,CACjCZ,KAAK8yB,WAAW3F,EAASyhB,GACzB,MAAQ0kC,SAAUsJ,GAAW1vE,EAAK0vE,OAC5BlrC,EAAsBkrC,EAAOprC,qCAAqCxG,EA5NlD,IA6Na,IAA/B0G,GAAqBlpC,QACrB21E,GAAc,EACdD,GAAe,EAEvB,CACIC,GACAjxE,EAAKyxC,QAAQlwC,OAAO9F,KAAKuiC,GAE7Bh+B,EAAK2gC,QAAQ4B,OAASviC,EAAK2gC,QAAQ4B,QAAUyuC,EAC7CtvC,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,GAClC3xC,EAAK2gC,QAAQ4B,QACbzvC,KAAKo/C,aAAanH,GAEtBA,EAAIiH,gBAAgB,EAExBl/C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,UACvF,KAAE7xC,GAAS0hC,EAEjB,GADA5uC,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACnC0a,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MAClCt4C,KAAKo+E,eAAexvC,EAAYylC,EACpC,KACK,CACD,MAAM,cAAEv5B,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKw/C,2BAA6B,CAAC5Q,EAAY4uC,KAC3C,MAAMa,EAAY,EAAA5uD,OAAO6uD,qBACnBvvD,EAAc,CAChB6f,aACA4nC,WAAY,EAAAznC,YAAY0uC,UACxBD,iCAEJ,IAAAh+C,cAAa,EAAArN,YAAaksD,EAAWtvD,EAAY,EAErD/uB,KAAK8uC,0BAA4B,CAACF,EAAYtzC,EAAgBk7E,EAAa,EAAAznC,YAAYymC,gBACnF,MAAM,WAAEtoD,EAAU,kBAAEhB,GAAsB5wB,EACpC+iF,EAAY,EAAA5uD,OAAO8uD,oBACnBxvD,EAAc,CAChB6f,aACA1hB,aACAhB,oBACAsqD,eAEJ,IAAAh3C,cAAa,EAAArN,YAAaksD,EAAWtvD,EAAY,EAErD/uB,KAAKw+E,mBAAqB,CAAC5vC,EAAYtzC,EAAgBk7E,EAAa,EAAAznC,YAAYymC,aAAcgI,KACtFhH,IAAe,EAAAznC,YAAY0uC,UAC3Bz9E,KAAKw/C,2BAA2B5Q,EAAY4uC,GAG5Cx9E,KAAK8uC,0BAA0BF,EAAYtzC,EAAgBk7E,EAC/D,EAEJx2E,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOgvD,SAAUz+E,KAAK09E,kBAC/CvwD,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAK69E,oBACjD1wD,EAAQ1E,iBAAiB,EAAAgH,OAAOivD,WAAY1+E,KAAK+9E,oBACjD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAOwuD,mBAAoBj+E,KAAK+9E,oBACzD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAK+9E,mBAAmB,EAEvE/9E,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOgvD,SAAUz+E,KAAK09E,kBAClDvwD,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAK69E,oBACpD1wD,EAAQrE,oBAAoB,EAAA2G,OAAOivD,WAAY1+E,KAAK+9E,oBACpD5wD,EAAQrE,oBAAoB,EAAA2G,OAAOwuD,mBAAoBj+E,KAAK+9E,oBAC5D5wD,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAK+9E,mBAAmB,EAE1E/9E,KAAK2+E,aAAe,CAAC/vC,EAAY1yC,EAAUmkD,EAAkBu+B,KACzD,MAAM1xE,EAAO0hC,EAAW1hC,KAClBiX,EAAWnkB,KAAK82D,YAAY56D,GAClC,IAAKgR,EAAK0vE,OAAOtJ,SAAS7jC,SAAWmvC,EAAajxD,WAC9C,OAEJ,MAAM8mD,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,OAEJ,MAAM8/C,EAAoBxzC,EAAKyxC,QAAQlwC,OAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAChF,IAAKxB,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAE9DgM,GAAc,IAAAC,mBAAqBz0B,EAAkBzR,EAAW2Q,eAAiB,GADpE,UACoFk1B,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGk+B,IAClJthF,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAC5D,EAELmD,KAAK6+E,wBAA0B,CAAC5mC,EAAKrJ,KACjC,MAAM,KAAE1hC,GAAS0hC,EACXkwC,EAAa5xE,EAAK0vE,OAAO91E,KACzBi4E,EAAe/+E,KAAKg/E,iBAAiBF,GACrCrtC,EAAUstC,EAAa/C,6BAC7B,IAAiD,IAA7C+C,EAAa5C,4BACb,OAEJ,MAAMptD,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACdzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,GAChC,cAAE8zB,GAAkBlzB,GAClBo3E,SAAUsJ,GAAW1vE,EAAK0vE,OAC5BzmB,EAAYle,EAAI3lB,OAAOwoB,cAAcr/C,OACrCwjF,EAAmBrC,EAAOjrC,gBAAgBwkB,GAChD,GAAI8oB,EAAiBjjE,SAAWy1B,EAC5B,OAEJ,MAAM,MAAEjpC,EAAO8F,MAAO08B,GAAgB4xC,EAAO1sC,mBAAmB+uC,EAAiBtsC,QACjFzlC,EAAKyxC,QAAQlwC,OAAOwE,OAAOzK,EAAO,EAAG4mB,EAAc4b,IACnD4D,EAAWrzC,aAAc,EACzB,MAAMsjD,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,gBACzE,EAAAS,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKk/E,2BAA6B,CAACjnC,EAAKrJ,KACpC,MAAMkwC,EAAalwC,EAAW1hC,KAAK0vE,OAAO91E,KACpCi4E,EAAe/+E,KAAKg/E,iBAAiBF,GACrCrtC,EAAUstC,EAAa9C,6BAC7B,IAAiD,IAA7C8C,EAAa3C,4BACb,OAEJ,MAAMrtD,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,cAAE2tB,GAAkB/rB,GAC3BtzB,OAAQ06D,GAAcrb,GACtBw4B,SAAUsJ,GAAWhuC,EAAW1hC,KAAK0vE,OACvClrC,EAAsBkrC,EAAOprC,qCAAqC2kB,EAAW1kB,GAC9EC,GAGL1xC,KAAK49E,2BAA2BzwD,EAASyhB,EAAY8C,EAAoBlpC,MAAM,EAEnFxI,KAAKw0E,sBAAwB,CAAC5lC,EAAYzhB,KACtC,IAAKntB,KAAKyM,cAAcqiE,eACpB,OAEJ,MAAM5hE,EAAO0hC,EAAW1hC,KACxB,IAAKA,EAAK2gC,QAAQ4B,OACd,OAEJ,MAAMn0C,GAAiB,IAAA48B,mBAAkB/K,GACzC,IAAK7xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,GACf,YAAEsjD,GAAgB1xC,GAChB+hE,SAAUxgE,GAAWvB,EAAK2gC,QAC5B0nC,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,SAAE0L,GAAa1L,EACfklD,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Ds8B,EAAc0V,EAAkB,GAChCy+B,EAAqBjjF,EAASkzB,cAAc4b,GAC5Co0C,EAAcljF,EAASkzB,cAAc,CACvC4b,EAAY,GAAK,EACjBA,EAAY,KAEVq0C,EAAcnjF,EAASkzB,cAAc,CACvC4b,EAAY,GACZA,EAAY,GAAK,IAEfs0C,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,IAC7C,UAAEh9D,GAAc7mB,GAChB,MAAEgB,EAAK,SAAEw8E,IAAa,QAAiCx9E,GAAO,KAChE,MAAQ+nB,KAAMi8D,EAAY1+C,KAAM2+C,EAAYn8D,KAAMo8D,EAAY7+C,KAAM8+C,GAAgBltC,EAAKw8B,SAAS2Q,QAAQl/B,GACpGm/B,EAAiB3jF,EAASkzB,cAAc,CAC1CswD,EACAC,IAEEG,EAAiB,EAAAxzC,UAAA,sBAAgCjqB,EAAWw9D,GAC5DE,EAAqB7jF,EAASkzB,cAAc,CAC9CowD,EACAC,IAGJ,MAAO,CAACK,EADmB,EAAAxzC,UAAA,sBAAgCjqB,EAAW09D,GAC3B,IAE/C,IAAI9G,EAAOxmC,EAAKw8B,SAAS+Q,QAAQt/B,GAAqBlkD,EAAQA,EAC9Dy8E,GAAQqG,EAAWC,EACnB3gC,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACAD,WAER,CACA,MAAMz9E,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,GACAyE,KAAK8uC,0BAA0BF,EAAYtzC,EAAgB,EAAAyzC,YAAYymC,cAEpE52B,CAAW,EAEtB5+C,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,gBAAA32B,CAAiBpG,GACb,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,GAC3BtzB,OAAQ06D,GAAcrb,EACxB0iC,GAA+B,EAAAyC,GAAA,GAAoBhoC,EAAI3lB,OAAO4tD,SAChElgF,KAAKyM,cAAciwE,+BACjBphF,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACtBszC,EAAa5uC,KAAKmgF,iBAAiBloC,GACzCj4C,KAAKs+C,WAAY,EACjBt+C,KAAKioD,cAAcrZ,EAAYzhB,GAC/B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAazE,OAZA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,EACf1a,eAAe,EACfE,UAAU,EACVokB,gBAAiB3nB,EACjBqnB,gCAEJx9E,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CACX,CACA,MAAA3jC,CAAOkiB,GACH,IAAKntB,KAAKs+C,UACN,OAEJt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,SAC5Dya,IACA,IAAA9R,kBAAiB9Y,EAAW2Q,eAEhCnI,MAAMgpC,iBAAiBxxC,GACvB,MAAMtzC,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EAG5B,OAFA,EAAA6jD,EAAA,GAAsCN,GACtC7+C,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,CACA,yBAAA8gC,GACI,OAAO,CACX,CACA,wBAAAC,CAAyBC,GACrB,MAAM,eAAEjlF,EAAc,SAAE6oB,EAAQ,iBAAEk8B,EAAgB,gBAAEmgC,GAAoBD,GAClE,SAAErkF,GAAaZ,GACf,cAAEokD,GAAkBxjD,GACpB,QAAEixB,GAAYjxB,EACd0yC,EAAa2xC,EAAc3xC,YAC3B,cAAE2Q,EAAa,KAAEryC,EAAI,YAAEuxC,GAAgB7P,GACvC,QAAE+P,GAAYzxC,GACZuB,OAAQihC,EAAa,kBAAE+oB,GAAsB9Z,EAC/C6a,EAAgBx5D,KAAK++C,UAAUya,eAC/B,UAAE7Y,EAAS,SAAEC,EAAQ,MAAExkD,EAAOqkF,OAAQC,GAAsBF,EAC5D9/B,EAAoBhR,EAAcrpC,KAAKqI,GAAMgxC,EAAchxC,MAC3D,mBAAEuuE,GAAuBj9E,KAAKyM,cAAcmwE,OAC5CkC,EAAalwC,EAAW1hC,KAAK0vE,OAAO91E,KACpCi4E,EAAe/+E,KAAKg/E,iBAAiBF,GACrClC,EAAShuC,EAAW1hC,KAAK0vE,OAAOtJ,SAChCqN,GAAmB,IAAAC,qBAAoBhyC,GAE7C,IAA2B,IADD+xC,EAAiBnuE,WAAWzG,IAAQA,IAE1D,MAAM,IAAI3N,MAAM,mCAAmCwwC,EAAWiyC,oBAAoBn1D,UAyBtF,IAAIwuC,EAIJ,GA3B+B,CAACtrB,KAAe+xC,GAAkB7rE,QAAQ85B,GAAe5uC,KAAK8gF,uBAAuBlyC,KAC7F3tC,SAAS2tC,IAC5B,MACMmyC,EADS/gF,KAAKghF,sBAAsB7zD,EAASyhB,GACfoE,oBACpChzC,KAAKihF,sBAAsBryC,EAAY,CACnCngC,OAAQsyE,EACRtxC,OAAQviC,EAAK2gC,QAAQ4B,OACrByxC,uBAAwB,KAAwBC,WACjDjlF,EAAU,CAAEklF,uBAAwBl0E,EAAK2gC,QAAQ4B,QAAS,IAEjE2H,MAAMkpC,yBAAyBC,GAC1BrzE,EAAK0xC,YAAYz6B,IACqB,MAAvCjX,EAAK0xC,YAAYz6B,GAAU60D,SAQtBpqC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYzhB,IARhDjgB,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACND,SAAU,MAEdh5E,KAAKw0E,sBAAsB5lC,EAAYzhB,IAMtCuzD,GAAqB1gF,KAAK++C,UAAkC,OAAtB0Z,IACvCyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,GAA4BV,GAAiB/a,EAAa,CAC1D,MAAM2b,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAukD,YACAqG,aAAc,KAEtB,CACA,GAAIi2B,GACAL,EAAOjtC,iBAAmB,GAC1B3vC,KAAK++C,UAAU++B,kBACdlB,EAAOntC,OAAQ,CAChB,MAAM,gBAAEquC,GAAoB99E,KAAK++C,SAC3BsiC,EAAwBzE,EAAO1pC,yBAAyB4qC,EAlkBpC,KAmkB1B,IAAAwD,cAAgBjhC,EAAkBd,EAAe,sBAAuB8hC,EAAuB,CAC3FjlF,MAAO,UACPwkD,SAAUA,EACVD,UAAW,GAEnB,CACA,GAAIo+B,EAAa7C,4BAA6B,CAC1C,MAAMqF,EAA0B,IAAI7gC,GAChCk8B,EAAOntC,QACP8xC,EAAwB54E,KAAK+3C,EAAkB,KAEnD,IAAA4gC,cAAgBjhC,EAAkBd,EAAe,0BAA2BgiC,EAAyB,CACjGnlF,MAAO,2BACPukD,UAAW,GAEnB,CAOA,OANA3gD,KAAK2+E,aAAa/vC,EAAY1yC,EAAUmkD,EAAkBmgC,EAAgBgB,SACtExhF,KAAKu9E,oBAAoBh+B,gBAAkBA,IAC3Cv/C,KAAKw+E,mBAAmB5vC,EAAYtzC,EAAgB0E,KAAKu9E,mBAAmB/G,WAAYx2E,KAAKu9E,mBAAmBC,8BAChHx9E,KAAKu9E,mBAAqB,MAE9B3uC,EAAWrzC,aAAc,GAClB,CACX,CACA,+BAAAkmF,CAAgC7yC,GAC5B,GAAIA,EAAW1hC,KAAKyxC,QAAQlwC,QAAQ7N,OAChC,OAEJ,MAAM,SAAEquE,GAAargC,EAAW1hC,KAAK2gC,QACrC,IAAKohC,IAAaA,EAASruE,OACvB,OAEJguC,EAAW1hC,KAAKyxC,QAAQlwC,OAAS,GACjC,MAAM,OAAEA,GAAWmgC,EAAW1hC,KAAKyxC,QAC7B3jB,EAAY/9B,KAAKkS,IAAI,GAAIlS,KAAK+Q,MAAMihE,EAASruE,OAAS,KAC5D,IAAK,IAAI8I,EAAI,EAAGA,EAAIulE,EAASruE,OAASo6B,EAAWtxB,GAAKsxB,EAClDvsB,EAAO9F,KAAKsmE,EAASvlE,IAEzB+E,EAAO9F,KAAKsmE,EAASA,EAASruE,OAAS,GAC3C,CACA,gBAAAu/E,CAAiBloC,GACb,MAAMypC,EAAoBtqC,MAAM+oC,iBAAiBloC,IACzCK,MAAO94B,GAAay4B,EAAI3lB,OAAOwoB,eAC/Bh0C,KAAMg4E,GAAe9+E,KAAKyM,cAAcmwE,OAC1CmC,EAAe/+E,KAAKg/E,iBAAiBF,GACrClC,EAAS,IAAImC,EAAajC,MAC1B6E,EAAe,KAAM,CACvB76E,KAAMi4E,EAAaj4E,KACnBwsE,SAAUsJ,EACVvtC,WAAY0vC,EAAa1vC,aAE7B,IAAIuyC,EAOJ,OANI5hF,KAAKyM,cAAcoM,eAAeiuC,UAClC86B,EAA2BhzC,IACvBA,EAAW1hC,KAAK0vE,SAAW+E,IAC3B3hF,KAAKyhF,gCAAgC7yC,EAAW,GAGjD,EAAAtC,UAAA,UAAoBo1C,EAAmB,CAC1Cx0E,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,KAEjBo9D,OAAQ+E,IACR/iC,YAAa,CAAC,GAElBgjC,2BAER,CACA,0BAAAhE,CAA2BzwD,EAASyhB,EAAY+uC,GAC5C,MAAMriF,GAAiB,IAAA48B,mBAAkB/K,IACjC1e,OAAQihC,GAAkBd,EAAW1hC,KAAKyxC,QACrB,IAAzBjP,EAAc9uC,QACd,IAAA8mD,kBAAiB9Y,EAAW2Q,eAG5B7P,EAAcz8B,OAAO0qE,EAAmB,GAE5C,MAAM,gBAAEhkE,GAAoBre,EACtBujD,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE9P,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,EAC1C,CACA,sBAAAiiC,CAAuBlyC,GACnB,QAASA,EAAW1hC,MAAM0vE,MAC9B,CACA,gBAAAoC,CAAiBl4E,GACb,MAAQ2F,cAAe0rD,GAAWn4D,KAC5B6hF,EAAgB1pB,EAAOykB,OAAOnwE,cACpC,OAAO7M,OAAOm7D,OAAO,CAAEj0D,QAAQi1E,GAAuB8F,EAAc/6E,GACxE,CACA,qBAAAk6E,CAAsB7zD,EAASyhB,GAC3B,MAAMtzC,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAEokD,GAAkBxjD,GACpB,KAAEgR,GAAS0hC,GACT9nC,KAAMg4E,EAAYxL,SAAUsJ,GAAWhuC,EAAW1hC,KAAK0vE,OACzDmC,EAAe/+E,KAAKg/E,iBAAiBF,GAErC/X,EADc75D,EAAKyxC,QAAQlwC,OACApI,IAAIq5C,GAC/BrQ,OAAyCrxC,IAA5B+gF,EAAa1vC,WAC1BzT,SAASmjD,EAAa1vC,iBACtBrxC,EACAxB,OAA+BwB,IAAvB+gF,EAAaviF,MACrBia,WAAWsoE,EAAaviF,YACxBwB,EAgBN,OAfA4+E,EAAO9rC,iBAAiBi2B,GACxB6V,EAAOntC,SAAWviC,EAAK2gC,QAAQ4B,OAC1BmtC,EAAOrtC,sBACOvxC,IAAfqxC,GACAutC,EAAOvtC,aAAeA,IACtButC,EAAOvtC,WAAaA,EACpBT,EAAWrzC,aAAc,GAEzBqhF,aAAkBzlC,KACjBylC,EAAOrlC,iBACEv5C,IAAVxB,GACAogF,EAAOpgF,QAAUA,IACjBogF,EAAOpgF,MAAQA,EACfoyC,EAAWrzC,aAAc,GAEtBqhF,CACX,QACS58E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,GAAImT,EAAO7N,OApsBO,EAssBd,YADAwP,QAAQC,KAAK,6CAGjB,MAAM,oBAAErG,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,OAAE2iB,EAAM,SAAEkxC,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYsH,GAAejhF,EAAgBmT,EAAQrK,GACnJ06E,EAAa16E,GAAS06E,YAAczC,GAAgBU,WAGpD+E,EAAiB,IAAIC,EAFNzO,EAAS0L,iBAAiBF,GACdhC,OAE3BluC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,EAAAjT,UAAA,SACzCp/B,KAAM,CACFyxC,QAAS,CACLlwC,UAEJkjB,MAAO,GACPitB,YAAa,CAAC,EACdg+B,OAAQ,CACJ91E,KAAMg4E,EACNxL,SAAUwO,GAEdj0C,QAAS,CACL4B,QAAQ,IAGhBgP,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,EAEP,SAAS,GAAoB6D,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,KAAE80D,EAAI,YAAEa,EAAW,SAAEd,GAAavD,EAClChB,EAAY,GAClB,GAAIwE,EAAM,CACN,MAAMsB,EAAWT,EACX,8BACA,SAAS,EAAAxtC,UAAA,YAAsB2sC,MAASD,IAC9CvE,EAAU9rE,KAAK4xE,EACnB,CACA,OAAO9F,CACX,CACA,YC5wBA,MAAMuN,WAAsC,UAC/BhiF,KAAKy4C,SAAW,+BAAiC,CAC1D,WAAAh5C,CAAYo4C,GAMRT,MALqB,EAAA9K,UAAA,UAAoB,CACrC7/B,cAAe,CACXqiE,gBAAgB,IAErBj3B,GAEP,CACA,yBAAAwoC,GACI,OAAO,CACX,E,0DCMJ,MAAM4B,WAA4BzF,GAAA,SACrBx8E,KAAKy4C,SAAW,iBAAmB,CAC5C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXunE,aAAc,GACdlF,gBAAgB,EAChB9G,2BAA2B,EAC3B0U,+BAAgC,EAAAzkB,iBAAiBC,MACjDgqB,iBAAkB,EAClBrpE,cAAe,CACXiuC,SAAS,EACTq7B,YAAa,EACbC,2BAA2B,GAE/B1jE,SAAU,CACNooC,SAAS,EACT61B,QAAS,IAEbllB,QAAS,CACL4qB,iBAAkB,CACd1qB,OAAQ,mBACRC,SAAU,CACN,CACIz3D,IAAK,gBAOzBi3C,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfgnF,EAAmBv4B,EAAYA,EAC/Bgd,EAAen4B,EAAW1hC,KAAK2gC,QAAQohC,SAAS5oE,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACxF,IAAIk/B,EAAam5B,EAAaA,EAAanmE,OAAS,GACpD,IAAK,IAAI8I,EAAI,EAAGA,EAAIq9D,EAAanmE,OAAQ8I,IAAK,CAC1C,MAAM4mC,EAAWy2B,EAAar9D,GAE9B,GAD+B+oC,EAAKrC,YAAYwD,uBAAuBhG,EAAY0C,EAAUwZ,IAC/Dw4B,EAC1B,OAAO,EAEX10C,EAAa0C,CACjB,CACA,OAAO,CAAK,EAEhBtwC,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnB,MAAM54E,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EAC5B0E,KAAKmiD,gBAAgBh1B,IACrB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEpB,GAAI5a,EAAOuP,cACPqL,GAAgB,MAEf,CACD,MAAM,OAAEzlE,GAAWvB,EAAKyxC,QACxB4a,EAAc9qD,EAAO+D,WAAW9D,GAAMA,IAAM4qD,GAChD,CACA,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAe,CAACnH,EAAKsqC,GAAkB,KACxC,MAAMxzD,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,6BAAEgkB,GAAkCx9E,KAAK++C,UACzF,KAAE7xC,GAAS0hC,EACjB5uC,KAAKkzE,eACLhmE,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACzC,GAAKntB,KAAKooE,sBACNpoE,KAAKyM,cAAcu7D,2BACnBua,EAIA,OAHA,IAAA76B,kBAAiB9Y,EAAW2Q,eAC5Bv/C,KAAKwiF,qBACL,EAAArjC,EAAA,GAAsCN,IAG1C,EAAAM,EAAA,GAAsCN,GACtC,MAAM23B,EAAahd,EACb,EAAAzqB,YAAY0uC,UACZ,EAAA1uC,YAAYggC,eAClB/uE,KAAKw+E,mBAAmB5vC,EAAYtzC,EAAgBk7E,EAAYgH,GAChEx9E,KAAKwiF,eAAe,EAExBxiF,KAAKw+E,mBAAqB,CAAC5vC,EAAYtzC,EAAgBk7E,EAAa,EAAAznC,YAAYymC,aAAcgI,GAA+B,KACrHhH,IAAe,EAAAznC,YAAY0uC,WAC3B,KAAAgF,mCAAkC7zC,EAAY4uC,IAG9C,KAAA1uC,2BAA0BF,EAAYtzC,EAAeY,SAASixB,QAASqpD,EAC3E,EAEJx2E,KAAK+9E,mBAAsB9lC,IACvB,MAAM+lC,EAAc/lC,EAAInxC,OAAS,EAAA2oB,OAAOwuD,oBAClC,WAAErvC,EAAU,oBAAEiQ,EAAmB,aAAE6jC,EAAY,aAAEC,EAAY,cAAEnpB,GAAmBx5D,KAAK++C,SAC7F,GAAI/+C,KAAK++C,SAAStP,OACd,OAEJ,MAAM1gB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,GAClBtzB,OAAQ06D,EAAW7d,MAAOsqC,GAAqB9nC,EACvD,IAAIt7B,EAAWojE,EACf,MAAMtnF,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EAChCo0C,EAAgB1vC,KAAK++C,SAAS8jC,YAAY5xC,mBAChD,IAAIi2B,EAAYx3B,EAAc9uC,QAAU,GAAKo9E,EAK7C,GAJAh+E,KAAKkzE,eACLlzE,KAAK8yB,WAAW3F,EAASyhB,EAAY,CACjC4qB,cAAeA,GAA0C,IAAzB9pB,EAAc9uC,SAE9C8uC,EAAc9uC,QAAU,EAAG,CAC3B,MAAMkiF,EAAqB,CACvBt6E,OAAQ,EACRu6E,YAAapsE,KAEjB,IAAK,IAAIjN,EAAI,EAAG4nC,EAAM5B,EAAc9uC,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACtD,MACMs5E,EAAoBL,EADLjzC,EAAchmC,IAE7Bu5E,EAAqB/mF,EAASwjD,cAAcsjC,GAC5CD,EAActwC,EAAKnkC,MAAMslC,uBAAuBuiB,EAAW8sB,GAC7DF,GA5JW,KA6JXA,EAAcD,EAAmBC,cACjCD,EAAmBC,YAAcA,EACjCD,EAAmBt6E,MAAQkB,EAEnC,CACiC,IAA7Bo5E,EAAmBt6E,QACnB0+D,GAAY,EAEpB,CACA,MAAM,iBAAEgb,GAAqBliF,KAAKyM,cAClC,GAAIy1E,IAAqBliF,KAAK++C,SAAStP,OAAQ,CAC3C,MAAMozC,EAAc,IAAI,KAClBK,EAAYljF,KAAKmjF,SAASC,cAAcV,EAAaE,GAAmB,GACxES,EAAarjF,KAAKmjF,SAASG,gBAAgBJ,GACjDL,EAAYU,UAAUF,GACtBR,EAAYW,YAAYxjF,KAAK++C,SAAS0kC,eACtCjkE,EAAWmjE,EAAaO,GACxBljF,KAAK++C,SAAS8jC,YAAcA,CAChC,CACA7iF,KAAK++C,SAAStP,OAASzvC,KAAK++C,SAAStP,QAAUy3B,EAC/ClnE,KAAK++C,SAAS0kC,cAAgBzjF,KAAK++C,SAAS8jC,YAC5C,MAAMa,EAAY1jF,KAAK++C,SAAS8jC,YAAYc,eAC5C3jF,KAAK++C,SAAS0kC,cAAczzC,gBAAgB0zC,GAC5C90C,EAAW1hC,KAAKyxC,QAAQlwC,OAAO9F,KAAKg6E,EAAae,IACjD1jF,KAAKmjF,SAASS,YAAYlB,EAAaljE,IACvCovB,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,GAClC7+C,KAAK++C,SAAStP,SACdzvC,KAAK6jF,iBAAiB7jF,KAAK++C,SAAS0kC,eACpCzjF,KAAKo/C,aAAanH,IAEtBA,EAAIiH,gBAAgB,EAExBl/C,KAAK69E,mBAAsB5lC,IACvB,MAAM,QAAE9qB,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,QAC/BgmB,MAAO94B,EAAU/jB,OAAQ06D,GAAcrb,GACzC,gBAAEnhC,IAAoB,IAAAue,mBAAkB/K,GACxC0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAS++B,gBAAkB3nB,EAChC,MAAQv5D,MAAOknF,EAAUjnF,OAAQknF,GAAc/jF,KAAKmjF,UAC9C,aAAET,GAAiB1iF,KAAK++C,SACxBilC,EAAatB,EAAaljE,GAChC,GAAIwkE,EAAW,GAAK,GAChBA,EAAW,GAAK,GAChBA,EAAW,IAAMF,GACjBE,EAAW,IAAMD,EACjB,OAEJ,MAAMV,EAAarjF,KAAKmjF,SAASG,gBAAgBU,GAC3CnB,EAAc,IAAI,KACxBA,EAAYU,UAAUF,GACtBR,EAAYW,YAAYxjF,KAAK++C,SAAS0kC,eACtCzjF,KAAK++C,SAAS8jC,YAAcA,GAC5B,EAAA1jC,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAEq1B,EAAa,YAAE3a,EAAW,cAAEC,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EACLnpD,QAAQC,KAAK,uCAEZ,CACD,MAAM,cAAEyqC,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/Bt4C,KAAKikF,WAAWzkE,EAAU2N,EAASyhB,EAAY2qB,EACnD,CACAv5D,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKiL,OAAUkiB,IACX,IAAKntB,KAAKs+C,UACN,OAEJt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,SAOhE,OANIya,IACA,IAAA9R,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GACtC7+C,KAAKkzE,eACLlzE,KAAKmjF,SAAW,KACTv0C,EAAW2Q,aAAa,EAEnCv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAK69E,oBACjD1wD,EAAQ1E,iBAAiB,EAAAgH,OAAOivD,WAAY1+E,KAAK+9E,oBACjD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAOwuD,mBAAoBj+E,KAAK+9E,oBACzD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAK+9E,mBAAmB,EAEvE/9E,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAK69E,oBACpD1wD,EAAQrE,oBAAoB,EAAA2G,OAAOivD,WAAY1+E,KAAK+9E,oBACpD5wD,EAAQrE,oBAAoB,EAAA2G,OAAOwuD,mBAAoBj+E,KAAK+9E,oBAC5D5wD,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAK+9E,mBAAmB,EAE1E/9E,KAAKw0E,sBAAwB,CAAC5lC,EAAYzhB,KACtC,IAAKntB,KAAKyM,cAAcqiE,eACpB,OAEJ,MAAM5hE,EAAO0hC,EAAW1hC,KACxB,IAAKA,EAAK2gC,QAAQ4B,OACd,OAEJ,MAAMn0C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,GAChC,YAAEsjD,GAAgB1xC,GAChB+hE,SAAUxgE,GAAWvB,EAAK2gC,QAC5B0nC,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,SAAE0L,GAAa1L,EACfklD,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Ds8B,EAAc0V,EAAkB,GAChCy+B,EAAqBjjF,EAASkzB,cAAc4b,GAC5Co0C,EAAcljF,EAASkzB,cAAc,CACvC4b,EAAY,GAAK,EACjBA,EAAY,KAEVq0C,EAAcnjF,EAASkzB,cAAc,CACvC4b,EAAY,GACZA,EAAY,GAAK,IAEfs0C,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,IAC7C,UAAEh9D,GAAc7mB,GAChB,MAAEgB,EAAK,SAAEw8E,IAAa,QAAiCx9E,GAAO,KAChE,MAAQ+nB,KAAMi8D,EAAY1+C,KAAM2+C,EAAYn8D,KAAMo8D,EAAY7+C,KAAM8+C,GAAgBltC,EAAKw8B,SAAS2Q,QAAQl/B,GACpGm/B,EAAiB3jF,EAASkzB,cAAc,CAC1CswD,EACAC,IAEEG,EAAiB,EAAAxzC,UAAA,sBAAgCjqB,EAAWw9D,GAC5DE,EAAqB7jF,EAASkzB,cAAc,CAC9CowD,EACAC,IAGJ,MAAO,CAACK,EADmB,EAAAxzC,UAAA,sBAAgCjqB,EAAW09D,GAC3B,IAE/C,IAAI9G,EAAOxmC,EAAKw8B,SAAS+Q,QAAQt/B,GAAqBlkD,EAAQA,EAC9Dy8E,GAAQqG,EAAWC,EACnB3gC,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACAD,SAAUA,EAElB,CACA,MAAMz9E,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,GACAyE,KAAK8uC,0BAA0BF,EAAYtzC,EAAgB,EAAAyzC,YAAYymC,cAEpE52B,CAAW,EAEtB5+C,KAAK2+E,aAAe,CAAC/vC,EAAY1yC,EAAUmkD,EAAkBu+B,KACzD,MAAM1xE,EAAO0hC,EAAW1hC,KAClBiX,EAAWnkB,KAAK82D,YAAY56D,GAClC,IAAKgR,EAAK2gC,QAAQ4B,SAAWmvC,EAAajxD,WACtC,OAEJ,MAAM8mD,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,OAEJ,MAAM8/C,EAAoBxzC,EAAKyxC,QAAQlwC,OAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAChF,IAAKxB,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAE9DgM,GAAc,IAAAC,mBAAqBz0B,EAAkBzR,EAAW2Q,eAAiB,GADpE,UACoFk1B,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGk+B,IAClJthF,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAC5D,EAELmD,KAAK8uC,0BAA4B,CAACF,EAAYtzC,EAAgBk7E,EAAa,EAAAznC,YAAYymC,gBACnF,MAAM,WAAEtoD,EAAU,kBAAEhB,GAAsB5wB,EACpC+iF,EAAY,EAAA5uD,OAAO8uD,oBACnBxvD,EAAc,CAChB6f,aACA1hB,aACAhB,oBACAsqD,eAEJ,IAAAh3C,cAAa,EAAArN,YAAaksD,EAAWtvD,EAAY,EAErD/uB,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,iBAAAkP,CAAkB1kE,EAAU2N,EAASyhB,EAAYu1C,EAAS3G,GACtD,MAAMliF,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM8lC,EAAoBloF,EAASw5B,gBAC3BrT,UAAW4oB,GAAiBm5C,EACpC,IAAI1B,EACAC,EACA/lF,EACAC,EACAsI,EACJ,GAAMjJ,aAAoB,EAAAsyC,eAUrB,MAAItyC,aAAoB,EAAAsyC,gBAiBzB,MAAM,IAAIpwC,MAAM,0BAjByB,CACzC,MAAMimF,EAAiB,0CAAsCnoF,IACvD,mBAAE44B,EAAkB,mBAAEC,GAAuBsvD,EACnD3B,EAAgBp0E,IACZ,MAAMg2E,EAAW,kCAA8Br5C,EAAc38B,GACvD01E,EAAa,mBAAmB,CAAC,EAAG,EAAG,GAAIM,EAAUvvD,GAC3D,MAAO,CAACivD,EAAW,GAAIA,EAAW,GAAG,EAEzCrB,EAAgBr0E,IACZ,MAAMg2E,EAAW,mBAAmB,CAAC,EAAG,EAAG,GAAI,CAACh2E,EAAM,GAAIA,EAAM,GAAI,GAAIwmB,GACxE,OAAO,kCAA8BmW,EAAcq5C,EAAS,EAEhEn/E,EAAak/E,EAAel/E,WAC5BvI,EAAQynF,EAAeznF,MACvBC,EAASwnF,EAAexnF,MAC5B,CAGA,MA3BID,EAAQwnF,EAAkBv8E,WAAW,GACrChL,EAASunF,EAAkBv8E,WAAW,GACtC66E,EAAgBp0E,IACZ,MAAMg2E,EAAW,kCAA8Br5C,EAAc38B,GAC7D,MAAO,CAACg2E,EAAS,GAAIA,EAAS,GAAG,EAErC3B,EAAgBr0E,GAAU,kCAA8B28B,EAAc,CAAC38B,EAAM,GAAIA,EAAM,GAAI,IAC3FnJ,EAAai/E,EAAkBj/E,WAqBnCA,EAAa,+BAA2BA,EAAYvI,EAAOC,GAC3D,MAAM,SAAEohB,GAAa/hB,EAAS+oB,gBACxBs/D,EAAW7B,EAAaljE,GAC9Bxf,KAAKmjF,SAAWqB,GAAA,EAAiBC,+BAA+Bt/E,EAAYvI,EAAOC,EAAQohB,GACvFkmE,IACAnkF,KAAK0kF,aAAeF,GAAA,EAAiBC,+BAA+Bt/E,EAAYvI,EAAOC,EAAQohB,GAC/Fje,KAAK0kF,aAAad,YAAYlB,EAAayB,KAE/CnkF,KAAKmjF,SAASS,YAAYW,GAC1B,MAAM/qB,GAAiB2qB,EACjBV,EAAgB,IAAI,KACpBZ,EAAc,IAAI,KAClB8B,EAAkBnrB,OAAgBx7D,EAAY,IAAI,KACxDylF,EAAc1rE,SAASwsE,GACvBd,EAAczzC,gBAAgBu0C,GAC9B,MAAM1lC,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACnEo/B,EAAkB5hF,EAASwjD,cAAclgC,GAC/Cxf,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA2a,gBACAE,UAAU,EACVokB,kBACA2F,gBACAZ,cACA+B,kBAAmBD,EACnBl1C,QAAQ,EACR8pB,YAAav5D,KAAK++C,UAAUwa,aAAe3qB,EAAW+P,SAAS8Z,kBAC/DiqB,eACAC,eACAnF,+BAER,CACA,gBAAAn/B,CAAiBpG,GACb,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,GAC3BupB,MAAO94B,GAAas7B,EACtBlM,EAAa5uC,KAAKmgF,iBAAiBloC,GACnCulC,GAA+B,EAAAyC,GAAA,GAAoBhoC,EAAI3lB,OAAO4tD,SAChElgF,KAAKyM,cAAciwE,+BAMvB,OALA18E,KAAKkkF,kBAAkB1kE,EAAU2N,EAASyhB,OAAY5wC,EAAWw/E,GACjEx9E,KAAKioD,cAAcrZ,EAAYzhB,GAC/BntB,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCn/C,KAAK++C,SAASF,qBAC7CjQ,CACX,CACA,aAAA4zC,GACIxiF,KAAK++C,SAAW,KAChB/+C,KAAKmjF,SAAW,KAChBnjF,KAAK0kF,aAAe,KACpB1kF,KAAKs+C,WAAY,CACrB,CACA,UAAA2lC,CAAWzkE,EAAU2N,EAASyhB,EAAY2qB,GACtC,MAAM,KAAErsD,GAAS0hC,GACTngC,OAAQo2E,GAAiB33E,EAAKyxC,SAC9B/9C,OAAQkkF,GAAeD,EACzBE,EAAiBF,GAActrB,EAAc,EAAIurB,GAAcA,GAC/DE,EAAaH,GAActrB,EAAc,GAAKurB,GACpD,IAAK9kF,KAAK++C,UAAU6lC,kBAAmB,CACnC5kF,KAAKkkF,kBAAkBa,EAAgB53D,EAASyhB,EAAYo2C,GAC5D,MAAM,SAAE/V,GAAa/hE,EAAK2gC,QACpB41C,EAAgB,IAAI,KACpBmB,EAAoB,IAAI,MACxB,aAAElC,GAAiB1iF,KAAK++C,SACxBgyB,GAAgB,EAAAkU,GAAA,GAAwBr2C,EAAY2qB,EAAc,GAClEyX,GAAY,EAAAiU,GAAA,GAAwBr2C,EAAY2qB,EAAc,GACpE,IAAmB,IAAfyX,IAAuC,IAAnBD,EACpB,MAAM,IAAI3yE,MAAM,4BAA0C,IAAf4yE,GAAoBgU,MAAiC,IAAnBjU,GAAwBgU,KAErF,IAAhBxrB,EACAqrB,EAAkBrB,UAAUtU,EAASvuE,MAAMswE,EAAY,EAAGD,GAAe1qE,IAAIq8E,KAG7Ee,EAAcF,UAAUtU,EAASvuE,MAAM,EAAGqwE,EAAgB,GAAG1qE,IAAIq8E,IACjEkC,EAAkBrB,UAAUtU,EAASvuE,MAAMswE,EAAW/B,EAASruE,QAAQyF,IAAIq8E,KAE/E1iF,KAAK++C,SAAS0kC,cAAgBA,EAC9BzjF,KAAK++C,SAAS6lC,kBAAoBA,CACtC,CACA,MAAM,SAAE7lC,EAAQ,SAAEokC,GAAanjF,MACzB,aAAE0iF,EAAY,aAAEC,GAAiB5jC,GACjC,kBAAE0Z,GAAsBvrD,EAAKyxC,QACnC,GAAI8Z,QACAvrD,EAAKyxC,QAAQ8Z,kBAAoBc,OAEhC,GAAId,IAAsBc,EAC3B,MAAM,IAAIn7D,MAAM,yEAAyEm7D,OAAiBrsD,EAAKyxC,QAAQ8Z,qBAE3H,MAAMysB,EAAWxC,EAAaljE,GAC9B,GAAI0lE,EAAS,GAAK,GACdA,EAAS,IAAM/B,EAASvmF,OACxBsoF,EAAS,GAAK,GACdA,EAAS,IAAM/B,EAAStmF,OACxB,OAEJgoF,EAAatrB,GAAeopB,EAAauC,GACzC,MAAMC,EAAiBhC,EAASG,gBAAgB4B,GAC1CE,EAAkBplF,KAAK0kF,aAAapB,gBAAgB4B,GACpDrC,EAAc,IAAI,KACxBA,EAAYW,YAAYzkC,EAAS0kC,eACb,IAAhBlqB,GACAspB,EAAYU,UAAU4B,GAE1BtC,EAAYU,UAAU6B,EAAgBt3E,WACtC+0E,EAAYwC,WAAWtmC,EAAS6lC,mBACZ,IAAhBrrB,GACAspB,EAAYU,UAAU4B,GAE1BpmC,EAAS8jC,YAAcA,EACvBj0C,EAAWrzC,aAAc,EACzBwjD,EAAS2a,UAAW,EACpB3a,EAAStP,QAAS,CACtB,CACA,gBAAA2Q,CAAiB9kD,EAAgB+kD,GAE7B,OADArgD,KAAK6jF,iBAAiB7jF,KAAK++C,UAAU8jC,aAC9BzrC,MAAMgJ,iBAAiB9kD,EAAgB+kD,EAClD,CACA,yBAAAggC,GACI,OAAO,CACX,CACA,gBAAAF,CAAiBloC,GACb,MAAMqtC,EAAgCluC,MAAM+oC,iBAAiBloC,IACrDK,MAAO94B,GAAay4B,EAAI3lB,OAAOwoB,cAQvC,OAPmB,sBAAkBwqC,EAA+B,CAChEp4E,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,OAK7B,CACA,gBAAA6iE,CAAiBl1D,EAASgrC,EAAQlgB,GACzBj4C,KAAK++C,SAIV/+C,KAAKo/C,aAAanH,GAAK,GAHnBj4C,KAAKgyB,MAIb,CACA,wBAAAsuD,CAAyBC,GACrB,MAAM,WAAE3xC,EAAU,eAAEtzC,EAAc,iBAAE+kD,EAAgB,gBAAEmgC,EAAe,SAAEr8D,GAAco8D,GAC/E,SAAErkF,GAAaZ,GACf,QAAE6xB,GAAYjxB,GACd,cAAEwjD,GAAkBxjD,GACpB,cAAEqjD,EAAa,KAAEryC,EAAI,YAAEuxC,GAAgB7P,GACvC,QAAE+P,GAAYzxC,EACdssD,EAAgBx5D,KAAK++C,UAAUya,eAC/B,UAAE7Y,EAAS,SAAEC,EAAQ,MAAExkD,GAAUokF,EACvC,GAAI/hC,GACC+a,GACG5qB,EAAW2Q,gBAAkBv/C,KAAK++C,UAAUnQ,YAAY2Q,cAAgB,CAC5E,MAAM6a,EAAiB,IACjBmrB,EAAgB5mC,EAAQlwC,OAAOpI,IAAIq5C,IACzC,IAAAyQ,aAAe9P,EAAkBd,EAAe6a,EAAgBmrB,EAAe,CAC3EnpF,QACAwkD,WACAD,aAER,CAeA,OAdAvJ,MAAMkpC,yBAAyBC,GAC1BrzE,EAAK0xC,YAAYz6B,IACuB,OAAzCjX,EAAK0xC,YAAYz6B,IAAW60D,SAQvBpqC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYzhB,IARhDjgB,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACND,SAAU,MAEdh5E,KAAKw0E,sBAAsB5lC,EAAYzhB,IAK3CntB,KAAK2+E,aAAa/vC,EAAY1yC,EAAUmkD,EAAkBmgC,EAAgBgB,UACnE,CACX,CACA,gBAAAqC,CAAiB2B,GACb,IAAKxlF,KAAK++C,WAAaymC,EACnB,OAEJ,MAAM,WAAE52C,EAAU,aAAE+zC,EAAY,aAAED,EAAY,OAAEjzC,EAAM,cAAE+pB,GAAkBx5D,KAAK++C,SAC/E,IAAM0mC,WAAYC,GAAgBF,EAC9BE,EAAY9kF,OAAS,IACrB8kF,EAAc,IAAIA,EAAaA,EAAY,KAE/C,MAAMxE,EAAyB1nB,GAAiB/pB,EAAS,KAAwB0xC,eAAYnjF,EAC7FgC,KAAKihF,sBAAsBryC,EAAY,CACnCngC,OAAQi3E,EACRj2C,SACAyxC,0BACD,CACC9xD,cAAeuzD,EACfjjC,cAAegjC,GAEvB,EAEJ,YACA,SAAS,GAAoBx1E,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,KAAE80D,EAAI,SAAED,GAAavD,EACrBhB,EAAY,GAClB,GAAIwE,EAAM,CACN,MAAMsB,EAAW,SAAS,wBAAoBtB,MAASD,IACvDvE,EAAU9rE,KAAK4xE,EACnB,CACA,OAAO9F,CACX,CC9oBA,MAAMkR,WAAwC,UACjC3lF,KAAKy4C,SAAW,iCAAmC,CAC5D,4BAAAmtC,CAA6Bh3C,EAAYtzC,IACjC0E,KAAK++C,UACJnQ,EAAWrzC,aACXqzC,EAAW1hC,KAAKyxC,QAAQknC,uBAG7Bj3C,EAAW1hC,KAAK2gC,QAAQi4C,iBAAmBl3C,EAAW1hC,KAAK2gC,QAAQohC,SACnE8W,gBAAe,KACX,IAAKn3C,EAAW1hC,KAAKyxC,QAAQknC,qBACzB,OAEJ,MAAM,OAAEp3E,GAAWmgC,EAAW1hC,KAAKyxC,SAC7B,QAAExxB,GAAY7xB,EAAeY,SACnC8D,KAAKkkF,kBAAkBz1E,EAAO,GAAI0e,EAASyhB,GAC3C,MAAQhuC,OAAQqO,GAAUR,GACpB,SAAE00E,GAAanjF,MACf,YAAEmiF,EAAW,oBAAE6D,GAAwBhmF,KAAKyM,cAAcoM,cAChE+1B,EAAW1hC,KAAKyxC,QAAQsnC,eAAiBx3E,EACzC,MAAM,aAAEi0E,EAAY,aAAEC,GAAiB3iF,KAAK++C,SACtCmnC,EAAkB,GACxB,GAAI/D,EAAa,CACb,IAAIuB,EAAYhB,EAAaj0E,EAAOA,EAAO7N,OAAS,IACpD6N,EAAOxN,SAAQ,CAACqN,EAAO63E,KACnB,MAAMC,EAAY1D,EAAap0E,GAC/Bo1E,EAAY0C,EACZF,EAAgBv9E,KAAKy9E,GACrBjD,EAASS,YAAYF,GACrBP,EAASG,gBAAgB8C,GACzBjD,EAASG,gBAAgBZ,EAAaj0E,GAAQ03E,EAAS,GAAK13E,EAAO7N,UACnE,MAAMylF,EAAWlD,EAASC,cAAcgD,EAAWjE,GAC9C,oBAAgBiE,EAAWC,KAC5BH,EAAgBC,GAAUE,EAC1B3C,EAAY2C,EACZ53E,EAAO03E,GAAUxD,EAAa0D,GAClC,GAER,CACA,MAAMC,EAAe,IAAI,KACzB,IAAK,IAAI58E,EAAI,EAAGA,EAAIuF,EAAOvF,IAAK,CAC5By5E,EAASS,YAAYlB,EAAaj0E,EAAO/E,KACzC,MAAM68E,EAAOpD,EAASG,gBAAgBZ,EAAaj0E,GAAQ/E,EAAI,GAAKuF,KACpEq3E,EAAa/C,UAAUgD,EAC3B,CACAvmF,KAAK6jF,iBAAiByC,GACtBtmF,KAAKmjF,SAAW,KAChBnjF,KAAK0kF,aAAe,KACpB1kF,KAAK++C,SAAW,KAChBnQ,EAAW1hC,KAAKyxC,QAAQknC,qBAAuB,KAC3CG,IACA,KAAAl3C,2BAA0BF,EAAYtzC,EAAeY,SAASixB,QAAS,EAAA4hB,YAAYy3C,qBACvF,IAER,CACA,wBAAAlG,CAAyBC,GACrB,MAAM,eAAEjlF,EAAc,iBAAE+kD,GAAqBkgC,EACvC3xC,EAAa2xC,EAAc3xC,YAC3B,cAAE2Q,GAAkB3Q,GACpB,SAAE1yC,GAAaZ,GACf,cAAEokD,GAAkBxjD,GACpB,0BAAEkmF,GAA8BpiF,KAAKyM,cAAcoM,eAAiB,CAAC,EAC3E7Y,KAAK4lF,+BAA+Bh3C,EAAYtzC,GAChD,MAAM,iBAAEwqF,GAAqBl3C,EAAW1hC,KAAK2gC,QACvC44C,EAAWrvC,MAAMkpC,yBAAyBC,GAChD,GAAI6B,GACA0D,GACAl3C,EAAW2kC,cAAe,CAC1B,MAAMmT,EAAuBZ,EAAiBz/E,IAAIq5C,GAClDgnC,EAAqB/9E,KAAK+9E,EAAqB,KAC/C,IAAApF,cAAgBjhC,EAAkBd,EAAe,yBAA0BmnC,EAAsB,CAC7FtqF,MAAO,UACPukD,UAAW,EACXsmB,YAAa,GAErB,CACA,OAAOwf,CACX,CACA,yBAAApG,GACI,OAAO,CACX,ECxEJ,MAAMsG,WAA0B,aACnB3mF,KAAKy4C,SAAW,eAAiB,CAC1C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACR0rB,gBAAe,GACfC,mBAAkB,GAClBrK,2BAA2B,EAC3B4e,YAAY,EACZC,eAAgB,YAGpBzvC,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,GACtC,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,IACnF,WAAEwkD,GAAe5mF,KAAKyM,cACtBzC,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACF6lE,KAAM,GACNp0B,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmuB,aACAhe,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,MAGf,IAAAs2B,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACVma,EAAQE,GAAU/7C,EAAKyxC,QAAQlwC,OAChC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCgG,EAAO,CACTvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAIxB,OADwB,mBAA4B,CAACnlB,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACpHC,CAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,EAAQ,cAAEwa,GAAmBl0E,KAAK++C,UACpF,KAAE7xC,GAAS0hC,EACb4qB,IAAkBE,IAGtBxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACfntB,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,eAE5Bia,EACAx5D,KAAKyM,cAAc2lE,iBAAiBW,IAChC,IAAKA,EAKD,OAJA,IAAArrB,kBAAiB9Y,EAAW2Q,gBAC5B,EAAAJ,EAAA,GAAsCN,GACtC7+C,KAAK++C,SAAW,UAChB/+C,KAAKs+C,WAAY,GAGrB1P,EAAW1hC,KAAK6lE,KAAOA,GACvB,KAAAjkC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,iBAC3D,KAAAvvB,4BAA2B5Q,GAC3B5uC,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,gBAAiBx5D,KAAKyyB,OAC7Dkc,GAAmBC,EAAYzhB,EAAS4lD,IACxC,EAAA5zB,EAAA,GAAsCN,EAAoB,IAGxDq1B,IACN,KAAAplC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,gBAE/D/uE,KAAKkzE,eACLlzE,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EAAK,EAE1Bt+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAK8mF,iBAAoB7uC,IACE,GAAnBA,EAAI3lB,OAAOy0D,MACX/mF,KAAKgnF,oBAAoB/uC,EAC7B,EAEJj4C,KAAKgnF,oBAAuB/uC,IACxB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB,IAAIwxB,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GAErD,GADAozB,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAEJ,MAAMqmF,EAAoB1mC,EAAY7iC,MAAMkxB,GAAe5uC,KAAKgiD,gBAAgB70B,EAASyhB,EAAY7f,EAAY+rB,cAAcr/C,OAAQ,KACvI,IAAKwrF,EACD,OAEJ,MAAMr4C,EAAaq4C,EACnBjnF,KAAKyM,cAAc4lE,mBAAmB4U,EAAmBhvC,EAAI3lB,OAAQtyB,KAAKwzE,0BAA0BhjE,KAAKxQ,KAAMmtB,EAASyhB,IACxH5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBrG,EAAIivC,2BACJjvC,EAAIiH,gBAAgB,EAExBl/C,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,QAAE+P,EAAO,KAAEo0B,GAAS7lE,GACpB,OAAEuB,EAAM,kBAAEgqD,GAAsB9Z,EACtC8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,EAAQ,WAAEumC,GAAennF,KAAK6gD,mBAAmB,CACvEjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE,IAAIwrD,EAMJ,IALK,KAAAhP,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,MAE7Cv8D,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,GAAI2a,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAukD,aAER,CACA,MAAMymC,EAAW,IAoBjB,GAnBIpnF,KAAKyM,cAAcm6E,YACnB,IAAAS,WAAahnC,EAAkBd,EAAe6nC,EAAU1mC,EAAkB,GAAIA,EAAkB,GAAI,CAChGtkD,QACAQ,MAAO+jD,EACPC,SAAUA,EACV0mC,UAAiD,WAAtCtnF,KAAKyM,cAAco6E,eAC9BM,gBAIJ,IAAAE,WAAahnC,EAAkBd,EAAe6nC,EAAU1mC,EAAkB,GAAIA,EAAkB,GAAI,CAChGtkD,QACAQ,MAAO+jD,EACPC,SAAUA,EACV0mC,UAAiD,WAAtCtnF,KAAKyM,cAAco6E,eAC9BM,eAGR7mC,GAAe,GACVyyB,EACD,SAEJ,MAAM3uE,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,IAAK71D,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,EAAsBh0B,EAAkB,GAC9CxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAY,CAACL,GAAO6B,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IAC9H9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,CAE3B,QACStgD,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQskE,EAAM3uE,KAC/C,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAY0R,GAAmBrrF,EAAgBmT,EAAQrK,GAC/IwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACF6lE,KAAMA,GAAQ,GACdp0B,QAAS,CACLlwC,WAGRgwC,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,sBAAA64C,CAAuBjK,EAAKrJ,EAAY0qB,GACpC,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,yBAAAs0B,CAA0BrmD,EAASyhB,EAAY6kC,GAC3C7kC,EAAW1hC,KAAK6lE,KAAOU,GACA,IAAAv7C,mBAAkB/K,GAAzC,MACM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,gBACzE,EAAAS,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAC1C,CACA,eAAAumD,CAAgBC,EAAQC,EAAQ/rE,GAC5B,OAAQ,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,EAC9C,EAEJ,SAAS,GAAgBgsE,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAAS,GAAmB5mE,EAAM0yB,EAAWi0C,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,CClcA,MAAMyT,WAAkB,aACXvnF,KAAKy4C,SAAW,OAAS,CAClC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAc,MAGlB58B,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,GAAIj4C,KAAKwnF,4BACL,OAEJxnF,KAAKwnF,6BAA8B,EACnC,MAAMz4D,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,GACtC,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACVma,EAAQE,EAAQE,GAAUj8C,EAAKyxC,QAAQlwC,OACxC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCw+B,EAAQ,CACV/rF,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAIxB,GADwB,mBAA4B,CAACqT,EAAM/rF,MAAM4B,EAAGmqF,EAAM/rF,MAAM8B,GAAI,CAACiqF,EAAMz1E,IAAI1U,EAAGmqF,EAAMz1E,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACxHC,EACnB,OAAO,EAEX,IAAKZ,EACD,OAAO,EAEX,MAAMu+B,EAAexrF,EAASwjD,cAAcyJ,GACtCw+B,EAAQ,CACVjsF,MAAO,CACH4B,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,IAEpBpiE,IAAK,CACD1U,EAAGoqF,EAAa,GAChBlqF,EAAGkqF,EAAa,KAIxB,OADyB,mBAA4B,CAACC,EAAMjsF,MAAM4B,EAAGqqF,EAAMjsF,MAAM8B,GAAI,CAACmqF,EAAM31E,IAAI1U,EAAGqqF,EAAM31E,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACxHC,CAGZ,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ,GAAI15D,KAAKwnF,6BAA8D,IAA/Bt6E,EAAKyxC,QAAQlwC,OAAO7N,OAExD,YADAZ,KAAK++C,SAASwa,YAAc,GAGhCv5D,KAAKwnF,6BAA8B,EACnCt6E,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACxB0E,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,GAAkBl0E,KAAK++C,UACvE,KAAE7xC,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EASjB,OARAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKwnF,6BAA8B,EAC5B54C,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QAC3C8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAWnE,IAAIwrD,EAMJ,GAhBKhtD,EAAK0xC,YAAYz6B,IACkB,MAApCjX,EAAK0xC,YAAYz6B,GAAUrnB,MAMtB8xC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IANjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBrnB,MAAO,MAEXkD,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAMvD,KAAA4vD,oBAAmBtc,EAAW2Q,gBAC9Bv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,MAE7Cv8D,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,GAAI2a,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAwkD,WACAD,aAER,CACA,IAAI2O,EAAU,IAOd,IANA,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO+jD,EACPC,aAEJN,GAAe,EACkB,IAA7BI,EAAkB9/C,OAClB,OAAO0/C,EAQX,GANAgP,EAAU,KACV,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO+jD,EACPC,cAEC1zC,EAAK0xC,YAAYz6B,IAAWrnB,MAC7B,SAEJ,MAAMsH,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKjX,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,EAAsBh0B,EAAkB,GAC9CxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,QACSh1E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYsS,GAAWjsF,EAAgBmT,EAAQrK,GACvIwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACFyxC,QAAS,CACLlwC,WAGRgwC,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,IAAI,CACrD,CACH,sBAAA64C,CAAuBjK,EAAKrJ,EAAY0qB,GACpC,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,qBAAAs1B,CAAsB5lC,EAAYj1B,EAAiBre,GAC/C,MAAM4R,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAY7xB,EAAeY,SACnC,GAAmC,IAA/BgR,EAAKyxC,QAAQlwC,OAAO7N,OACpB,OAEJ,MAAMy0E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,GAChCm5E,EAAY16E,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrB5M,GAAQ,EAAA0mD,GAAA,GAAkB,CAAC6xB,EAAWC,GAAY,CAACA,EAAWsS,KAC9D,WAAE//E,EAAU,UAAEwa,GAAcriB,KAAKgkE,mBAAmB7/C,GAC1DnkB,KAAKooE,qBAAuB,CAACiN,EAAWC,EAAWsS,GAC9CvhF,KAAKmZ,GAAa,kCAA8B6C,EAAW7C,KAC3DyH,MAAMze,IAAW,kCAA8BA,EAAOX,KAC3D+2C,EAAYz6B,GAAY,CACpBrnB,MAAO0f,MAAM1f,GAAS,mBAAqBA,EAEnD,CACA,MAAMvB,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CACX,EAEJ,SAAS,GAAoB1xC,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,MAAErnB,GAAU24E,EAClB,QAAcz3E,IAAVlB,EACA,OAEJ,GAAI0f,MAAM1f,GACN,MAAO,CAAC,GAAGA,KAKf,MAHkB,CACd,GAAG,wBAAoBA,MAAUsP,OAAOy7E,aAAa,OAG7D,C,gBCpdA,MAAMC,WAAsB,aACf9nF,KAAKy4C,SAAW,WAAa,CACtC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAc,GACd+T,cAAc,KAGlB3wC,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,GAAIj4C,KAAKwnF,4BACL,OAEJxnF,KAAKwnF,6BAA8B,EACnC,MAAMz4D,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,GACtC,KAAA2jD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,gBAAEiE,EAAe,iBAAEohB,GAAqBj0D,KAAKgoF,gBAAgB,CAC/D9rF,WACAuS,OAAQvB,EAAKyxC,QAAQlwC,OACrBq7C,eACAC,cAEJ,OAAIlX,GAAmBkX,GAAakK,GAAoBlK,CAG5C,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,EAAYqb,EAAiBH,EAAcC,EAAY,KACrF,MAAMh7B,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACnEpjD,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,GAChC,gBAAE2sF,EAAe,iBAAEC,GAAqBloF,KAAKgoF,gBAAgB,CAC/D9rF,WACAuS,OAAQmgC,EAAW1hC,KAAKyxC,QAAQlwC,OAChCq7C,eACAC,cAEJ/pD,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,EACf+T,kBACAC,oBAEJloF,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAGJ,GADA15D,KAAKkzE,eACDlzE,KAAKwnF,6BAA+Bt6E,EAAKyxC,QAAQlwC,OAAO7N,OAAS,EAGjE,OAFA,KAAA0+C,oBAAmBnyB,QACnBntB,KAAK++C,SAASwa,YAAcrsD,EAAKyxC,QAAQlwC,OAAO7N,QAGpDZ,KAAKwnF,6BAA8B,EACnCt6E,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACxB0E,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAK+9E,mBAAsB9lC,IACvB,MAAM,WAAErJ,EAAU,YAAE2qB,GAAgBv5D,KAAK++C,SACnChwB,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,cAAE2tB,GAAkB/rB,EAC7BvP,EAAWs7B,EAAcxC,OACzB,KAAEprC,GAAS0hC,EACjB,OAAoB,IAAhB2qB,GACArsD,EAAKyxC,QAAQlwC,OAAO,GAAK+Q,OACzBxf,KAAK++C,SAAS2a,SACVxsD,EAAKyxC,QAAQlwC,OAAO,GAAG,KAAOvB,EAAKyxC,QAAQlwC,OAAO,GAAG,IACjDvB,EAAKyxC,QAAQlwC,OAAO,GAAG,KAAOvB,EAAKyxC,QAAQlwC,OAAO,GAAG,KAG7C,IAAhB8qD,GACArsD,EAAKyxC,QAAQlwC,OAAO,GAAK+Q,EACzBxf,KAAK++C,SAAS2a,SACVxsD,EAAKyxC,QAAQlwC,OAAO,GAAG,KAAOvB,EAAKyxC,QAAQlwC,OAAO,GAAG,IACjDvB,EAAKyxC,QAAQlwC,OAAO,GAAG,KAAOvB,EAAKyxC,QAAQlwC,OAAO,GAAG,QAC7DzO,KAAKwnF,6BAA8B,KAGvCxnF,KAAK++C,SAAS2a,UAAW,GACzB,KAAAza,mBAAkB9xB,GAClBjgB,EAAKyxC,QAAQlwC,OAAO,GAAKvB,EAAKyxC,QAAQlwC,OAAO,GAAK+Q,OAClDxf,KAAK++C,SAASwa,YAAcrsD,EAAKyxC,QAAQlwC,OAAO7N,OAAS,GAAC,EAE9DZ,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,gBAAE+T,EAAe,iBAAEC,EAAgB,cAAE1uB,GAAmBx5D,KAAK++C,SAChI/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,IACJ0uB,GAAmBC,GAAmB,CACvC,MAAM,YAAE9vC,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MAC5B7pC,EAASvB,EAAKyxC,QAAQlwC,OAC5B,GAAIw5E,EAAiB,CACO,CAACx5E,EAAO,GAAIA,EAAO,IAC3BxN,SAASqN,IACrBA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,GAEpC,MACK,GAAI6T,EAAkB,CACE,CAACz5E,EAAO,GAAIA,EAAO,IAC3BxN,SAASqN,IACtBA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,GAEpC,CACAzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GAClCjQ,EAAWrzC,cACX,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAKiL,OAAUkiB,IACX,IAAKntB,KAAKs+C,UACN,OAEJt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACb1hC,EAAKyxC,QAAQlwC,OAAO7N,OAAS,IAC7B,IAAA8mD,kBAAiB9Y,EAAW2Q,eAEhC3Q,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjC,MAAMn9D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EAO5B,OANA,EAAA6jD,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKwnF,6BAA8B,EAC5B54C,EAAW2Q,aAAa,EAEnCv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO04D,YAAanoF,KAAK+9E,oBAClD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO04D,YAAanoF,KAAK+9E,oBACrD5wD,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOivD,WAAY1+E,KAAK+9E,oBACjD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO04D,YAAanoF,KAAK+9E,oBAClD5wD,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOivD,WAAY1+E,KAAK+9E,oBACpD5wD,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO04D,YAAanoF,KAAK+9E,oBACrD5wD,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QAC3C8B,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,mBAEEC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KA+BnE,IAAIwrD,EAMJ,GApCKhtD,EAAK0xC,YAAYz6B,IACkB,MAApCjX,EAAK0xC,YAAYz6B,GAAUrnB,MA0BtB8xC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IA1BjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBrnB,MAAO,KACPsrF,UAAW,KACXC,UAAW,KACX55E,OAAQ,CACJ6pC,MAAO,CACHgwC,UAAW,KACXC,QAAS,KACTC,UAAW,KACXC,QAAS,KACTL,UAAW,KACXC,UAAW,MAEf5sF,OAAQ,CACJ6sF,UAAW,KACXC,QAAS,KACTC,UAAW,KACXC,QAAS,KACTL,UAAW,KACXC,UAAW,QAIvBroF,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAMvD,KAAA4vD,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,MAE7Cv8D,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAEJ,GAAI2a,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgB1Z,EAAmB,CAC/EtkD,QACAwkD,WACAD,aAER,CACA,MAAM+nC,EAAY,CAAChoC,EAAkB,GAAIA,EAAkB,IACrDioC,EAAa,CAACjoC,EAAkB,GAAIA,EAAkB,IAC5D,IAAI4O,EAAU,QAOd,IANA,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAASo5B,EAAU,GAAIA,EAAU,GAAI,CAC9EtsF,QACAQ,MAAO+jD,EACPC,aAEJN,GAAe,EACXI,EAAkB9/C,OAAS,EAC3B,OAAO0/C,EAEXgP,EAAU,SACV,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAASq5B,EAAW,GAAIA,EAAW,GAAI,CAChFvsF,QACAQ,MAAO+jD,EACPC,aAEJ0O,EAAU,WACV,MAAMs5B,GAAO,EAAAC,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACzCI,GAAO,EAAAD,GAAA,GAAUF,EAAW,GAAIA,EAAW,KACjD,IAAAp5B,UAAYlP,EAAkBd,EAAe+P,EAASs5B,EAAME,EAAM,CAC9D1sF,QACAukD,UAAW,IACXC,SAAU,QAEd,MAAM,UAAE0nC,EAAS,QAAEC,EAAO,QAAEE,EAAO,UAAED,GAAct7E,EAAK0xC,YAAYz6B,GAAU1V,OAAOhT,QAC/E,UAAE2sF,EAAS,UAAEC,GAAcn7E,EAAK0xC,YAAYz6B,GAalD,GAZInkB,KAAKyM,cAAcs7E,eACnBz4B,EAAU,QACV,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAASg5B,EAAWC,EAAS,CACtEnsF,QACAukD,UAAW,MAEf2O,EAAU,QACV,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAASk5B,EAAWC,EAAS,CACtErsF,QACAukD,UAAW,QAGdzzC,EAAK0xC,YAAYz6B,IAAWrnB,MAC7B,SAEJ,MAAMsH,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKjX,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,gBACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAO3C,GANA3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,KAEzDmD,KAAKyM,cAAcs7E,aAAc,CACjC,MAAMgB,EAAiB,YACjBC,EAAe,CACjB,GAAGZ,EAAU1tD,QAAQ,MAAMtuB,OAAOy7E,aAAa,QAE7CoB,GAAqB,EAAAJ,GAAA,GAAUP,EAAWC,IAChD,IAAAjb,aAAejtB,EAAkBd,EAAewpC,EAAgBC,EAAcC,EAAoB,IAC3F7kF,EACHozD,QAAS,IAEb,MAAM0xB,EAAiB,YACjBC,EAAe,CACjB,GAAGd,EAAU3tD,QAAQ,MAAMtuB,OAAOy7E,aAAa,QAE7CuB,GAAqB,EAAAP,GAAA,GAAUL,EAAWC,IAChD,IAAAnb,aAAejtB,EAAkBd,EAAe2pC,EAAgBC,EAAcC,EAAoB,IAC3FhlF,EACHozD,QAAS,GAEjB,CACJ,CACA,OAAOlX,CAAY,EAEvBtgD,KAAKgoF,gBAAkB,EAAG9rF,WAAUuS,SAAQq7C,eAAcC,gBACtD,MAAOhB,EAAQE,EAAQE,EAAQkgC,GAAU56E,EACnC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCy+B,EAAexrF,EAASwjD,cAAcyJ,GACtCmgC,EAAeptF,EAASwjD,cAAc2pC,GACtC5B,EAAQ,CACV/rF,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAGlBuT,EAAQ,CACVjsF,MAAO,CACH4B,EAAGoqF,EAAa,GAChBlqF,EAAGkqF,EAAa,IAEpB11E,IAAK,CACD1U,EAAGgsF,EAAa,GAChB9rF,EAAG8rF,EAAa,KAGlBz2C,EAAkB,mBAA4B,CAAC40C,EAAM/rF,MAAM4B,EAAGmqF,EAAM/rF,MAAM8B,GAAI,CAACiqF,EAAMz1E,IAAI1U,EAAGmqF,EAAMz1E,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACzImK,EAAmB,mBAA4B,CAAC0zB,EAAMjsF,MAAM4B,EAAGqqF,EAAMjsF,MAAM8B,GAAI,CAACmqF,EAAM31E,IAAI1U,EAAGqqF,EAAM31E,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KAChJ,IAAIm+B,GAAkB,EAClBC,GAAmB,EAOvB,OANIr1C,GAAmBkX,EACnBk+B,GAAkB,EAEbh0B,GAAoBlK,IACzBm+B,GAAmB,GAEhB,CACHr1C,kBACAohB,mBACAg0B,kBACAC,mBACH,EAELloF,KAAKupF,sBAAwB,EAAGb,YAAWC,aAAYC,OAAME,WACzD,MAAMU,EAAW,CAACZ,EAAME,GAClBV,GAAY,EAAA5kC,GAAA,GAAkBklC,EAAWc,GACzCnB,GAAY,EAAA7kC,GAAA,GAAkBmlC,EAAYa,GAC1CC,EAAWrB,EAAY,GAAK,EAAI,EAChCsB,EAAWrB,EAAY,GAAK,EAAI,EAChCsB,GAAc,EAAAd,GAAA,GAAUW,EAAS,GAAIA,EAAS,IAC9CI,EAAiB3sF,KAAKwmC,MAAM+lD,EAAS,GAAG,GAAKA,EAAS,GAAG,KAAO,GACjEA,EAAS,GAAG,GAAKA,EAAS,GAAG,KAAO,GACnC1yD,EAAQ,GACR+yD,GAAe,EAAAhB,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACjDoB,GAAgB,EAAAjB,GAAA,GAAUF,EAAW,GAAIA,EAAW,IACpDoB,EAA2B,CAC7BrB,EAAUe,GAAU,GAAKI,EAAa,GACtCnB,EAAUe,GAAU,GAAKI,EAAa,IAEpCG,EAAqB/sF,KAAKwmC,KAAKsmD,EAAyB,IAAM,EAAIA,EAAyB,IAAM,GACjGE,EAA+B,CACjCF,EAAyB,GAAKC,EAC9BD,EAAyB,GAAKC,GAE5B1B,EAAY,CACduB,EAAa,GACTI,EAA6B,GAAKL,EAAiB9yD,EACvD+yD,EAAa,GACTI,EAA6B,GAAKL,EAAiB9yD,GAErDozD,EAAyB,CAC3BP,EAAY,GAAKf,EAAK,GACtBe,EAAY,GAAKf,EAAK,IAEpBuB,EAAmBltF,KAAKwmC,KAAKymD,EAAuB,IAAM,EAAIA,EAAuB,IAAM,GAC3FE,EAA6B,CAC/BF,EAAuB,GAAKC,EAC5BD,EAAuB,GAAKC,GAE1B5B,EAAU,CACZK,EAAK,GAAKwB,EAA2B,GAAKR,EAAiB9yD,EAC3D8xD,EAAK,GAAKwB,EAA2B,GAAKR,EAAiB9yD,GAEzDuzD,EAA2B,CAC7B1B,EAAWe,GAAU,GAAKI,EAAc,GACxCnB,EAAWe,GAAU,GAAKI,EAAc,IAEtCQ,EAAqBrtF,KAAKwmC,KAAK4mD,EAAyB,IAAM,EAAIA,EAAyB,IAAM,GACjGE,EAA+B,CACjCF,EAAyB,GAAKC,EAC9BD,EAAyB,GAAKC,GAE5B9B,EAAY,CACdsB,EAAc,GACVS,EAA6B,GAAKX,EAAiB9yD,EACvDgzD,EAAc,GACVS,EAA6B,GAAKX,EAAiB9yD,GAErD0zD,EAAyB,CAC3Bb,EAAY,GAAKb,EAAK,GACtBa,EAAY,GAAKb,EAAK,IAEpB2B,EAAmBxtF,KAAKwmC,KAAK+mD,EAAuB,IAAM,EAAIA,EAAuB,IAAM,GAC3FE,EAA6B,CAC/BF,EAAuB,GAAKC,EAC5BD,EAAuB,GAAKC,GAMhC,MAAO,CACHnC,YACAC,UACAC,YACAC,QARY,CACZK,EAAK,GAAK4B,EAA2B,GAAKd,EAAiB9yD,EAC3DgyD,EAAK,GAAK4B,EAA2B,GAAKd,EAAiB9yD,GAO3DsxD,UAAWA,EAAY,GAAK,IAAMA,EAAYA,EAC9CC,UAAWA,EAAY,GAAK,IAAMA,EAAYA,EACjD,EAELroF,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,GAAI,CAAEQ,UAAU,GAC/F,CACA,sBAAA9yB,CAAuBjK,EAAKrJ,EAAY0qB,EAAQrP,EAAkB,SAC9D,MAAMl7B,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,qBAAAs1B,CAAsB5lC,EAAYj1B,EAAiBre,GAC/C,MAAM4R,EAAO0hC,EAAW1hC,KACxB,GAAmC,IAA/BA,EAAKyxC,QAAQlwC,OAAO7N,OACpB,OAEJ,MAAM+pF,EAAO,CAAC,KAAM,MACdC,EAAO,CAAC,KAAM,MACpB,IAAIC,EAAU7+E,OAAO8+E,UACrB,IAAK,IAAIphF,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxB,IAAK,IAAIuI,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC3B,MAAMkvD,EAAO,cAAcj0D,EAAKyxC,QAAQlwC,OAAO/E,GAAIwD,EAAKyxC,QAAQlwC,OAAOwD,IACnEkvD,EAAO0pB,IACPA,EAAU1pB,EACVwpB,EAAK,GAAKz9E,EAAKyxC,QAAQlwC,OAAO/E,GAC9BihF,EAAK,GAAKz9E,EAAKyxC,QAAQlwC,QAAQ/E,EAAI,GAAK,GACxCkhF,EAAK,GAAK19E,EAAKyxC,QAAQlwC,OAAOwD,GAC9B24E,EAAK,GAAK19E,EAAKyxC,QAAQlwC,OAAO,GAAMwD,EAAI,GAAK,GAErD,CAEJ,MAAM,SAAE/V,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACd6qE,EAAe75D,EAAKyxC,QAAQlwC,OAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACrEg6E,EAAY,CAAC3hB,EAAa,GAAIA,EAAa,IAC3C4hB,EAAa,CAAC5hB,EAAa,GAAIA,EAAa,IAC5C6hB,GAAO,EAAAC,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACzCI,GAAO,EAAAD,GAAA,GAAUF,EAAW,GAAIA,EAAW,KAC3C,UAAEL,EAAS,QAAEC,EAAO,QAAEE,EAAO,UAAED,EAAS,UAAEJ,EAAS,UAAEC,GAAcroF,KAAKupF,sBAAsB,CAChGb,YACAC,aACAC,OACAE,UAEE,YAAElqC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CAEvCk1C,EADiB22B,EAAU7rE,IACH,CACpB5M,OAAO,EAAA0mD,GAAA,GAAkBmnC,EAAMC,GAC/BxC,YACAC,YACA55E,OAAQ,CACJhT,OAAQ,CACJ6sF,YACAC,UACAE,UACAD,aAEJlwC,MAAO,CACHgwC,UAAWpsF,EAASkzB,cAAck5D,GAClCC,QAASrsF,EAASkzB,cAAcm5D,GAChCE,QAASvsF,EAASkzB,cAAcq5D,GAChCD,UAAWtsF,EAASkzB,cAAco5D,KAIlD,CACA,MAAMjtF,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CACX,EAEJ,SAAS,GAAoB1xC,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,MAAErnB,GAAU24E,EAClB,QAAcz3E,IAAVlB,EACA,OAGJ,MADkB,CAAC,GAAGA,EAAM49B,QAAQ,MAAMtuB,OAAOy7E,aAAa,OAElE,CACA,MCvrBQ/lD,sBAAqB,IAAK,YAClC,MAAMipD,WAAkC,aAC3B/qF,KAAKy4C,SAAW,2BAA6B,CACtD,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXi6C,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAc,GACdgX,0BAA0B,KAG9B5zC,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,GAAIj4C,KAAKirF,eACL,OAEJjrF,KAAKirF,gBAAiB,EACtB,MAAMl8D,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC,KAAMY,aAAoB,EAAAi8B,eACtB,MAAM,IAAI/5B,MAAM,kEAEpB,KAAA6gD,mBAAkB9xB,GAClBntB,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,qBAEJ2G,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCpxC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAYzE,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,GACnB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACVma,EAAQE,GAAU/7C,EAAKyxC,QAAQlwC,OAChC0lE,EAAej4E,EAASwjD,cAAcqJ,GACtCqrB,EAAel4E,EAASwjD,cAAcuJ,GACtCgG,EAAO,CACTvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAIxB,OADwB,EAAAhkC,YAAA,gBAA4B,CAAC6e,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,MACpHC,CAGX,EAEhB/pD,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ,GAAI15D,KAAKirF,gBAAiD,IAA/B/9E,EAAKyxC,QAAQlwC,OAAO7N,OAE3C,YADAZ,KAAK++C,SAASwa,YAAc,GAGhCv5D,KAAKirF,gBAAiB,EACtB/9E,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,EACxB0E,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,GAAkBl0E,KAAK++C,UACvE,KAAE7xC,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBvP,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvCovB,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,EACzB,MAAMp+D,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EASjB,OARAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKirF,gBAAiB,EACfr8C,EAAW2Q,aACtB,GAEJv/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,GAAWvB,EAAKyxC,QACxB8B,EAAelB,cAAgBA,EAC/B,MAAMnjD,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8R,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAenE,GAdKxB,EAAK0xC,YAAYz6B,IACoB,MAAtCjX,EAAK0xC,YAAYz6B,GAAU+mE,QAUtBt8C,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IAVjE4R,EAAK0xC,YAAYz6B,GAAY,CACzB+mE,QAAS,CAAC,EAAG,GACbC,QAAS,CAAC,EAAG,GACbC,cAAc,EACdnU,MAAO,CAAC,IACRoU,YAAY,GAEhBrrF,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAKvDY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI8Z,EAAiB,IAKrB,IAJA,IAAAkxB,YAAcjrC,EAAkBd,EAAe6a,EAAgB1Z,EAAkB,GAAI,CACjFtkD,SACD,GACHkkD,GAAe,EACkB,IAA7BI,EAAkB9/C,OAClB,OAAO0/C,EAEX8Z,EAAiB,KACjB,IAAAkxB,YAAcjrC,EAAkBd,EAAe6a,EAAgB1Z,EAAkB,GAAI,CACjFtkD,SACD,GAEH,GADmB8Q,EAAK0xC,YAAYz6B,GAAUknE,WAoCzC,CACD,MAAMvqC,EAAS,GAAGvB,WACZ+P,EAAU,KAChB,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAQ,MAAO,EACP8pD,OAAQ1mD,KAAKyM,cAAci6C,QAC5B5F,EACP,KA3CiB,CACb,MAAMqzB,EAAezzB,EAAkB,GACjC0zB,EAAe1zB,EAAkB,GACjC6qC,EAAenX,EAAa,GAAKD,EAAa,GAC9CqX,EAAepX,EAAa,GAAKD,EAAa,GAEpD,IAAIsX,EAAuB,CAAC,EAAG,GAE3BA,EAHiBv+E,EAAK0xC,YAAYz6B,GAAUinE,aAGrB,CACnBjX,EAAa,GAAKqX,EAClBrX,EAAa,IAIM,CACnBA,EAAa,GACbA,EAAa,GAAKoX,GAG1B,IAAIzqC,EAAS,GAAGvB,WACZ+P,EAAU,KACd,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAI+qC,EAAsB,CAC9FrvF,QACAQ,MAAO,EACP8pD,OAAQ1mD,KAAKyM,cAAci6C,QAC5B5F,GACHA,EAAS,GAAGvB,WACZ+P,EAAU,KACV,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAI+qC,EAAsB,CAC9FrvF,QACAQ,MAAO,EACPgkD,SAAU,CAAC,EAAG,GACd8F,OAAQ1mD,KAAKyM,cAAci6C,QAC5B5F,EACP,CAUA,MAAM18C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,EAAUnkB,KAAKyM,eACvE,IAAKS,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,EAAsBh0B,EAAkB,GAC9CxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,oBAAA/yB,CAAqBhK,EAAKrJ,EAAYqb,EAAiBH,GAEvD,CACA,sBAAA5H,CAAuBjK,EAAKrJ,EAAY0qB,GACpC,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE,IACI6a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7Dt5D,KAAK++C,SAAW,CACZwa,cACA3qB,aACAiQ,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,EAAA6jD,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,qBAAAs1B,CAAsB5lC,EAAYj1B,EAAiBre,GAC/C,MAAM4R,EAAO0hC,EAAW1hC,MAClB,QAAEigB,GAAY7xB,EAAeY,SACnC,GAAmC,IAA/BgR,EAAKyxC,QAAQlwC,OAAO7N,OACpB,OAEJ,MAAM,YAAEg+C,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,UAAE6mB,GAAc7mB,EAChB65E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,GAChCi9E,EAAc,GAAsBrpE,EAAWgzD,GAC/CsW,EAAc,GAAsBtpE,EAAWizD,IAC7C36D,OAAQixE,EAAS3U,MAAO4U,IAAW,QAAgCrwF,EAAO,CAACkwF,KAC3E/wE,OAAQmxE,EAAS7U,MAAO8U,IAAW,QAAgCvwF,EAAO,CAACmwF,IACnF,IAAIT,EAASC,EAASlU,EAAOmU,EACzBC,GAAa,EACjB,GAAIQ,EAAO,KAAOE,EAAO,IACrBF,EAAO,KAAOE,EAAO,IACN,QAAdF,EAAO,IAA8B,QAAdE,EAAO,GAAe,CAC9C,MAAM9rF,GAAQ,KAAA4yC,iBAAgBwiC,EAAWC,GACzC4V,EAAU,CAACjrF,EAAO,GAClBkrF,EAAU,CAAClrF,EAAO,GAClBg3E,EAAQ,CAAC,MACToU,GAAa,CACjB,KACK,CACD,MAAMlX,EAAe74E,EAAeY,SAASwjD,cAAc21B,GACrDjB,EAAe94E,EAAeY,SAASwjD,cAAc41B,GACrDiW,EAAenX,EAAa,GAAKD,EAAa,GAC9CqX,EAAepX,EAAa,GAAKD,EAAa,GACpDiX,EAAenuF,KAAK6e,IAAI0vE,GAAgBvuF,KAAK6e,IAAIyvE,GACjDL,EAAU,CAACU,EAAQ,GAAIE,EAAQ,IAC/BX,EAAU,CAACS,EAAQ,GAAIE,EAAQ,IAC/B7U,EAAQ,CAAC4U,EAAO,GAAIA,EAAO,GAC/B,CACAjtC,EAAYz6B,GAAY,CACpB+mE,UACAC,UACAC,eACAnU,QACAoU,aAER,CACA,MAAM9vF,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,KAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CACX,EAEJ,SAAS,GAAoB1xC,EAAMiX,EAAU1X,GACzC,MAAMmyC,EAAc1xC,EAAK0xC,YAAYz6B,IAC/B,QAAE+mE,EAAO,QAAEC,EAAO,MAAElU,EAAK,WAAEoU,EAAU,aAAED,GAAiBxsC,EAC9D,GAAIysC,EACA,MAAO,CAAC,GAAG,wBAAoBH,EAAQ,UAE3C,GAAIz+E,EAAcu+E,yBAA0B,CACxC,MAAMgB,EAAQ/uF,KAAK6e,IAAIovE,EAAQ,GAAKA,EAAQ,IACtCe,EAAQhvF,KAAK6e,IAAIqvE,EAAQ,GAAKA,EAAQ,IAC5C,MAAO,CACH,GAAG,wBAAoBa,MAAU/U,EAAM,KACvC,GAAG,wBAAoBgV,MAAUhV,EAAM,KAE/C,CACA,GAAImU,EAAc,CACd,MAAMjqB,EAAOlkE,KAAK6e,IAAIovE,EAAQ,GAAKA,EAAQ,IAC3C,MAAO,CAAC,GAAG,wBAAoB/pB,MAAS8V,EAAM,KAClD,CACK,CACD,MAAM9V,EAAOlkE,KAAK6e,IAAIqvE,EAAQ,GAAKA,EAAQ,IAC3C,MAAO,CAAC,GAAG,wBAAoBhqB,MAAS8V,EAAM,KAClD,CACJ,CCzdA,MAAMiV,WAAqB,aACdlsF,KAAKy4C,SAAW,UAAY,QAC5Bz4C,KAAKmsF,WAAa,CACvBj/E,KAAM,CACFk/E,aAAa,GAElB,QACMpsF,KAAKqsF,UAAY,CACtBn/E,KAAM,CACFo/E,SAAS,GAEd,CACH,WAAA7sF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX2lE,gBAAe,GACfC,mBAAkB,GAClBka,eAAgB,CAAC,GAAI,IACrBrgB,WAAY,GACZllB,aAAc,IACdolC,aAAa,EACbE,SAAS,KAGbl1C,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,EAAO,cAAE2tB,GAAkB/rB,EAC7BzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfkkB,EAAWs7B,EAAcxC,MACzB1J,EAAc5uC,KAAgB,YAAEk2E,4BAA4Bh6E,EAAU,CACxEgR,KAAM,CACFyxC,QAAS,CAAElwC,OAAQ,CAAC,IAAI+Q,KACxB4sE,YAAapsF,KAAKyM,cAAc2/E,YAChCE,QAAStsF,KAAKyM,cAAc6/E,YAGpC,IAAArkC,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAezE,OAdAzG,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GACtC7+C,KAAKyM,cAAc2lE,iBAAiBW,IAChC,IAAKA,EAID,OAHA,IAAArrB,kBAAiB9Y,EAAW2Q,gBAC5B,EAAAJ,EAAA,GAAsCN,QACtC7+C,KAAKs+C,WAAY,GAGrB1P,EAAW1hC,KAAK6lE,KAAOA,GACvB,KAAAvzB,4BAA2B5Q,IAC3B,EAAAuQ,EAAA,GAAsCN,EAAoB,IAE9D7+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,eAAe,IAC/C5qB,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,EACjB,IAAK1hC,GAAMo/E,QACP,OAAO,EAEX,MAAM,eAAEC,EAAc,WAAErgB,GAAelsE,KAAKyM,cAC5C,QAAK8/E,GAAgB3rF,SAGjB3D,KAAK6e,IAAIguC,EAAa,GAAKyiC,EAAe,GAAKrgB,EAAa,IAC5DA,EAAa,GACbjvE,KAAK6e,IAAIguC,EAAa,GAAKyiC,EAAe,GAAKrgB,EAAa,IACxDA,EAAa,EAGT,EAEhBlsE,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9BA,EAAW6P,aAAc,EACzBxG,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,WAAE7xB,EAAU,gBAAEvT,IAAoB,IAAAue,mBAAkB/K,GAC1DntB,KAAKm2E,oBAAsB,CACvBjpD,aACAhB,kBAAmBvS,EAAgBtQ,IAEvCrJ,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACfqsC,GACAx5D,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBAE3Cx5D,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKkzE,eACDlzE,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKgnF,oBAAuB/uC,IACxB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB,IAAIwxB,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GAErD,GADAozB,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAEJ,MAAMqmF,EAAoB1mC,EAAY7iC,MAAMkxB,GAAe5uC,KAAKgiD,gBAAgB70B,EAASyhB,EAAY7f,EAAY+rB,cAAcr/C,OAAQ,KACvI,IAAKwrF,EACD,OAEJ,MAAMr4C,EAAaq4C,EACnBjnF,KAAK8yB,WAAW3F,EAASyhB,GACzB5uC,KAAKyM,cAAc4lE,mBAAmB4U,EAAmBhvC,EAAI3lB,OAAQtyB,KAAKwzE,0BAA0BhjE,KAAKxQ,KAAMmtB,EAASyhB,IACxH5uC,KAAKs+C,WAAY,EACjBt+C,KAAKkzE,eACLj7B,EAAIivC,2BACJjvC,EAAIiH,gBAAgB,EAExBl/C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,OACzB,WAAE1J,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EACjB5uC,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvCtsD,EAAKyxC,QAAQlwC,OAAO,GAAK,IAAI+Q,GAC7BovB,EAAWrzC,aAAc,GACzB,EAAA4jD,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,EAChC6R,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,GAAc3gD,KAAK6gD,mBAAmB,CACjDjS,aACA6R,oBAEE,eAAE8rC,EAAc,WAAErgB,GAAelsE,KAAKyM,cACtC26E,EAAW,IACjB,GAAIl6E,GAAMo/E,QAAS,CACf,MAAMh+E,EAAQpB,EAAKyxC,QAAQlwC,OAAO,GAC5BiyC,EAAoBxkD,EAASwjD,cAAcpxC,IACjD,IAAA6hD,aAAe9P,EAAkBd,EAAe6nC,EAAU,CAAC1mC,GAAoB,CAC3EtkD,QACAukD,YACAqG,aAAchnD,KAAKyM,cAAcu6C,cAEzC,MACSulC,GAAgB3rF,SACrB,IAAAymF,WAAahnC,EAAkBd,EAAe6nC,EAAUmF,EAAelmF,KAAK0F,GAAOA,EAAKmgE,IAAaqgB,EAAgB,CACjHnwF,QACAQ,MAAO,IAIf,GADA0jD,GAAe,GACVpkD,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,CAEf,CACA,OAAOA,CAAY,CAE3B,CACA,sBAAA4B,CAAuBjK,EAAKrJ,GACxB,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,uBAEJ7+C,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsCN,GACtC5G,EAAIiH,gBACR,CACA,eAAOstC,CAAS59C,EAAY09C,GAAW19C,EAAW1hC,KAAKo/E,QAASn/D,GAC5DyhB,EAAW1hC,KAAKo/E,QAAUA,GAC1B,KAAAx9C,2BAA0BF,EAAYzhB,EAC1C,CACA,yBAAAqmD,CAA0BrmD,EAASyhB,EAAY6kC,GAC3C7kC,EAAW1hC,KAAK6lE,KAAOU,EACvB,MAAM50B,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,gBACzE,EAAAS,EAAA,GAAsCN,IACtC,KAAA/P,2BAA0BF,EAAYzhB,EAC1C,CACA,MAAAliB,CAAOkiB,GACH,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,CACJ,CACA,eAAAm0B,CAAgBC,EAAQC,EAAQ/rE,GAC5B,OAAQ,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,EAC9C,EAEJ,SAAS,GAAgBgsE,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAAS,GAAmB5mE,EAAM0yB,EAAWi0C,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,C,gBCvQA,MAAM2Y,WAA6B,MAC/B,WAAAhtF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,GAClBj4C,KAAK0sF,yBAAyBz0C,EAAK,SAE9Cj4C,KAAKqkD,sBAAyBpM,GACnBj4C,KAAK0sF,yBAAyBz0C,EAAK,QAElD,CACA,wBAAAy0C,CAAyBz0C,EAAKgS,GAC1B,MAAM,kBAAE/9B,EAAiB,WAAEgB,EAAU,QAAEC,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OAChEq6D,GAAY,IAAA3mC,yBAAwB94B,EAAYhB,GACtD,IAAKygE,EACD,OAAO,EAEX,MAAMC,EAAQD,EAAUE,eAClBC,EAAsB,GAC5B,IAAK,MAAMr0C,KAAYm0C,EAAO,CAC1B,MAAMzsB,EAAeysB,EAAMn0C,GAC3B,GAA4C,mBAAjC0nB,EAAane,iBAEhB,mBADGme,EAAa3f,wCAEpB,SAEJ,MAAMD,GAAc,IAAAmQ,gBAAejY,EAAUtrB,GACvC4/D,EAA0B5sB,EAAa3f,wCAAwCrzB,EAASozB,GAC9F,GAAKwsC,EAGL,IAAK,MAAMn+C,KAAcm+C,EACjB5sB,EAAane,gBAAgB70B,EAASyhB,EAAYkM,EAAcr/C,OAAQ,GAAIwuD,IAC5E6iC,EAAoBnkF,KAAKimC,EAAW2Q,cAGhD,CACA,IAAK,MAAMA,KAAiButC,EAAqB,EAC7C,KAAAE,uBAAsBztC,GACtB,MAAM3Q,GAAa,IAAAq+C,eAAc1tC,GACjC,MAAe2tC,qBAAqB//D,EAASyhB,EAAY,CACrDu+C,UAAU,KAEd,IAAAzlC,kBAAiBnI,EACrB,CAEA,OADAtH,EAAIiH,kBACG,CACX,EAEJutC,GAAqBh0C,SAAW,S,gBC9ChC,MAAM20C,WAA0BC,GAAA,SACnBrtF,KAAKy4C,SAAW,eAAiB,CAC1C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX6gF,iBAAiB,EACjBC,qBAAsB,GACtBC,qBAAsB,MAG1Bp2C,MAAMS,EAAWC,GACjB93C,KAAKk4C,cAAiBD,IAClB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,GAC3B0Y,MAAOm1C,GAAsB3yC,EAC/Bx/C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAK0tF,YAAYC,kBAAoBF,GACrC,OAAuC,CAACvxF,EAASmN,IAAI,EAEzDrJ,KAAKo/C,aAAepmB,MAAOif,IACvB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,EACdtkC,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAK4tF,aACL5tF,KAAKq/C,gBAAgBlyB,GACrBntB,KAAK0tF,YAAc,MACnB,KAAApuC,oBAAmBnyB,IACnB,OAAuC,CAACjxB,EAASmN,IAAI,EAEzDrJ,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,aAAa,CAE1E,CACA,0BAAMtG,CAAqBb,GACvB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,GAC3B0Y,MAAOpN,GAAe4P,EACxBx/C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EAStC,aARM87C,MAAM0B,qBAAqBb,GACjCr4C,OAAOm7D,OAAO/6D,KAAK0tF,YAAa,CAC5BG,kBAAmB3iD,EACnByiD,kBAAmBziD,IAEvBlrC,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,IAClB,OAAuC,CAACjxB,EAASmN,MAC1C,CACX,CACA,wBAAMykF,CAAmBJ,GACrB,MAAQK,cAAc,mBAAErtD,GAAoB,kBAAExU,EAAiB,WAAEgB,EAAU,kBAAE2gE,EAAiB,kBAAEF,EAAiB,QAAEvpF,GAAaspF,EAE1HxxF,GADkB,IAAAiwB,oBAAmBD,GACVkC,YAAYlB,GAEvC8gE,EAAa,CACfp3E,OAAQi3E,EACR/qD,OAHsB,SAAS,SAAS,cAAe+qD,EAAmBF,KAK9E,OAAO,EAAAM,QAAA,oBAA4BvtD,EAAoBstD,EAAY9xF,EAAUkI,EACjF,CACA,aAAA46C,CAAc7xB,GACVA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,aACtD,CACA,gBAAAgB,CAAiB9kD,EAAgB+kD,GAC7B,IAAKrgD,KAAK0tF,YACN,OAEJ,MAAM,SAAExxF,GAAaZ,GACbyyF,aAAcG,EAAgB,kBAAEL,EAAiB,kBAAEF,GAAuB3tF,KAAK0tF,YACjFS,EAAoBjyF,EAASwjD,cAAcmuC,GAC3CO,EAAoBlyF,EAASwjD,cAAciuC,GAC3CU,EAAoB,SAAS,cAAeD,EAAmBD,GAC/D59B,EAAe,SAAS89B,GAC9B,GAAI,oBAAgB99B,EAAc,GAC9B,OAEJ,MAEM,MAAEn0D,GAAU4D,KAAKsuF,gBAAgB,CACnChuB,eAAgB4tB,EAAiB5tB,eACjCiuB,aAAcL,EAAiBK,aAC/BrhE,WAAYhxB,EAASmN,MAEzB,IAAAonD,YAAcpQ,EAPQ,UACJ,IAMwC8tC,EAAmB59B,EAAc,CACvFn0D,SAER,E,gBChGJ,MAAMoyF,WAA8BnB,GAAA,SACvBrtF,KAAKy4C,SAAW,mBAAqB,CAC9C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX6gF,iBAAiB,EACjBC,qBAAsB,GACtBC,qBAAsB,GACtBiB,2BAA4B,GAC5BC,cAAe,CACX5nC,SAAS,MAIjB1P,MAAMS,EAAWC,GACjB93C,KAAK2uF,WAAa,KAClB3uF,KAAK4uF,kBAAmB,CAC5B,CACA,iBAAA7jC,CAAkB9S,GACd,MAAMrY,EAAYqY,EAAI3lB,QAChB,cAAEwoB,EAAa,QAAE3tB,GAAYyS,GAC3B0Y,MAAOpN,GAAe4P,EAC9B3tB,EAAQO,MAAMmhE,OAAS,UACC,OAApB7uF,KAAK2uF,aACLphE,OAAOuhE,aAAa9uF,KAAK2uF,YACzB3uF,KAAK2uF,WAAa,MAEtB3uF,KAAK2uF,WAAaphE,OAAOoC,YAAW,KAChC3vB,KAAK+uF,cAAc92C,EAAK/M,EAAY/d,EAAQ,GAC7CntB,KAAKyM,cAAcuiF,qBAAuB,IACjD,CACA,mBAAMD,CAAc92C,EAAK/M,EAAY/d,SAC3BiqB,MAAM0B,qBAAqBb,GACjC,MAAMg3C,EAAY,EAAA39D,MAAM7M,UAAUzkB,KAAK0tF,YAAYK,aAAartD,oBAC1DwuD,GAAQ,SAAsBD,EAAW/jD,EAAY,CAAC,IACtD,oBAAEikD,EAAmB,oBAAEC,GAAwBF,EACrD,IAAIL,EACAM,EAAoB3mE,KAAO4mE,EAAoB5mE,KAAO,IACtD4mE,EAAoB5mE,KAAO,IAC3BqmE,EAAS,cACT7uF,KAAK4uF,kBAAmB,IAGxBC,EAAS,OACT7uF,KAAK4uF,kBAAmB,GAE5B,MAAMtzF,GAAiB,IAAA48B,mBAAkB/K,GACrCA,IACAA,EAAQO,MAAMmhE,OAASA,EACvBQ,uBAAsB,KACdliE,EAAQO,MAAMmhE,SAAWA,IACzB1hE,EAAQO,MAAMmhE,OAASA,EAC3B,KAGJ7uF,KAAK4uF,mBACL5uF,KAAKkvF,MAAQA,GAEb5zF,GAAkBA,EAAeY,UACjCZ,EAAeY,SAASD,QAEhC,CACA,0BAAM68C,CAAqBb,GACvB,IAAKj4C,KAAK4uF,iBACN,OAAO,EAEX,MAAMhvD,EAAYqY,EAAI3lB,QAChB,cAAEwoB,EAAa,QAAE3tB,GAAYyS,GACZ,IAAA1H,mBAAkB/K,KAErCA,EAAQO,MAAMmhE,OAAS,OACvBQ,uBAAsB,KACW,SAAzBliE,EAAQO,MAAMmhE,SACd1hE,EAAQO,MAAMmhE,OAAS,OAC3B,KAGR,MAAQv2C,MAAOpN,GAAe4P,EAgB9B,aAfM1D,MAAM0B,qBAAqBb,GACjCj4C,KAAK0tF,YAAc,sBAAkB1tF,KAAK0tF,YAAa,CACnDxiD,aACAwjD,cAAe,CACXY,kBAAmB,CAACpkD,MAG5BlrC,KAAK0tF,YAAYxiD,WAAaA,EAC9BlrC,KAAK0tF,YAAYgB,cAAgB,CAC7BY,kBAAmB,CAACpkD,UAElBlrC,KAAK4tF,aACPzgE,IACAA,EAAQO,MAAMmhE,OAAS,YAEpB,CACX,CACA,mBAAAU,CAAoB7B,GAChB,MAAM,WAAExiD,GAAewiD,EACvB,MAAO,CACH4B,kBAAmB,CAACpkD,GAE5B,CACA,wBAAM4iD,CAAmBJ,GACrB,MAAQK,cAAc,mBAAErtD,GAAoB,WAAEwK,EAAU,QAAE9mC,GAAaspF,GACjE,2BAAEe,GAA+BzuF,KAAKyM,cACtC+iF,EAAgB,IACfprF,EACHqqF,6BACAS,MAAOlvF,KAAKkvF,OAEhB,OAAO,EAAAjB,QAAA,mBAA2B,CAC9BvtD,qBACAmoC,cAAe39B,EACf9mC,QAASorF,GAEjB,EAEJ,MChHMC,GAAuB,EAAE94E,KAAW,KACpC+4E,GAAuB,CAAC,EAAG,MAC3BC,GAAqB,CAAC,IAAM,OAC1B7tD,sBAAqB,6BAA4B,YACzD,MAAM8tD,WAA6BvC,GAAA,EAC/B,WAAA5tF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX6gF,iBAAiB,EACjBuC,mBAAoBH,GACpBI,mBAAoBL,GACpBf,cAAe,CACX5nC,SAAS,EACTipC,iBAAkBJ,OAI1Bv4C,MAAMS,EAAWC,GACjB93C,KAAKk4C,cAAiBD,IAClB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,GAC3B0Y,MAAOm1C,GAAsB3yC,EAC/Bx/C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfy3C,EAAa/yC,KAAKgwF,8BAA8B10F,EAAgBmyF,GACtEztF,KAAK0tF,YAAYuC,gBAAgB,GAAKl9C,GACtC,OAAuC,CAAC72C,EAASmN,IAAI,EAEzDrJ,KAAKo/C,aAAepmB,MAAOif,IACvB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,EACdtkC,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,QACf0E,KAAK4tF,aACX5tF,KAAKq/C,gBAAgBlyB,GACrBntB,KAAK0tF,YAAc,MACnB,KAAApuC,oBAAmBnyB,IACnB,OAAuC,CAACjxB,EAASmN,IAAI,EAEzDrJ,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,aAAa,CAE1E,CACA,0BAAMtG,CAAqBb,GACvB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,GAC3B0Y,MAAOpN,GAAe4P,EACxBx/C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EAChCy3C,EAAa/yC,KAAKgwF,8BAA8B10F,EAAgB4vC,GAMtE,aALMkM,MAAM0B,qBAAqBb,GACjCj4C,KAAK0tF,YAAYuC,gBAAkB,CAACl9C,EAAYA,GAChD/yC,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,IAClB,OAAuC,CAACjxB,EAASmN,MAC1C,CACX,CACA,gBAAA+2C,CAAiB9kD,EAAgB+kD,GAC7B,IAAKrgD,KAAK0tF,YACN,OAEJ,MAAQK,aAAcG,EAAgB,gBAAE+B,GAAoBjwF,KAAK0tF,YACjE,GAA+B,IAA3BuC,EAAgBrvF,OAChB,OAEJ,MAAM,SAAE1E,GAAaZ,GACf,eAAEglE,EAAc,aAAEiuB,GAAiBL,GAClCzG,EAAOE,GAASsI,GAChBC,EAAcC,GAAgB1I,GAC9B2I,EAAcC,GAAgB1I,EAC/B5gB,EAAe,CACjBmpB,EACAC,EACAE,EACAD,GACF/pF,KAAK6kC,GAAehvC,EAASwjD,cAAcxU,MAGvC,MAAE9uC,EAAK,UAAE4qE,EAAS,UAAErmB,EAAS,YAAEsmB,EAAW,SAAErmB,GAAa5gD,KAAKsuF,gBAAgB,CAChFhuB,iBACAiuB,eACArhE,WAAYhxB,EAASmN,MAEzB,IAAAi4E,cAAgBjhC,EAPM,cACC,IAM0C0mB,EAAc,CAC3E3qE,QACA4qE,YACAC,cACAtmB,YACAC,WACAsmB,WAAW,GAEnB,CACA,wBAAM4mB,CAAmBJ,GACrB,MAAQK,cAAc,aAAEQ,EAAY,mBAAE7tD,GAAoB,kBAAExU,EAAiB,WAAEgB,EAAU,gBAAE+iE,GAAqBvC,EAE1GxxF,GADkB,IAAAiwB,oBAAmBD,GACVkC,YAAYlB,IACtCu6D,EAAOE,GAASsI,EACjBK,EAAoB,CAAC7I,EAAM,GAAIA,EAAM,GAAIE,EAAM,GAAIA,EAAM,IACzDhnD,EAAmB,EAAArP,MAAM7M,UAAUic,IACjCoiC,QAASytB,EAAcxtB,YAAaytB,GAAqBxwF,KAAKywF,wCAAwCv0F,EAAUo0F,GAGlHI,EAAkB,CACpB7b,YAAa,CACT5zC,WAJW,GAAsBN,EAAiBte,UAAWkuE,GAK7DI,eAJe,GAAsBhwD,EAAiBte,UAAWmuE,KAOnEr4B,EAASn4D,KAAKyM,cACdrI,EAAU,CACZwsF,kBAAmBrC,EACnBsC,kBAAmB,IACnBf,mBAAoB33B,EAAO23B,mBAC3BD,mBAAoB13B,EAAO03B,oBAE/B,OAAO,EAAA5B,QAAA,yBAAiCvtD,EAAoBgwD,EAAiBtsF,EACjF,CACA,mBAAAmrF,GACI,MAAQxB,cAAc,aAAEQ,EAAY,mBAAE7tD,EAAkB,iBAAEowD,IAAwB9wF,KAAK0tF,YACjF/sD,EAAmB,EAAArP,MAAM7M,UAAUic,GACnCqwD,EAAiB,EAAAz/D,MAAM7M,UAAUqsE,GACjCE,EAAuBrwD,EAAiB37B,aAAaw8B,6BACrDyvD,EAAeF,EAAe/rF,aAAaw8B,8BAC3C,iBAAEuuD,GAAqB/vF,KAAKyM,cAAciiF,cAC1CwC,EAAqB,GAC3B,IAAK,IAAIxnF,EAAI,EAAG4nC,EAAM2/C,EAAarwF,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CACrD,GAAIunF,EAAavnF,KAAO6kF,EACpB,SAEJ,MAAM4C,EAAaH,EAAqBtnF,GACpCynF,GAAcpB,EAAiB,IAC/BoB,GAAcpB,EAAiB,IAC/BmB,EAAmBvoF,KAAKe,EAEhC,CACA,MAAO,CACHwnF,qBAER,CACA,aAAAlyC,CAAc7xB,GACVA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,aACtD,CACA,8BAAAgyC,CAA+Bl1F,EAAUm1F,EAAgBC,GACrD,MAAMxtE,EAAS9jB,KAAKuxF,mBAAmBr1F,IACjC,WAAE2L,GAAeic,EACjBwgE,EAAW,GAAsBxgE,EAAOzB,UAAWgvE,GACnD92C,EAAO+2C,EAAa9+E,WAAWgZ,GAAM,oBAAgBvuB,KAAK6e,IAAI0P,GAAI,KACxE,IAAc,IAAV+uB,EACA,MAAM,IAAIn8C,MAAM,mCAEpB,MAAMozF,EAAY,IAAIlN,GAChBmN,EAAY,IAAInN,GAGtB,OAFAkN,EAAUj3C,GAAQ,EAClBk3C,EAAUl3C,GAAQ1yC,EAAW0yC,GAAQ,EAC9B,CAACi3C,EAAWC,EACvB,CACA,8CAAAC,CAA+Cx1F,EAAUm1F,GACrD,MAAM,gBAAE5xE,GAAoBvjB,EAASwkB,YACrC,OAAO1gB,KAAKoxF,+BAA+Bl1F,EAAUm1F,EAAgB5xE,EACzE,CACA,2BAAAkyE,CAA4Bz1F,EAAUo0F,GAClC,MAAMsB,EAAe,GACf9tE,EAAS9jB,KAAKuxF,mBAAmBr1F,GAMvC,OALAo0F,EAAkBrvF,SAAS4wF,IACvB,MACMC,EADgB9xF,KAAK0xF,+CAA+Cx1F,EAAU21F,GAC9CxrF,KAAKi+E,GAAanjD,GAAsBrd,EAAOzB,UAAWiiE,KAChGsN,EAAajpF,QAAQmpF,EAAgB,IAElCF,CACX,CACA,uCAAAnB,CAAwCv0F,EAAUo0F,GAC9C,MAAMyB,EAAoB/xF,KAAK2xF,4BAA4Bz1F,EAAUo0F,GAC/DxtB,EAAU,IAAIivB,EAAkB,IAChChvB,EAAc,IAAIgvB,EAAkB,IAK1C,OAJAA,EAAkB9wF,SAASiqC,IACvB,SAAS43B,EAASA,EAAS53B,GAC3B,SAAS63B,EAAaA,EAAa73B,EAAW,IAE3C,CAAE43B,UAASC,cACtB,CACA,kBAAAwuB,CAAmBr1F,GACf,KAAMA,aAAoB,EAAA8mD,oBACtB,MAAM,IAAI5kD,MAAM,wCAEpB,MAAM0M,EAAW5O,EAAS81D,kBAAkB,GAC5C,OAAO,EAAA1gC,MAAM7M,UAAU3Z,EAC3B,CACA,2BAAAknF,CAA4B12F,EAAgB4vC,GACxC,MAAM,SAAEhvC,GAAaZ,EACfwoB,EAAS9jB,KAAKuxF,mBAAmBr1F,IACjC,WAAE2L,GAAeic,EACjBwgE,EAAW,GAAsBxgE,EAAOzB,UAAW6oB,IACnD,OAAE9I,EAAM,gBAAE3iB,GAAoBvjB,EAASwkB,YAEvC65B,EADS,WAAW,cAAenY,EAAQ3iB,GAC7BjN,WAAWgZ,GAAM,oBAAgBvuB,KAAK6e,IAAI0P,GAAI,KAC5DgmE,EAAY,IAAIlN,GAChBmN,EAAY,IAAInN,GAGtB,OAFAkN,EAAUj3C,GAAQ,EAClBk3C,EAAUl3C,GAAQ1yC,EAAW0yC,GAAQ,EAC9B,CAACi3C,EAAWC,EACvB,CACA,6BAAAzB,CAA8B10F,EAAgB4vC,GAC1C,MAAM,SAAEhvC,GAAaZ,EACfwoB,EAAS9jB,KAAKuxF,mBAAmBr1F,IAChC+1F,EAAWC,GAAalyF,KAAKgyF,4BAA4B12F,EAAgB4vC,GAGhF,MAAO,CAFa/J,GAAsBrd,EAAOzB,UAAW4vE,GACxC9wD,GAAsBrd,EAAOzB,UAAW6vE,GAEhE,EAEJtC,GAAqBn3C,SAAW,mB,oDClNhC,MAAM05C,WAA8BC,GAAA,EAChC,WAAA3yF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX4lF,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpBr7C,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,IACzB,IAAuB,IAAnBj4C,KAAKs+C,UACL,OAEJ,MAAMvvB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9BiyE,EAA6B,GAAAC,mBAAA,sBAAyCz2F,EAASmN,IACrF,IAAKqpF,EACD,MAAM,IAAIt0F,MAAM,0EAEpB,MAAM,eAAEkiE,GAAmBoyB,EACrBnE,EAAe,GAAAA,aAAA,sBAA6CjuB,GAC5DsyB,EAAiB,GAAAC,eAAA,wBAAuCvyB,GACxDwyB,EAAe,qCAA8C52F,EAASmN,GAAIi3D,EAAgBiuB,IAC1F,mBAAEwE,IAAuB,KAAAC,iBAAgB1yB,GACzC2wB,EAAe8B,EAAmB,EAAAxyB,4BAA4BC,UAC9D5xB,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuY,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,oBAAqB9N,EAASsiD,yBAC9Bj4C,kBAAmB,GACnBkyC,SAAUz4C,KAAK0+C,cACfo0C,gBAEJ5lF,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERi5C,kBAAmB,QAIzB5Z,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAgBzE,GAfA1+C,KAAK++C,SAAW,CACZnQ,aACA2/C,eACAjuB,iBACAsyB,iBACAE,eACAj0C,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,EACV5uD,SAAU,KACV41B,mBAAoB,KACpBv8B,QAAS,MAETjI,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAammF,EACflD,EAAe,EAAAz8D,MAAM7M,UAAU3Z,GACrC9K,KAAK++C,SAAW,IACT/+C,KAAK++C,SACRj0C,WACA41B,mBAAoBqtD,EAAartD,mBAEzC,KACK,CACD,MAAMuyD,GAAsB,KAAAC,sCAAqCh3F,EAASmN,GAAIi3D,GAC9EtgE,KAAK++C,SAAW,IACT/+C,KAAK++C,SACR56C,QAAS8uF,EAEjB,CAKA,OAJAjzF,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,IAC/B,CAAI,EAEf7+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,GAAgBv5D,KAAK++C,UACxD,KAAE7xC,GAAS0hC,GACX,cAAEkM,GAAkB/rB,EACpBzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEuyB,EAAa,cAAEtwB,GAAkB9zB,EAAeY,SAClDsjB,EAAWs7B,EAAcxC,OACzB,OAAE7pC,GAAWvB,EAAKyxC,QAExB,IAAI1nB,EACAD,EACA2oB,EACA5oB,EACAM,EACAD,EACAF,EACAC,EACJ,OATA1oB,EAAO8qD,GAAe,IAAI/5C,GASlB+5C,GACJ,KAAK,EACL,KAAK,EACDtiC,EAAmByoB,EAAcjxC,EAAO,IACxCsoB,EAAiB2oB,EAAcjxC,EAAO,IACtCuoB,EAAoB,CAACD,EAAe,GAAIE,EAAiB,IACzD0oB,EAAgB,CAAC1oB,EAAiB,GAAIF,EAAe,IACrDK,EAAmBhI,EAAc4H,GACjCE,EAAe9H,EAAcuwB,GAC7BlxC,EAAO,GAAK2oB,EACZ3oB,EAAO,GAAKyoB,EACZ,MACJ,KAAK,EACL,KAAK,EACDF,EAAoB0oB,EAAcjxC,EAAO,IACzCkxC,EAAgBD,EAAcjxC,EAAO,IACrCwoB,EAAmB,CACf0oB,EAAc,GACd3oB,EAAkB,IAEtBD,EAAiB,CAACC,EAAkB,GAAI2oB,EAAc,IACtDtoB,EAAkBjI,EAAc6H,GAChCE,EAAgB/H,EAAc2H,GAC9BtoB,EAAO,GAAK4oB,EACZ5oB,EAAO,GAAK0oB,EAGpByX,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,cAAE4qB,EAAa,SAAEE,GAAa15D,KAAK++C,UAC/C,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACnCgmE,EAAgB,IACfnzF,KAAK++C,SACRtwC,OAAQvB,EAAKyxC,QAAQlwC,OACrBqkB,WAAY9yB,KAAK8yB,WAAWtiB,KAAKxQ,OAErCA,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKozF,oBAAoB93F,EAAgB63F,GACzCnzF,KAAKkzE,cAAc,EAEvBlzE,KAAKg/C,cAAiB7xB,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,IAAKtgD,KAAK++C,SACN,OAAOuB,EAEX,MAAM,SAAEpkD,GAAaZ,GACf,WAAEszC,GAAe5uC,KAAK++C,SACtBs0C,EAAezkD,EAAW1nC,SAC1Bq4C,EAAgB3Q,EAAW2Q,cAC3BryC,EAAO0hC,EAAW1hC,MAClB,OAAEuB,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DtS,EAAQ,OAAOi3F,EAAaP,aAAapyF,MAAM,EAAG,MACxD,IAAKxE,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAOX,OAJA,IAAAU,UAAYX,EAAkBd,EADT,IACsCmB,EAAkB,GAAIA,EAAkB,GAAI,CACnGtkD,UAEJkkD,GAAe,EACRA,CAAY,CAE3B,EAEJ6xC,GAAsB15C,SAAW,mB,4BCtNjC,MAAM66C,WAA2BlB,GAAA,EAC7B,WAAA3yF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX4lF,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpBr7C,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,IACzB,IAAuB,IAAnBj4C,KAAKs+C,UACL,OAEJ,MAAMvvB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzB6d,EAAYrb,EAAcr/C,OAC1BH,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9BiyE,EAA6B,GAAAC,mBAAA,sBAAyCz2F,EAASmN,IACrF,IAAKqpF,EACD,MAAM,IAAIt0F,MAAM,0EAEpB,MAAM,eAAEkiE,GAAmBoyB,EACrBnE,EAAe,GAAAA,aAAA,sBAA6CjuB,GAC5DsyB,EAAiB,GAAAC,eAAA,wBAAuCvyB,GACxDwyB,EAAe,qCAA8C52F,EAASmN,GAAIi3D,EAAgBiuB,IAC1F,mBAAEwE,IAAuB,KAAAC,iBAAgB1yB,GACzC2wB,EAAe8B,EAAmBvyB,SACxC,IAAKywB,EACD,MAAM,IAAI7yF,MAAM,6FAEpB,MAAMwwC,EAAa,CACfrzC,aAAa,EACbkjD,aAAa,EACbv3C,SAAU,CACNuY,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,oBAAqB9N,EAASsiD,yBAC9Bj4C,kBAAmB,GACnBkyC,SAAUz4C,KAAK0+C,cACfo0C,gBAEJ5lF,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERi5C,kBAAmB,MAEvBna,WAAW,EACXM,YAAa,CAAC,IAGhBC,EAAsB,CAAC3iD,EAASmN,IAiBtC,GAhBArJ,KAAK++C,SAAW,CACZnQ,aACA2U,aAAc4S,EACdo4B,eACAjuB,iBACAsyB,iBACAE,eACAj0C,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,EACV5uD,SAAU,KACV41B,mBAAoB,KACpBv8B,QAAS,MAETjI,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAammF,EACflD,EAAe,EAAAz8D,MAAM7M,UAAU3Z,GACrC9K,KAAK++C,SAAW,IACT/+C,KAAK++C,SACRj0C,WACA41B,mBAAoBqtD,EAAartD,mBAEzC,KACK,CACD,MAAMuyD,GAAsB,KAAAC,sCAAqCh3F,EAASmN,GAAIi3D,GAC9EtgE,KAAK++C,SAAW,IACT/+C,KAAK++C,SACR56C,QAAS8uF,EAEjB,CAKA,OAJAjzF,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,IAC/B,CAAI,EAEf7+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCH,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,GAChC,cAAE8zB,GAAkBlzB,GACpB,WAAE0yC,EAAU,oBAAEiQ,EAAmB,aAAE0E,GAAiBvjD,KAAK++C,UACzD,KAAE7xC,GAAS0hC,EACXypC,EAAKp7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpD+0B,EAAKr7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpDzgB,EAAS7lC,KAAKwmC,KAAK40C,EAAKA,EAAKC,EAAKA,GAClCC,EAAe,CACjBh1B,EAAa,GACbA,EAAa,GAAKzgB,GAEhB01C,EAAY,CAACj1B,EAAa,GAAIA,EAAa,GAAKzgB,GAChD21C,EAAa,CACfl1B,EAAa,GAAKzgB,EAClBygB,EAAa,IAEXm1B,EAAc,CAChBn1B,EAAa,GAAKzgB,EAClBygB,EAAa,IAEjBr2C,EAAKyxC,QAAQlwC,OAAS,CAClB2gB,EAAcmpD,GACdnpD,EAAcopD,GACdppD,EAAcqpD,GACdrpD,EAAcspD,IAElB9pC,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,cAAE4qB,EAAa,SAAEE,GAAa15D,KAAK++C,UAC/C,KAAE7xC,GAAS0hC,GACX,gBAAEnvB,EAAe,OAAE2iB,GAAWwM,EAAW1nC,SAC/C,GAAIsyD,IAAkBE,EAClB,OAEJxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACnCgmE,EAAgB,IACfnzF,KAAK++C,SACRtwC,OAAQvB,EAAKyxC,QAAQlwC,OACrBgR,kBACA2iB,SACAtP,WAAY9yB,KAAK8yB,WAAWtiB,KAAKxQ,OAErCA,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKozF,oBAAoB93F,EAAgB63F,GACzCnzF,KAAKkzE,cAAc,EAEvBlzE,KAAKg/C,cAAiB7xB,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,IAAKtgD,KAAK++C,SACN,OAAOuB,EAEX,MAAM,SAAEpkD,GAAaZ,GACf,oBAAEujD,GAAwB7+C,KAAK++C,SACrC,IAAKF,EAAoBhkC,SAAS3e,EAASmN,IACvC,OAAOi3C,EAEX,MAAM,WAAE1R,GAAe5uC,KAAK++C,SACtBs0C,EAAezkD,EAAW1nC,SAC1Bq4C,EAAgB3Q,EAAW2Q,cAC3BryC,EAAO0hC,EAAW1hC,MAClB,OAAEuB,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Dq8D,EAASrqB,EAAkB,GAC3B/rC,EAAM+rC,EAAkB,GACxB9pC,EAAS,CACX3Z,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,GAClC1X,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAEhCmuB,EAAS7lC,KAAK6e,IAAIivD,EAAO,GAAK9tE,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAChEvY,EAAQ,OAAOi3F,EAAaP,aAAapyF,MAAM,EAAG,MACxD,IAAKxE,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAOX,OAJA,IAAAmQ,YAAcpQ,EAAkBd,EADd,IACwC3oC,EAAQksB,EAAQ,CACtE1mC,UAEJkkD,GAAe,EACRA,CAAY,CAE3B,EAEJgzC,GAAmB76C,SAAW,gB,2BC7N9B,MAAM86C,WAA2BnB,GAAA,EAC7B,WAAA3yF,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX4lF,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpBr7C,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,IACzB,IAAuB,IAAnBj4C,KAAKs+C,UACL,OAEJt+C,KAAKkzE,eACL,MAAMnkD,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzB6d,EAAYrb,EAAcr/C,OAC1BH,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9B+yE,EAAmC,GAAAb,mBAAA,sBAAyCz2F,EAASmN,IAC3F,IAAKmqF,EACD,MAAM,IAAIp1F,MAAM,0EAEpB,MAAM,eAAEkiE,GAAmBkzB,EACrBjF,EAAe,GAAAA,aAAA,sBAA6CjuB,GAC5DsyB,EAAiB,GAAAC,eAAA,wBAAuCvyB,GACxDwyB,EAAe,qCAA8C52F,EAASmN,GAAIi3D,EAAgBiuB,GAChGvuF,KAAKs+C,WAAY,EACjB,MAAM1P,EAAa,CACf1nC,SAAU,CACNuY,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,oBAAqB9N,EAASsiD,yBAC9Bj4C,kBAAmB,GACnBkyC,SAAUz4C,KAAK0+C,cACfo0C,gBAEJ5lF,KAAM,CACF3R,aAAa,EACbojD,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERi5C,kBAAmB,MAEvB7Z,YAAa,CAAC,EACdH,aAAa,IAGfI,EAAsB,CAAC3iD,EAASmN,IACtCrJ,KAAK++C,SAAW,CACZnQ,aACA2U,aAAc4S,EACdo4B,eACAjuB,iBACAsyB,iBACAE,eACAt5C,YAAax5C,KAAKw5C,YAClBqF,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,EACV5uD,SAAU,KACV41B,mBAAoB,KACpBv8B,QAAS,MAEb,MAAM,mBAAE4uF,IAAuB,KAAAC,iBAAgB1yB,GACzCvhB,EAAW/+C,KAAKyzF,YAAY,CAC9Bv3F,WACA62F,qBACAH,iBACAtyB,mBAUJ,OARAtgE,KAAK++C,SAAW,IACT/+C,KAAK++C,YACLA,GAEP/+C,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,IAC/B,CAAI,EAEf7+C,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,cAAE+rB,GAAkB/rB,EACpB+qC,EAAsBhf,EAAcr/C,OACpCH,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,EAAe,SAAEzd,GAAaZ,GAChC,cAAE8zB,GAAkBlzB,GACpB,WAAE0yC,EAAU,oBAAEiQ,EAAmB,aAAE0E,GAAiBvjD,KAAK++C,UACzD,KAAE7xC,GAAS0hC,EACXypC,EAAKp7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpD+0B,EAAKr7E,KAAK6e,IAAIg+C,EAAoB,GAAKvW,EAAa,IACpDzgB,EAAS7lC,KAAKwmC,KAAK40C,EAAKA,EAAKC,EAAKA,GAClCC,EAAe,CACjBh1B,EAAa,GACbA,EAAa,GAAKzgB,GAEhB01C,EAAY,CAACj1B,EAAa,GAAIA,EAAa,GAAKzgB,GAChD21C,EAAa,CACfl1B,EAAa,GAAKzgB,EAClBygB,EAAa,IAEXm1B,EAAc,CAChBn1B,EAAa,GAAKzgB,EAClBygB,EAAa,IAEjBr2C,EAAKyxC,QAAQlwC,OAAS,CAClB2gB,EAAcmpD,GACdnpD,EAAcopD,GACdppD,EAAcqpD,GACdrpD,EAAcspD,IAElB9pC,EAAWrzC,aAAc,EACzByE,KAAK++C,SAAS2a,UAAW,GACzB,EAAAva,EAAA,GAAsCN,EAAoB,EAE9D7+C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,cAAE4qB,EAAa,SAAEE,EAAQ,aAAE60B,EAAY,eAAEqE,GAAoB5yF,KAAK++C,UAC9E,KAAE7xC,GAAS0hC,GACX,gBAAEnvB,EAAe,OAAE2iB,GAAWwM,EAAW1nC,SAC/C,GAAIsyD,IAAkBE,EAClB,OAEJ9qB,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACnCgmE,EAAgB,IACfnzF,KAAK++C,SACRtwC,OAAQvB,EAAKyxC,QAAQlwC,OACrB8/E,eACAqE,iBACAnzE,kBACA2iB,SACAtP,WAAY9yB,KAAK8yB,WAAWtiB,KAAKxQ,OAErCA,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACjBt+C,KAAKozF,oBAAoB93F,EAAgB63F,GACzCnzF,KAAKkzE,cAAc,EAEvBlzE,KAAKg/C,cAAiB7xB,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,IAAKtgD,KAAK++C,SACN,OAAOuB,EAEX,MAAM,SAAEpkD,GAAaZ,GACf,oBAAEujD,GAAwB7+C,KAAK++C,SACrC,IAAKF,EAAoBhkC,SAAS3e,EAASmN,IACvC,OAAOi3C,EAEX,MAAM,WAAE1R,GAAe5uC,KAAK++C,SACtBs0C,EAAezkD,EAAW1nC,SAC1Bq4C,EAAgB3Q,EAAW2Q,cAC3BryC,EAAO0hC,EAAW1hC,MAClB,OAAEuB,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Dq8D,EAASrqB,EAAkB,GAC3B/rC,EAAM+rC,EAAkB,GACxB9pC,EAAS,CACX3Z,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,GAClC1X,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAEhCmuB,EAAS7lC,KAAK6e,IAAIivD,EAAO,GAAK9tE,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAChEvY,EAAQ,OAAOi3F,EAAaP,aAAapyF,MAAM,EAAG,MACxD,IAAKxE,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAOX,OAJA,IAAAmQ,YAAcpQ,EAAkBd,EADd,IACwC3oC,EAAQksB,EAAQ,CACtE1mC,UAEJkkD,GAAe,EACRA,CAAY,CAE3B,EAEJizC,GAAmB96C,SAAW,gB,kBC5M9B,MAAQ3W,sBAAqB,IAAK,YAClC,MAAM4xD,WAAuC,GACzC,WAAAj0F,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX8qE,gBAAgB,EAChBoc,qBAAsB,GACtBC,6BAA6B,EAC7B5f,aAAc,GACdyD,gBAAiB,GAAAC,qBACjBmc,aAAa,KAGjBz8C,MAAMS,EAAWC,GACjB93C,KAAKooE,sBAAuB,EAC5BpoE,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EACpC,IAAIla,EAAmBgZ,EAAazU,EACpC,GAAI5O,aAAoB,EAAAi8B,cACpB,MAAM,IAAI/5B,MAAM,kCAEf,CACD,MAAM+lB,EAAWnkB,KAAK82D,YAAY56D,GAClC4O,EAAW,wBAAoBqZ,GAC/B5E,EAAc,EAAA+R,MAAM7M,UAAU3Z,GAC9BvE,EAAoB,8BAA0BgZ,EAAaC,EAAUC,EACzE,CACA,MAAMq0E,EAAkB,wCAAoCv0E,EAAaE,GACnEs0E,EAAa/zF,KAAKg0F,oBAAoBx0E,EAAUs0E,EAAiBr0E,GACjEw0E,EAAWj0F,KAAKk0F,kBAAkB10E,EAAUs0E,EAAiBr0E,GAC7DzV,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,oBACAuE,WACAgpF,kBACAx4F,kBAEJ4R,KAAM,CACFykB,MAAO,GACPwiE,gBAAiBJ,EACjBK,cAAeH,EACft1C,QAAS,CACLiqB,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5Bt0D,OAAQ,CAAC,IAAI+Q,GAAW,IAAIA,IAC5Bi5C,kBAAmB,MAEvB7Z,YAAa,CACTy1C,eAAgB,GAChBC,iBAAkB,GAClBC,WAAY,IAEhBC,YAAa,OAGrBx0F,KAAKy0F,yBAAyB7lD,EAAYrvB,IAC1C,IAAA0oC,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAWzE,OAVA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA2a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CAAU,EAErB5uC,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ9qB,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,eAEhC,MAAMp7B,EAAWnkB,KAAK82D,YAAYx7D,EAAeY,UAC3CqjB,EAAc,EAAA+R,MAAM7M,UAAUN,EAAS/hB,MAAM,gBAAgB,IAC/DpC,KAAKyM,cAAcmnF,6BACnB5zF,KAAK00F,2BAA2B9lD,EAAYrvB,EAAa4E,EAAU7oB,IAEvE,EAAA6jD,EAAA,GAAsCN,GAClC2a,IACA,KAAAha,4BAA2B5Q,EAC/B,EAEJ5uC,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,EACrB,IAAIilD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAexiD,EAASixB,SAC9D,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAEXC,GAAc,IAAAo0C,kCAAiCp0C,EAAarkD,EAASwkB,aACrE,MAAM+/B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,EAAI,SAAEhG,GAAa0nC,GACpC,gBAAEulD,EAAe,cAAEC,GAAkBlnF,GACrC,OAAEuB,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QAC3C8B,EAAelB,cAAgBA,EAC/B,MAAMoB,EAAY3gD,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GACvDgS,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GAC/C8R,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DkI,EAAS8pC,EAAkB,GAC3B5d,GAAS,KAAAu2B,uBAAsB3Y,IAC/B,kBAAE82B,GAAsBx3E,KAAKyM,cAC7BorE,GAAgB,KAAA6C,wBAAuBh6B,GACvC9/B,EAAa1kB,EAASwkB,YAAYE,WAClCg0E,EAAkB14F,EAASwkB,YAAYjB,gBAC7C,IAAIo1E,EAAsBV,EACtBW,EAAoBV,EACpB11F,MAAMC,QAAQw1F,KACdU,EAAsB70F,KAAK+0F,iCAAiCF,EAAqBD,GACjF1nF,EAAKinF,gBAAkBU,GAEvBn2F,MAAMC,QAAQy1F,KACdU,EAAoB90F,KAAK+0F,iCAAiCD,EAAmBF,GAC7E1nF,EAAKknF,cAAgBU,GAEzB,MAAME,EAAyB,6BAA2B9nF,EAAKinF,iBACzDc,EAAuB,6BAA2B/nF,EAAKknF,eACvDc,EAAmBl1F,KAAK+0F,iCAAiCn0E,EAAYg0E,GACrEO,EAA0B,6BAA2BD,GAC3D,GAAIC,EACAl4F,KAAKa,IAAIk3F,EAAwBC,IACjCE,EACIl4F,KAAKkS,IAAI6lF,EAAwBC,GACrC,SAEJ,MAAMG,EAAmB,8BAA4BloF,EAAKinF,gBAAkBjnF,EAAKknF,eAAiB,GAClG,IAYIl6B,EAZAm7B,GAAgB,EAQpB,GAPIF,IAA4BC,IAC5BC,GAAgB,GAEpBnoF,EAAKyxC,QAAQlwC,OAAO,GAAGzO,KAAKs1F,yCAAyCV,IAAoBQ,EACrFxmD,EAAWrzC,aACXyE,KAAKu0E,+BAA+B3lC,EAAYtzC,IAE/CY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAGX,KAAK,KAAA6Z,qBAAoB5a,GACrB,SAQJ,IANK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACA48B,IACAn7B,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,IAAIm5F,EAAiB50C,EACjB60C,EAAgB50C,EAChBy0C,GACAE,EAAiB50C,EACjB60C,EAAgB,IAGhBA,EAAgB,CAAC,EAAG,GAExB,MAAMhlC,EAAY,IAgBlB,IAfA,IAAAC,YAAcpQ,EAAkBd,EAAeiR,EAAW55C,EAAQksB,EAAQ,CACtE1mC,QACAwkD,SAAU40C,EACV70C,UAAW40C,IAEX/d,EAAoB,GAChB10C,EAAS,EAAI00C,IACb,IAAA/mB,YAAcpQ,EAAkBd,EAAe,GAAGiR,WAAoB55C,EAAQ4gE,EAAmB,CAC7Fp7E,QACAwkD,WACAD,cAIZL,GAAe,EACuB,GAAlCtgD,KAAKyM,cAAconF,aAC+B,GAAlD7zF,KAAKyM,cAAcmnF,4BAAqC,CACxD,MAAMxvF,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAM,CAAEhG,aAC1D,IAAKutE,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAI8zE,EACCxnE,EAAKyxC,QAAQiqB,QAAQlP,WACtBgb,GAAsB,IAAAC,wBAAuBkD,GAC7C3qE,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,IAE/B,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACJ,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKy1F,0BAA2B,IAAK,CAAEzgB,UAAU,GACpG,CACA,wBAAAyf,CAAyB7lD,EAAYrvB,GACjC,MAAM,KAAErS,EAAI,SAAEhG,GAAa0nC,GACrB,gBAAEnvB,EAAe,gBAAEq0E,GAAoB5sF,GACvC,UAAEmb,GAAc9C,GAChB,gBAAE40E,EAAe,cAAEC,GAAkBlnF,GACrC,OAAEuB,GAAWvB,EAAKyxC,QAClB+2C,EAAW,GAAsBrzE,EAAW5T,EAAO,IACnDknF,EAAS,GAAsBtzE,EAAW5T,EAAO,IACjDmnF,EAAiB,sBAAkBnnF,GACnConF,EAAa,cACnBxzE,EAAUyzE,iBAAiBJ,EAAUG,GACrC,MAAME,EAAW,cACjB1zE,EAAUyzE,iBAAiBH,EAAQI,GACmC,GAAlE/1F,KAAKs1F,yCAAyC71E,IAC9Co2E,EAAW,GAAK1B,EAChB4B,EAAS,GAAK3B,EACdwB,EAAe,GAAG,GAAKzB,EACvByB,EAAe,GAAG,GAAKzB,GAEgD,GAAlEn0F,KAAKs1F,yCAAyC71E,IACnDo2E,EAAW,GAAK1B,EAChB4B,EAAS,GAAK3B,EACdwB,EAAe,GAAG,GAAKzB,EACvByB,EAAe,GAAG,GAAKzB,GAEgD,GAAlEn0F,KAAKs1F,yCAAyC71E,KACnDo2E,EAAW,GAAK1B,EAChB4B,EAAS,GAAK3B,EACdwB,EAAe,GAAG,GAAKzB,EACvByB,EAAe,GAAG,GAAKzB,GAE3B,MAAMn4E,EAAW,cAAc65E,EAAYE,GACrCC,EAAsB,GAC5B,IAAK,IAAI70B,EAAO,EAAGA,EAAOnlD,EAAUmlD,GAAQ2yB,EACxCkC,EAAoBrtF,KAAKitF,EAAevvF,KAAKiI,IACzC,MAAM2nF,EAAW,cAEjB,OADA,iBAAiBA,EAAU3nF,EAAOmR,EAAiB0hD,GAC5CziE,MAAM6D,KAAK0zF,EAAS,KAGnC/oF,EAAK0xC,YAAY01C,iBAAmB0B,CACxC,CACA,0BAAAtB,CAA2B9lD,EAAYrvB,EAAa4E,EAAU7oB,GAC1D,MAAM,KAAE4R,EAAI,SAAEhG,GAAa0nC,GACrB,gBAAEnvB,EAAe,OAAE2iB,GAAWl7B,GAC9B,SAAEhL,GAAaZ,EACfg5F,EAAmBpnF,EAAK0xC,YAAY01C,iBACpC4B,EAAqB,CAAC,IACtB16F,EAAQwE,KAAKgkE,mBAAmB7/C,GAChCu8B,EAAoBxzC,EAAKyxC,QAAQlwC,OAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,MACzEixC,EAAe3oB,IAAsB,KAAA0jD,wBAAuBh6B,GAC7Dy0B,EAAOj5E,EAASkzB,cAAcuwB,GAC9By1B,EAAOl5E,EAASkzB,cAAc4H,IAC9B,WAAE2iD,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoCp6D,EAAiB2iB,EAAQ+yC,EAAMC,GACjG+gB,GAAc,QAAiC36F,EAAO0R,EAAKyxC,SAC3Do8B,GAAS,QAAoBv/E,GAC7By9E,EAAOh8E,KAAK6e,IAAI7e,KAAKC,IACtBy8E,EAAawc,EAAY35F,MAAQ,IACjCo9E,EAAcmB,EAASob,EAAY35F,MAAQ,IAC1C45F,EAAsB,CACxB73F,aAAa,EAAAm4E,GAAA,GAAoBx6E,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpEswE,GAAe,EAAAK,EAAA,GAAmBhwE,EAASy8B,SAAUiL,EAAW1nC,SAASX,kBAAmB6vF,GAClG,IAAK,IAAI1sF,EAAI,EAAGA,EAAI4qF,EAAiB1zF,OAAQ8I,IAAK,CAC9C,IAAK6V,EACD,SAEJ,MAAM+6B,EAAcg6C,EAAiB5qF,GAAG,GAClCg3C,EAAoB4zC,EAAiB5qF,GAAGrD,KAAKqI,GAAMxS,EAASwjD,cAAchxC,MACzEixC,EAAe3oB,IAAsB,KAAA0jD,wBAAuBh6B,GAC7DxpB,EAAeh7B,EAASkzB,cAAcuwB,GACtCvoB,EAAmBl7B,EAASkzB,cAAc4H,GAC1Cq+C,EAAYn+C,EACZo+C,EAAYl+C,GACZ,WAAEvvB,EAAU,UAAEwa,EAAS,aAAErd,GAAiBua,EAC1C82E,EAAiB,GAAsBh0E,EAAWgzD,GAClDihB,EAA4B,GAAsBj0E,EAAWi4B,GAC7Di8C,EAAoBv2F,KAAKs1F,yCAAyC71E,GACxE42E,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9CA,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9CA,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9CA,EAAeE,GACXD,EAA0BC,GAC9B,MAAMC,EAAiB,GAAsBn0E,EAAWizD,GAMxD,GALAkhB,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC9CA,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC9CA,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC9CA,EAAeD,GACXD,EAA0BC,GAC1Bv2F,KAAK0zE,gBAAgB2iB,EAAgBG,EAAgB3uF,GAAa,CAClE,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAC3Cv5F,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,KAOpD,CANSv5F,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAC3Cv5F,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,KAMpD,CALSv5F,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAC3Cv5F,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,MAOlDjd,EAAa,CACf3iE,OAFW0jC,EAGXk/B,QAASv8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DqiD,QAASx8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC3DsiD,QAASz8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,GAEzD8R,EAAgBlkC,EAAa/D,QAAQjB,KAAKyM,cAAcgrE,gBAAgBsC,cAAe,CACzFC,WAAajwC,IAAa,KAAAkwC,gBAAeV,EAAYxvC,GACrD70B,YACAmN,YACAumB,aAAc5oC,KAAKyM,cAAc8qE,iBAErC2e,EAAmBvtF,KAAKugC,EAC5B,CACJ,CACA,MAAMvtC,EAAQqE,KAAKyM,cAAcgrE,gBAAgB0C,gBACjDjtE,EAAK0xC,YAAYy1C,eAAiB6B,EAClChpF,EAAK0xC,YAAY21C,WAAa,CAC1B5wD,SAAUz8B,EAASy8B,SACnBs1C,OACA31C,KAAM3nC,EAAM2nC,MAAMrjC,MAClBsjC,OAAQ5nC,EAAM4nC,QAAQtjC,MACtBkP,IAAKxT,EAAMwT,KAAKlP,MAChBm6E,WAAYz+E,EAAMqR,MAClBgsE,SAAUmd,EAAYnd,SACtBnC,eAER,CACA,yBAAA4e,CAA0B7mD,EAAYtzC,GAClC,MAAM4R,EAAO0hC,EAAW1hC,MAClB,SAAEhR,GAAaZ,GACf,YAAEsjD,GAAgB1xC,EAClBiX,EAAWnkB,KAAK82D,YAAY56D,GAC5BqjB,EAAc,EAAA+R,MAAM7M,UAAUN,EAAS/hB,MAAM,gBAAgB,IAOnE,OANApC,KAAKy0F,yBAAyB7lD,EAAYrvB,GACtCvf,KAAKyM,cAAcmnF,6BACnB5zF,KAAK00F,2BAA2B9lD,EAAYrvB,EAAa4E,EAAU7oB,GAEvEszC,EAAWrzC,aAAc,GACzB,KAAAuzC,2BAA0BF,EAAY1yC,EAASixB,SACxCyxB,CACX,CACA,mBAAAo1C,CAAoBx0E,EAAUs0E,EAAiBr0E,GAC3C,MAAMk0E,EAAuB3zF,KAAKyM,cAAcknF,qBAC1C8C,EAAgCx5F,KAAKkkB,MAAMwyE,EAAuB,GAClEpP,EAAW,cACjB,iBAAiBA,EAAU/kE,EAAUC,EAAiBg3E,GAAiC3C,GAEvF,OADmB9zF,KAAK+0F,iCAAiCxQ,EAAU9kE,EAEvE,CACA,iBAAAy0E,CAAkB10E,EAAUs0E,EAAiBr0E,GACzC,MAAMk0E,EAAuB3zF,KAAKyM,cAAcknF,qBAC1C+C,EAA4B/C,EAAuB12F,KAAKkkB,MAAMwyE,EAAuB,GACrFgD,EAAS,cACf,iBAAiBA,EAAQn3E,EAAUC,EAAiBi3E,EAA4B5C,GAEhF,OADiB9zF,KAAK+0F,iCAAiC4B,EAAQl3E,EAEnE,CACA,wCAAA61E,CAAyC71E,GACrC,MAAMm3E,EAAqB,CACvB35F,KAAK6e,IAAI2D,EAAgB,IACzBxiB,KAAK6e,IAAI2D,EAAgB,IACzBxiB,KAAK6e,IAAI2D,EAAgB,KAG7B,OADyBm3E,EAAmB5zF,QAAQ/F,KAAKkS,OAAOynF,GAEpE,CACA,gCAAA7B,CAAiC8B,EAAKp3E,GAElC,OAAOo3E,EADkB72F,KAAKs1F,yCAAyC71E,GAE3E,EAEJ,SAAS,GAAoBvS,EAAM4pF,EAAW,CAAC,GAC3C,MAAMrhB,EAAoBvoE,EAAK0xC,YAAY21C,YACrC,KAAEtb,EAAI,KAAE31C,EAAI,IAAEn0B,EAAG,OAAEo0B,EAAM,SAAEy1C,EAAQ,aAAEnC,GAAiBpB,EAC5D,QAAaz3E,IAATslC,EACA,OAEJ,MAAMmxC,EAAY,GAKlB,OAJAA,EAAU9rE,KAAK,SAAS,wBAAoBswE,MAASD,KACrDvE,EAAU9rE,KAAK,SAAS,wBAAoB26B,MAASuzC,KACrDpC,EAAU9rE,KAAK,QAAQ,wBAAoBwG,MAAQ0nE,KACnDpC,EAAU9rE,KAAK,YAAY,wBAAoB46B,MAAWszC,KACnDpC,CACX,CACAif,GAA+Bj7C,SAAW,6B,qCCrd1C,MAAQ3W,sBAAqB,eAAc,YAC3C,MAAMi1D,WAAsB,MACxB,WAAAt3F,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjB93C,KAAK84C,qBAAwBb,IACzB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,aAClB,gBAAEjB,GAAoBgB,EACtB+yE,EAAmC,GAAAb,mBAAA,sBAAyCz2F,EAASmN,IAC3F,IAAKmqF,EACD,MAAM,IAAIp1F,MAAM,0EAEpB,MAAM,eAAEkiE,GAAmBkzB,EACrBjF,EAAe,GAAAA,aAAA,sBAA6CjuB,GAC5DsyB,EAAiB,GAAAC,eAAA,wBAAuCvyB,IACxD,mBAAEyyB,IAAuB,KAAAC,iBAAgB1yB,GAC/C,IAAIz4D,EACAI,EACAO,EACAxD,EAEJ,GADAhF,KAAKkzE,eACDh3E,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAaioF,EAAmB,EAAAxyB,4BAA4BC,UAC9DutB,EAAe,EAAAz8D,MAAM7M,UAAU3Z,KAClCjD,aAAYI,aAAc8lF,GAC7B/oF,EAAe+oF,EAAa/oF,aAC5BwD,EAAQ,GAAsBulF,EAAa1rE,UAAW7C,EAC1D,KACK,CACD,MAAMw3E,GAA6B,KAAA9D,sCAAqCh3F,EAASmN,GAAIi3D,GACrF,IAAK02B,EACD,MAAM,IAAI54F,MAAM,kFAEpB,MAAM,UAAEikB,GAAcnmB,EAASw5B,eAC/B7tB,EAAawa,EAAUQ,gBACvB5a,EAAYoa,EAAUI,eACtB,MAAMjnB,EAAQ,EAAA81B,MAAM2lE,SAASD,GAC7BhyF,EAAexJ,EAAMwJ,aACrBwD,EAAQ,GAAsB6Z,EAAW7C,EAC7C,CACA,MAAM03E,EAAiBl3F,KAAKm3F,kBAAkB13E,EAAiBxX,GAC/D,QAAuBjK,IAAnBk5F,EAEA,YADA9mF,QAAQC,KAAK,wCAGjB,MAAM,gBAAE+mF,EAAe,cAAEC,EAAa,+BAAEC,EAA8B,iBAAEC,EAAgB,oBAAEC,GAAyBx3F,KAAKy3F,gBAAgBzyF,EAAc6C,EAAYW,EAAO0uF,GACzK,GAAI1uF,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,GACvB,OAEJ,MAAM6vF,EAAoBL,EAAc7uF,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAClE,GAAIoqF,EAAe/3E,SAAS68E,GACxB,OAEJ,MAAMC,GAAkB,EAAA1jF,GAAA,GAAUmjF,EAAiBG,IAC7C,QAAEK,GAAYD,EACpBC,EAAQ32F,SAASuH,IACb,MAAMqvF,EAAkBP,EAA+B9uF,EAAM,GAAIA,EAAM,IACvExD,EAAa8yF,WAAWD,EAAiBtJ,EAAa,IAE1D,MAAMwJ,EAAiB/3F,KAAKg4F,kBAAkBd,EAAgBM,EAAqBG,GAEnF,OADA,KAAAM,iCAAgC33B,EAAgBy3B,IACzC,CAAI,EAEf/3F,KAAKg4F,kBAAoB,CAACd,EAAgBM,EAAqBG,KAC3D,MAAQC,QAASM,GAAeP,EAChC,GAAuB,IAAnBT,EACA,MAAO,CAACM,GAEZ,IAAIW,EAAOxhF,IACPyhF,GAAQzhF,IACZ,IAAK,IAAIO,EAAI,EAAGA,EAAIghF,EAAWt3F,OAAQsW,IAAK,CACxC,MAAMjF,EAAIimF,EAAWhhF,GAAG,GACpBjF,EAAIkmF,IACJA,EAAOlmF,GAEPA,EAAImmF,IACJA,EAAOnmF,EAEf,CACA,MAAM8lF,EAAiB,GACvB,IAAK,IAAIp7C,EAAQw7C,EAAMx7C,GAASy7C,EAAMz7C,IAClCo7C,EAAepvF,KAAKg0C,GAExB,OAAOo7C,CAAc,EAEzB/3F,KAAKy3F,gBAAkB,CAACzyF,EAAc6C,EAAYwwF,EAAanB,EAAiB,KAC5E,IAAIM,EACAD,EACJ,OAAQL,GACJ,KAAK,EACDM,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,KAAK,EACDb,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,KAAK,EACDb,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,QACI,MAAM,IAAIj6F,MAAM,2BAA2B84F,KAEnD,MAGMG,EAAgB,CAAC/5F,EAAGE,EAAGqR,IAClB7J,EAAaszF,SAASh7F,EAAGE,EAAGqR,GAEjCuoF,EAAkBp3F,KAAKu4F,wBAAwB1wF,EAAYqvF,EAAgBM,EAAqBH,GAEtG,MAAO,CACHC,+BAFmCt3F,KAAKw4F,wCAPd,CAACl7F,EAAGE,EAAGqR,IAC1B7J,EAAauO,QAAQ,CAACjW,EAAGE,EAAGqR,KAMmEqoF,EAAgBM,GAGtHH,gBACAD,kBACAG,mBACAC,sBACH,EAELx3F,KAAKu4F,wBAA0B,CAAC1wF,EAAYqvF,EAAgBM,EAAqBH,KAC7E,IAAID,EACJ,OAAQF,GACJ,KAAK,EACDE,EAAkB,CAAC55F,EAAGqR,KAClB,KAAIrR,GAAKqK,EAAW,IAAMrK,EAAI,GAAKqR,GAAKhH,EAAW,IAAMgH,EAAI,GAG7D,OAAOwoF,EAAcG,EAAqBh6F,EAAGqR,EAAE,EAEnD,MACJ,KAAK,EACDuoF,EAAkB,CAAC95F,EAAGuR,KAClB,KAAIvR,GAAKuK,EAAW,IAAMvK,EAAI,GAAKuR,GAAKhH,EAAW,IAAMgH,EAAI,GAG7D,OAAOwoF,EAAc/5F,EAAGk6F,EAAqB3oF,EAAE,EAEnD,MACJ,KAAK,EACDuoF,EAAkB,CAAC95F,EAAGE,KAClB,KAAIF,GAAKuK,EAAW,IAAMvK,EAAI,GAAKE,GAAKqK,EAAW,IAAMrK,EAAI,GAG7D,OAAO65F,EAAc/5F,EAAGE,EAAGg6F,EAAoB,EAEnD,MACJ,QACI,MAAM,IAAIp5F,MAAM,2BAA2B84F,KAEnD,OAAOE,CAAe,EAE1Bp3F,KAAKw4F,uCAAyC,CAACC,EAAuBvB,EAAgBM,KAClF,IAAIF,EACJ,OAAQJ,GACJ,KAAK,EACDI,EAAiC,CAAC95F,EAAGqR,IAC1B4pF,EAAsBjB,EAAqBh6F,EAAGqR,GAEzD,MACJ,KAAK,EACDyoF,EAAiC,CAACh6F,EAAGuR,IAC1B4pF,EAAsBn7F,EAAGk6F,EAAqB3oF,GAEzD,MACJ,KAAK,EACDyoF,EAAiC,CAACh6F,EAAGE,IAC1Bi7F,EAAsBn7F,EAAGE,EAAGg6F,GAEvC,MACJ,QACI,MAAM,IAAIp5F,MAAM,2BAA2B84F,KAEnD,OAAOI,CAA8B,CAE7C,CACA,iBAAAH,CAAkB13E,EAAiBxX,GAC/B,MAAMywF,EAAazwF,EAAUvH,MAAM,EAAG,GAChCi4F,EAAa1wF,EAAUvH,MAAM,EAAG,GAChCk4F,EAAa3wF,EAAUvH,MAAM,EAAG,GAChCm4F,EAA4B,CAC9B57F,KAAK6e,IAAI2D,EAAgB,IACzBxiB,KAAK6e,IAAI2D,EAAgB,IACzBxiB,KAAK6e,IAAI2D,EAAgB,KAEvBq5E,EAAuB,CACzB77F,KAAK6e,IAAI48E,EAAW,IACpBz7F,KAAK6e,IAAI48E,EAAW,IACpBz7F,KAAK6e,IAAI48E,EAAW,KAExB,GAAI//D,GAAQkgE,EAA2BC,GACnC,OAAO,EAEX,MAAMC,EAAuB,CACzB97F,KAAK6e,IAAI68E,EAAW,IACpB17F,KAAK6e,IAAI68E,EAAW,IACpB17F,KAAK6e,IAAI68E,EAAW,KAExB,GAAIhgE,GAAQkgE,EAA2BE,GACnC,OAAO,EAEX,MAAMC,EAAuB,CACzB/7F,KAAK6e,IAAI88E,EAAW,IACpB37F,KAAK6e,IAAI88E,EAAW,IACpB37F,KAAK6e,IAAI88E,EAAW,KAExB,OAAIjgE,GAAQkgE,EAA2BG,GAC5B,OADX,CAGJ,EAEJjC,GAAct+C,SAAW,Y,ICzNrBwgD,G,oFACJ,SAAWA,GACPA,EAAkBA,EAAkC,eAAI,GAAK,iBAC7DA,EAAkBA,EAAwB,KAAI,GAAK,OACnDA,EAAkBA,EAA0B,OAAI,GAAK,QACxD,CAJD,CAIGA,KAAsBA,GAAoB,CAAC,IAC9C,MAAMC,WAA8B,aACvBl5F,KAAKm5F,KAAO,CAAG,QACfn5F,KAAKo5F,KAAO,CAAG,QACfp5F,KAAKq5F,QAAU,CAAG,QAClBr5F,KAAKs5F,qBAAuBL,EAAmB,CACxD,WAAAx5F,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CrrC,cAAe,CACX8sF,kBAAmB,CACfzyC,SAAS,EACT0yC,eAAgB,MAA2BC,QAAQC,aACnDC,aAAc,IACdC,aAAc,IACdC,aAAc,KAElBC,kBAAmBZ,GAAsBI,qBAAqBS,eAC9DC,qBAAsB,CAClB,CAACd,GAAsBI,qBAAqBS,gBAAiB,CACzDE,eAAgB,CACZC,MAAO,CAAEnnB,KAAM,IAAKonB,UAAW,UAAWC,aAAc,IACxDC,OAAQ,CAAEtnB,KAAM,IAAKonB,UAAW,UAAWC,aAAc,KACzDE,MAAO,CACHvnB,KAAM,IACNonB,UAAW,UACXI,UAAW,QACXH,aAAc,KAElBI,OAAQ,CAAEznB,KAAM,IAAKonB,UAAW,UAAWI,UAAW,SACtDE,MAAO,CAAE1nB,KAAM,KACf2nB,OAAQ,CAAE3nB,KAAM,MAEpB4nB,aAAc,CACVC,UAAW,OACXrtB,WAAY,QACZgtB,UAAW,QACXM,cAAgBC,GAAQA,EAAM,EAC9BX,UAAW,UACXY,cAAe,GACfC,UAAW,QACX3rD,WAAY,MAGpB,CAAC6pD,GAAsBI,qBAAqB2B,MAAO,CAAC,EACpD,CAAC/B,GAAsBI,qBAAqB4B,QAAS,CACjDC,YAAa,kJAKzB/jD,MAAMS,EAAWC,GACjB93C,KAAK44C,iBAAmB,IAAIpnC,IAC5BxR,KAAKy0D,iBAAmB,KACpBz0D,KAAKo7F,gBACLp7F,KAAKq7F,4BAA4B,EAErCr7F,KAAK05C,gBAAkB,KACnB15C,KAAKo7F,gBACLp7F,KAAKq7F,4BAA4B,EAErCr7F,KAAKm6C,kBAAoB,KACrBn6C,KAAKs7F,cACLt7F,KAAKs0D,oCAAoC,EAE7Ct0D,KAAKs5C,kBAAoB,KACH,IAAAC,cAAav5C,KAAKw5C,aAAaC,cAGrDz5C,KAAKoiE,OAAUl1C,IACX,MAAMquE,EAAoBv7F,KAAKw7F,mBAAmBtuE,GAClD,IAAKquE,EACD,OAEJ,MAAM,kBAAEhC,GAAsBgC,EAC9BhC,EAAkBkC,gBAAgB,EAEtCz7F,KAAKw7F,mBAAqB,CAAC,EAC3Bx7F,KAAK07F,0BAA4B,CAAC,CACtC,CACA,kCAAApnC,GACI,MAAMqnC,EAAc,KACM37F,KAAKs5C,oBACbr4C,SAAQ,EAAGisB,aAAYhB,wBACjC,MAAM,SAAEhwB,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAClD,QAAEiB,GAAYjxB,EACpBixB,EAAQrE,oBAAoB,EAAAojB,MAAA,OAAapS,2BAA4B95B,KAAKo7F,cAAc5qF,KAAKxQ,OACtEA,KAAK44C,iBAAiBx4C,IAAI8sB,GAClC0uE,UAAUzuE,EAAQ,GACnC,EAEN,EAAAgF,YAAYrJ,oBAAoB,EAAA2G,OAAOyqB,0BAA2BjC,IAC1DA,EAAI3lB,OAAOknB,cAAgBx5C,KAAKw5C,cAGpCmiD,IACA37F,KAAKo7F,gBAAe,GAE5B,CACA,0BAAAC,GACI,MAAM1hD,EAA2B,KACP35C,KAAKs5C,oBACbr4C,SAAQ,EAAGisB,aAAYhB,wBACjC,MAAM,SAAEhwB,IAAa,IAAA09C,wBAAuB1sB,EAAYhB,IAClD,QAAEiB,GAAYjxB,EACpB8D,KAAKo7F,gBACLjuE,EAAQ1E,iBAAiB,EAAAyjB,MAAA,OAAapS,2BAA4B95B,KAAKo7F,cAAc5qF,KAAKxQ,OAC1F,MAAM65C,EAAiB,IAAIC,gBAAe,KACtCnqB,YAAW,KACP,MAAMxC,GAAU,IAAAysB,wBAAuB1sB,EAAYhB,GACnD,IAAKiB,EACD,OAEJ,MAAM,SAAEjxB,GAAaixB,EACrBntB,KAAKoiE,OAAOl1C,GACZhxB,EAASD,QAAQ,GAClB,IAAI,IAEX49C,EAAeG,QAAQ7sB,GACvBntB,KAAK44C,iBAAiB14C,IAAIgtB,EAAY2sB,EAAe,GACvD,EAENF,IACA,EAAAxnB,YAAY1J,iBAAiB,EAAAgH,OAAOyqB,0BAA2BjC,IACvDA,EAAI3lB,OAAOknB,cAAgBx5C,KAAKw5C,cAGpCG,IACA35C,KAAKo7F,gBAAe,GAE5B,CACA,WAAAE,IAC6B,IAAA54B,uBACgB,GACPnvC,eACxBtyB,SAAS/E,IACf,MAAMq/F,EAAoBv7F,KAAKw7F,mBAAmBt/F,EAASmN,IAC3D,IAAKkyF,EACD,OAEJ,MAAM,MAAEplF,EAAK,kBAAEojF,GAAsBgC,EACrChC,GAAmBsC,YAAW,GAC9BtC,GAAmB/1F,SACnB2S,GAAO3S,SACctH,EAChBiwB,qBACA2vE,2BAA2BC,kBACnB9/F,SACbC,EAASiwB,qBAAqBlwB,gBACvB+D,KAAKw7F,mBAAmBt/F,EAASmN,GAAG,GAEnD,CACA,aAAA+xF,GACI,MACMzhF,GADmB,IAAA+oD,uBACgB,GACzC,IAAK/oD,EACD,OAEJ,IAAIC,EAAYD,EAAgB4Z,eAChC3Z,GAAY,IAAA+oD,gCAA+B/oD,EAAW5Z,KAAK0+C,eAC3D9kC,EAAU3Y,SAAS/E,IACf,MAAM8/F,EAAS9/F,EAAS+/F,UAAUj8F,KAAK0+C,eAClCs9C,IAAUA,EAAOE,aAClBl8F,KAAKm8F,uBAAuBjgG,EAChC,GAER,CACA,4BAAMigG,CAAuBjgG,GACzB,MAAMgxB,EAAahxB,EAASmN,GAC5B,IAAKrJ,KAAK07F,0BAA0BxuE,GAAa,CAC7CltB,KAAK07F,0BAA0BxuE,IAAc,EAC7C,MAAMpmB,EAAO9G,KAAKyM,cAAcqtF,kBAC1BE,EAAuBh6F,KAAKyM,cAAcutF,qBAAqBlzF,GACrE,GAAI9G,KAAKw7F,mBAAmBtuE,GAAa,CACrC,MAAM,MAAE/W,EAAK,kBAAEojF,GAAsBv5F,KAAKw7F,mBAAmBtuE,GAC7DhxB,EAASkgG,cAAcC,YAAYlmF,GACnCojF,EAAkBsC,YAAW,EACjC,CACA,IAAI1lF,EACS,IAATrP,EACAqP,EAAQnW,KAAKs8F,qBAAqBtC,GAEpB,IAATlzF,EACLqP,EAAQ,oBAEM,IAATrP,IACLqP,QAAcnW,KAAKu8F,qBAEvB,MAAMC,EAAWtgG,EAASkgG,cACpBK,EAAevgG,EAChBiwB,qBACA2vE,2BAA2BC,mBAC1B,QAAEj1C,EAAO,eAAE0yC,EAAc,aAAEG,EAAY,aAAEC,EAAY,aAAEC,GAAkB75F,KAAKyM,cAAc8sF,kBAC5FA,EAAoB,kBAAuC,CAC7DpjF,QACAumF,WAAYD,EAAaE,gBACzBC,eAAgBJ,IAEpBjD,EAAkBsC,WAAW/0C,GAC7ByyC,EAAkBsD,kBAAkBrD,GACpCD,EAAkBuD,gBAAgBnD,GAClCJ,EAAkBwD,gBAAgBnD,GAClCL,EAAkByD,gBAAgBnD,GAClCN,EAAkB0D,0BAClBj9F,KAAKw7F,mBAAmBtuE,GAAc,CAClCqsE,oBACApjF,SAEJja,EAASghG,UAAUl9F,KAAK0+C,cAAe66C,GACvCkD,EAAaxgG,SACbC,EAASiwB,qBAAqBlwB,SAC9B+D,KAAK07F,0BAA0BxuE,IAAc,CACjD,CACJ,CACA,uBAAMqvE,GACF,MAAMY,EAAMn9F,KAAKyM,cAAcutF,qBAAqBf,GAAkBiC,QACjEC,YACCiC,QAAiBC,MAAMF,GACvBG,QAAoBF,EAASE,cAC7BC,EAAY,oBAClBA,EAAUC,mBAAmBF,GAC7BC,EAAUljC,SACV,MAAMjtB,EAAW,oBACjBA,EAASqwD,YAAYF,EAAUj2B,iBAC/Bl6B,EAAStE,eAAe40D,iBAAiB,SACzC,MAAM3kD,EAAS,oBACfA,EAAO4kD,aAAavwD,GACpB2L,EAAO6kD,8BACP,MAAMznF,EAAQ,oBAGd,OAFAA,EAAM0nF,UAAU9kD,GAChB5iC,EAAM2nF,QAAQ,KACP3nF,CACX,CACA,oBAAAmmF,CAAqBtC,GACjB,MAAM7jF,EAAQ,oBAoBd,OAnBAA,EAAM4nF,gBAAgB,IAAK/D,EAAqBW,eAChDxkF,EAAM6nF,qBAAqB,IACpBhE,EAAqBC,eAAeC,QAE3C/jF,EAAM8nF,sBAAsB,IACrBjE,EAAqBC,eAAeI,SAE3ClkF,EAAM+nF,qBAAqB,IACpBlE,EAAqBC,eAAeK,QAE3CnkF,EAAMgoF,sBAAsB,IACrBnE,EAAqBC,eAAeO,SAE3CrkF,EAAMioF,qBAAqB,IACpBpE,EAAqBC,eAAeQ,QAE3CtkF,EAAMkoF,sBAAsB,IACrBrE,EAAqBC,eAAeS,SAEpCvkF,CACX,CACA,8BAAMmoF,GACF,MAAMC,EAAO,qBACP,eAAEtE,EAAc,aAAEU,GAAiB36F,KAAKyM,cAAc+xF,cAM5D,OALAD,EAAKR,gBAAgBpD,GACrB/6F,OAAO4B,KAAKy4F,GAAgBh5F,SAASd,IACjC,MAAMs+F,EAAa,MAAMt+F,EAAIu+F,OAAO,GAAGC,cAAgBx+F,EAAIO,MAAM,iBACjE69F,EAAKE,GAAYxE,EAAe95F,GAAK,IAElCo+F,CACX,EAEJrF,GAAsBzgD,SAAW,oB,uCCjRjC,MAAMmmD,WAA0B,aACnB5+F,KAAK6+F,WAAa,CACvBC,OAAQ,SACRC,OAAQ,SACT,CACH,WAAAt/F,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXuyF,aAAc,IACdjgC,KAAM6/B,GAAkBC,WAAWE,OACnCE,aAAc,KAGlB7nD,MAAMS,EAAWC,GACjB93C,KAAK+qD,kBAAqB9S,IAClBj4C,KAAKk/F,YACLpQ,aAAa9uF,KAAKk/F,YAEtBl/F,KAAKk/F,WAAavvE,YAAW,KACzB3vB,KAAKm/F,kBAAkBlnD,GACvBj4C,KAAKk/F,WAAa,IAAI,GACvBl/F,KAAKyM,cAAcuyF,eACf,GAEXh/F,KAAKy0D,iBAAmB,KACpBz0D,KAAK05C,iBAAiB,EAE1B15C,KAAK05C,gBAAkB,KACnB15C,KAAKk/F,WAAa,IAAI,EAE1Bl/F,KAAKm6C,kBAAoB,KACrBn6C,KAAKk/F,WAAa,IAAI,EAE1Bl/F,KAAKk/F,WAAa,IACtB,CACA,iBAAAC,CAAkBlnD,EAAM,CAAC,GACrB,GAAI,KAAM2H,sBACN,OAEJ,MAAM,QAAEzyB,EAAO,cAAE2tB,GAAkB7C,EAAI3lB,OACjC4Y,EAAa4P,EAAcxC,MAC3Bh9C,GAAiB,IAAA48B,mBAAkB/K,GACzC,IAAK7xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACfq3F,GAAqB,KAAAyM,uBAAsBljG,EAASmN,IACrDspF,GAGL3yF,KAAKq/F,yBAAyB1M,EAAoBznD,EAAYhvC,EAClE,CACA,wBAAAmjG,CAAyB1M,EAAoBznD,EAAYhvC,GAErD,IADsBA,EAASw5B,eAE3B,OAEJ,MAAM,eAAE4qC,EAAc,mBAAEyyB,GAAuBJ,EAC/C,IAAI2M,EAoBJ,GAnBIt/F,KAAKyM,cAAcsyD,OAAS6/B,GAAkBC,WAAWC,OACzDQ,GAAsB,IAAAC,6BAA4Bj/B,EAAgBp1B,EAAY,CAC1EhvC,aAIA62F,EAAmBvyB,SACnB8+B,GAAsB,IAAAE,iCAAgCl/B,EAAgBp1B,EAAY,CAC9EhvC,WACA+iG,aAAcj/F,KAAKyM,cAAcwyF,eAGhClM,EAAmB0M,QACxBH,GACI,IAAAI,yCAAwCp/B,GAEvCyyB,EAAmB4M,SAG3BL,GAA+C,IAAxBA,EACxB,QAEJ,KAAAM,uBAAsBt/B,EAAgBg/B,GACtC,MACMzlF,EADkB3d,EAASiwB,qBACGoH,eAAeltB,KAAKoJ,GAAMA,EAAEpG,MAChE,KAAAw2F,6BAA4Bv/B,IAC5B,EAAAnhB,EAAA,GAAsCtlC,EAC1C,EAEJ+kF,GAAkBnmD,SAAW,oB,gBCtF7B,MAAMqnD,WAAiCC,GAAA,SAC1B//F,KAAKy4C,SAAW,sBAAwB,CACjD,WAAAh5C,CAAYo4C,EAAY,CAAC,GACrBT,MAAMS,GACN73C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACdgxB,EAAahxB,EAASmN,GAC5B,IAAIk3C,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QACrC+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE+xC,EAAelB,cAAgBA,EAC/B,MAAM,aAAEgvC,EAAY,eAAEjuB,GAAmB1xB,EAAW1nC,UAC9C,UAAEy5C,EAAS,SAAEC,EAAQ,OAAE8F,GAAW1mD,KAAK6gD,mBAAmB,CAC5DjS,aACA6R,mBAGErkD,EAAQ,QADK,KAAA4jG,sBAAqB9yE,EAAYozC,EAAgBiuB,GACpC7tF,MAAM,EAAG,GAAGgrB,KAAK,QAajD,GAZKxe,EAAK0xC,YAAYz6B,IACiB,MAAnCjX,EAAK0xC,YAAYz6B,GAAUmwD,KAQtB1lC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IARjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBvjB,OAAQ,KACRhE,MAAO,KACP03E,KAAM,MAEVt0E,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAKvDY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,KAAAC,qBAAoB5a,GACrB,SAOJ,IALK,KAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM6jG,EAAU,GAAG1gD,WACb2gD,EAAU,GAAG3gD,WACb+P,EAAU,KAChB,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAukD,YACAC,WACA8F,UACDu5C,GACH,MAAME,EAAgB,KACtB,IAAA5wC,UAAYlP,EAAkBd,EAAe4gD,EAAez/C,EAAkB,GAAIA,EAAkB,GAAI,CACpGtkD,QACAukD,YACAC,WACA8F,UACDw5C,GACH5/C,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA3+D,EAAQhI,MAAQA,EAChB,MAAMq4E,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAI8zE,EACCxnE,EAAKyxC,QAAQiqB,QAAQlP,WACtBgb,GAAsB,IAAAC,wBAAuBj0B,GAC7CxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,IAE/B,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,CAE3B,CACA,gBAAAjC,CAAiBpG,GACb,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERopD,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5BtK,kBAAmB,MAEvB9mC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAazE,OAZA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsCN,GAC/BjQ,CACX,QACS5uC,KAAKqzE,QAAU,CAACnmD,EAAYqtB,EAAMn2C,KACvC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EAEf8kG,GADsB,IAAApnC,qBACgBlkD,QAAQ85B,GAAgD,yBAAjCA,EAAW1nC,SAASuxC,WACjF4nD,EAAqBD,EAAgB1iF,MAAMkxB,IAC7C,MAAM,SAAE1nC,GAAa0nC,EACrB,OAAI1nC,EAASqnF,eAAiBnqF,GAASmqF,cACnCrnF,EAASo5D,iBAAmBl8D,GAASk8D,cAG7B,IAEZ+/B,IACA,IAAA34C,kBAAiB24C,EAAmB9gD,eAExC,MAAM,oBAAEv1C,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,GAActzE,KAAKi1E,YAAY6qB,GAA0BxkG,EAAgBi/C,EAAK,GAAIn2C,IAC5Ik8F,EAAWC,GAAahmD,GACxBimD,EAAQC,GAAUH,GAClBI,EAAQC,GAAUJ,EACnB9xF,EAAS,CAAC+xF,EAAQC,EAAQC,EAAQC,GAClC/xD,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,EAAAjT,UAAA,SACzCp/B,KAAM,CACFyxC,QAAS,CACLlwC,SACAgqD,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCnkB,YAAa,CAAC,GAElBH,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNqnF,aAAcnqF,GAASmqF,aACvBjuB,eAAgBl8D,GAASk8D,eACzB7nB,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,IAKX,OAFA,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,EAAAgyB,EAAA,GAAsC,CAACjjD,EAASmN,KACzCulC,CAAU,CAClB,E,yBCrPP,MAAMgyD,WAA2B,aACpB5gG,KAAKy4C,SAAW,gBAAkB,CAC3C,WAAAh5C,CAAYohG,EAAoB,CAAC,GAC7BzpD,MAAMypD,EAAmB,CACrB9oD,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CAAEi6C,QAAQ,EAAMshB,2BAA2B,KAE9DhoE,KAAKq+C,iBAAoBpG,IACrB,MAAMrY,EAAYqY,EAAI3lB,QAChB,cAAEwoB,EAAa,QAAE3tB,GAAYyS,EAC7BpgB,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM1P,EAAc5uC,KAAgB,YAAEk2E,4BAA4Bh6E,EAAU,CACxEgR,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,SAKpB,QAAcovB,EAAYzhB,GAC1B,MAAM2zE,GAAuB,IAAAhiD,gCAA+B3xB,EAASntB,KAAK0+C,eAAe,GAYzF,OAXA1+C,KAAK++C,SAAW,CACZnQ,aACAkyD,uBACAvnC,YAAa,EACbC,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,KAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,EAAAC,EAAA,GAAsC2hD,GAC/BlyD,CAAU,EAErB5uC,KAAKsrD,wBAA0B,CAACn+B,EAASyhB,EAAYkb,EAAcC,KAC/D,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QACxB,IAAK,IAAIj1C,EAAI,EAAGA,EAAI+E,EAAO7N,OAAQ8I,IAAK,CACpC,MAAM4E,EAAQG,EAAO/E,GACfq3F,EAA2B7kG,EAASwjD,cAAcpxC,GAExD,IAAa,IADA,cAAcw7C,EAAci3C,GAA4Bh3C,EAGjE,OADA78C,EAAKyxC,QAAQ8Z,kBAAoB/uD,EAC1B4E,CAEf,CACApB,EAAKyxC,QAAQ8Z,kBAAoB,IAAI,EAEzCz4D,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClBw1B,EAAej4E,EAASwjD,cAAcjxC,EAAO,IAC7C2lE,EAAel4E,EAASwjD,cAAcjxC,EAAO,IAC7CuyF,EAAOhhG,KAAKihG,8BAA8B,CAC5C9sB,EACAC,IAEE9lE,EAAQ,CAACw7C,EAAa,GAAIA,EAAa,KACvC,KAAE3I,EAAI,IAAExsC,EAAG,MAAE/X,EAAK,OAAEC,GAAWmkG,EAErC,GADwBE,GAAUruD,gBAAgB,CAACsO,EAAMxsC,EAAK/X,EAAOC,GAASyR,IACvDy7C,EACnB,OAAO,CACX,EAEJ/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,EAAYqb,EAAkB,WAC5D,MAAMrqB,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,GACd,KAAE1yB,GAAS0hC,EACjB1hC,EAAKi0F,QAAS,EACd,MAAML,GAAuB,IAAAhiD,gCAA+B3xB,EAASntB,KAAK0+C,eAAe,GACzF1+C,KAAK++C,SAAW,CACZnQ,aACAkyD,wBAEJ9gG,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsC2hD,GACtC7oD,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,EAAQrP,EAAkB,WACtE,MAAMrqB,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,GACd,KAAE1yB,GAAS0hC,EACjB1hC,EAAKi0F,QAAS,EACd,IACI5nC,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMwnC,GAAuB,IAAAhiD,gCAA+B3xB,EAASntB,KAAK0+C,eAAe,GACzF1+C,KAAK++C,SAAW,CACZnQ,aACAkyD,uBACAvnC,eAEJv5D,KAAKmiD,gBAAgBh1B,IACrB,KAAA8xB,mBAAkB9xB,IAClB,EAAAgyB,EAAA,GAAsC2hD,GACtC7oD,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,GACd,WAAEgP,EAAU,qBAAEkyD,EAAoB,cAAEtnC,EAAa,SAAEE,GAAa15D,KAAK++C,UACrE,KAAE7xC,GAAS0hC,EACb4qB,IAAkBE,IAGtB15D,KAAKkzE,eACLhmE,EAAKi0F,QAAS,EACdj0F,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,KAAAmyB,oBAAmBnyB,GACnBntB,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,QAAiBp5B,EAAW2Q,gBAEhC,EAAAJ,EAAA,GAAsC2hD,GAAqB,EAE/D9gG,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAM1e,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,GACd,WAAEgP,EAAU,qBAAEkyD,EAAoB,YAAEvnC,EAAW,cAAEC,GAAkBx5D,KAAK++C,SAC9E/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,QAAoB5wC,IAAhBu7D,EAA2B,CAC3B,MAAM,YAAEnhB,GAAgBxY,EAClBy0C,EAAgBj8B,EAAYE,OAC5B,OAAE7pC,GAAWvB,EAAKyxC,QACxBlwC,EAAOxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCnnE,EAAK3R,aAAc,CACvB,KACK,CACD,MAAM,cAAEu/C,GAAkBlb,EACpBtkC,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEuyB,EAAa,cAAEtwB,GAAkB9zB,EAAeY,SAClDsjB,EAAWs7B,EAAcxC,OACzB,OAAE7pC,GAAWvB,EAAKyxC,QAExB,IAAI1nB,EACAD,EACA2oB,EACA5oB,EACAM,EACAD,EACAF,EACAC,EACJ,OATA1oB,EAAO8qD,GAAe,IAAI/5C,GASlB+5C,GACJ,KAAK,EACL,KAAK,EACDtiC,EAAmByoB,EAAcjxC,EAAO,IACxCsoB,EAAiB2oB,EAAcjxC,EAAO,IACtCuoB,EAAoB,CAACD,EAAe,GAAIE,EAAiB,IACzD0oB,EAAgB,CAAC1oB,EAAiB,GAAIF,EAAe,IACrDK,EAAmBhI,EAAc4H,GACjCE,EAAe9H,EAAcuwB,GAC7BlxC,EAAO,GAAK2oB,EACZ3oB,EAAO,GAAKyoB,EACZ,MACJ,KAAK,EACL,KAAK,EACDF,EAAoB0oB,EAAcjxC,EAAO,IACzCkxC,EAAgBD,EAAcjxC,EAAO,IACrCwoB,EAAmB,CACf0oB,EAAc,GACd3oB,EAAkB,IAEtBD,EAAiB,CACbC,EAAkB,GAClB2oB,EAAc,IAElBtoB,EAAkBjI,EAAc6H,GAChCE,EAAgB/H,EAAc2H,GAC9BtoB,EAAO,GAAK4oB,EACZ5oB,EAAO,GAAK0oB,EAGpBjqB,EAAK3R,aAAc,CACvB,CACAyE,KAAK++C,SAAS2a,UAAW,GACF,IAAAxhC,mBAAkB/K,IACzC,EAAAgyB,EAAA,GAAsC2hD,EAAqB,EAE/D9gG,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEnEl4C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,cAAc,EAEtEl4C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,MAAMC,GAAe,GACf,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,QAAevgD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMG,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,GAAkB3Q,EACpB1hC,EAAO0hC,EAAW1hC,MAClB,OAAEuB,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QACrC+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7DiyC,EAAY3gD,KAAKi6D,SAAS,YAAaxZ,EAAgB7R,GACvDgS,EAAW5gD,KAAKi6D,SAAS,WAAYxZ,EAAgB7R,GACrDxyC,EAAQ4D,KAAKi6D,SAAS,QAASxZ,EAAgB7R,GACrD,IAAK1yC,EAASiwB,qBAEV,YADA/b,QAAQC,KAAK,uCAGjB,IAAI6pD,EAKJ,GAJKl6D,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM2kD,EAAe,KACrB,IAAAqgD,mBAAqB/gD,EAAkBd,EAAewB,EAAcL,EAAkB,GAAIA,EAAkB,GAAI,CAC5GtkD,MAAO,QACPwkD,WACAD,aAER,GAEJ3gD,KAAKihG,8BAAiCxyF,IAClC,MAAO4yF,EAAQt4C,GAAUt6C,EACzB,MAAO,CACH0yC,KAAMlkD,KAAKa,IAAIujG,EAAO,GAAIt4C,EAAO,IACjCp0C,IAAK1X,KAAKa,IAAIujG,EAAO,GAAIt4C,EAAO,IAChCnsD,MAAOK,KAAK6e,IAAIulF,EAAO,GAAKt4C,EAAO,IACnClsD,OAAQI,KAAK6e,IAAIulF,EAAO,GAAKt4C,EAAO,IACvC,EAEL/oD,KAAKw0E,sBAAwB,CAAC5lC,EAAYnvB,EAAiB2iB,EAAQzoB,EAAiBre,KAChF,MAAM,KAAE4R,GAAS0hC,GACX,YAAE0yD,EAAW,mBAAEC,EAAkB,SAAEC,GAAalmG,EAChD+5E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBu0F,EAAa7hG,OAAO4B,KAAKo9C,GAC/B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI+3F,EAAW7gG,OAAQ8I,IAAK,CACxC,MAAMg4F,EAAYD,EAAW/3F,IACvB,YAAE6V,GAAgBvf,KAAK2hG,6BAA6BD,EAAW/nF,IAC/D,WAAE9R,EAAU,WAAE1C,EAAY8lC,aAAc5oB,EAAS,SAAEnb,GAAcqY,EACjE82E,EAAiB,gBAAgB,EAAG,EAAG,GACvCG,EAAiB,gBAAgB,EAAG,EAAG,GAS7C,GARAn0E,EAAUu/E,iBAAiBvsB,EAAWghB,GACtCA,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9CA,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9CA,EAAe,GAAKp5F,KAAK+Q,MAAMqoF,EAAe,IAC9Ch0E,EAAUu/E,iBAAiBtsB,EAAWkhB,GACtCA,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC9CA,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC9CA,EAAe,GAAKv5F,KAAK+Q,MAAMwoF,EAAe,IAC1Cx2F,KAAK0zE,gBAAgB2iB,EAAgBG,EAAgB3uF,GAAa,CAClE7H,KAAKooE,sBAAuB,EAC5B,MAAMj/B,EAAOlsC,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAClDptD,EAAOnsC,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,IAClDntD,EAAOpsC,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAClDltD,EAAOrsC,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,IAClDjtD,EAAOtsC,KAAKa,IAAIu4F,EAAe,GAAIG,EAAe,IAClDhtD,EAAOvsC,KAAKkS,IAAIknF,EAAe,GAAIG,EAAe,KAClD,WAAE7c,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoCp6D,EAAiB2iB,EAAQizC,EAAWC,GACtG2D,EAAOU,EAAaC,EAC1B,IAAI3qE,EAAQ,EACRq0B,EAAO,EACPC,EAAS,EACb,MAAMoG,EAAY9hC,EAAW,GACvB+hC,EAAY/hC,EAAW,GAAKA,EAAW,GAC7C,IAAK,IAAIwK,EAAIk3B,EAAMl3B,GAAKm3B,EAAMn3B,IAC1B,IAAK,IAAIJ,EAAIo3B,EAAMp3B,GAAKq3B,EAAMr3B,IAC1B,IAAK,IAAIvI,EAAIy/B,EAAMz/B,GAAK0/B,EAAM1/B,IAAK,CAE/BuF,IACAq0B,GAFcn+B,EAAWkN,EAAIu3B,EAAY33B,EAAI03B,EAAYjgC,EAG7D,CAGR45B,GAAQr0B,EACR,IAAK,IAAIoD,EAAIk3B,EAAMl3B,GAAKm3B,EAAMn3B,IAC1B,IAAK,IAAIJ,EAAIo3B,EAAMp3B,GAAKq3B,EAAMr3B,IAC1B,IAAK,IAAIvI,EAAIy/B,EAAMz/B,GAAK0/B,EAAM1/B,IAAK,CAC/B,MACMm4F,EADQ18F,EAAWkN,EAAIu3B,EAAY33B,EAAI03B,EAAYjgC,GAC1B45B,EAC/BC,GAAUs+D,EAAiBA,CAC/B,CAGRt+D,GAAUt0B,EACVs0B,EAAStmC,KAAKwmC,KAAKF,GACnBqb,EAAY8iD,GAAa,CACrB/9D,SAAUz8B,EAASy8B,SACnBs1C,OACA31C,OACAC,SAER,MAEIvjC,KAAKooE,sBAAuB,EAC5BxpB,EAAY8iD,GAAa,CACrB/9D,SAAUz8B,EAASy8B,SAG/B,CACA,MAAMpoC,EAAcqzC,EAAWrzC,YAE/B,GADAqzC,EAAWrzC,aAAc,EACrBA,EAAa,CACb,MAAM8iF,EAAY,EAAA5uD,OAAO8uD,oBACnBxvD,EAAc,CAChB6f,aACA0yD,cACAC,qBACAC,SAAUA,EACVhrB,WAAY,EAAAznC,YAAYymC,eAE5B,IAAAh2C,cAAa,EAAArN,YAAaksD,EAAWtvD,EACzC,CACA,OAAO6vB,CAAW,EAEtB5+C,KAAK0zE,gBAAkB,CAACC,EAAQC,EAAQ/rE,IAC5B,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,GAE9C7H,KAAK8hG,oBAAuBC,IACxB,GAAI/hG,KAAKyM,cAAcu1F,UACnB,OAAOhiG,KAAKyM,cAAcu1F,UAE9B,MAAM39E,EAAe09E,EAAME,kBAC3B,OAAK59E,GAAiBA,EAAazjB,OAG5ByjB,EAAa,GAAGtD,SAHvB,CAG0B,EAE9B/gB,KAAKu0E,gCAAiC,EAAAQ,EAAA,GAAS/0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,MAAA/pE,CAAOkiB,GACH,IAAKntB,KAAKs+C,UACN,OAEJt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,KAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,qBAAEkyD,GAAyB9gG,KAAK++C,UAC5C,KAAE7xC,GAAS0hC,EAKjB,OAJA1hC,EAAKi0F,QAAS,EACdj0F,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,EAAAtZ,EAAA,GAAsC2hD,GACtC9gG,KAAK++C,SAAW,KACTnQ,EAAW1nC,SAASq4C,aAC/B,CACA,4BAAAoiD,CAA6BD,EAAW/nF,GACpC,IAAI4F,EACJ,GAAImiF,EAAU1gG,WAAW,eAAgB,CACrC,MAAMkhG,EAAcR,EAAU1+F,QAAQ,KAChCs+F,EAAcI,EAAUz9E,UAAUi+E,EAAc,GAEtD3iF,EADiB5F,EAAgByU,YAAYkzE,GACtB5rE,cAC3B,MAEInW,EAAc,EAAA+R,MAAM7M,UAAUi9E,GAElC,MAAO,CAAEniF,cAAarjB,SAVLA,UAWrB,CACA,kBAAAimG,CAAmBjmG,GACf,MAAO,eAAeA,EAAS6kB,KACnC,E,oDCxbJ,MAAMqhF,GAAM,CACVC,QAAS,EACTC,UAAW,GAEPC,GAAU,IAAI1pE,IA0GpB,MAAM2pE,GAAiB,CAAC,EAIxB,SAASphG,GAAOqhG,EAAWC,GACzB,IAAIC,EAAgBC,UAAUhiG,OAAS,QAAsB5C,IAAjB4kG,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFhjG,OAAOm7D,OAAO2nC,EAAOF,GAAgBG,GACrC,GAAAE,EAAM9jF,IAAI0jF,EAAWC,GACrB,GAAAG,EAAMC,KAAKL,EAAWC,EAAO,EAAG,GAjHlC,SAAkCD,EAAWC,GAC3CD,EAAUM,YAAc,CAACC,EAAQC,KAC/B,MAAO77E,GAAS47E,EACXC,EAAQ,KACXA,EAAQ,GAAK,qBAEf,MAAOC,GAAUD,EACjBR,EAAUU,gBAAgB/7E,EAAO87E,GACjCA,EAAO13D,UAAU,EAEnBi3D,EAAUW,aAAe,CAACC,EAAItjF,EAAKujF,EAAaC,EAAWC,KACzD,IAAIC,EAASH,EACTI,EAAWH,EACXI,GAAa,EACbC,EAAc,EAClB,MAAQD,GAAY,CAClB,MAAM,aACJE,GACER,EAAGS,cAAcL,GACrB,IAAKI,EAEH,SAEFH,EAAWG,EAAa,KAAOH,EAAWG,EAAa,GAAKA,EAAa,GACzED,IAGA,MAAM58D,EAAIjnB,EAAM6jF,EAChBJ,EAAW76F,KAAK,CACdq+B,IACA+8D,KAAML,IAER,MAAMM,EAAWX,EAAGY,cAAcP,GAClC,GAAwB,IAApBM,EAASpjG,QAAgB8iG,IAAaH,EAExC,OAAOG,EAEe,IAApBM,EAASpjG,QAEX6iG,EAASO,EAAS,KAAOP,EAASO,EAAS,GAAKA,EAAS,GACzDzB,GAAQj/F,IAAImgG,IAGZE,GAAa,CAEjB,CACA,OAAOD,CAAQ,EAEjBjB,EAAUU,gBAAkB,CAAC/7E,EAAO87E,KAClC,MAAMgB,EAAQ,GACd3B,GAAQzuF,QACR,MAAMqwF,EAAU/8E,EAAMkmB,WACtB41D,EAAOh1D,YAAYk2D,QAAQn7F,aAAa1G,KAAK6kB,EAAM8mB,YAAYlF,YAI/D,IAAK,IAAIq7D,EAAK,EAAGA,EAAKF,EAAQG,mBAAoBD,IAAM,CACtD,GAAI9B,GAAQl/F,IAAIghG,GAEd,SAEF,MAAM,aACJR,GACEz8E,EAAM08E,cAAcO,GACxB,IAAKR,EAEH,SAEFtB,GAAQj/F,IAAI+gG,GACZ,MAAMd,EAAYM,EAAa,GACzBL,EAAa,GACnBA,EAAW76F,KAAK,CACdq+B,EAAG,EACH+8D,KAAMR,IAGJA,IADYd,EAAUW,aAAah8E,EAAOg7E,GAAIC,QAASgC,EAAId,EAAWC,KAGxEf,EAAUW,aAAah8E,EAAOg7E,GAAIE,SAAU+B,EAAId,EAAWC,GAC3DA,EAAWvnF,MAAK,CAACC,EAAGhF,IAAMgF,EAAE8qB,EAAI9vB,EAAE8vB,GAAK,EAAI,IAEvCw8D,EAAW5iG,QAAU4iG,EAAW,GAAGO,OAASP,EAAWA,EAAW5iG,OAAS,IAAImjG,MACjFP,EAAW76F,KAAK,IACX66F,EAAWA,EAAW5iG,OAAS,MAIpC4iG,EAAW5iG,QACbsjG,EAAMv7F,KAAK66F,EAEf,CAGA,MAAMe,EAAWrB,EAAO51D,WACxBi3D,EAASniC,OAAO,GAChB8hC,EAAMjjG,SAAQ++B,IACZukE,EAASC,eAAexkE,EAAK35B,KAAI6c,GAAMA,EAAG6gF,OAAM,GAChD,CAEN,CAeEU,CAAyBhC,EAC3B,CAQA,IAAI,GAAQ,CACViC,YALkB,GAAA7B,EAAM6B,YAAYtjG,GAAQ,4BAM5CA,W,YC5HF,MAAQqxC,MAAQw8B,UAAU,cAAEp7B,GAAa,QAAE+rC,GAAO,YAAE+kB,KAAkBC,uBAAuB,mBAAEC,GAAkB,aAAEC,IAAgBjwB,aAAa,+BAAEkwB,IAAkCxwF,QAAQ,wBAAEywF,KAA+B,EAY7N,MAAMC,GAAoB,CACtBC,QAAS,KACTC,qBAAqB,EACrBC,2BAA4B,KAC5B,uBAAMC,CAAkBC,GACpB,IAAIC,EACJ,IACIA,SAlBZvsE,eAA0BwsE,GACtB,IACI,GAAiB,sBAAbA,EACA,OAAO,+BAEf,CACA,MAAO7/F,GAEH,OADAyK,QAAQC,KAAK,0BAA2B1K,GACjC,IACX,CACJ,CAQgC8/F,CAAW,sBAAsBC,OACzD,CACA,MAAO//F,GAGH,OAFAyK,QAAQzK,MAAMA,QACdyK,QAAQqM,MAAM,+EAElB,CACIzc,KAAKmlG,0BACCnlG,KAAKolG,2BAGXplG,KAAKklG,SAAS5xB,WAGlBtzE,KAAKmlG,qBAAsB,EAC3BnlG,KAAKolG,2BAA6B,IAAIvgG,SAASC,IAC3C9E,KAAKklG,QAAU,IAAIK,EACnBvlG,KAAKklG,QACAS,WAAW,CACZC,eAAgBN,IAEfvgG,MAAK,KACN/E,KAAKmlG,qBAAsB,EAC3BrgG,GAAS,GACX,UAEA9E,KAAKolG,2BACf,EACA,6BAAMS,CAAwBC,KAASC,GACnC,MAAM,UAAEC,EAAS,eAAEC,GAAmBH,GAC/BR,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAE7B,aADsBtlG,KAAKklG,QAAQ5xB,SAAS4yB,2BAA2BF,EAAWC,EAEtF,EACA,8BAAME,CAAyBL,KAASC,GACpC,MAAOT,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAC7B,MAAMc,EAAUpmG,KAAKklG,QAAQ5xB,SAAS6yB,yBAAyBL,EAAK3gG,WAAY2gG,EAAKj+F,WAAYi+F,EAAKh+F,QAASg+F,EAAK79F,UAAW69F,EAAK/9F,OAAQ,CAAC+9F,EAAKvX,eAC5I8X,EAAexB,GAAmBiB,EAAK79F,WAC7C,IAAKo+F,EAAaC,WAAY,CAC1B,MAAMC,EAAgBzB,GAAauB,EAAaG,eAAgBV,EAAK/9F,OAAQq+F,EAAQ33F,QACrF23F,EAAQ33F,OAAS,IAAI83F,EACzB,CACA,OAAOH,CACX,EACA,oCAAMK,CAA+BX,KAASC,GAC1C,MAAOT,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAC7B,MAAM,eAAEoB,EAAc,WAAEvhG,EAAU,2BAAEwhG,EAA0B,WAAE9+F,EAAU,OAAEE,EAAM,UAAEE,EAAS,QAAEH,GAAag+F,EACtGc,EAA2B,EAAAt6D,UAAA,aAAuBu6D,+BAA+B,CACnFh/F,aACA1C,eAEEkd,EAAY,oBAClBA,EAAUykF,cAAcj/F,GACxBwa,EAAU0kF,UAAUh/F,GACpBsa,EAAU2kF,aAAa/+F,GACvBoa,EAAU4kF,WAAWn/F,GACrB,MAAMo/F,EAAc,kBAAyB,CACzC5mG,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQxV,IAEZkd,EAAUymB,eAAeq+D,WAAWD,GACpC7kF,EAAUmpB,WACV,IAAK,MAAMhjC,KAASk+F,EAAgB,CAChC,MAAMnmD,EAAcomD,EAA2BvmG,IAAIoI,GACnD,IAAK,MAAMomC,KAAc2R,EAAa,CAClC,IAAK3R,EAAWqgC,SACZ,SAEJ,MAAM,SAAEA,EAAQ,cAAEm4B,GAAkBx4D,EAC9BroB,EAASw+E,GAA+B91B,IACvC9lC,EAAME,EAAME,GAAQ,EAAA+C,UAAA,sBAAgCjqB,EAAW,CAClEkE,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAEP6iB,EAAME,EAAME,GAAQ,EAAA8C,UAAA,sBAAgCjqB,EAAW,CAClEkE,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAER,kBAAE8gF,EAAiB,qBAAEC,GAAyB3C,GAAY11B,GAC1Ds4B,EAAQH,GAAe/gG,KAAKmhG,IAC9B,MAAQH,kBAAmBI,GAAkB9C,GAAY6C,GACzD,OAAOC,CAAa,IAElBC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAChC,EAAAh7D,UAAA,aAAuBu6D,+BAA+B,CACjEh/F,aACA1C,eAEGlE,SAAQ,EAAGwoC,eACdm9D,EAAyBgB,cAAcn+D,EAAUjhC,EAAM,GACxD,CACC6Z,YACA23D,WAAajwC,IACT,MAAM89D,EAAU,CAAC99D,EAAS29D,GAAW39D,EAAS49D,IAI9C,OAHiB9zD,GAAcwzD,EAAmBQ,EAAS,CACvDN,SAEW,EAEnBryF,UAAW,CACP,CAACi0B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,KAGnB,CACJ,CACA,OAAOo9D,EAAyBzhG,UACpC,EACA,mCAAM2iG,CAA8BhC,KAASC,GACzC,MAAOT,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAC7B,MAAM,kBAAEyC,EAAiB,2BAAEpB,EAA0B,eAAED,GAAmBZ,EACpEkC,EAA4B,IAAIx2F,IACtCu2F,EAAkB9mG,SAAQ,CAACgnG,EAAkB1hG,KACzC,MAAM,WAAEsB,EAAU,WAAE1C,EAAU,UAAE8C,EAAS,QAAEH,EAAO,OAAEC,GAAWkgG,EACzDC,EAAU,EAAA57D,UAAA,aAAuBu6D,+BAA+B,CAClEh/F,aACA1C,eAEEkd,EAAY,oBAClBA,EAAUykF,cAAcj/F,GACxBwa,EAAU0kF,UAAUh/F,GACpBsa,EAAU2kF,aAAa/+F,GACvBoa,EAAU4kF,WAAWn/F,GACrB,MAAMo/F,EAAc,kBAAyB,CACzC5mG,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQxV,IAEZkd,EAAUymB,eAAeq+D,WAAWD,GACpC7kF,EAAUmpB,WACVw8D,EAA0B9nG,IAAIqG,EAAmB,CAAE2hG,UAAS7lF,aAAY,IAE5E,IAAK,MAAM7Z,KAASk+F,EAAgB,CAChC,MAAMnmD,EAAcomD,EAA2BvmG,IAAIoI,GACnD,IAAK,MAAMomC,KAAc2R,EAAa,CAClC,IAAK3R,EAAWqgC,SACZ,SAEJ,MAAM,SAAEA,EAAQ,cAAEm4B,EAAa,kBAAE7gG,GAAsBqoC,EACjDroB,EAASw+E,GAA+B91B,IACtCi5B,QAAStB,EAAwB,UAAEvkF,GAAc2lF,EAA0B5nG,IAAImG,IAChF4iC,EAAME,EAAME,GAAQ,EAAA+C,UAAA,sBAAgCjqB,EAAW,CAClEkE,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAEP6iB,EAAME,EAAME,GAAQ,EAAA8C,UAAA,sBAAgCjqB,EAAW,CAClEkE,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAER,kBAAE8gF,EAAiB,qBAAEC,GAAyB3C,GAAY11B,GAC1Ds4B,EAAQH,GAAe/gG,KAAKmhG,IAC9B,MAAQH,kBAAmBI,GAAkB9C,GAAY6C,GACzD,OAAOC,CAAa,IAElBC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAChC,EAAAh7D,UAAA,aAAuBpnC,wBAAwB,CAC1DtI,MAAOylB,EAAUQ,gBAAgB,GACjChmB,OAAQwlB,EAAUQ,gBAAgB,GAClC1d,WAAYkd,EAAUymB,eAAeC,aAAaC,YAE/C/nC,SAAQ,EAAGwoC,eACdm9D,EAAyBgB,cAAcn+D,EAAUjhC,EAAM,GACxD,CACC6Z,YACA23D,WAAajwC,IACT,MAAM89D,EAAU,CAAC99D,EAAS29D,GAAW39D,EAAS49D,IAI9C,OAHiB9zD,GAAcwzD,EAAmBQ,EAAS,CACvDN,SAEW,EAEnBryF,UAAW,CACP,CAACi0B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,KAGnB,CACJ,CAKA,OAJAu+D,EAAkB9mG,SAAQ,CAACgnG,EAAkB1hG,KACzC,MAAQ2hG,QAAStB,GAA6BoB,EAA0B5nG,IAAImG,GAC5E0hG,EAAiB9iG,WAAayhG,EAAyBzhG,UAAU,IAE9D4iG,CACX,EACA,oCAAMI,CAA+BrC,KAASC,GAC1C,MAAOT,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAE7B,OADgBtlG,KAAKklG,QAAQ5xB,SAAS80B,yBAAyBtC,EAAKr3F,OAAQq3F,EAAKuC,MAAOvC,EAAKj+F,WAAYi+F,EAAKh+F,QAASg+F,EAAK79F,UAAW69F,EAAK/9F,OAEhJ,EACA,qCAAMugG,CAAgCxC,KAASC,GAC3C,MAAOT,GAAoBS,QACrB/lG,KAAKqlG,kBAAkBC,GAC7B,MAAM,aAAEiD,GAAiBzC,EACnB0C,EAAW9pG,MAAM6D,KAAKgmG,EAAa/mG,QAAQ6E,KAAKkoF,IAClD,MAAM,OAAE9/E,EAAM,MAAE45F,GAAUE,EAAanoG,IAAImuF,GAE3C,MAAO,IADQvuF,KAAKklG,QAAQ5xB,SAAS80B,yBAAyB35F,EAAQ45F,EAAOvC,EAAKj+F,WAAYi+F,EAAKh+F,QAASg+F,EAAK79F,UAAW69F,EAAK/9F,QAG7HwmF,eACH,IAEC6X,QAAgBvhG,QAAQ4jG,IAAID,GAC5BE,EAAkB,oBACxBA,EAAgB5B,cAAchB,EAAKj+F,YACnC6gG,EAAgB3B,UAAUjB,EAAK/9F,QAC/B2gG,EAAgBzB,WAAWnB,EAAKh+F,SAChC4gG,EAAgB1B,aAAalB,EAAK79F,WAClC,MAAM0gG,EAAY7C,EAAKj+F,WAAW,GAAKi+F,EAAKj+F,WAAW,GAAKi+F,EAAKj+F,WAAW,GACtEq/F,EAAc,kBAAyB,CACzC5mG,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQ,IAAI3R,WAAW2/F,KAE3BD,EAAgB5/D,eAAeq+D,WAAWD,GAC1CwB,EAAgBl9D,WAChB,MAAM,WAAE3jC,GAAei+F,EACjB3gG,EAAaujG,EAAgB5/D,eAAeC,aAAaC,UACzD49D,EAA2B,EAAAt6D,UAAA,aAAuBu6D,+BAA+B,CACnFh/F,aACA1C,eAEEyjG,EAAoBxC,EAAQ//F,KAAKq1B,IACnC,MAAM,KAAExuB,EAAI,WAAErF,EAAU,UAAEI,EAAS,OAAEF,EAAM,QAAED,GAAY4zB,EACnD5X,EAAS,oBACfA,EAAOgjF,cAAcj/F,GACrBic,EAAOijF,UAAUh/F,GACjB+b,EAAOmjF,WAAWn/F,GAClBgc,EAAOkjF,aAAa/+F,GACpB,MAAMi/F,EAAc,kBAAyB,CACzC5mG,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQzN,IAEZ4W,EAAOglB,eAAeq+D,WAAWD,GACjCpjF,EAAO0nB,WACP,MAAMxmC,EAAe,EAAAsnC,UAAA,aAAuBu6D,+BAA+B,CACvEh/F,aACA1C,WAAY+H,IAEV27F,EAAS/kF,EAAO2C,YACtB,MAAO,CACH3C,SACA9e,eACA6jG,SACA1jG,WAAY+H,EACZqhF,aAAc7yD,EAAO6yD,aACxB,IA8BL,OA5Be,EAAAjiD,UAAA,aAAuBu6D,+BAA+B,CACjEh/F,WAAY6gG,EAAgB7lF,gBAC5B1d,WAAYujG,EAAgB5/D,eAAeC,aAAaC,YAErD/nC,SAAQ,EAAGwoC,WAAUM,eACxB,IACI,IAAK,MAAM++D,KAAcF,EAAmB,CACxC,MAAM,OAAE9kF,EAAM,OAAE+kF,EAAM,aAAE7jG,EAAY,aAAEupF,GAAiBua,EACjDtgG,EAAQsb,EAAOyT,aAAawS,GAClC,GAAIvhC,EAAM,GAAKqgG,EAAO,IAClBrgG,EAAM,GAAKqgG,EAAO,IAClBrgG,EAAM,GAAKqgG,EAAO,IAClBrgG,EAAM,GAAKqgG,EAAO,IAClBrgG,EAAM,GAAKqgG,EAAO,IAClBrgG,EAAM,GAAKqgG,EAAO,GAClB,SAEJ,MAAME,EAAevgG,EAAMnC,IAAIpJ,KAAKkkB,OAEpC,GADcnc,EAAaszF,YAAYyQ,GAC3B,EAAG,CACXnC,EAAyBgB,cAAcn+D,EAAU8kD,GACjD,KACJ,CACJ,CACJ,CACA,MAAO5oF,GACP,IACD,CAAE0c,UAAWqmF,IACT9B,EAAyBzhG,UACpC,EACA,gBAAA6jG,EAAiB,aAAEC,IACf,MAAMC,EAAQ,IAAI13F,IAClB,IAAK,MAAM,OAAE/C,EAAM,GAAEpF,KAAQ4/F,EAAc,CACvC,MAAMr5D,EAAOgwC,GAAQnxE,EAAQ,CAAE06F,cAAe,IAC9CD,EAAMhpG,IAAImJ,EAAIumC,EAClB,CACA,OAAOs5D,CACX,EACA,qBAAAE,EAAsB,WAAEC,EAAU,aAAEJ,EAAY,aAAEK,EAAe,IAAI93F,KAAS8zF,EAAkBiE,GAC5F,MAAMC,EAAiBH,EAAWzoG,OAC5B6oG,EAAS,oBACTC,EAAS,oBACfD,EAAOE,eAAeD,GACtB,MAAME,EAAkB,oBACxB,IACI,IAAK,MAAOphG,EAAOqhG,KAAcR,EAAWpgF,UAAW,CACnD,MAAM,WAAE6gF,EAAU,OAAEC,GAAWF,EACzBG,EAAkB,IAAIx4F,IAC5B,IAAK,MAAMy4F,KAAgBhB,EAAc,CACrC,MAAM,OAAEx6F,EAAM,MAAE45F,EAAK,GAAEh/F,EAAE,aAAEklF,GAAiB0b,EACtCC,EAAQZ,EAAalpG,IAAIiJ,IAAOu2E,GAAQnxE,EAAQ,CAAE06F,cAAe,IAClEG,EAAajmG,IAAIgG,IAClBigG,EAAappG,IAAImJ,EAAI6gG,GAEzB,MAAM,KAAE5mF,EAAI,KAAEud,EAAI,KAAEE,EAAI,KAAExd,EAAI,KAAEud,EAAI,KAAEE,GAASkpE,GACzC,OAAEniG,EAAM,OAAEk/B,GAAW8iE,EAAO,GAClC,IAAK/E,GAAwBj9F,EAAQk/B,EAAQ3jB,EAAMud,EAAME,EAAMxd,EAAMud,EAAME,GACvE,SAEJ4oE,EAAgB17D,YAAYk2D,QAAQ31F,EAAQ,GAC5Cm7F,EAAgBO,WAAW/F,QAAQiE,EAAO,GAC1CuB,EAAgBp+D,WAChBi+D,EAAO9L,aAAaiM,GACpBF,EAAO3C,UAAUh/F,GACjB2hG,EAAOU,UAAUnjE,GACjB,IACIwiE,EAAOpvC,QACX,CACA,MAAO3qD,GACHU,QAAQC,KAAK,wBAAyBX,GACtC,QACJ,CACA,MAAM09B,EAAWq8D,EAAOniC,gBAClB+iC,EAAej9D,EACrBi9D,EAAaC,aACb,MAAMC,EAAiB,iBACvBA,EAAe5M,aAAa0M,GAC5B,MAAMG,EAAaD,EAAejjC,gBAC9Bl6B,GACA48D,EAAgB9pG,IAAIquF,EAAc,CAC9B9/E,OAAQ+7F,EAAWt8D,YAAYlF,UAC/ByhE,MAAOD,EAAWl9D,WAAWtE,UAC7B0hE,cAAeF,EAAWl9D,WAAWg3D,mBACrC/V,gBAGZ,CACA+W,EAAiB,CAAEqF,UAAWniG,EAAQ,GAAKghG,IAC3CD,EAAoB,CAAEO,aAAYE,mBACtC,CACJ,CACA,MAAOt6F,GACHU,QAAQC,KAAK,0BAA2BX,EAC5C,CACA,QACIu5F,EAAe,KACfS,EAAOlmG,QACX,CACJ,IAEJ,OAAOyhG,G,gDCtYP,MAiQA,EAjQ8B,CAC1B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,K,0EC7PnB,MAAM2F,EAAmB,mBAwBzB,SAASC,EAAWC,EAAYC,GAC5B,GAAKljF,EAAA,GAAMmjF,aAAaF,GAGxB,OAAIjjF,EAAA,GAAMmjF,aAAaF,GAAYC,GACxBljF,EAAA,GAAMmjF,aAAaF,GAAYC,GAAUE,YADpD,CAGJ,CACA,SAASC,EAAWC,EAAiBL,EAAYM,EAASL,GACtD,IAAKljF,EAAA,GAAMmjF,aAAaF,GACpB,OAAO,KAEXjjF,EAAA,GAAMmjF,aAAaF,GAAYC,GAAY,CACvCM,SAAS,EACTJ,OAAQG,GAEZD,EAAgBr9E,YAAYs9E,EAChC,CACA,SAASE,EAAeR,EAAYC,GAC3BljF,EAAA,GAAMmjF,aAAaF,IAGpBjjF,EAAA,GAAMmjF,aAAaF,GAAYC,KAC/BljF,EAAA,GAAMmjF,aAAaF,GAAYC,GAAUM,SAAU,EAE3D,CACA,SAASE,EAAeJ,EAAiBL,GAChCjjF,EAAA,GAAMmjF,aAAaF,IAGxBlrG,OAAO4B,KAAKqmB,EAAA,GAAMmjF,aAAaF,IAAa7pG,SAAS8pG,IACjD,MAAMS,EAAa3jF,EAAA,GAAMmjF,aAAaF,GAAYC,IAC7CS,EAAWH,SAAWG,EAAWP,SAClCE,EAAgBt0C,YAAY20C,EAAWP,eAChCpjF,EAAA,GAAMmjF,aAAaF,GAAYC,GAC1C,GAER,CACA,QA7DA,SAA6B59E,GACzB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,WAAED,EAAU,kBAAEhB,GAAsB5wB,EACpCwvG,EAAa,GAAG59E,KAAchB,IAC9Bi/E,EAaV,SAAsBh+E,GAClB,MAAMypC,EAAkB,IAAIg0C,IACtBa,EAAqBt+E,EAAQkpC,cAAcO,GAC3C0b,EAAWm5B,GAAoBp1C,cAAc,uBACnD,OAAOic,CACX,CAlB4Bo5B,CAAav+E,GAIrC,OAHAvtB,OAAO4B,KAAKqmB,EAAA,GAAMmjF,aAAaF,IAAa7pG,SAAS8pG,IACjDljF,EAAA,GAAMmjF,aAAaF,GAAYC,GAAUM,SAAU,CAAK,IAErD,CACHF,gBAAiBA,EACjBQ,sBAAuB9jF,EAAA,GAAMmjF,aAC7BH,WAAYA,EAAWr6F,KAAKxQ,KAAM8qG,GAClCI,WAAYA,EAAW16F,KAAKxQ,KAAMmrG,EAAiBL,GACnDQ,eAAgBA,EAAe96F,KAAKxQ,KAAM8qG,GAC1CS,eAAgBA,EAAe/6F,KAAKxQ,KAAMmrG,EAAiBL,GAEnE,ECbA,QALA,SAAc39E,EAASy+E,GACnB,MAAMvrD,EAAmB,EAAoBlzB,GAC7Cy+E,EAAGvrD,GACHA,EAAiBkrD,gBACrB,C,qFCoCA,QAtCA,SAAoBlrD,EAAkBd,EAAeiR,EAAW55C,EAAQksB,EAAQ1+B,EAAU,CAAC,EAAG08C,EAAS,IACnG,MAAM,MAAE1kD,EAAK,KAAE0V,EAAI,MAAElV,EAAK,UAAE+jD,EAAS,SAAEC,EAAQ,YAAEqmB,EAAW,cAAE4kC,GAAmBjsG,OAAOm7D,OAAO,CAC3F3+D,MAAO,iBACP0V,KAAM,cACNlV,MAAO,IACPgkD,cAAU5iD,EACV2iD,eAAW3iD,EACX6tG,cAAe,EACf5kC,YAAa,GACd7iE,GACG0nG,EAAcnrD,GAAa/jD,EAE3BmvG,GAAc,OAASxsD,EAAe,SAAUiR,GAChDw7C,EAAwB3rD,EAAiBwqD,WAAWkB,GACpDE,EAAa,CACf/oE,GAAI,GAAGtsB,EAAO,KACdusB,GAAI,GAAGvsB,EAAO,KACdI,EAAG,GAAG8rB,IACNopE,OAAQ9vG,EACR0V,OACA,eAAgBg6F,EAChB,mBAAoBlrD,EACpB,eAAgBqmB,EAChB,iBAAkB4kC,GAEtB,GAAIG,GACA,OAAyBC,EAAYD,GACrC3rD,EAAiBirD,eAAeS,OAE/B,CACD,MAAMI,EAAmB/+E,SAASg/E,gBAnBxB,6BAmB+C,UAC1C,KAAXtrD,GACAqrD,EAAiBn+E,aAAa,UAAW8yB,IAE7C,OAAwBmrD,EAAYE,GACpC9rD,EAAiB6qD,WAAWiB,EAAkBJ,EAClD,CACJ,C,qFCKA,QA1CA,SAAkC1rD,EAAkBd,EAAe25B,EAAYx4B,EAAmBt8C,EAAU,CAAC,EAAG08C,EAAS,IACrH,MAAM,MAAE1kD,EAAK,MAAEQ,EAAK,UAAE+jD,EAAS,SAAEC,GAAahhD,OAAOm7D,OAAO,CACxD3+D,MAAO,iBACPQ,MAAO,IACP+jD,eAAW3iD,EACX4iD,cAAU5iD,GACXoG,GACG0nG,EAAcnrD,GAAa/jD,EAE3BmvG,GAAc,OAASxsD,EAAe,UAAW25B,GACjDmzB,EAAkBhsD,EAAiBwqD,WAAWkB,IAC7ChhC,EAAQp2D,EAAKwsC,EAAMooB,GAAS7oB,EAC7B4rD,EAAIrvG,KAAKsvG,MAAMprD,EAAK,GAAKooB,EAAM,GAAIpoB,EAAK,GAAKooB,EAAM,IACnDijC,EAAIvvG,KAAKsvG,MAAM53F,EAAI,GAAKo2D,EAAO,GAAIp2D,EAAI,GAAKo2D,EAAO,IACnDjuE,EAA8D,IAArDG,KAAKwvG,MAAMtrD,EAAK,GAAKooB,EAAM,GAAIpoB,EAAK,GAAKooB,EAAM,IAAatsE,KAAKC,GAC1E0Z,EAAS,EAAEuqC,EAAK,GAAKooB,EAAM,IAAM,GAAI50D,EAAI,GAAKo2D,EAAO,IAAM,GAG3DkhC,EAAa,CACf/oE,GAAI,GAAGtsB,EAAO,KACdusB,GAAI,GAAGvsB,EAAO,KACd81F,GAAI,GALQJ,EAAI,IAMhBK,GAAI,GALQH,EAAI,IAMhBN,OAAQ9vG,EACR0V,KAAM,cACNrV,UAAW,UAAUK,KAAS8Z,EAAO,MAAMA,EAAO,MAClD,eAAgBk1F,EAChB,mBAAoBlrD,GAExB,GAAIyrD,GACA,OAAyBJ,EAAYI,GACrChsD,EAAiBirD,eAAeS,OAE/B,CACD,MAAMa,EAAoBx/E,SAASg/E,gBA1BzB,6BA0BgD,WAC3C,KAAXtrD,GACA8rD,EAAkB5+E,aAAa,UAAW8yB,IAE9C,OAAwBmrD,EAAYW,GACpCvsD,EAAiB6qD,WAAW0B,EAAmBb,EACnD,CACJ,C,+DCtCA,QALA,SAAqB1rD,EAAkBd,EAAe6a,EAAgByqB,EAAczgF,EAAU,CAAC,GAC3FygF,EAAa5jF,SAAQ,CAACq4D,EAAQ5vD,MAC1B,OAAW22C,EAAkBd,EAAe6a,EAAgBd,EAAQl1D,EAASsF,EAAE,GAEvF,C,oFCoBA,QAvBA,SAAkB22C,EAAkBd,EAAestD,EAASC,EAAwBC,EAAUl4B,EAAazwE,EAAU,CAAC,GAClH,MAAM1I,EAAQoxG,EAAuBlsG,OAAS,GACxC,EAAAosG,EAAA,GAAiBF,EAAwBC,GACzCA,EACAE,EASV,SAA4Bp4B,GACxB,MAAQv3E,EAAG6jD,EAAM3jD,EAAGmX,EAAG,OAAE9X,EAAM,MAAED,GAAUi4E,EACrCq4B,EAAYtwG,EAAQ,EACpBuwG,EAAatwG,EAAS,EAK5B,MAAO,CAJW,CAACskD,EAAO+rD,EAAWv4F,GAClB,CAACwsC,EAAMxsC,EAAMw4F,GACX,CAAChsD,EAAO+rD,EAAWv4F,EAAM9X,GAC1B,CAACskD,EAAOvkD,EAAO+X,EAAMw4F,GAE7C,CAlB8BC,CAAmBv4B,GACvC7iE,GAAM,EAAAg7F,EAAA,GAAiBC,EAAmBvxG,GAC1C8zF,EAAgB5vF,OAAOm7D,OAAO,CAChC3+D,MAAO,mBACPukD,UAAW,IACXC,SAAU,OACXx8C,IACH,EAAAmrD,EAAA,GAASlP,EAAkBd,EAAe,QAAQstD,IAAWnxG,EAAOsW,EAAKw9E,EAC7E,ECAA,QAZA,SAA2BnvC,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBk4B,EAAwBlkC,EAASxkE,EAAU,CAAC,GAC5I,MAAMorF,EAAgB5vF,OAAOm7D,OAAO,CAChC/T,aAAc,IACdqmD,UAAW,CACP/vG,GAAG,EACHE,GAAG,IAER4G,GACGkpG,GAAoB,EAAAhgC,EAAA,GAAYjtB,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiB4a,GAE/G,OADA,EAASnvC,EAAkBd,EAAe6zB,EAAY05B,EAAwBl4B,EAAiB04B,EAAmB9d,GAC3G8d,CACX,C,wECXe,SAAStsD,EAASX,EAAkBd,EAAewB,EAAcrlD,EAAOsW,EAAK5N,EAAU,CAAC,EAAG08C,EAAS,IAC/G,MAAMgiB,EAAU,CAACpnE,EAAM,GAAIA,EAAM,IAC3B2zB,EAAW,CAACrd,EAAI,GAAItW,EAAM,IAC1B4zB,EAAa,CAAC5zB,EAAM,GAAIsW,EAAI,IAC5B+wD,EAAc,CAAC/wD,EAAI,GAAIA,EAAI,KACjC,OAAsBquC,EAAkBd,EAAewB,EAAc,CAAC+hB,EAASzzC,EAAUC,EAAYyzC,GAAc3+D,EAAS08C,EAChI,C,8aCPe,SAAS80B,EAAWv1B,EAAkBd,EAAeo2B,EAAWj6E,EAAOsW,EAAK5N,EAAU,CAAC,GAClG,GAAIoY,MAAM9gB,EAAM,KAAO8gB,MAAM9gB,EAAM,KAAO8gB,MAAMxK,EAAI,KAAOwK,MAAMxK,EAAI,IACjE,OAEJ,MAAM,MAAE5V,EAAK,MAAEQ,EAAK,UAAE+jD,EAAS,SAAEC,GAAahhD,OAAOm7D,OAAO,CACxD3+D,MAAO,iBACPQ,MAAO,IACP+jD,eAAW3iD,EACX4iD,cAAU5iD,GACXoG,GACGmpG,EAAOv7F,EAAI,IAAMtW,EAAM,GAAKsW,EAAI,IAAM,EACtCw7F,EAAe,CAACD,EAAM7xG,EAAM,IAC5B+xG,EAAgB,CAACF,EAAMv7F,EAAI,IAC3B02E,EAAY,CACdhtF,MAAOA,EACPsW,IAAKw7F,GAEH7kB,EAAa,CACfjtF,MAAO8xG,EACPx7F,IAAKy7F,GAEHC,EAAY,CACdhyG,MAAO+xG,EACPz7F,IAAKA,IAET,EAAAu9C,EAAA,GAASlP,EAAkBd,EAAe,IAAKmpC,EAAUhtF,MAAOgtF,EAAU12E,IAAK,CAC3E5V,QACAQ,QACA+jD,YACAC,cAEJ,EAAA2O,EAAA,GAASlP,EAAkBd,EAAe,IAAKopC,EAAWjtF,MAAOitF,EAAW32E,IAAK,CAC7E5V,QACAQ,QACA+jD,YACAC,cAEJ,EAAA2O,EAAA,GAASlP,EAAkBd,EAAe,IAAKmuD,EAAUhyG,MAAOgyG,EAAU17F,IAAK,CAC3E5V,QACAQ,QACA+jD,YACAC,YAER,C,qEC3CA,MAAM+sD,EAAQ,6BACC,SAAStmB,EAAUhnC,EAAkBd,EAAe6nC,EAAU1rF,EAAOsW,EAAK5N,EAAU,CAAC,GAChG,GAAIoY,MAAM9gB,EAAM,KAAO8gB,MAAM9gB,EAAM,KAAO8gB,MAAMxK,EAAI,KAAOwK,MAAMxK,EAAI,IACjE,OAEJ,MAAM,UAAEs1E,GAAY,EAAK,MAAElrF,EAAQ,iBAAgB,WAAE+qF,EAAa,IAAQ/iF,EAC1E,IAAKkjF,EAED,YAiCR,SAAyBjnC,EAAkBd,EAAe6nC,EAAU1rF,EAAOsW,EAAK5N,EAAU,CAAC,GACvF,MAAM,MAAEhI,EAAQ,iBAAgB,MAAEQ,EAAQ,EAAC,UAAE+jD,EAAS,SAAEC,GAAax8C,EAC/DwpG,EAAa,GACb9wG,EAAQG,KAAKwvG,MAAMz6F,EAAI,GAAKtW,EAAM,GAAIsW,EAAI,GAAKtW,EAAM,IACrDgtF,EAAY,CACdhtF,MAAO,CACHsW,EAAI,GAAK47F,EAAa3wG,KAAKy+E,IAAI5+E,EAAQG,KAAKC,GAAK,GACjD8U,EAAI,GAAK47F,EAAa3wG,KAAK0+E,IAAI7+E,EAAQG,KAAKC,GAAK,IAErD8U,IAAKA,GAEH22E,EAAa,CACfjtF,MAAO,CACHsW,EAAI,GAAK47F,EAAa3wG,KAAKy+E,IAAI5+E,EAAQG,KAAKC,GAAK,GACjD8U,EAAI,GAAK47F,EAAa3wG,KAAK0+E,IAAI7+E,EAAQG,KAAKC,GAAK,IAErD8U,IAAKA,IAET,EAAAu9C,EAAA,GAASlP,EAAkBd,EAAe6nC,EAAU1rF,EAAOsW,EAAK,CAC5D5V,QACAQ,QACA+jD,YACAC,cAEJ,EAAA2O,EAAA,GAASlP,EAAkBd,EAAe,IAAKmpC,EAAUhtF,MAAOgtF,EAAU12E,IAAK,CAC3E5V,QACAQ,QACA+jD,YACAC,cAEJ,EAAA2O,EAAA,GAASlP,EAAkBd,EAAe,IAAKopC,EAAWjtF,MAAOitF,EAAW32E,IAAK,CAC7E5V,QACAQ,QACA+jD,YACAC,YAER,CAtEQitD,CAAgBxtD,EAAkBd,EAAe6nC,EAAU1rF,EAAOsW,EAAK5N,GAG3E,MAEM0pG,EAAe,GADA,SAASvuD,OADdc,EAAiB8qD,gBAAgB9hG,KAG3C0kG,EAAO1tD,EAAiB8qD,gBAAgB90C,cAAc,QAC5D,IAAI23C,EAAcD,EAAK13C,cAAc,IAAIy3C,KACzC,GAAKE,EAeA,CACDA,EAAYhgF,aAAa,cAAe,GAAGm5D,KAC3C6mB,EAAYhgF,aAAa,eAAgB,GAAGm5D,KAC5C,MAAM8mB,EAAYD,EAAY33C,cAAc,QACxC43C,GACAA,EAAUjgF,aAAa,OAAQ5xB,EAEvC,KAtBkB,CACd4xG,EAAc5gF,SAASg/E,gBAAgBuB,EAAO,UAC9CK,EAAYhgF,aAAa,KAAM8/E,GAC/BE,EAAYhgF,aAAa,UAAW,aACpCggF,EAAYhgF,aAAa,OAAQ,KACjCggF,EAAYhgF,aAAa,OAAQ,KACjCggF,EAAYhgF,aAAa,cAAe,GAAGm5D,KAC3C6mB,EAAYhgF,aAAa,eAAgB,GAAGm5D,KAC5C6mB,EAAYhgF,aAAa,SAAU,QACnC,MAAMigF,EAAY7gF,SAASg/E,gBAAgBuB,EAAO,QAClDM,EAAUjgF,aAAa,IAAK,yBAC5BigF,EAAUjgF,aAAa,OAAQ5xB,GAC/B4xG,EAAYlgF,YAAYmgF,GACxBF,EAAKjgF,YAAYkgF,EACrB,CASA5pG,EAAQ8pG,YAAcJ,GACtB,EAAAv+C,EAAA,GAASlP,EAAkBd,EAAe6nC,EAAU1rF,EAAOsW,EAAK5N,EACpE,C,qCCtCe,SAASg9F,EAAkB/gD,EAAkBd,EAAewB,EAAcrlD,EAAOsW,EAAK5N,EAAU,CAAC,GAC5G,MAAM,MAAEhI,EAAOQ,MAAOuxG,EAAM,UAAExtD,EAAS,SAAEC,GAAchhD,OAAOm7D,OAAO,CACjE3+D,MAAO,iBACPQ,MAAO,IACP+jD,eAAW3iD,EACX4iD,cAAU5iD,GACXoG,GACG0nG,EAAcnrD,GAAawtD,EAE3BpC,GAAc,EAAAqC,EAAA,GAAS7uD,EAAe,OAAQwB,GAC9CstD,EAAehuD,EAAiBwqD,WAAWkB,GAC3CxuG,EAAO,CAACN,KAAKa,IAAIpC,EAAM,GAAIsW,EAAI,IAAK/U,KAAKa,IAAIpC,EAAM,GAAIsW,EAAI,KAC3DpV,EAAQK,KAAK6e,IAAIpgB,EAAM,GAAKsW,EAAI,IAChCnV,EAASI,KAAK6e,IAAIpgB,EAAM,GAAKsW,EAAI,IACjCi6F,EAAa,CACf3uG,EAAG,GAAGC,EAAK,KACXC,EAAG,GAAGD,EAAK,KACXX,MAAO,GAAGA,IACVC,OAAQ,GAAGA,IACXqvG,OAAQ9vG,EACR0V,KAAM,QACN,eAAgBg6F,EAChB,mBAAoBlrD,GAExB,GAAIytD,GACA,OAA0BpC,EAAYoC,GACtChuD,EAAiBirD,eAAeS,OAE/B,CACD,MAAMuC,EAAiBlhF,SAASg/E,gBArBtB,6BAqB6C,SACvD,OAAyBH,EAAYqC,GACrCjuD,EAAiB6qD,WAAWoD,EAAgBvC,EAChD,CACJ,C,+BCpCA,IAAIh9D,E,iBACJ,SAAWA,GACPA,EAAyB,YAAI,cAC7BA,EAA4B,eAAI,iBAChCA,EAA0B,aAAI,eAC9BA,EAA0B,aAAI,eAC9BA,EAAuB,UAAI,YAC3BA,EAAkC,qBAAI,uBACtCA,EAAqB,QAAI,UACzBA,EAAuC,0BAAI,4BAC3CA,EAAyB,YAAI,aAChC,CAVD,CAUGA,IAAgBA,EAAc,CAAC,IAClC,S,+BCZA,IAAIw/D,E,iBACJ,SAAWA,GACPA,EAAU,GAAI,KACdA,EAAY,KAAI,OAChBA,EAAY,KAAI,OAChBA,EAAa,MAAI,OACpB,CALD,CAKGA,IAAUA,EAAQ,CAAC,G,2KCMtB,MAAMC,EAAgC,wCAiDtC,SAASC,EAAoCx/B,EAAU/yE,GACnD,MAAMwyG,EAAYz/B,EAASruE,OACrBymG,EAAoB,IAAI3oG,MAAMgwG,GACpC,IAAK,IAAIhlG,EAAI,EAAGA,EAAIglG,EAAWhlG,IAC3B29F,EAAkB39F,GAAKxN,EAASwjD,cAAcuvB,EAASvlE,IAE3D,OAAO29F,CACX,CA2BO,SAASsH,EAAmBzyG,EAAU0yG,EAAkBC,GAC3D,MAAQC,iBAAkB5tB,GAA2B0tB,EAAiB1hG,KAAK2gC,SACnEihE,iBAAkBC,GAAyBF,EAAe3hG,KAAK2gC,SACvE,IAAAmhE,oBAAmBJ,EAAkBC,IACrC,IAAAI,qCAAoCJ,GACpC,MAAQhhE,QAASqhE,GAAgBL,EAAe3hG,KAC1CiiG,EAAeV,EAAoCS,EAAYjgC,SAAU/yE,IAC/E,OAAsB2yG,EAAgB,CAClCpgG,OAAQ0gG,EACR1/D,OAAQy/D,EAAYz/D,QACrBvzC,GACH,MAAM,QAAEixB,GAAYjxB,EACdkzG,EAAmB,IAAIv2E,IAAI,CAC7B21E,EACAI,EAAiB1nG,SAASuxC,SAC1Bo2D,EAAe3nG,SAASuxC,WAE5B,IAAK,MAAMA,KAAY22D,EAAiBz0F,SAAU,CAC9C,MAAMkkC,GAAsB,IAAAC,gCAA+B3xB,EAASsrB,IACpE,OAAsCoG,EAC1C,CACJ,C,2NCxFkC,IAAIrtC,I,qMCjBtC,MAAM69F,EAAY,CACd,CAAC,IAAgB7uC,UAAW,KAC5B,CAAC,IAAgBi/B,SAAU,IAC3B,CAAC,IAAgBE,SAAU,MAEzB2P,EAAwB,IAAsC72D,SAiIpE,SAAS82D,EAA0BriF,GAC/BsiF,EAA4BC,+BAA+BviF,EAC/D,CAIA,MAAMsiF,EAA8B,IAtIpC,MACI,WAAA/vG,GACIO,KAAK0vG,aAAe,IAAI72E,IACxB74B,KAAK2vG,oBAAqB,EAC1B3vG,KAAK4vG,sBAAwB,KAC7B5vG,KAAK6vG,iBAAmB,KACI,IAAAntC,uBACDlkD,SAAS7E,GAAoBA,EAAgB4Z,iBAExEvzB,KAAK8vG,4BAA8B,KAC/B9vG,KAAK+vG,oBACerxG,MAAM6D,KAAKvC,KAAK0vG,cACxBzuG,SAASisB,IACjBltB,KAAKgwG,eAAe9iF,EAAW,IAEnCltB,KAAK0vG,aAAa57F,QAClB9T,KAAK2vG,oBAAqB,EAC1B3vG,KAAK4vG,sBAAwB,IAAI,CAEzC,CACA,8BAAAH,CAA+BviF,GAC3B,MAAMrT,EAAcqT,EACd,CAACA,GACDltB,KAAKiwG,iCACXjwG,KAAKkwG,mCAAmCr2F,EAC5C,CACA,kBAAAs2F,CAAmB7vC,GACf,MAAMzmD,EAAc7Z,KAAKiwG,+BAA+B3vC,GACxDtgE,KAAKkwG,mCAAmCr2F,EAC5C,CACA,8BAAAo2F,CAA+B3vC,GAC3B,MAAM1mD,EAAY5Z,KAAK6vG,mBACjBh2F,EAAc,GACpB,IAAK,MAAM3d,KAAY0d,EAAW,CAC9B,MAAMsT,EAAahxB,EAASmN,GAC5B,GAAIi3D,EAAgB,CAChB,MAAM8vC,GAA8B,QAA+BljF,EAAY,CAAEozC,mBAC7E8vC,GAA6BxvG,OAAS,GACtCiZ,EAAYlR,KAAKukB,EAEzB,KACK,CACD,MAAMkjF,GAA8B,QAA+BljF,GAC/DkjF,GAA6BxvG,OAAS,GACtCiZ,EAAYlR,KAAKukB,EAEzB,CACJ,CACA,OAAOrT,CACX,CACA,iBAAAk2F,GACI,GAAI/vG,KAAK+Z,iBACL,MAAM,IAAI3b,MAAM,uHAExB,CACA,kCAAA8xG,CAAmCr2F,GAC/BA,EAAY5Y,SAASisB,IACjBltB,KAAK0vG,aAAapsG,IAAI4pB,EAAW,IAErCltB,KAAKqwG,SACT,CACA,OAAAA,GACQrwG,KAAK0vG,aAAalnF,KAAO,IAAiC,IAA5BxoB,KAAK2vG,qBACnC3vG,KAAK4vG,sBAAwBriF,OAAO8hE,sBAAsBrvF,KAAK8vG,6BAC/D9vG,KAAK2vG,oBAAqB,EAElC,CACA,cAAAK,CAAe9iF,GACX,MAAMkjF,GAA8B,QAA+BljF,GACnE,IAAKkjF,GAA6BxvG,OAC9B,OAEJ,MAAM,SAAE1E,IAAa,IAAAmgE,+BAA8BnvC,IAAe,CAAC,EACnE,IAAKhxB,EACD,OAEJ,MAAMo0G,EAAqB,GACrBC,EAAyBH,EAA4B/pG,KAAKmqG,IACxDA,EAAe1pG,OAAS,EAAAy5D,4BAA4Bk/B,SACpDz/F,KAAKywG,+BAA+Bv0G,GAExC,MAAMs6D,EAAU64C,EAAUmB,EAAe1pG,MACzC,IACI,MAAMomB,EAAaspC,EAAQv6D,OAAOC,EAAUs0G,GAC5CF,EAAmB3nG,KAAKukB,EAC5B,CACA,MAAOvnB,GACHyK,QAAQzK,MAAMA,EAClB,CACA,OAAOd,QAAQC,QAAQ,CACnBw7D,eAAgBkwC,EAAelwC,eAC/Bx5D,KAAM0pG,EAAe1pG,MACvB,IAENjC,QAAQ6rG,WAAWH,GAAwBxrG,MAAMqhG,IAC7C,MAAMuK,EAAsBvK,EACvBtxF,QAAQkC,GAAmB,cAAbA,EAAE45F,SAChBvqG,KAAK2Q,GAAMA,EAAE/W,QAeF/D,EAASixB,QACjB1E,iBAAiB,EAAAyjB,MAAA,OAAaxc,gBAftC,SAASmhF,EAAqB54D,GAC1B,MAAM,QAAE9qB,EAAO,WAAED,GAAe+qB,EAAI3lB,OACpCnF,EAAQrE,oBAAoB,EAAAojB,MAAA,OAAaxc,eAAgBmhF,GACzDF,EAAoB1vG,SAASqxB,IACzB,MAAMvD,EAAc,CAChB7B,aACAozC,eAAgBhuC,EAAOguC,eACvBx5D,KAAMwrB,EAAOxrB,OAEjB,IAAA04B,cAAa,EAAArN,YAAa,SAAc2+E,sBAAuB,IACxD/hF,GACL,GAEV,IAGA7yB,EAASD,QAAQ,GAEzB,CACA,8BAAAw0G,CAA+Bv0G,GACrBozG,KAAyB,KAAM1iB,QACjC,QAAQ,KAEZ,MAAMD,GAAY,IAAA3mC,yBAAwB9pD,EAASmN,IAC9CsjF,EAAUokB,QAAQzB,KACnB3iB,EAAUqkB,QAAQ1B,GAClB3iB,EAAUztB,eAAeowC,GAEjC,E,oJCxIJ,MAAM2B,EAAsB,CACxBC,SAAU,GACVC,cAAe,GACfC,2BAA4B,CAAC,GAsdjCp4E,eAAeq4E,GAAuC,SAAEjrG,EAAQ,QAAEhC,IAC9D,MAAMktG,EAAuBlrG,EACvB0E,EAAW1G,GAAS0G,UAAY,qBAEtC,aADM,EAAAymG,aAAA,+BAA4CzmG,EAAUwmG,GACrD,CAAExmG,WACb,CACAkuB,eAAew4E,GAAqC,eAAElxC,EAAc,QAAEl8D,IAClE,MAAM2pF,EAAe0jB,EAAgCze,gBAAgB1yB,GAC/DpzD,EAAO6gF,EAAagF,mBACrBvyB,UACC,SAAE11D,SAAmBumG,EAAuC,CAC9DjrG,SAAU8G,EAAK9G,SACfhC,YAEJ2pF,EAAagF,mBAAmBvyB,SAAS11D,SAAWA,CACxD,CACA,SAAS4mG,EAA0B5qG,GAC/B,MAAMgQ,EAAO,mBACPa,EAAO,mBAEb,OADAA,EAAKI,SAAS,EAAG,GACbjR,IAAS,EAAAy5D,4BAA4BC,SAC9B,CACH1pD,OACAa,QAIG,CAAC,CAEhB,CACA,MAAM85F,EAAkC,IAlfzB,MACX,WAAAhyG,CAAYshB,GACR/gB,KAAK2xG,kCAAoC,IAAIngG,IAC7CxR,KAAK4xG,6BAA+B,IAAIpgG,IACxCuP,IAAQ,qBACR/gB,KAAK6nB,MAAQjoB,OAAOiyG,OAAO,sBAAkBZ,IAC7CjxG,KAAK+gB,IAAMA,CACf,CACA,QAAA+wF,GACI,OAAO9xG,KAAK6nB,KAChB,CACA,WAAAkqF,CAAYC,GACR,MAAMC,EAAW,sBAAkBjyG,KAAK6nB,OACxCmqF,EAAQC,GACRjyG,KAAK6nB,MAAQjoB,OAAOiyG,OAAOI,EAC/B,CACA,WAAAC,CAAYC,GACR,OAAOnyG,KAAK6nB,MAAMqpF,SAASiB,EAC/B,CACA,oBAAAC,GACI,OAAOpyG,KAAK6nB,MAAMqpF,SAAStwG,MAC/B,CACA,UAAAyxG,GACIryG,KAAK2xG,kCAAkC79F,QACvC9T,KAAK4xG,6BAA6B99F,QAClC9T,KAAK6nB,MAAQjoB,OAAOiyG,OAAO,sBAAkBZ,GACjD,CACA,eAAAje,CAAgB1yB,GACZ,OAAOtgE,KAAK6nB,MAAMspF,cAAczzF,MAAMqwE,GAAiBA,EAAaztB,iBAAmBA,GAC3F,CACA,kBAAAgyC,CAAmBhyC,EAAgB54C,GAC/B1nB,KAAK+xG,aAAaQ,IACd,MAAMxkB,EAAewkB,EAAWpB,cAAczzF,MAAMqwE,GAAiBA,EAAaztB,iBAAmBA,IAChGytB,EAILnuF,OAAOm7D,OAAOgzB,EAAcrmE,GAHxBtX,QAAQC,KAAK,wBAAwBiwD,+BAGL,KAExC,IAAAu/B,6BAA4Bv/B,EAChC,CACA,eAAAkyC,CAAgBzkB,GACZ,GAAI/tF,KAAKgzF,gBAAgBjF,EAAaztB,gBAClC,MAAM,IAAIliE,MAAM,wBAAwB2vF,EAAaztB,iCAEzDtgE,KAAK+xG,aAAalqF,IACd,MAAM4qF,EAAkB,sBAAkB1kB,GAC1C,GAAI0kB,EAAgB1f,mBAAmBvyB,UACnC,aAAciyC,EAAgB1f,mBAAmBvyB,YAC/C,aAAciyC,EAAgB1f,mBAAmBvyB,UAAW,CAC9D,MAAMp6D,EAAWpG,KAAK0yG,oBAAoBD,EAAgB1f,oBAC1D0f,EAAgB1f,mBACXvyB,SAASp6D,SAAWA,CAC7B,CACAyhB,EAAMspF,cAAcxoG,KAAK8pG,EAAgB,KAE7C,OAAyB1kB,EAAaztB,eAC1C,CACA,kBAAAqyC,CAAmBryC,GACftgE,KAAK+xG,aAAalqF,IACd,MAAM+qF,EAAwB/qF,EAAMspF,cAAcr8F,QAAQi5E,GAAiBA,EAAaztB,iBAAmBA,IAC3Gz4C,EAAMspF,cAAcl+F,OAAO,EAAG4U,EAAMspF,cAAcvwG,UAAWgyG,EAAsB,KAEvF,IAAAC,4BAA2BvyC,EAC/B,CACA,6BAAAwyC,CAA8B5lF,EAAYozC,EAAgBx5D,EAAMisG,GAE5D,KADuB,IAAA12C,+BAA8BnvC,GAEjD,OAE4BltB,KAAKgzG,+BAA+B9lF,EAAY,CAC5EpmB,KAAMA,EACNw5D,mBAEwB1/D,OAAS,EACjCwP,QAAQqM,MAAM,wCAAyC3V,EAAM,6BAA8BomB,EAAY,mBAAoBozC,IAG/HtgE,KAAK+xG,aAAalqF,IACTA,EAAMupF,2BAA2BlkF,KAClCrF,EAAMupF,2BAA2BlkF,GAAc,GAC/C,IAAkB+lF,+BAA+B/lF,GAAY,IAE7DpmB,IAAS,EAAAy5D,4BAA4BC,SACrCxgE,KAAKkzG,qCAAqCrrF,EAAOqF,EAAYozC,EAAgBx5D,EAAMisG,GAGnF/yG,KAAKmzG,0BAA0BtrF,EAAOqF,EAAYozC,EAAgByyC,EACtE,KAEJ,IAAAK,2CAA0ClmF,EAAYozC,EAAgBx5D,GAC1E,CACA,oCAAAosG,CAAqCrrF,EAAOqF,EAAYozC,EAAgBx5D,EAAMisG,GAC1E,MAAMhlB,EAAelmE,EAAMspF,cAAczzF,MAAMqwE,GAAiBA,EAAaztB,iBAAmBA,IAChG,IAAKytB,EACD,OAEJ,MAAMslB,EAAc,CAAC,EACrBzzG,OAAO4B,KAAKusF,EAAaulB,UAAUryG,SAASstF,IACxC8kB,EAAYrnG,OAAOuiF,IAAiB,CAChCnwB,SAAS,EACZ,IAELv2C,EAAMupF,2BAA2BlkF,GAAYvkB,KAAK,CAC9C23D,iBACAx5D,OACAq6F,QAAQ,EACR/iC,SAAS,EACTm1C,cAAeR,GAAiBQ,eAAiB,EACjDD,SAAUD,EACVl7C,OAAQ,IACDu5C,EAA0B5qG,MAC1BisG,KAGX/yG,KAAKwzG,uBAAuB3rF,EAAOqF,EAAYozC,EACnD,CACA,yBAAA6yC,CAA0BtrF,EAAOqF,EAAYozC,EAAgByyC,EAAkBrB,EAA0B,EAAAnxC,4BAA4BC,WAEjI,KADuB,IAAAnE,+BAA8BnvC,GAEjD,OAEJ,MAAM6gE,EAAe/tF,KAAKgzF,gBAAgB1yB,GAC1C,IAAKytB,EACD,OAEJ,MAAM,mBAAEgF,GAAuBhF,EAC/B,IAAKgF,EAAmBvyB,SACpB,OAAOxgE,KAAKkzG,qCAAqCrrF,EAAOqF,EAAYozC,EAAgB,EAAAC,4BAA4BC,SAAUuyC,GAE9H/yG,KAAKyzG,sCAAsCvmF,EAAYozC,GACvDtgE,KAAKkzG,qCAAqCrrF,EAAOqF,EAAYozC,EAAgB,EAAAC,4BAA4BC,SAAUuyC,EACvH,CACA,2CAAMU,CAAsCvmF,EAAYozC,GACpD,MAAMhlE,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAMyyF,EAAe/tF,KAAKgzF,gBAAgB1yB,GAC1C,IAAKytB,EACD,OAEJ,MAAMn0D,EAAiBt+B,EAAeY,oBAAoB,EAAA8mD,oBACpD,mBAAE+vC,GAAuBhF,EACzB2lB,EAA2B,aAAc3gB,EAAmBvyB,SACjDllE,EAAeY,SAC3B09B,GAAmB85E,GACnB1zG,KAAK2zG,0CAA0CzmF,EAAY6gE,EAAaztB,eAEjF,CACA,qCAAAszC,CAAsCtzC,EAAgBpkE,EAAU23G,EAAkBC,GAC9E,MAAMC,EAAmB73G,EAASqjC,oBAClC,IAAIy0E,GAA+B,EACnC,IAAK,MAAMC,KAAmBJ,EAAkB,CACpB33G,EAASg4G,oBAAoB,CAAE3tG,kBAAmB0tG,GAAmB,CAAEE,WAAW,MAEtGH,GAA+B,EAC/Bh0G,KAAK2xG,kCACAvxG,IAAIkgE,GACJpgE,IAAI6zG,EAAkBE,GAC3Bj0G,KAAKo0G,mCAAmC,CACpC9zC,iBACAyzC,mBACAE,oBAGZ,CAIA,OAHIH,GACAA,EAAe53G,EAAUokE,EAAgBuzC,GAEtCG,EACDh0G,KAAK2xG,kCACFvxG,IAAIkgE,GACJlgE,IAAI2zG,QACP/1G,CACV,CACA,yCAAA21G,CAA0CzmF,EAAYozC,GAClD,MAAMytB,EAAe/tF,KAAKgzF,gBAAgB1yB,GAC1C,IAAKytB,EACD,OAEC/tF,KAAK2xG,kCAAkCtuG,IAAIi9D,IAC5CtgE,KAAK2xG,kCAAkCzxG,IAAIogE,EAAgB,IAAI9uD,KAEnE,MAAM,mBAAEuhF,GAAuBhF,EAC/B,IAAKgF,EAAmBvyB,SACpB,OAEJ,MAAMqzC,EAAmB7zG,KAAK0yG,oBAAoB3f,GAE5C54D,GADiB,IAAAkiC,+BAA8BnvC,GAChBhxB,SACrC,OAAO8D,KAAK4zG,sCAAsCtzC,EAAgBnmC,EAAe05E,EAAkB,KACvG,CACA,6CAAAQ,CAA8CnnF,EAAYozC,GACtD,MAAMytB,EAAe/tF,KAAKgzF,gBAAgB1yB,GAC1C,IAAKytB,EACD,OAEC/tF,KAAK2xG,kCAAkCtuG,IAAIi9D,IAC5CtgE,KAAK2xG,kCAAkCzxG,IAAIogE,EAAgB,IAAI9uD,KAEnE,MAAM,mBAAEuhF,GAAuBhF,EAC/B,IAAKgF,EAAmBvyB,SACpB,OAEJ,MAAMqzC,EAAmB7zG,KAAK0yG,oBAAoB3f,GAE5C54D,GADiB,IAAAkiC,+BAA8BnvC,GAChBhxB,SACrC8D,KAAK4zG,sCAAsCtzC,EAAgBnmC,EAAe05E,GAAkB,CAAC15E,EAAemmC,EAAgBuzC,KACvG15E,EAAcxG,cACtB1yB,SAAQ,CAAC8yG,EAAkBvrG,KAChC,IAAK,MAAMyrG,KAAmBJ,EAAkB,CACpB15E,EAAc+5E,oBAAoB,CAAE3tG,kBAAmB0tG,EAAiBnK,WAAYthG,GAAS,CAAE2rG,WAAW,EAAMG,gBAAgB,MAEpJt0G,KAAK2xG,kCACAvxG,IAAIkgE,GACJpgE,IAAI6zG,EAAkBE,GAC3Bj0G,KAAKo0G,mCAAmC,CACpC9zC,iBACAyzC,mBACAE,oBAGZ,IACF,GAEV,CACA,mBAAAvB,CAAoB3f,GAChB,MAAM9B,EAAe8B,EAAmBvyB,SACxC,IAAIqzC,EACJ,GAAI5iB,EAAa7qF,SACbytG,EAAmB5iB,EACd7qF,cAEJ,IAAKytG,GACN5iB,EAAanmF,SAAU,CACvB,MAAMA,EAAWmmF,EACZnmF,SAEL+oG,EADe,EAAAviF,MAAM7M,UAAU3Z,GACL1E,QAC9B,CACA,OAAOytG,CACX,CACA,6BAAAU,CAA8BpwG,EAASm8D,GACnC,MAAMngE,EAAMH,KAAKw0G,gBAAgB,CAC7Bl0C,iBACAyzC,iBAAkB5vG,IAEtB,OAAOnE,KAAK4xG,6BAA6BxxG,IAAID,EACjD,CACA,qCAAAs0G,CAAsCvnF,EAAYozC,GAC9C,MAAMhlE,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MACMy4G,EADgBz4G,EAAeY,SACEqjC,oBACvC,OAAOv/B,KAAKu0G,8BAA8BR,EAAkBzzC,EAChE,CACA,oCAAA4yB,CAAqChmE,EAAYozC,GAC7C,MAAMhlE,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,IAAK0E,KAAK2xG,kCAAkCtuG,IAAIi9D,GAC5C,OAEJ,MACMhhC,EADgBhkC,EAAeY,SACAqjC,oBAErC,OAD4Bv/B,KAAK2xG,kCAAkCvxG,IAAIkgE,GAC5ClgE,IAAIk/B,EACnC,CACA,uCAAAo1E,CAAwCxnF,EAAYozC,GAEhD,IADqBtgE,KAAKgzF,gBAAgB1yB,GAEtC,MAAO,GAEXtgE,KAAKq0G,8CAA8CnnF,EAAYozC,GAC/D,MAAM,SAAEpkE,IAAa,IAAAmgE,+BAA8BnvC,GAC7C9mB,EAAWlK,EAASy3B,cACpBghF,EAA8C30G,KAAK2xG,kCAAkCvxG,IAAIkgE,GAC/F,OAAOl6D,EAASC,KAAKlC,GACVwwG,EAA4Cv0G,IAAI+D,IAE/D,CACA,yCAAAywG,CAA0C1nF,EAAY2nF,GAClD,MAAMC,EAAyB,GAwC/B,OAvCA90G,KAAK+xG,aAAalqF,IACd,IAAKA,EAAMupF,2BAA2BlkF,GAClC,OAEJ,MAAM6nF,EAAyBltF,EAAMupF,2BAA2BlkF,GAChE,IAAI8nF,GAA8B,EAClC,IAAKH,GACDj1G,OAAO+a,OAAOk6F,GAAWtoF,OAAOtsB,QAAoBjC,IAAViC,IAC1C60G,EAAuBnsG,QAAQosG,UACxBltF,EAAMupF,2BAA2BlkF,OAEvC,CACD,MAAM,eAAEozC,EAAc,KAAEx5D,GAAS+tG,EACjChtF,EAAMupF,2BAA2BlkF,GAC7B6nF,EAAuBjgG,QAAQ07F,IAC3B,MAAMyE,EAAgB30C,GAClBx5D,GACA0pG,EAAelwC,iBAAmBA,GAClCkwC,EAAe1pG,OAASA,GACvBw5D,IACIx5D,GACD0pG,EAAelwC,iBAAmBA,IACpCA,GAAkBx5D,GAAQ0pG,EAAe1pG,OAASA,EAOxD,OANImuG,IACAH,EAAuBnsG,KAAK6nG,GACxBA,EAAerP,SACf6T,GAA8B,KAG9BC,CAAY,IAEgC,IAAxDptF,EAAMupF,2BAA2BlkF,GAAYtsB,cACtCinB,EAAMupF,2BAA2BlkF,GAEnC8nF,IACLntF,EAAMupF,2BAA2BlkF,GAAY,GAAGi0E,QAAS,EAEjE,KAEG2T,CACX,CACA,iCAAAI,CAAkChoF,EAAY2nF,GAC1C,MAAMC,EAAyB90G,KAAK40G,0CAA0C1nF,EAAY2nF,GAC1FC,EAAuB7zG,SAASuvG,KAC5B,IAAA2E,0CAAyCjoF,EAAYsjF,EAAelwC,eAAgBkwC,EAAe1pG,KAAK,IAE5G,MAAMsuG,EAA2Bp1G,KAAKgzG,+BAA+B9lF,GAKrE,OAJIkoF,EAAyBx0G,OAAS,GAClCw0G,EAAyB,GAAGjU,SAC5B,IAAAiS,2CAA0ClmF,EAAYkoF,EAAyB,GAAG90C,eAAgB80C,EAAyB,GAAGtuG,MAE3HguG,CACX,CACA,gCAAAO,CAAiCnoF,EAAY2nF,EAAWS,GACpD,MAAMR,EAAyB90G,KAAK40G,0CAA0C1nF,EAAY2nF,GAM1F,OALKS,GACDR,EAAuB7zG,SAAQ,EAAGq/D,iBAAgBx5D,YAC9C,IAAAquG,0CAAyCjoF,EAAYozC,EAAgBx5D,EAAK,IAG3EguG,CACX,CACA,kCAAAV,EAAmC,eAAE9zC,EAAc,iBAAEyzC,EAAgB,gBAAEE,IACnE,MAAM9zG,EAAMH,KAAKw0G,gBAAgB,CAAEl0C,iBAAgByzC,qBACnD,IAAK/zG,KAAK4xG,6BAA6BvuG,IAAIlD,GAEvC,YADAH,KAAK4xG,6BAA6B1xG,IAAIC,EAAK,CAAC8zG,IAGhD,MAAMsB,EAAgBv1G,KAAK4xG,6BAA6BxxG,IAAID,GACtDq1G,EAAY92G,MAAM6D,KAAK,IAAIs2B,IAAI,IAAI08E,EAAetB,KACxDj0G,KAAK4xG,6BAA6B1xG,IAAIC,EAAKq1G,EAC/C,CACA,sBAAAhC,CAAuB3rF,EAAOqF,EAAYozC,GACtC,MAAMpkE,EAAW2rB,EAAMupF,2BAA2BlkF,GAC7ChxB,GAGLA,EAAS+E,SAAShB,IACdA,EAAMkhG,OAASlhG,EAAMqgE,iBAAmBA,CAAc,GAE9D,CACA,qBAAAm1C,CAAsBvoF,EAAYozC,GAC9BtgE,KAAK+xG,aAAalqF,IACd,MAAM3rB,EAAW2rB,EAAMupF,2BAA2BlkF,GAC7ChxB,GAGLA,EAAS+E,SAAShB,IACdA,EAAMkhG,OAASlhG,EAAMqgE,iBAAmBA,CAAc,GACxD,KAEN,IAAA8yC,2CAA0ClmF,EAAYozC,EAC1D,CACA,qBAAA8+B,CAAsBlyE,GAClB,IAAKltB,KAAK6nB,MAAMupF,2BAA2BlkF,GACvC,OAEJ,MAAMwoF,EAAe11G,KAAK6nB,MAAMupF,2BAA2BlkF,GAAYxP,MAAMi4F,GAAWA,EAAOxU,SAC/F,OAAKuU,EAGE11G,KAAKgzF,gBAAgB0iB,EAAap1C,qBAHzC,CAIJ,CACA,8BAAA0yC,CAA+B9lF,EAAY2nF,EAAY,CAAC,GACpD,MAAMe,EAA0B51G,KAAK6nB,MAAMupF,2BAA2BlkF,GACtE,OAAK0oF,EAGAf,EAAU/tG,MAAS+tG,EAAUv0C,eAG3Bs1C,EAAwB9gG,QAAQ07F,IACnC,MAAMqF,GAAYhB,EAAU/tG,MACtB0pG,EAAe1pG,OAAS+tG,EAAU/tG,KAElCgvG,GAAUjB,EAAUv0C,gBACpBkwC,EAAelwC,iBAAmBu0C,EAAUv0C,eAElD,OAAOu1C,GAAaC,CAAO,IATpBF,EAHA,EAcf,CACA,6BAAAG,CAA8B7oF,EAAY2nF,GACtC,OAAO70G,KAAKgzG,+BAA+B9lF,EAAY2nF,GAAW,EACtE,CACA,uCAAAmB,CAAwC9oF,EAAY2nF,GAChD,MAAMoB,EAAyBj2G,KAAK+1G,8BAA8B7oF,EAAY2nF,GAC9E,OAAOoB,GAAwB73C,OACnC,CACA,uCAAA83C,CAAwChpF,EAAY2nF,EAAWz2C,GAC3Dp+D,KAAK+xG,aAAalqF,IACd,MAAM+tF,EAA0B51G,KAAKgzG,+BAA+B9lF,EAAY2nF,GAC3Ee,GAGLA,EAAwB30G,SAASuvG,IAC7BA,EAAepyC,QAAUA,EACzBx+D,OAAOqpB,QAAQunF,EAAe8C,UAAUryG,SAAQ,EAAEstF,EAAc9gD,MAC5DA,EAAQ2wB,QAAUA,CAAO,GAC3B,GACJ,KAEN,IAAAg1C,2CAA0ClmF,EAAY2nF,EAAUv0C,eAAgBu0C,EAAU/tG,KAC9F,CACA,WAAAqvG,CAAYjF,EAAUiB,GAClBnyG,KAAK+xG,aAAalqF,IACVA,EAAMqpF,SAASiB,IACf/hG,QAAQC,KAAK,+CAEjBwX,EAAMqpF,SAASiB,GAAY,sBAAkBjB,EAAS,GAE9D,CACA,cAAAkF,CAAe7C,GACXvzG,KAAK+xG,aAAalqF,WACPA,EAAMqpF,SAASqC,EAAc,GAE5C,CACA,sBAAA8C,CAAuBjwG,GACnB,OAAOA,EACFC,KAAKlC,GAAYA,EAAQzD,OAAOzD,KAAKkkB,MAAuB,IAAjBhd,EAAQvD,WACnD8qB,KAAK,IACd,CACA,yCAAA4qF,GACI,OAAO12G,OAAOqpB,QAAQjpB,KAAK6nB,MAAMupF,4BAA4B/qG,KAAI,EAAE6mB,EAAYqpF,MAAqB,CAChGrpF,aACAqpF,qBAER,CACA,8CAAAC,CAA+Cl2C,GAC3C,MAAM5kC,EAAS,GAOf,OANA97B,OAAOqpB,QAAQjpB,KAAK6nB,MAAMupF,4BAA4BnwG,SAAQ,EAAEisB,EAAYupF,MACxE,MAAMC,EAAeD,EAAa3hG,QAAQ07F,GAAmBA,EAAelwC,iBAAmBA,IAC3Fo2C,EAAa91G,OAAS,GACtB86B,EAAO/yB,KAAK,CAAEukB,aAAYqpF,gBAAiBG,GAC/C,IAEGh7E,CACX,CACA,eAAA84E,EAAgB,eAAEl0C,EAAc,iBAAEyzC,IAC9B,MAAO,GAAGzzC,KAAkByzC,GAChC,GAgCiE,U,gGCjSrE,MAAM4C,EAAoB,IAzN1B,MACI,WAAAl3G,GACIO,KAAKm4D,OAAS,CACVy+C,OAAQ,CAAC,EACTzF,cAAe,CAAC,EAChB0F,eAAgB,CAAC,EAEzB,CACA,QAAAC,CAASjC,EAAWkC,GAChB,MAAM,WAAE7pF,EAAU,eAAEozC,EAAc,KAAEx5D,EAAI,aAAEynF,GAAiBsmB,EACrDmC,EAAgBh3G,KAAKi6D,SAAS46C,GACpC,IAAIoC,EAaJ,GALIA,EAPC/pF,GAAeozC,EAOAtgE,KAAKk3G,kCAAkC,IAChDF,KACAD,GACJjwG,GATa,IACTkwG,KACAD,IASNjwG,EACD,MAAM,IAAI1I,MAAM,mCAEpB,GAAI8uB,EAAY,CACPltB,KAAKm4D,OAAO0+C,eAAe3pF,KAC5BltB,KAAKm4D,OAAO0+C,eAAe3pF,GAAc,CACrCiqF,6BAA6B,EAC7BZ,gBAAiB,CAAC,IAG1B,MAAMA,EAAkBv2G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAC/D,GAAIj2C,EAAgB,CACXi2C,EAAgBj2C,KACjBi2C,EAAgBj2C,GAAkB,CAAC,GAElCi2C,EAAgBj2C,GAAgBx5D,KACjCyvG,EAAgBj2C,GAAgBx5D,GAAQ,CAAC,GAE7C,MAAMswG,EAAYb,EAAgBj2C,GAAgBx5D,QAC7B9I,IAAjBuwF,GACK6oB,EAAUC,aACXD,EAAUC,WAAa,CAAC,GAE5BD,EAAUC,WAAW9oB,GAAgB0oB,GAGrCG,EAAUE,YAAcL,CAEhC,KACK,CACD,MAAMM,EAAwB,uBACzBhB,EAAgBgB,KACjBhB,EAAgBgB,GAAyB,CAAC,GAEzChB,EAAgBgB,GAAuBzwG,KACxCyvG,EAAgBgB,GAAuBzwG,GAAQ,CAAC,GAEpDyvG,EAAgBgB,GAAuBzwG,GAAMwwG,YACzCL,CACR,CACJ,MACK,GAAI32C,EAAgB,CAChBtgE,KAAKm4D,OAAOg5C,cAAc7wC,KAC3BtgE,KAAKm4D,OAAOg5C,cAAc7wC,GAAkB,CAAC,GAE5CtgE,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,KAC3C9G,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,GAAQ,CAAC,GAEvD,MAAM0wG,EAAYx3G,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,QACvC9I,IAAjBuwF,GACKipB,EAAUH,aACXG,EAAUH,WAAa,CAAC,GAE5BG,EAAUH,WAAW9oB,GAAgB0oB,GAGrCO,EAAUF,YAAcL,CAEhC,MAEIj3G,KAAKm4D,OAAOy+C,OAAO9vG,GAAQmwG,CAEnC,CACA,iCAAAC,CAAkCH,EAAQjwG,GACtC,MAAM2wG,EAAkB,IAAKV,GAC7B,GAAIjwG,IAAS,8BAAkC05D,SAAU,CACrD,MAAMk3C,EAAiBD,EACvBC,EAAeC,wBAA0BD,EAAeE,cACxDF,EAAeG,uBAAyBH,EAAeI,aACvDJ,EAAeK,qBAAuBL,EAAeM,WACrDN,EAAeO,oBAAsBP,EAAeQ,UACpDR,EAAeS,yBAA2BT,EAAeU,cAC7D,MACK,GAAItxG,IAAS,8BAAkC24F,QAAS,CACzD,MAAM4Y,EAAgBZ,EACtBY,EAAcR,uBAAyBQ,EAAcP,aACrDO,EAAcF,yBAA2BE,EAAcD,eACvDC,EAAcC,sBAAwBD,EAAcE,YACpDF,EAAcV,wBAA0BU,EAAcT,cACtDS,EAAcN,qBAAuBM,EAAcL,WACnDK,EAAcJ,oBAAsBI,EAAcH,SACtD,CACA,OAAOT,CACX,CACA,QAAAx9C,CAAS46C,GACL,MAAM,WAAE3nF,EAAU,eAAEozC,EAAc,KAAEx5D,EAAI,aAAEynF,GAAiBsmB,EAC3D,IAAI2D,EAAgBx4G,KAAKy4G,gBAAgB3xG,GACrCqwG,GAA8B,EAoBlC,GAnBIn3G,KAAKm4D,OAAOy+C,OAAO9vG,KACnB0xG,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAOy+C,OAAO9vG,KAG1B9G,KAAKm4D,OAAOg5C,cAAc7wC,KAAkBx5D,KAC5C0xG,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,GAAMwwG,kBAElCt5G,IAAjBuwF,GACAvuF,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,GAAMuwG,aAAa9oB,KAC7DiqB,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAOg5C,cAAc7wC,GAAgBx5D,GAAMuwG,WAAW9oB,MAItErhE,GAAcltB,KAAKm4D,OAAO0+C,eAAe3pF,GAAa,CACtDiqF,EACIn3G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYiqF,4BAC3C,MAAMuB,EAAsB,uBACxB14G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBmC,KAAuB5xG,KAC9E0xG,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBmC,GAAqB5xG,GAAMwwG,cAGzFh3C,GACAtgE,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBj2C,KAAkBx5D,KACzE0xG,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBj2C,GAAgBx5D,GAAMwwG,kBAE/Dt5G,IAAjBuwF,GACAvuF,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBj2C,GAAgBx5D,GAAMuwG,aAAa9oB,KAC1FiqB,EAAgB,IACTA,KACAx4G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYqpF,gBAAgBj2C,GAAgBx5D,GAAMuwG,WAAW9oB,KAI3G,CACA,OAAOiqB,CACX,CACA,8BAAAG,CAA+BzrF,GAC3B,OAAOltB,KAAKm4D,OAAO0+C,eAAe3pF,IAAaiqF,2BACnD,CACA,8BAAAlE,CAA+B/lF,EAAYiqF,GAClCn3G,KAAKm4D,OAAO0+C,eAAe3pF,KAC5BltB,KAAKm4D,OAAO0+C,eAAe3pF,GAAc,CACrCiqF,6BAA6B,EAC7BZ,gBAAiB,CAAC,IAG1Bv2G,KAAKm4D,OAAO0+C,eAAe3pF,GAAYiqF,4BACnCA,CACR,CACA,eAAAsB,CAAgB3xG,GACZ,OAAQA,GACJ,KAAK,8BAAkC05D,SACnC,OAAO,SACX,KAAK,8BAAkCi/B,QACnC,OAAO,SACX,KAAK,8BAAkCE,QACnC,MAAO,CAAC,EACZ,QACI,MAAM,IAAIvhG,MAAM,gCAAgC0I,KAE5D,CACA,sBAAA8xG,CAAuBt4C,GACftgE,KAAKm4D,OAAOg5C,cAAc7wC,WACnBtgE,KAAKm4D,OAAOg5C,cAAc7wC,EAEzC,CACA,0BAAAu4C,GACI74G,KAAKm4D,OAAOg5C,cAAgB,CAAC,CACjC,CACA,kBAAA2H,CAAmB5rF,GACXltB,KAAKm4D,OAAO0+C,eAAe3pF,WACpBltB,KAAKm4D,OAAO0+C,eAAe3pF,EAE1C,CACA,sBAAA6rF,GACI,IAAK,MAAM7rF,KAAcltB,KAAKm4D,OAAO0+C,eAAgB,CACjD,MACMM,EADgBn3G,KAAKm4D,OAAO0+C,eAAe3pF,GACCiqF,4BAClDn3G,KAAKm4D,OAAO0+C,eAAe3pF,GAAc,CACrCiqF,8BACAZ,gBAAiB,CAAC,EAE1B,CACJ,CACA,kBAAAyC,GACIh5G,KAAK64G,6BACL74G,KAAK+4G,wBACT,CACA,cAAAE,CAAepE,GACX,MAAM,KAAE/tG,GAAS+tG,EACXnnF,EAAQ1tB,KAAKi6D,SAAS46C,GACtBla,EAAe36F,KAAKy4G,gBAAgB3xG,GAC1C,OAAQ,EAAAwlC,UAAA,UAAoB5e,EAAOitE,EACvC,E,iICzNJ,SAAS,EAAsBztE,GAC3B,OAAO,OAAuBA,EAClC,CACA,SAAS,EAAsBA,EAAYozC,ICJpC,SAA+BpzC,EAAYozC,GACb,KACRm1C,sBAAsBvoF,EAAYozC,EAC/D,CDEI,CAAuBpzC,EAAYozC,EACvC,C,+FEHO,SAAS61C,EAAYjF,EAAU1oG,GAClC,MAAM0wG,EAA2B,KAC3BC,EAAa3wG,IAAS,SAC5B,IAAI4wG,EAAgB,IAAIlI,GAWxB,GAVK,EAAA5kE,UAAA,QAAkB8sE,EAAc,GAAI,CAAC,EAAG,EAAG,EAAG,MAC/ChpG,QAAQC,KAAK,uHACb+oG,EAAgB,CAAC,CAAC,EAAG,EAAG,EAAG,MAAOA,IAEtCA,EAAgBA,EAAc/yG,KAAKjK,GACV,IAAjBA,EAAMwE,OACC,CAACxE,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAI,KAEnCA,IAEPg9G,EAAcx4G,OAAS,IAAK,CAC5B,MAAMy4G,EAAmB,IAAsB34G,MAAM04G,EAAcx4G,QACnEw4G,EAAgB,IAAIA,KAAkBC,EAC1C,CAEA,OADAH,EAAyB/C,YAAYiD,EAAeD,GAC7CA,CACX,C,yECtBO,SAAS94C,EAA+BnzC,EAAYosF,GACvDA,EAAuBjzG,KAAKkzG,IACjB,OAAsCrsF,EAAYqsF,IAEjE,C,gGCgEA,QApEA,SAAoCA,GAChC,MAAM,eAAEj5C,EAAc,eAAEkwC,EAAc,OAAEr4C,GAAWohD,GAC7C,KAAEzyG,EAAMoG,KAAMssG,GAAchJ,EAC5BtjG,EAAOssG,EAAY,IAAKA,GAAc,CAAC,EAC7C,IAAKtsG,EACD,MAAM,IAAI9O,MAAM,yDAmBxB,IAA8Bq7G,EAjBtB3yG,IAAS,EAAAy5D,4BAA4Bk/B,WAiBfga,EAhBDvsG,GAiBbwsG,YAAcD,EAAYC,aAAe,GACrDD,EAAYE,kBAAoBF,EAAYE,mBAAqB,IAAInoG,KAhBrE,MAAMooG,EAkBV,SAA2BC,EAAgB/yG,EAAMoG,GAC7C,MAAM0sG,EAAqB,CAAC,EACxBC,EACAj6G,OAAOqpB,QAAQ4wF,GAAgB54G,SAAQ,EAAEstF,EAAc9gD,MACnDmsE,EAAmBrrB,GAAgB,CAC/BA,aAAcviF,OAAOuiF,GACrB58D,MAAO8b,EAAQ9b,OAAS,WAAW48D,IACnC9N,OAAQhzC,EAAQgzC,SAAU,EAC1B7hC,YAAanR,EAAQmR,aAAe,CAAC,EACrCuiD,OAAQ1zD,EAAQ0zD,SAAU,EAC7B,IAGAr6F,IAAS,EAAAy5D,4BAA4Bo/B,QAQlD,SAAkCia,EAAoBE,GAClD,MAAM,YAAEJ,GAAgBI,EACxBJ,GAAaz4G,SAAS84G,IAClB,MAAMC,EAAW,EAAA1oF,MAAM2oF,YAAYF,GACnC,GAAIC,GAAU9sG,KAAM,CAChB,MAAM,aAAEqhF,GAAiByrB,EAAS9sG,KAClC0sG,EAAmBrrB,GAAgB,CAAEA,eACzC,IAER,CAhBQ2rB,CAAyBN,EAAoB1sG,GAG7C0sG,EAAmB,GAehB,CACHrrB,aAAc,EACd58D,MAAO,YACP8uD,QAAQ,EACR7hC,YAAa,CAAC,EACduiD,QAAQ,GAlBZ,OAAOyY,CACX,CAtC+BO,CAAkBhiD,GAAQm7C,SAAUxsG,EAAMoG,GAErE,cADOirD,GAAQm7C,SACR,CACHhzC,iBACA3uC,MAAOwmC,GAAQxmC,OAAS,KACxBitB,YAAauZ,GAAQvZ,aAAe,CAAC,EACrC00D,SAAUsG,EACV7mB,mBAAoB,CAChB,CAACjsF,GAAO,IACDoG,IAInB,ECtBO,SAASktG,EAAiBd,EAAwB5qF,GACrD,MAAMwqF,EAA2B,KACjCI,EAAuBr4G,SAASs4G,IAC5B,MAAMxrB,EAAe,EAA2BwrB,GAChDL,EAAyB1G,gBAAgBzkB,GACpCr/D,IACD,IAAAmxE,6BAA4B9R,EAAaztB,eAC7C,GAER,C,wLCRA,SAAS61C,EAAYjF,EAAUqC,GAC3B,IAAKrC,EACD,MAAM,IAAI9yG,MAAM,qCAEpB,OAAO,OAAa8yG,EAAUqC,EAClC,CACA,SAAS8G,EAAYntF,EAAYozC,EAAgBg6C,GAC7C,KAAK,OAAaA,GACd,MAAM,IAAIl8G,MAAM,mDAAmDk8G,KAEvE,MAAMlK,GAA8B,QAA+BljF,EAAY,CAAEozC,mBACjF,IAAK8vC,EACD,MAAM,IAAIhyG,MAAM,wCAAwC8uB,oBAE5DkjF,EAA4BnvG,SAASs5G,IACjCA,EAA2BhH,cAAgB+G,CAAc,KAE7D,IAAAlH,2CAA0ClmF,EAAYozC,EAC1D,CACA,SAAS0/B,EAAqB9yE,EAAYozC,EAAgBiuB,GACtD,MAAMgoB,GAAkB,QAA+BrpF,EAAY,CAC/DozC,mBAEJ,IAAKi2C,GAA8C,IAA3BA,EAAgB31G,OACpC,OAAO,KAEX,MAAM4vG,EAAiB+F,EAAgB,IACjC,cAAEhD,GAAkB/C,EACpBU,GAAW,OAAaqC,GAC9B,IAAIiH,EAAatJ,EAAS3iB,GAC1B,IAAKisB,EAAY,CACb,GAA4B,iBAAjBjsB,EAEP,OADAn+E,QAAQC,KAAK,qCAAqCk+E,KAC3C,KAEXisB,EAAatJ,EAAS3iB,GAAgB,CAAC,EAAG,EAAG,EAAG,EACpD,CACA,OAAOisB,CACX,CACA,SAASC,EAAqBvtF,EAAYozC,EAAgBiuB,EAAcnyF,GACpE,MAAMs+G,EAAiB1a,EAAqB9yE,EAAYozC,EAAgBiuB,GACxE,IAAK,IAAI7kF,EAAI,EAAGA,EAAItN,EAAMwE,OAAQ8I,IAC9BgxG,EAAehxG,GAAKtN,EAAMsN,IAE9B,IAAA0pG,2CAA0ClmF,EAAYozC,EAC1D,C,qFC9CO,SAAS23B,EAAgC33B,EAAgBq6C,EAAqBpsB,GACjF,MAAMx/D,EAAc,CAChBuxC,iBACAq6C,sBACApsB,iBAEJ,QAAqBjuB,IACrB,IAAA9gC,cAAa,EAAArN,YAAa,EAAA1C,OAAOmrF,2BAA4B7rF,EACjE,C,+DCVO,SAASqwE,EAAsBlyE,GAElC,OADiC,KACDkyE,sBAAsBlyE,EAC1D,C,kFCHO,SAAS8lF,EAA+B9lF,EAAY2nF,EAAY,CAAC,GAEpE,OADiC,KACD7B,+BAA+B9lF,EAAY2nF,EAC/E,CACO,SAASkB,EAA8B7oF,EAAY2nF,GACtD,MAAMqE,EAA2B,KACjC,IAAKrE,EAAUv0C,iBAAmBu0C,EAAU/tG,KACxC,MAAM,IAAI1I,MAAM,+GAEpB,MAAMm4G,EAAkB2C,EAAyBlG,+BAA+B9lF,EAAY2nF,GAC5F,OAAO0B,IAAkB,EAC7B,CACO,SAASC,EAA+Cl2C,GAE3D,OADiC,KACDk2C,+CAA+Cl2C,EACnF,C,+DCfO,SAAS01C,EAAwC9oF,EAAY2nF,GAEhE,OADiC,KACDmB,wCAAwC9oF,EAAY2nF,EACxF,C,+DCHO,SAASgG,IAGZ,OAFiC,KACM/I,WAC1BX,aACjB,C,0ECHO,SAAS2J,EAAyB5tF,EAAYpmB,GAWjD,OAViC,KACMgrG,WACDV,2BAA2BlkF,GACnB7mB,KAAKmqG,IAC3C1pG,GAAQ0pG,EAAe1pG,MAChB,OAAgB0pG,EAAelwC,mBAIFxrD,QAAQi5E,QAAkC/vF,IAAjB+vF,GAEzE,C,qFCPO,SAASgtB,GAA6B,eAAEz6C,EAAc,QAAEl8D,IAC3D,MAAM2pF,GAAe,OAAgBztB,GACrC,IAAKytB,EACD,OAEJ,MAAM,SAAEjjF,GAAaijF,EAAagF,mBAC7BvyB,SACCw6C,EAAqB,EAAA1pF,MAAM7M,UAAU3Z,GAC3C,OAAO,OAA6B,CAChCw1D,iBACApzC,WAAY9oB,EAAQ8oB,WACpB9mB,SAAU40G,EAAmB50G,SAC7BhC,WAER,C,8DCpBO40B,eAAeiiF,EAA+BnV,GACjD,OAAO,QAAuCA,EAClD,C,2eCsBgC,IACE,IACF,G,0ECIhC,QA7BA,UAAuC,eAAExlC,EAAc,KAAEx5D,EAAI,KAAEoG,IAC3D,MAAM6gF,GAAe,OAAgBztB,GACrC,IAAKytB,EACD,MAAM,IAAI3vF,MAAM,gBAAgBkiE,eAKpC,OAHIytB,EAAagF,mBAAmBjsF,IAChCsJ,QAAQC,KAAK,+BAA+BvJ,qCAAwCw5D,sBAEhFx5D,GACJ,KAAK,IAA4B05D,SAMjC,KAAK,IAA4Bi/B,QAKjC,KAAK,IAA4BE,QACzBzyF,IACA6gF,EAAagF,mBAAmBjsF,GAAQoG,GAE5C,MACJ,QACI,MAAM,IAAI9O,MAAM,+BAA+B0I,KAE3D,C,yICtBA,SAASo0G,EAAsChuF,EAAYiuF,GACvD,MAAM,eAAE76C,EAAc,OAAEnI,GAAWgjD,EAC7BpI,EAAkB,CACpBQ,cAAe6H,EAAiBjjD,MAC7BA,GAEP,KAAgC26C,8BAA8B5lF,EAAYozC,EAAgB66C,EAAoBr0G,KAAMisG,GAChHoI,EAAoBr0G,OAAS,EAAAy5D,4BAA4Bk/B,UACzD,IAAAz4D,GAAsC,CAAC9Z,KAE3C,IAAA2yE,6BAA4Bv/B,EAChC,CACA,SAAS86C,EAAiBjjD,GACtB,MAAM,gBAAEkjD,GAAoBljD,GAAU,CAAC,EACvC,QAAwBn6D,IAApBq9G,EAA+B,CAE/B,OADc,OAAYr/E,KAAKs/E,MAAMt/E,KAAKC,UAAU,MAExD,CACA,GAA+B,iBAApBo/E,EACP,OAAOA,EAEX,GAAI38G,MAAMC,QAAQ08G,IACdA,EAAgB9uF,OAAOpX,GAASzW,MAAMC,QAAQwW,IAAyB,IAAhBA,EAAKvU,SAAe,CAE3E,OADc,OAAYy6G,EAE9B,CAEA,OADc,OAAYr/E,KAAKs/E,MAAMt/E,KAAKC,UAAU,MAExD,C,6FCjCO,SAAS02E,EAAmBryC,GAC/B,MAAM44C,EAA2B,KACCA,EAC7B5C,4CACAxhG,QAAO,EAAGyhG,qBAAsBA,EAAgBtvF,MAAMs0F,GAAQA,EAAIj7C,iBAAmBA,MACrFj6D,KAAI,EAAG6mB,gBAAiBA,IACHjsB,SAASisB,KAC/B,QAAkCA,EAAY,CAAEozC,kBAAiB,IAErE44C,EAAyBvG,mBAAmBryC,IAC5C,IAAAuyC,4BAA2BvyC,EAC/B,CACO,SAASk7C,IACZ,MAAMtC,EAA2B,KACXA,EAAyBpH,WAAWX,cACpB9qG,KAAK0nF,GAAiBA,EAAaztB,iBACzDr/D,SAASq/D,IACrBqyC,EAAmBryC,EAAe,IAEtC44C,EAAyB7G,YAC7B,C,6KChBA,SAASgD,EAAiCnoF,EAAY2nF,EAAW4G,GAC7D,OAAOC,EAAmCxuF,EAAY2nF,EAAW4G,EACrE,CACA,SAASvG,EAAkChoF,EAAY2nF,EAAW4G,GAC9D,OAAOC,EAAmCxuF,EAAY2nF,EAAW4G,EACrE,CACA,SAASC,EAAmCxuF,EAAY2nF,EAAW4G,GAC/D,MAAM,eAAEn7C,EAAc,KAAEx5D,GAAS+tG,EAEjC,OAmCJ,SAAqC3nF,EAAYozC,EAAgBx5D,EAAM20G,GACnE,MAAMlF,GAAkB,EAAAR,EAAA,IAA+B7oF,EAAY,CAC/DozC,iBACAx5D,SAEJyvG,EAAgBt1G,SAASuvG,IACjBA,EAAe1pG,OAASy5D,EAAA,EAA4BC,SACpDm7C,EAAA,wBAAqCzuF,EAAYsjF,EAAelwC,eAAgBm7C,GAE3EjL,EAAe1pG,OAASy5D,EAAA,EAA4Bk/B,QACzDmc,EAAA,EAAeC,qBAAqB3uF,EAAYsjF,EAAelwC,eAAgBm7C,GAE1EjL,EAAe1pG,OAASy5D,EAAA,EAA4Bo/B,SACzDmc,EAAA,GAAeD,qBAAqB3uF,EAAYsjF,EAAelwC,eAAgBm7C,EACnF,IAEJ,MAAM,SAAEv/G,IAAa,IAAAmgE,+BAA8BnvC,IAAe,CAAC,EAC/DhxB,GACAA,EAASD,QAEjB,CAxDI8/G,CAA4B7uF,EAAYozC,EAAgBx5D,EAAM20G,GACvD,KAAgCvG,kCAAkChoF,EAAY,CACjFozC,iBACAx5D,QAER,CACA,SAASk1G,IACS,KAAgC1F,4CACxCr1G,SAAQ,EAAGisB,aAAYqpF,sBACzBA,EAAgBt1G,SAAQ,EAAGq/D,iBAAgBx5D,WACvCuuG,EAAiCnoF,EAAY,CACzCozC,iBACAx5D,QACF,GACJ,IAEN,KAAgCurG,YACpC,CACA,SAAS4J,EAA6B/uF,EAAYozC,EAAgBm7C,GAC9DpG,EAAiCnoF,EAAY,CACzCozC,iBACAx5D,KAAMy5D,EAAA,EAA4BC,UACnCi7C,EACP,CACA,SAASS,EAA4BhvF,EAAYozC,EAAgBm7C,GAC7DpG,EAAiCnoF,EAAY,CACzCozC,iBACAx5D,KAAMy5D,EAAA,EAA4Bk/B,SACnCgc,EACP,CACA,SAASU,EAA4BjvF,EAAYozC,EAAgBm7C,GAC7DpG,EAAiCnoF,EAAY,CACzCozC,iBACAx5D,KAAMy5D,EAAA,EAA4Bo/B,SACnC8b,EACP,C,yLC3CA,SAAS7b,EAAsBt/B,EAAgBiuB,GAC3C,MAAMR,GAAe,OAAgBztB,GACT,iBAAjBiuB,IACPn+E,QAAQC,KAAK,kDACbk+E,EAAeviF,OAAOuiF,IAE1B3uF,OAAO+a,OAAOozE,EAAaulB,UAAUryG,SAASwsC,IAC1CA,EAAQ0zD,QAAS,CAAK,IAErBpT,EAAaulB,SAAS/kB,KACvBR,EAAaulB,SAAS/kB,GAAgB,CAClCA,eACA58D,MAAO,GACP8uD,QAAQ,EACR7hC,YAAa,CAAC,EACduiD,QAAQ,KAGmC,IAA/CpT,EAAaulB,SAAS/kB,GAAc4S,SACpCpT,EAAaulB,SAAS/kB,GAAc4S,QAAS,GAC7C,IAAAtB,6BAA4Bv/B,IAEhC,MAAMzmD,GAAc,OAA+BymD,GACnDzmD,EAAY5Y,SAASisB,KACO,QAA+BA,EAAY,CAC/DozC,mBAEYr/D,SAASuvG,IAChBA,EAAe8C,SAAS/kB,KACzBiiB,EAAe8C,SAAS/kB,GAAgB,CACpCnwB,SAAS,GAEjB,GACF,IAENvkD,EAAY5Y,SAASisB,IACjB,MAAMy/D,GAAY,IAAA3mC,yBAAwB94B,IAC1C,OAAsBy/D,EAAUtjF,GAAG,GAE3C,C,8JC5CA,SAAS+yG,EAAqB97C,EAAgBiuB,GAC1C,MAAMR,GAAe,OAAgBztB,GACrC,IAAKytB,EACD,MAAM,IAAI3vF,MAAM,mCAAmCkiE,KAEvD,MAAM,SAAEgzC,GAAavlB,EACrB,OAAOulB,EAAS/kB,GAAc9N,MAClC,CACA,SAAS47B,EAAsB/7C,EAAgBiuB,EAAc9N,GAAS,GAClE,MAAMsN,GAAe,OAAgBztB,GACrC,IAAKytB,EACD,MAAM,IAAI3vF,MAAM,mCAAmCkiE,KAEvD,MAAM,SAAEgzC,GAAavlB,EACrBulB,EAAS/kB,GAAc9N,OAASA,GAChC,IAAAof,6BAA4Bv/B,EAChC,CACA,SAASg8C,EAAwBh8C,GAC7B,MAAMytB,GAAe,OAAgBztB,GACrC,IAAKytB,EACD,MAAM,IAAI3vF,MAAM,mCAAmCkiE,KAEvD,MAAM,SAAEgzC,GAAavlB,EAErB,OAD6BnuF,OAAO4B,KAAK8xG,GAAUx+F,QAAQy5E,GAAiB+kB,EAAS/kB,GAAc9N,SACvEp6E,KAAKkoF,GAAiB3yD,SAAS2yD,IAC/D,C,q9BC1BO,SAAS6nB,EAAe7C,GACM,KACR6C,eAAe7C,EAC5C,C,gDCHO,SAASmB,EAAwCxnF,EAAYozC,GAEhE,OADiC,KACDo0C,wCAAwCxnF,EAAYozC,EACxF,C,eCYA,SAASi8C,IACL,KAAgClK,YACpC,C,+DCjBO,SAASsB,EAA0CzmF,EAAYozC,GAElE,OADiC,KACDqzC,0CAA0CzmF,EAAYozC,EAC1F,C,0ECaA,QAfA,SAAiCpzC,EAAYhB,GACpCA,IACDA,GAAoB,IAAAw2C,uBAAsBhlD,MAAM8+F,GAAOA,EAAGjpF,eAAe7V,MAAM4H,GAAOA,EAAGjc,KAAO6jB,OAAc7jB,IAElH,MAAMozG,EAAyB,KAAM37C,WAAWhsD,QAAQ4nG,GAAOA,EAAGjjE,cAAcxyB,MAAM3B,GAAOA,EAAG4G,oBAAsBA,KAChH5G,EAAG4H,YAAc5H,EAAG4H,aAAeA,OACzC,GAAKuvF,EAAuB77G,OAA5B,CAGA,GAAI67G,EAAuB77G,OAAS,EAChC,MAAM,IAAIxC,MAAM,qDAAqD8tB,qBAAqCgB,oFAG9G,OAAOuvF,EAAuB,EAL9B,CAMJ,C,gDChBA,IAAIzR,EAAe,CAAC,EAIpB,S,yOCaA,MAAM,sBAAElpE,GAA0B,YAClC,MAAMi+D,UAA0B,YACnB//F,KAAKy4C,SAAW,eAAiB,CAC1C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACXu7D,2BAA2B,EAC3BgM,aAAcC,KAGlB78B,MAAMS,EAAWC,GACjB93C,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QACxB,IAAIw1B,EAAej4E,EAASwjD,cAAcjxC,EAAO,IAC7C2lE,EAAel4E,EAASwjD,cAAcjxC,EAAO,IAC7CwgD,EAAO,CACPvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAGpBvhC,EAAkB,kBAA4B,CAACoc,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACzI,OAAIjX,GAAmBkX,IAGvBoqB,EAAej4E,EAASwjD,cAAcjxC,EAAO,IAC7C2lE,EAAel4E,EAASwjD,cAAcjxC,EAAO,IAC7CwgD,EAAO,CACHvzD,MAAO,CACH4B,EAAG62E,EAAa,GAChB32E,EAAG22E,EAAa,IAEpBniE,IAAK,CACD1U,EAAG82E,EAAa,GAChB52E,EAAG42E,EAAa,KAGxBvhC,EAAkB,kBAA4B,CAACoc,EAAKvzD,MAAM4B,EAAG2xD,EAAKvzD,MAAM8B,GAAI,CAACyxD,EAAKj9C,IAAI1U,EAAG2xD,EAAKj9C,IAAIxU,GAAI,CAACssD,EAAa,GAAIA,EAAa,KACjIjX,GAAmBkX,EAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,OAAsCujD,IACtC,IAAAI,mBAAkB9xB,GAClB8qB,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACd7hB,EAAO0hC,EAAW1hC,KACxB0hC,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,gBACzE,IAAAO,mBAAkB9xB,GAClBntB,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,GACrB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,OAAsCujD,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACjB,GAAI4qB,IAAkBE,EAClB,OAEJ15D,KAAKkzE,eACLhmE,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,IAAAmyB,oBAAmBnyB,GACnB,MAAM,gBAAExT,IAAoB,IAAAue,mBAAkB/K,GAC9C,QAAkCnvB,IAA9BgC,KAAK++C,SAASwa,YAA2B,CACzC,MAAM,OAAE9qD,GAAWvB,EAAKyxC,QAClBg+D,EAAyB,cAAcluG,EAAO,GAAIA,EAAO,IAE/D,GADgC,cAAcA,EAAO,GAAIA,EAAO,IAClCkuG,EAAwB,CAClD,MAAMC,EAAW,CAAC,IAAInuG,EAAO,IAAK,IAAIA,EAAO,KACvCouG,EAAkB,IAAIpuG,EAAO,IAC7BquG,EAAkB,IAAIruG,EAAO,IAC7BsuG,EAAiB,cACvB,SAASA,EAAgBH,EAAS,GAAG,GAAKA,EAAS,GAAG,GAAIA,EAAS,GAAG,GAAKA,EAAS,GAAG,IACvF,MAAMI,EAA0C,cAChD,SAASA,GAA0CD,EAAe,GAAIA,EAAe,IACrF,MAAME,EAAyB,cAE/B,IAAIC,EADJ,SAASD,EAAwBH,EAAgB,GAAKD,EAAgB,GAAIC,EAAgB,GAAKD,EAAgB,IAG3GK,EADA,SAASD,EAAwBD,GAA2C,EAChE,CAACH,EAAiBC,GAGlB,CAACA,EAAiBD,GAElC3vG,EAAKyxC,QAAQlwC,OAAS,CAClBmuG,EAAS,GACTA,EAAS,GACTM,EAAU,GACVA,EAAU,GAElB,CACJ,CACIl9G,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,IAAAtgB,kBAAiB9Y,EAAW2Q,gBAEhC,OAAsCV,GAClC2a,IACA,IAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,CAAK,EAE1Bt+C,KAAKy5D,kBAAqBxhB,IACtBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAEokD,GAAkBxjD,GACpB,WAAE0yC,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAEC,GAAkBx5D,KAAK++C,SAC7E/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACXpvB,EAAWs7B,EAAcxC,MAC/BprC,EAAKyxC,QAAQlwC,OAAO8qD,GAAe,IAAI/5C,GACvC,MAAM29F,EAAoBjwG,EAAKyxC,QAAQlwC,OAAOpI,IAAIq5C,GAC5CoK,EACe,CACbpuD,MAAO,CACH4B,EAAG6/G,EAAkB,GAAG,GACxB3/G,EAAG2/G,EAAkB,GAAG,IAE5BnrG,IAAK,CACD1U,EAAG6/G,EAAkB,GAAG,GACxB3/G,EAAG2/G,EAAkB,GAAG,KAe9BC,GAVSD,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAGrBA,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAIvB,cAAcA,EAAkB,GAAIA,EAAkB,IAC5B,GACjCz6F,EAAKonC,EAA6BpuD,MAAM4B,EAAIwsD,EAA6B93C,IAAI1U,EAC7EqlB,EAAKmnC,EAA6BpuD,MAAM8B,EAAIssD,EAA6B93C,IAAIxU,EAC7EoD,EAAS3D,KAAKwmC,KAAK/gB,EAAKA,EAAKC,EAAKA,GAClC06F,EAAU36F,EAAK9hB,EACf08G,EAAU36F,EAAK/hB,EACf28G,GAAQzzD,EAA6BpuD,MAAM4B,EAC7CwsD,EAA6B93C,IAAI1U,GACjC,EACEkgH,GAAQ1zD,EAA6BpuD,MAAM8B,EAC7CssD,EAA6B93C,IAAIxU,GACjC,EACEigH,EAASF,EAAOH,EAA0BE,EAC1CI,EAASF,EAAOJ,EAA0BC,EAC1CM,EAAOJ,EAAOH,EAA0BE,EACxCM,EAAOJ,EAAOJ,EAA0BC,EAC9CnwG,EAAKyxC,QAAQlwC,OAAO,GAAKvS,EAASkzB,cAAc,CAACquF,EAAQC,IACzDxwG,EAAKyxC,QAAQlwC,OAAO,GAAKvS,EAASkzB,cAAc,CAACuuF,EAAMC,IACvDhvE,EAAWrzC,aAAc,GACzB,OAAsCsjD,IACtC,IAAA/P,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,gBAC3D/uE,KAAK++C,SAAS2a,UAAW,CAAI,EAEjC15D,KAAK25D,oBAAuB1hB,IACxBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,MACnBprC,EAAKyxC,QAAQlwC,OACrBxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,MAEIyE,KAAK69G,kBAAkB5lE,GACvBrJ,EAAWrzC,aAAc,GAE7B,OAAsCsjD,GAClCjQ,EAAWrzC,cACX,IAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAK69G,kBAAqB5lE,IACtB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,WAAEszC,EAAY2qB,YAAaukD,GAAsB99G,KAAK++C,UACtD,KAAE7xC,GAAS0hC,EACXpvB,EAAWs7B,EAAcxC,MACzBylE,EAA4B,CAC9B7hH,EAASwjD,cAAcxyC,EAAKyxC,QAAQlwC,OAAO,IAC3CvS,EAASwjD,cAAcxyC,EAAKyxC,QAAQlwC,OAAO,IAC3CvS,EAASwjD,cAAcxyC,EAAKyxC,QAAQlwC,OAAO,IAC3CvS,EAASwjD,cAAcxyC,EAAKyxC,QAAQlwC,OAAO,KAEzCuvG,EAAmB,CACrBtiH,MAAO,CACH4B,EAAGygH,EAA0B,GAAG,GAChCvgH,EAAGugH,EAA0B,GAAG,IAEpC/rG,IAAK,CACD1U,EAAGygH,EAA0B,GAAG,GAChCvgH,EAAGugH,EAA0B,GAAG,KAGlCE,EAAoB,CACtBviH,MAAO,CACH4B,EAAGygH,EAA0B,GAAG,GAChCvgH,EAAGugH,EAA0B,GAAG,IAEpC/rG,IAAK,CACD1U,EAAGygH,EAA0B,GAAG,GAChCvgH,EAAGugH,EAA0B,GAAG,KAGlCG,EAAgB,IAAI1+F,GACpB2+F,EAAsBjiH,EAASwjD,cAAcw+D,GACnD,GAA0B,IAAtBJ,GAAiD,IAAtBA,EAAyB,CACpD,MACMM,EAAyBL,EADgB,IAAtBD,EAA0B,EAAI,GAEjDO,EAAgC,SAAS,cAAeF,EAAoB,GAAKC,EAAuB,GAAID,EAAoB,GAAKC,EAAuB,IAC5JE,EAA2B,SAAS,cAAeP,EAA0BD,GAAmB,GAClGM,EAAuB,GAAIL,EAA0BD,GAAmB,GACxEM,EAAuB,IAC3B,eAAeC,EAA+BA,GAC9C,eAAeC,EAA0BA,GACzC,MAAMC,EAA2B,CAC7B7iH,MAAO,CACH4B,EAAG8gH,EAAuB,GAC1B5gH,EAAG4gH,EAAuB,IAE9BpsG,IAAK,CACD1U,EAAG6gH,EAAoB,GACvB3gH,EAAG2gH,EAAoB,KAG/B,GAAIn+G,KAAKw+G,0CAA0CD,EAA0BN,GACzE,OAEJ,MAAMQ,EAAmBL,EACnBthH,EAAQkD,KAAK0+G,gBAAgBJ,EAA0BD,GAC7D,IAAIM,EAAcZ,EAA0B,GAAG,GAC3Ca,EAAcb,EAA0B,GAAG,GAC3Cc,EAAed,EAA0B,GAAG,GAC5Ce,EAAef,EAA0B,GAAG,GAChDY,GAAeF,EAAiB,GAChCG,GAAeH,EAAiB,GAChCI,GAAgBJ,EAAiB,GACjCK,GAAgBL,EAAiB,GACjC,MAAMM,EAAoBJ,EAAc1hH,KAAKy+E,IAAI5+E,GAAS8hH,EAAc3hH,KAAK0+E,IAAI7+E,GAC3EkiH,EAAqBL,EAAc1hH,KAAK0+E,IAAI7+E,GAAS8hH,EAAc3hH,KAAKy+E,IAAI5+E,GAC5EmiH,EAAqBJ,EAAe5hH,KAAKy+E,IAAI5+E,GAASgiH,EAAe7hH,KAAK0+E,IAAI7+E,GAC9EoiH,EAAsBL,EAAe5hH,KAAK0+E,IAAI7+E,GAASgiH,EAAe7hH,KAAKy+E,IAAI5+E,GACrF6hH,EAAcI,EAAoBN,EAAiB,GACnDG,EAAcI,EAAqBP,EAAiB,GACpDI,EAAeI,EAAqBR,EAAiB,GACrDK,EAAeI,EAAsBT,EAAiB,GACtD,MAAMU,EAAgBjjH,EAASkzB,cAAc,CAACuvF,EAAaC,IACrDQ,EAAiBljH,EAASkzB,cAAc,CAC1CyvF,EACAC,IAEJ5xG,EAAKyxC,QAAQlwC,OAAOqvG,GAAqBI,EACzChxG,EAAKyxC,QAAQlwC,OAAO,GAAK0wG,EACzBjyG,EAAKyxC,QAAQlwC,OAAO,GAAK2wG,CAC7B,KACK,CACD,MAAMC,EAA6C,IAAtBvB,EAA0B,EAAI,EACrDwB,EAAsB,CACxBC,gBAAiB,CACb7jH,MAAOsiH,EAAiBtiH,MACxBsW,IAAKgsG,EAAiBhsG,KAE1BwtG,iBAAkB,CACd9jH,MAAOuiH,EAAkBviH,MACzBsW,IAAKisG,EAAkBjsG,MAGzBytG,EAAqB,cAAc,cAAe,CACpDH,EAAoBC,gBAAgBvtG,IAAI1U,EACxCgiH,EAAoBC,gBAAgBvtG,IAAIxU,GACzC,CACC8hH,EAAoBC,gBAAgB7jH,MAAM4B,EAC1CgiH,EAAoBC,gBAAgB7jH,MAAM8B,IAExCkiH,EAA+B,eAAe,cAAeD,GAC7DE,EAAuB,cAAc,cAAe,CAACxB,EAAoB,GAAIA,EAAoB,IAAK,CACxGJ,EAA0BD,GAAmB,GAC7CC,EAA0BD,GAAmB,KAE3C8B,EAAiB,YAAYD,GAC7B7iH,EAAQkD,KAAK0+G,gBAAgBgB,EAA8BC,GAC3DE,EAAiC5iH,KAAKy+E,IAAI5+E,GAAS8iH,EACnDE,EAAqB,iBAAiB,cAAe,CACvD/B,EAA0BsB,GAAsB,GAChDtB,EAA0BsB,GAAsB,IACjDK,EAA8BG,GACjC,GAAI7/G,KAAKw+G,0CAA0C,CAC/C9iH,MAAO,CACH4B,EAAG6gH,EAAoB,GACvB3gH,EAAG2gH,EAAoB,IAE3BnsG,IAAK,CACD1U,EAAGwiH,EAAmB,GACtBtiH,EAAGsiH,EAAmB,KAE3B,CACCpkH,MAAO,CACH4B,EAAGgiH,EAAoBC,gBAAgB7jH,MAAM4B,EAC7CE,EAAG8hH,EAAoBC,gBAAgB7jH,MAAM8B,GAEjDwU,IAAK,CACD1U,EAAGgiH,EAAoBC,gBAAgBvtG,IAAI1U,EAC3CE,EAAG8hH,EAAoBC,gBAAgBvtG,IAAIxU,KAG/C,OAGJ,IAD0B,gBAA0B,CAAC2gH,EAAoB,GAAIA,EAAoB,IAAK,CAAC2B,EAAmB,GAAIA,EAAmB,IAAK,CAAC9B,EAAiBtiH,MAAM4B,EAAG0gH,EAAiBtiH,MAAM8B,GAAI,CAACwgH,EAAiBhsG,IAAI1U,EAAG0gH,EAAiBhsG,IAAIxU,IAEtP,OAEJ0P,EAAKyxC,QAAQlwC,OAAO4wG,GAAwBnjH,EAASkzB,cAAc0wF,GACnE5yG,EAAKyxC,QAAQlwC,OAAOqvG,GAAqBI,CAC7C,GAEJl+G,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,IAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,OAAsC5Z,GAClC2a,IACA,IAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKy5D,mBACjDtsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKy5D,kBAAkB,EAEvEz5D,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKy5D,mBACpDtsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKy5D,kBAAkB,EAE1Ez5D,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAK25D,qBACjDxsC,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAK25D,qBACpDxsC,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,IAAAmQ,gBAAe1wD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QACrC+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE+xC,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,EAAQ,OAAE8F,GAAW1mD,KAAK6gD,mBAAmB,CACnEjS,aACA6R,mBAcJ,GAZKvzC,EAAK0xC,YAAYz6B,IACiB,MAAnCjX,EAAK0xC,YAAYz6B,GAAUmwD,KAQtB1lC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAYj1B,EAAiBre,IARjE4R,EAAK0xC,YAAYz6B,GAAY,CACzBvjB,OAAQ,KACRhE,MAAO,KACP03E,KAAM,MAEVt0E,KAAKw0E,sBAAsB5lC,EAAYj1B,EAAiBre,KAKvDY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,IAAAC,qBAAoB5a,GACrB,SAOJ,IALK,IAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM6jG,EAAU,GAAG1gD,WACb2gD,EAAU,GAAG3gD,WACb+P,EAAU,KAChB,IAAAC,UAAYlP,EAAkBd,EAAe+P,EAAS5O,EAAkB,GAAIA,EAAkB,GAAI,CAC9FtkD,QACAwkD,WACAD,YACA+F,UACDu5C,GACH,MAAME,EAAgB,KACtB,IAAA5wC,UAAYlP,EAAkBd,EAAe4gD,EAAez/C,EAAkB,GAAIA,EAAkB,GAAI,CACpGtkD,QACAwkD,WACAD,YACA+F,UACDw5C,GACH5/C,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAI8zE,EACCxnE,EAAKyxC,QAAQiqB,QAAQlP,WACtBgb,GAAsB,IAAAC,wBAAuBj0B,GAC7CxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,IAE/B,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKw+G,0CAA4C,CAACR,EAAkBC,KAChE,MAAM8B,EAA8B,cACpC,SAASA,EAA6B9B,EAAkBjsG,IAAI1U,EAAI2gH,EAAkBviH,MAAM4B,EAAG2gH,EAAkBjsG,IAAIxU,EAAIygH,EAAkBviH,MAAM8B,GAC7I,eAAeuiH,EAA6BA,GAC5C,MAAMC,EAA4B,CAC9BtkH,MAAO,CACH4B,EAAG2gH,EAAkBviH,MAAM4B,EAAqC,GAAjCyiH,EAA4B,GAC3DviH,EAAGygH,EAAkBviH,MAAM8B,EAAqC,GAAjCuiH,EAA4B,IAE/D/tG,IAAK,CACD1U,EAAG2gH,EAAkBjsG,IAAI1U,EAAqC,GAAjCyiH,EAA4B,GACzDviH,EAAGygH,EAAkBjsG,IAAIxU,EAAqC,GAAjCuiH,EAA4B,KAKjE,OAFkC,gBAA0B,CAACC,EAA0BtkH,MAAM4B,EAAG0iH,EAA0BtkH,MAAM8B,GAAI,CAACwiH,EAA0BhuG,IAAI1U,EAAG0iH,EAA0BhuG,IAAIxU,GAAI,CAACwgH,EAAiBtiH,MAAM4B,EAAG0gH,EAAiBtiH,MAAM8B,GAAI,CAACwgH,EAAiBhsG,IAAI1U,EAAG0gH,EAAiBhsG,IAAIxU,GAE7Q,EAEnCwC,KAAKw0E,sBAAwB,CAAC5lC,EAAYj1B,EAAiBre,KACvD,MAAM,KAAE4R,GAAS0hC,GACX,QAAEzhB,GAAY7xB,EAAeY,SAC7Bm5E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,GAChCm5E,EAAY16E,EAAKyxC,QAAQlwC,OAAO,GAChCwxG,EAAY/yG,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,UAAE6mB,EAAS,WAAExa,GAAerM,EAC5Bm4E,EAAS7xC,EAAsBzf,EAAWgzD,GAC1CzB,EAAS9xC,EAAsBzf,EAAWizD,GAC1C4qC,EAASp+E,EAAsBzf,EAAWulE,GAC1Cu4B,EAASr+E,EAAsBzf,EAAW49F,GAC1CG,EAAW,CAACzsC,EAAQC,GACpBysC,EAAW,CAACH,EAAQC,IAClB3jH,MAAO8jH,EAAQhsC,KAAMuX,IAAW,QAAiCrwF,EAAO4kH,IACxE5jH,MAAO+jH,EAAQjsC,KAAMyX,IAAW,QAAiCvwF,EAAO6kH,GAC1Er0B,EAAQhsF,KAAKk1E,iBAAiBG,EAAWC,GAAagrC,EACtDr0B,EAAQjsF,KAAKk1E,iBAAiB0S,EAAWq4B,GAAaM,EACtD3/G,EAASorF,EAAQC,EAAQD,EAAQC,EACjCrvF,EAAQovF,EAAQC,EAAQA,EAAQD,EAChC1X,EAAO0X,EAAQC,EAAQJ,EAASE,EAChCy0B,EAAYx0B,EAAQC,EAAQF,EAASF,EAC3C7rF,KAAK0zE,gBAAgBC,EAAQC,EAAQssC,EAAQC,EAAQt4G,GAC9C7H,KAAKooE,sBAAuB,EAC5BpoE,KAAKooE,sBAAuB,EACnCxpB,EAAYz6B,GAAY,CACpBvjB,SACAhE,QACA03E,OACAksC,YAER,CACA,MAAMjlH,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,IAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CAAW,EAEtB5+C,KAAK0zE,gBAAkB,CAACC,EAAQC,EAAQssC,EAAQC,EAAQt4G,IAC5C,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,IACtC,kCAA8Bq4G,EAAQr4G,IACtC,kCAA8Bs4G,EAAQt4G,GAE9C7H,KAAK0+G,gBAAkB,CAAC+B,EAASC,IACtBzjH,KAAKwvG,MAAMgU,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,GAAID,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,IAExH1gH,KAAKu0E,gCAAiC,OAASv0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,gBAAA32B,CAAiBpG,GACb,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKs+C,WAAY,EACjB,MAAM79B,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bla,EAAoBvG,KAAKu+C,qBAAqBriD,EAAUsjB,EAAUC,EAAiB2iB,GACnFp4B,EAAsB9N,EAASsiD,yBAC/B5P,EAAa,CACf6P,aAAa,EACbljD,aAAa,EACb2L,SAAU,CACNuxC,SAAUz4C,KAAK0+C,cACfj/B,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,sBACAzD,uBACGrK,EAASq9B,iBAAiB,CAAE9qB,OAAQ,CAAC+Q,MAE5CtS,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERopD,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5BtK,kBAAmB,MAEvB9mC,MAAO,GACPitB,YAAa,CAAC,KAGtB,IAAAqJ,eAAcrZ,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAazE,OAZA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,IAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,OAAsCL,GAC/BjQ,CACX,QACS5uC,KAAKqzE,QAAU,CAACnmD,EAAYqtB,EAAMn2C,KACvC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAY8qB,EAAmBzkG,EAAgB,GAAI8I,IAC1Ik8F,EAAWC,GAAahmD,GACxBimD,EAAQC,GAAUH,GAClBI,EAAQC,GAAUJ,EACnB9xF,EAAS,CAAC+xF,EAAQC,EAAQC,EAAQC,GAClC/xD,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,EAAAjT,UAAA,SACzCp/B,KAAM,CACFyxC,QAAS,CACLlwC,SACAgqD,kBAAmB,KACnBmQ,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,MAIhCnkB,YAAa,CAAC,GAElBH,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,IAKX,OAFA,IAAA6jD,eAAcrZ,EAAY1yC,EAASixB,UACnC,OAAsC,CAACjxB,EAASmN,KACzCulC,CAAU,CAClB,CACH,gBAAAsmC,CAAiBC,EAAMC,GACnB,MAAM1yD,EAAKyyD,EAAK,GAAKC,EAAK,GACpBzyD,EAAKwyD,EAAK,GAAKC,EAAK,GACpBxyD,EAAKuyD,EAAK,GAAKC,EAAK,GAC1B,OAAOn4E,KAAKwmC,KAAK/gB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAC9C,EAEJ,SAASqxD,EAAoB/mE,EAAMiX,GAC/B,MAAM,YAAEy6B,EAAW,MAAEjtB,GAAUzkB,GACzB,OAAEtM,EAAM,MAAEhE,EAAK,KAAE03E,GAAS11B,EAAYz6B,GACtCswD,EAAY,GAIlB,OAHI9iD,GACA8iD,EAAU9rE,KAAKgpB,QAEJ3zB,IAAX4C,GAGJ6zE,EAAU9rE,KAAK,MAAM,wBAAoB/H,MAAW0zE,GAAQA,IAAQ,MAAM,wBAAoB13E,MAAU03E,KAF7FG,CAIf,CACA,S,qFCzwBA,MAAMksC,UAA8C,WACvC3gH,KAAKy4C,SAAW,uCAAyC,CAClE,WAAAh5C,CAAYo4C,GAORT,MANqB,EAAA9K,UAAA,UAAoB,CACrC7/B,cAAe,CACXqiE,gBAAgB,EAChB8xC,mBAAmB,IAExB/oE,GAEP,CACA,yBAAAwoC,GACI,OAAO,CACX,CACA,wBAAAC,CAAyBC,GACrB,MAAM3xC,EAAa2xC,EAAc3xC,YAC3B,YAAErzC,GAAgBqzC,EAClBiyE,EAAezpE,MAAMkpC,yBAAyBC,GACpD,GAAIhlF,EAAa,CACb,MAAM,eAAE+kE,GAAmB1xB,EAAW1hC,KAAK6gF,cAC3C,IAAAkK,iCAAgC33B,EACpC,CACA,OAAOugD,CACX,EAEJ,S,wTCHA,MAAM,sBAAEC,GAA0B,EAAA7xC,UAC5B,QAAErvD,GAAY,EAAAumC,UACd+Q,EAAqB,EAAIt3C,EAC/B,MAAMmhG,UAA8B,WACvB/gH,KAAKy4C,SAAW,mBAAqB,CAC9C,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX8qE,gBAAgB,EAChB7wB,QAAQ,EACRshB,2BAA2B,EAC3B0U,+BAAgC,EAAAzkB,iBAAiBC,MACjD8oD,+BAAgC,CAC5Bl6D,SAAS,EACThkB,OAAQ,GAEZ89E,mBAAmB,EACnBK,sBAAuB,GACvBC,iCAAkC,EAClCC,eAAe,EACfC,mBAAoB,EACpBC,UAAW,CACPC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAEhC5oG,cAAe,CACXiuC,SAAS,EACT86B,wBAAyB,MAE7BljE,SAAU,CACNooC,SAAS,EACT61B,QAAS,IAEb+kC,6BAA6B,EAC7B5yC,gBAAgB,EAChBkF,aAAcC,EACdwD,gBAAiB,EAAAC,wBAGrBtgC,MAAMS,EAAWC,GACjB93C,KAAKs+C,WAAY,EACjBt+C,KAAK2hH,iBAAkB,EACvB3hH,KAAK4hH,eAAgB,EACrB5hH,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACd6f,EAAa5uC,KAAKmgF,iBAAiBloC,GACzCj4C,KAAKioD,cAAcrZ,EAAYzhB,GAC/B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAIzE,OAHA1+C,KAAK6hH,aAAa5pE,EAAKrJ,EAAYiQ,GACnC5G,EAAIiH,kBACJ,OAAsCL,GAC/BjQ,CAAU,EAErB5uC,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACd8vB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK8hH,2BAA2B7pE,EAAKrJ,EAAYiQ,EAAqBya,EAAO,EAEjFt5D,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACd8vB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACrE9P,EAAW1hC,KAAK2gC,QAAQ4B,OACxBzvC,KAAK+hH,0BAA0B9pE,EAAKrJ,EAAYiQ,GAGhD7+C,KAAKgiH,wBAAwB/pE,EAAKrJ,EAAYiQ,GAElD5G,EAAIiH,gBAAgB,EAExBl/C,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACb2zE,SAAUxgE,GAAWmgC,EAAW1hC,KAAK2gC,QAC7C,IAAIo0E,EAAgB/lH,EAASwjD,cAAcjxC,EAAO,IAClD,IAAK,IAAI/E,EAAI,EAAGA,EAAI+E,EAAO7N,OAAQ8I,IAAK,CACpC,MAAM68B,EAAK07E,EACL9tE,EAAKj4C,EAASwjD,cAAcjxC,EAAO/E,IAEzC,GADmBo3G,EAAsBh3D,EAAcvjB,EAAI4N,EAAI4V,GAE3D,OAAO,EAEXk4D,EAAgB9tE,CACpB,CACA,IAAKvF,EAAW1hC,KAAK2gC,QAAQ4B,OACzB,OAAO,EAEX,MAAMyyE,EAAShmH,EAASwjD,cAAcjxC,EAAO,IACvC0zG,EAAOjmH,EAASwjD,cAAcjxC,EAAOA,EAAO7N,OAAS,IAC3D,OAAOkgH,EAAsBh3D,EAAco4D,EAAQC,EAAMp4D,EAAU,EAEvE/pD,KAAKiL,OAAUkiB,IACX,MAAMmxB,EAAYt+C,KAAKs+C,UACjBsjE,EAAgB5hH,KAAK4hH,cACrBD,EAAkB3hH,KAAK2hH,gBACzBrjE,EACAt+C,KAAKoiH,cAAcj1F,GAEdy0F,EACL5hH,KAAKqiH,sBAAsBl1F,GAEtBw0F,GACL3hH,KAAKsiH,wBAAwBn1F,EACjC,EAEJntB,KAAKw0E,sBAAwB,CAAC5lC,EAAY1yC,EAAUyd,EAAiBre,KACjE,MAAM,KAAE4R,GAAS0hC,GACX,YAAEgQ,GAAgB1xC,GAChB+hE,SAAUxgE,EAAM,OAAEghC,GAAWviC,EAAK2gC,QACpC0nC,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,UAAE6mB,EAAS,SAAEnb,GAAa1L,EAC1BklD,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7D0nF,EAAsB,CACxB73F,aAAa,OAAoBrC,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpEswE,GAAe,OAAmB3vE,EAASy8B,SAAUiL,EAAW1nC,SAASX,kBAAmB6vF,GAC5FmsB,GAAkB,QAAiC/mH,GAAO,KAC5D,MAAMyzE,EAAW/hE,EAAK2gC,QAAQohC,SACxBy/B,EAAYz/B,EAASruE,OACrBymG,EAAoB,IAAI3oG,MAAMgwG,GACpC,IAAK,IAAIhlG,EAAI,EAAGA,EAAIglG,EAAWhlG,IAC3B29F,EAAkB39F,GAAKxN,EAASwjD,cAAcuvB,EAASvlE,IAE3D,MAAQ6Z,KAAMi8D,EAAY1+C,KAAM2+C,EAAYn8D,KAAMo8D,EAAY7+C,KAAM8+C,GAAgB,mBAAsB0nB,GACpGxnB,EAAiB3jF,EAASkzB,cAAc,CAACswD,EAAYC,IACrDG,EAAiB,kCAA8Bz9D,EAAWw9D,GAC1DE,EAAqB7jF,EAASkzB,cAAc,CAC9CowD,EACAC,IAGJ,MAAO,CAACK,EADmB,kCAA8Bz9D,EAAW09D,GACzB,IAE3CtwC,EACAzvC,KAAKwiH,wBAAwB,CACzBr+F,WACAjoB,WACAwkD,oBACAjyC,SACA4T,YACAnb,WACA03C,cACAi4B,eACA0rC,oBAIJviH,KAAKyiH,sBAAsB,CACvBv7G,WACAw5C,oBACAv8B,WACAy6B,cACAi4B,eACA0rC,mBAGZ,CACA,MAAMhnH,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,IAAAuzC,2BAA0BF,EAAYtzC,EAAeY,SAASixB,QAAS,EAAA4hB,YAAYymC,cAEhF52B,CAAW,EAEtB5+C,KAAK2+E,aAAe,CAAC/vC,EAAY1yC,EAAUZ,EAAgB+kD,KACvD,MAAM,KAAEnzC,GAAS0hC,EACXzqB,EAAWnkB,KAAK82D,YAAY56D,GAC5BukD,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAElCjF,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WACT,OAEJ,MAAM8mD,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,OAEJ,MAAM8/C,EAAoBxzC,EAAK2gC,QAAQohC,SAAS5oE,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAClF,IAAKxB,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAE9DgM,GAAc,IAAAC,mBAAkBz0B,EAAkBzR,EAAW2Q,eAAiB,GADjE,IACiFk1B,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IAC/I9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAC5D,GAEL,OAAiBmD,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MACtBA,KAAKu0E,gCAAiC,OAASv0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,CACA,uCAAAx0B,CAAwCrzB,EAASozB,GAC7C,IAAKA,IAAgBA,EAAY3/C,OAC7B,OAEJ,MAAMtF,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB,IAAIonH,EACJ,GAAIxmH,aAAoB,EAAAsyC,eAAgB,CACpC,MAAM/tB,EAASvkB,EAASwkB,aAClB,yBAAEC,GAA6B,iDAA6CzkB,EAAUukB,GAC5FiiG,EAAuB1iH,KAAK2iH,6BAA6BpiE,EAAa9/B,EAAQE,EAClF,MAEI+hG,GAAuB,IAAAE,6BAA4B1mH,EAAUqkD,GAEjE,OAAOmiE,CACX,CACA,4BAAAC,CAA6BpiE,EAAa9/B,EAAQE,GAC9C,MAAM,gBAAElB,GAAoBgB,EACtBoiG,EAAiCtiE,EAAYzrC,QAAQguG,IACvD,MAAMC,EAA4BD,EAAG57G,SAASuY,gBACxCwjD,EAAahmE,KAAK6e,IAAI,SAAS2D,EAAiBsjG,IAClD7rD,EACJ,OAAO6rD,GAA6B9/C,CAAU,IAElD,IAAK4/C,EAA+BjiH,OAChC,MAAO,GAEX,MAAMif,EAA+Bc,EAA2B,GAC1D,WAAEC,GAAeH,EACjBuiG,EAAyB,GAC/B,IAAK,MAAMp0E,KAAci0E,EAAgC,CACrD,MACMv0G,EADOsgC,EAAW1hC,KACL2gC,QAAQohC,SAAS,GACpC,IAAKrgC,EAAW2iC,UACZ,SAEJ,MAAMxxD,EAAM,cACZ,SAASA,EAAKa,EAAYtS,GAC1B,MAAM0R,EAAM,SAASD,EAAKN,GACtBxiB,KAAK6e,IAAIkE,GAAOH,GAChBmjG,EAAuBr6G,KAAKimC,EAEpC,CACA,OAAOo0E,CACX,CACA,yBAAA3iC,GACI,OAAO,CACX,CACA,gBAAAF,CAAiBloC,GACb,MAAMz4B,EAAWy4B,EAAI3lB,OAAOwoB,cAAcxC,MACpCopC,EAAoBtqC,MAAM+oC,iBAAiBloC,GAcjD,OAVmB,sBAAkBypC,EAAmB,CACpDx0E,KAAM,CACF2gC,QAAS,CACLohC,SAAU,CAAC,IAAIzvD,KAEnBmS,MAAO,GACPitB,YAAa,CAAC,GAElBgjC,wBAX6BhzC,IAC7BA,EAAW1hC,KAAKyxC,QAAQlwC,OAAO7N,OAAS,CAAC,GAajD,CACA,kBAAAigD,CAAmBn/C,GACf,OAAO01C,MAAMyJ,mBAAmBn/C,EACpC,CACA,wBAAA4+E,CAAyBC,GACrB,MAAM,eAAEjlF,EAAc,SAAE6oB,EAAQ,iBAAEk8B,GAAqBkgC,EACjD3xC,EAAa2xC,EAAc3xC,WACjC,IAAI0R,GAAe,EACnB,MAAM,SAAEpkD,EAAQ,gBAAEyd,GAAoBre,EAChCgjD,EAAYt+C,KAAKs+C,UACjBsjE,EAAgB5hH,KAAK4hH,cACrBD,EAAkB3hH,KAAK2hH,gBAC7B,GAAMrjE,GAAasjE,GAAiBD,EAS/B,CACD,MAAMxzC,EAAsBnuE,KAAKkuE,WAAWt/B,WAAW2Q,cACvD,GAAI3Q,EAAW2Q,gBAAkB4uB,EAC7B,GAAI7vB,EACAt+C,KAAKijH,wBAAwB3nH,EAAgB+kD,EAAkBzR,QAE9D,GAAI+yE,EACL3hH,KAAKkjH,+BAA+B5nH,EAAgB+kD,EAAkBzR,OAErE,KAAIgzE,EAIL,MAAM,IAAIxjH,MAAM,WAAW4B,KAAK0+C,4CAHhC1+C,KAAKmjH,6BAA6B7nH,EAAgB+kD,EAAkBzR,EAIxE,MAGI5uC,KAAKyM,cAAci1G,6BACyB,IAA5C9yE,EAAW1hC,KAAK2gC,QAAQohC,SAASruE,OACjCZ,KAAKojH,6BAA6B9nH,EAAgB+kD,EAAkBzR,GAGpE5uC,KAAKqjH,cAAc/nH,EAAgB+kD,EAAkBzR,GAG7D0R,GAAe,CACnB,MAlCQtgD,KAAKyM,cAAci1G,6BACyB,IAA5C9yE,EAAW1hC,KAAK2gC,QAAQohC,SAASruE,OACjCZ,KAAKojH,6BAA6B9nH,EAAgB+kD,EAAkBzR,GAGpE5uC,KAAKqjH,cAAc/nH,EAAgB+kD,EAAkBzR,GA8B7D,GAAK5uC,KAAKyM,cAAcqiE,eAKxB,OAFA9uE,KAAKsjH,wBAAwB10E,EAAYzqB,EAAUjoB,EAAUyd,EAAiBre,GAC9E0E,KAAK2+E,aAAa/vC,EAAY1yC,EAAUZ,EAAgB+kD,GACjDC,CACX,CACA,uBAAAgjE,CAAwB10E,EAAYzqB,EAAUjoB,EAAUyd,EAAiBre,GACrE,MAAM6yE,EAAsBnuE,KAAKkuE,YAAYt/B,WAAW2Q,cACxD,IAAI3Q,EAAW2Q,gBAAkB4uB,GAC5BnuE,KAAKkuE,YAAYgG,iBAGjBl0E,KAAKkuE,YAAYgG,cAAe,CACjC,MAAM,KAAEhnE,GAAS0hC,EACZ1hC,EAAK0xC,YAAYz6B,IAAWmwD,KAYxB1lC,EAAWrzC,aAChByE,KAAKu0E,+BAA+B3lC,EAAY1yC,EAAUyd,EAAiBre,IAZ3E4R,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACN9pE,IAAK,KACLm0B,KAAM,KACNC,OAAQ,KACRy1C,SAAU,KACV1E,KAAM,MAEVt0E,KAAKw0E,sBAAsB5lC,EAAY1yC,EAAUyd,EAAiBre,GAK1E,CACJ,CACA,uBAAAknH,EAAwB,SAAEtmH,EAAQ,OAAEuS,EAAM,UAAE4T,EAAS,SAAEnb,EAAQ,YAAE03C,EAAW,SAAEz6B,EAAQ,aAAE0yD,EAAY,kBAAEn2B,EAAiB,gBAAE6hE,IACrH,MAAM,MAAE/lH,EAAK,SAAEw8E,EAAQ,KAAE1E,GAASiuC,GAC5B,aAAEv9G,GAAiB9I,EAASw5B,eAC5BsV,EAAc0V,EAAkB,GAChCy+B,EAAqBjjF,EAASkzB,cAAc4b,GAC5Co0C,EAAcljF,EAASkzB,cAAc,CACvC4b,EAAY,GAAK,EACjBA,EAAY,KAEVq0C,EAAcnjF,EAASkzB,cAAc,CACvC4b,EAAY,GACZA,EAAY,GAAK,IAEfs0C,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,GAC7CkkC,EAAgB,kCAA8BlhG,EAAW5T,EAAO,IACtE80G,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5CA,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5CA,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5C,IAAIp6E,EAAOo6E,EAAc,GACrBn6E,EAAOm6E,EAAc,GACrBl6E,EAAOk6E,EAAc,GACrBj6E,EAAOi6E,EAAc,GACrBh6E,EAAOg6E,EAAc,GACrB/5E,EAAO+5E,EAAc,GACzB,IAAK,IAAItxG,EAAI,EAAGA,EAAIxD,EAAO7N,OAAQqR,IAAK,CACpC,MAAMsxG,EAAgB,kCAA8BlhG,EAAW5T,EAAOwD,IACtEsxG,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5CA,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5CA,EAAc,GAAKtmH,KAAK+Q,MAAMu1G,EAAc,IAC5Cp6E,EAAOlsC,KAAKa,IAAIqrC,EAAMo6E,EAAc,IACpCn6E,EAAOnsC,KAAKkS,IAAIi6B,EAAMm6E,EAAc,IACpCl6E,EAAOpsC,KAAKa,IAAIurC,EAAMk6E,EAAc,IACpCj6E,EAAOrsC,KAAKkS,IAAIm6B,EAAMi6E,EAAc,IACpCh6E,EAAOtsC,KAAKa,IAAIyrC,EAAMg6E,EAAc,IACpC/5E,EAAOvsC,KAAKkS,IAAIq6B,EAAM+5E,EAAc,GACxC,CACA,MAAMC,EAAiB,kCAA8BnhG,EAAW5T,EAAO,IACvE+0G,EAAe,GAAKvmH,KAAK+Q,MAAMw1G,EAAe,IAC9CA,EAAe,GAAKvmH,KAAK+Q,MAAMw1G,EAAe,IAC9CA,EAAe,GAAKvmH,KAAK+Q,MAAMw1G,EAAe,IAC9C,IAAIvqC,EAAO,EAAAhK,SAAA,QAAiBvuB,GAAqBlkD,EAAQA,EACzDy8E,GAAQqG,EAAWC,EACnB,MAAMkkC,EAAS,KAAQr6E,EAAOD,GACxBu6E,EAAS,KAAQp6E,EAAOD,GACxBs6E,EAAS,KAAQn6E,EAAOD,GAC9BJ,EAAOlsC,KAAK+Q,MAAMm7B,EAAOs6E,GACzBr6E,EAAOnsC,KAAK2mH,KAAKx6E,EAAOq6E,GACxBp6E,EAAOpsC,KAAK+Q,MAAMq7B,EAAOq6E,GACzBp6E,EAAOrsC,KAAK2mH,KAAKt6E,EAAOo6E,GACxBn6E,EAAOtsC,KAAK+Q,MAAMu7B,EAAOo6E,GACzBn6E,EAAOvsC,KAAK2mH,KAAKp6E,EAAOm6E,GACxB,MAAMzuG,EAAY,CACd,CAACi0B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAELq6E,EAAcxhG,EAAUS,aAAa,CAACsmB,EAAME,EAAME,IAClDs6E,EAAe5nH,EAASwjD,cAAcmkE,GAC5C,IAAIE,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAC1B,MAAM/6E,EAAgBlkC,EAAa/D,QAAQjB,KAAKyM,cAAcgrE,gBAAgBsC,cAAe,CACzF13D,YACA23D,WAAY,CAACjwC,EAAUm6E,KACnB,IAAIxoF,GAAS,EACb,MAAMptB,EAAQpS,EAASwjD,cAAc3V,GAsBrC,OArBIz7B,EAAM,IAAMy1G,IACZE,EAAsB,EACtBF,EAASz1G,EAAM,GACf01G,GAAgB,IAAAG,wCAAuCzjE,EAAmBpyC,EAAO,CAACw1G,EAAa,GAAIx1G,EAAM,KACzG01G,EAAc/nG,MACH,SAAUC,EAAGhF,GAChB,OAAOgF,EAMZ,KANyBhF,EAMzB,GALW,EACAgF,EAIX,GAJsBhF,EAItB,IAHgB,EACD,CACd,KAGJ8sG,EAAcpjH,QAAU0N,EAAM,GAAK01G,EAAc,GAAG,KACpDA,EAAcI,QACdH,KAEAA,EAAsB,GAAM,IAC5BvoF,GAAS,GAENA,CAAM,EAEjBxmB,YACA0zB,aAAc5oC,KAAKyM,cAAc8qE,iBAE/B57E,EAAQqE,KAAKyM,cAAcgrE,gBAAgB0C,gBACjDv7B,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACA2B,WAAW,OAAmBl6B,EAAmBjR,QAAUjzC,EAC3D8mC,KAAM3nC,EAAM2nC,MAAMrjC,MAClBkP,IAAKxT,EAAMwT,KAAKlP,MAChBsjC,OAAQ5nC,EAAM4nC,QAAQtjC,MACtBm6E,WAAYz+E,EAAMqR,MAClBk8B,cAAeA,EACf8vC,WACAnC,eACAvC,OAER,CACA,qBAAAmuC,EAAsB,SAAEt+F,EAAQ,SAAEjd,EAAQ,kBAAEw5C,EAAiB,YAAE9B,EAAW,aAAEi4B,EAAY,gBAAE0rC,IACtF,MAAM,MAAE/lH,EAAK,KAAE83E,GAASiuC,EACxB3jE,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnB/iC,QAAQ,OAAmB8/C,GAAmB,GAASlkD,EACvDq6E,eACAvC,OAER,EAEJ,SAASL,EAAoB/mE,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,KAAE80D,EAAI,KAAE31C,EAAI,OAAEC,EAAM,OAAE3iC,EAAM,UAAEg6E,EAAS,IAAEzrE,EAAG,YAAE2qE,EAAW,KAAExF,EAAI,SAAE0E,EAAQ,aAAEnC,GAAkBpB,GAAqB,CAAC,EACnHhB,EAAY,GAClB,GAAIwE,EAAM,CACN,MAAMsB,EAAWT,EACX,8BACA,SAAS,wBAAoBb,MAASD,IAC5CvE,EAAU9rE,KAAK4xE,EACnB,CAgBA,OAfIj3C,GACAmxC,EAAU9rE,KAAK,SAAS,wBAAoB26B,MAASuzC,KAErD7qE,OAAOq4G,SAASl1G,IAChBslE,EAAU9rE,KAAK,QAAQ,wBAAoBwG,MAAQ0nE,KAEnDtzC,GACAkxC,EAAU9rE,KAAK,YAAY,wBAAoB46B,MAAWszC,KAE1D+D,GACAnG,EAAU9rE,KAAK,cAAc,wBAAoBiyE,MAActG,KAE/D1zE,GACA6zE,EAAU9rE,KAAK,GAAG,wBAAoB/H,MAAW0zE,KAE9CG,CACX,CACA,S,yQChgBA,MAAM,sBAAE3yC,GAA0B,YAClC,MAAMwiF,UAAyB,YAClBtkH,KAAKy4C,SAAW,cAAgB,CACzC,WAAAh5C,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX8qE,gBAAgB,EAChB7wB,QAAQ,EACRshB,2BAA2B,EAC3BgM,aAAcC,EACdwD,gBAAiB,EAAAC,wBAGrBtgC,MAAMS,EAAWC,GACjB93C,KAAKq+C,iBAAoBpG,IACrB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,cAAEwoB,EAAa,QAAE3tB,GAAY4B,EAC7BvP,EAAWs7B,EAAcxC,MACzBh9C,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACrB0E,KAAKs+C,WAAY,EACjB,MAAM1P,EAAc5uC,KAAgB,YAAEk2E,4BAA4Bh6E,EAAU,CACxEgR,KAAM,CACFyxC,QAAS,CACLlwC,OAAQ,CACJ,IAAI+Q,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAERopD,QAAS,CACLlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,UAMxC,QAAcn0B,EAAYzhB,GAC1B,MAAM0xB,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eAazE,OAZA1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,YAAa,EACb2a,eAAe,EACf1a,eAAe,EACfE,UAAU,GAEd15D,KAAKg/C,cAAc7xB,IACnB,IAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,kBACJ,OAAsCL,GAC/BjQ,CAAU,EAErB5uC,KAAKgiD,gBAAkB,CAAC70B,EAASyhB,EAAYkb,EAAcC,KACvD,MAAMzuD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,KAAE4R,GAAS0hC,GACX,OAAEngC,GAAWvB,EAAKyxC,QAClBw1B,EAAej4E,EAASwjD,cAAcjxC,EAAO,IAC7C2lE,EAAel4E,EAASwjD,cAAcjxC,EAAO,IAC7CuyF,EAAOhhG,KAAKihG,8BAA8B,CAC5C9sB,EACAC,IAEE9lE,EAAQ,CAACw7C,EAAa,GAAIA,EAAa,KACvC,KAAE3I,EAAI,IAAExsC,EAAG,MAAE/X,EAAK,OAAEC,GAAWmkG,EAErC,OADwB,kBAA0B,CAAC7/C,EAAMxsC,EAAK/X,EAAOC,GAASyR,IACvDy7C,CAGX,EAEhB/pD,KAAKiiD,qBAAuB,CAAChK,EAAKrJ,KAC9B,MAAM7f,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,EACpB6f,EAAW6P,aAAc,EACzB,MAAMI,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACAq1B,eAAe,GAEnBl0E,KAAKmiD,gBAAgBh1B,IACrB,IAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,OAAsCujD,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKkiD,uBAAyB,CAACjK,EAAKrJ,EAAY0qB,KAC5C,MAAMvqC,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,KAAE7hB,GAAS0hC,EACjBA,EAAW6P,aAAc,EACzB,IACI8a,EADA2a,GAAgB,EAEhB5a,EAAOuP,cACPqL,GAAgB,EAGhB3a,EAAcrsD,EAAKyxC,QAAQlwC,OAAO+D,WAAW9D,GAAMA,IAAM4qD,IAE7D,MAAMza,GAAsB,IAAAC,gCAA+B3xB,EAASntB,KAAK0+C,eACzE1+C,KAAK++C,SAAW,CACZnQ,aACAiQ,sBACA0a,cACA2a,iBAEJl0E,KAAKmiD,gBAAgBh1B,IACrB,IAAA8xB,mBAAkB9xB,GAClB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,gBAAExT,GAAoBre,GAC5B,OAAsCujD,GACtC5G,EAAIiH,gBAAgB,EAExBl/C,KAAKo/C,aAAgBnH,IACjB,MAAMlpB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,cAAE2a,EAAa,SAAEE,GAAa15D,KAAK++C,UACpE,KAAE7xC,GAAS0hC,EACb4qB,IAAkBE,IAGtBxsD,EAAKyxC,QAAQ8Z,kBAAoB,KACjCz4D,KAAKoiD,kBAAkBj1B,GACvBntB,KAAKq/C,gBAAgBlyB,IACrB,IAAAmyB,oBAAmBnyB,GACnBntB,KAAKkzE,eACLlzE,KAAK++C,SAAW,KAChB/+C,KAAKs+C,WAAY,EACbt+C,KAAKooE,sBACLpoE,KAAKyM,cAAcu7D,4BACnB,QAAiBp5B,EAAW2Q,gBAEhC,OAAsCV,GAClC2a,IACA,IAAAha,4BAA2B5Q,GAC/B,EAEJ5uC,KAAKk4C,cAAiBD,IAClBj4C,KAAKs+C,WAAY,EACjB,MAAMvvB,EAAckpB,EAAI3lB,QAClB,QAAEnF,GAAY4B,GACd,WAAE6f,EAAU,oBAAEiQ,EAAmB,YAAE0a,EAAW,cAAE2a,EAAa,cAAE1a,GAAmBx5D,KAAK++C,SAC7F/+C,KAAK8yB,WAAW3F,EAASyhB,EAAY,CAAE4qB,kBACvC,MAAM,KAAEtsD,GAAS0hC,EACjB,GAAIslC,EAAe,CACf,MAAM,YAAE97B,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,QAAEswB,GAAY17D,EAAKyxC,SACnB,cAAEkqB,GAAkBD,EAC1BC,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCxL,EAAc,IAAMwL,EAAc,GAClCzL,EAAQlP,UAAW,CACvB,MACK,QAAoB17D,IAAhBu7D,EAA2B,CAChC,MAAM,YAAEnhB,GAAgBrpB,EAClBslD,EAAgBj8B,EAAYE,OAC5B,OAAE7pC,GAAWvB,EAAKyxC,QACxBlwC,EAAOxN,SAASqN,IACZA,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,GAC1B/lE,EAAM,IAAM+lE,EAAc,EAAE,IAEhCzlC,EAAWrzC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEu/C,GAAkB/rB,EACpBzzB,GAAiB,IAAA48B,mBAAkB/K,IACnC,cAAEuyB,EAAa,cAAEtwB,GAAkB9zB,EAAeY,SAClDsjB,EAAWs7B,EAAcxC,OACzB,OAAE7pC,GAAWvB,EAAKyxC,QAExB,IAAI1nB,EACAD,EACA2oB,EACA5oB,EACAM,EACAD,EACAF,EACAC,EACJ,OATA1oB,EAAO8qD,GAAe,IAAI/5C,GASlB+5C,GACJ,KAAK,EACL,KAAK,EACDtiC,EAAmByoB,EAAcjxC,EAAO,IACxCsoB,EAAiB2oB,EAAcjxC,EAAO,IACtCuoB,EAAoB,CAACD,EAAe,GAAIE,EAAiB,IACzD0oB,EAAgB,CAAC1oB,EAAiB,GAAIF,EAAe,IACrDK,EAAmBhI,EAAc4H,GACjCE,EAAe9H,EAAcuwB,GAC7BlxC,EAAO,GAAK2oB,EACZ3oB,EAAO,GAAKyoB,EACZ,MACJ,KAAK,EACL,KAAK,EACDF,EAAoB0oB,EAAcjxC,EAAO,IACzCkxC,EAAgBD,EAAcjxC,EAAO,IACrCwoB,EAAmB,CACf0oB,EAAc,GACd3oB,EAAkB,IAEtBD,EAAiB,CACbC,EAAkB,GAClB2oB,EAAc,IAElBtoB,EAAkBjI,EAAc6H,GAChCE,EAAgB/H,EAAc2H,GAC9BtoB,EAAO,GAAK4oB,EACZ5oB,EAAO,GAAK0oB,EAGpByX,EAAWrzC,aAAc,CAC7B,CACAyE,KAAK++C,SAAS2a,UAAW,GACF,IAAAxhC,mBAAkB/K,IACzC,OAAsC0xB,GAClCjQ,EAAWrzC,cACX,IAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYggC,eAC/D,EAEJ/uE,KAAKiL,OAAUkiB,IACX,GAAIntB,KAAKs+C,UAAW,CAChBt+C,KAAKs+C,WAAY,EACjBt+C,KAAKq/C,gBAAgBlyB,GACrBntB,KAAKoiD,kBAAkBj1B,IACvB,IAAAmyB,oBAAmBnyB,GACnB,MAAM,WAAEyhB,EAAU,oBAAEiQ,EAAmB,cAAE2a,GAAkBx5D,KAAK++C,UAC1D,KAAE7xC,GAAS0hC,EAQjB,OAPAA,EAAW6P,aAAc,EACzBvxC,EAAKyxC,QAAQ8Z,kBAAoB,MACjC,OAAsC5Z,GAClC2a,IACA,IAAAha,4BAA2B5Q,GAE/B5uC,KAAK++C,SAAW,KACTnQ,EAAW2Q,aACtB,GAEJv/C,KAAKg/C,cAAiB7xB,IAClB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOswB,WAAY//C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKq/C,gBAAmBlyB,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOswB,WAAY//C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKmiD,gBAAmBh1B,IACpB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,cAClDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOwwB,UAAWjgD,KAAKo/C,cAChDjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOywB,WAAYlgD,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEjEp/C,KAAKoiD,kBAAqBj1B,IACtB,KAAMyyB,uBAAwB,EAC9BzyB,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,cACrDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOwwB,UAAWjgD,KAAKo/C,cACnDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOywB,WAAYlgD,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAO0wB,UAAWngD,KAAKo/C,aAAa,EAEpEp/C,KAAKogD,iBAAmB,CAAC9kD,EAAgB+kD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAEpkD,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACpB,IAAIqkD,GAAc,QAAevgD,KAAK0+C,cAAevxB,GACrD,IAAKozB,GAAa3/C,OACd,OAAO0/C,EAGX,GADAC,EAAcvgD,KAAKwgD,wCAAwCrzB,EAASozB,IAC/DA,GAAa3/C,OACd,OAAO0/C,EAEX,MAAMn8B,EAAWnkB,KAAK82D,YAAY56D,GAC5Byd,EAAkBzd,EAASiwB,qBAC3Bs0B,EAAiB,CACnBjH,YAAax5C,KAAKw5C,YAClBf,SAAUz4C,KAAK0+C,cACfxxB,WAAY5xB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI62C,EAAY3/C,OAAQ8I,IAAK,CACzC,MAAMklC,EAAa2R,EAAY72C,IACzB,cAAE61C,EAAa,KAAEryC,GAAS0hC,GAC1B,OAAEngC,EAAM,kBAAEgqD,GAAsBvrD,EAAKyxC,QACrC+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KACnE+xC,EAAelB,cAAgBA,EAC/B,MAAM,MAAEnjD,EAAK,UAAEukD,EAAS,SAAEC,GAAa5gD,KAAK6gD,mBAAmB,CAC3DjS,aACA6R,oBAEE,gBAAEhhC,EAAe,OAAE2iB,GAAWlmC,EAASwkB,YAC7C,GAAKxT,EAAK0xC,YAAYz6B,IACqB,MAAvCjX,EAAK0xC,YAAYz6B,GAAU60D,UAW1B,GAAIpqC,EAAWrzC,cAChByE,KAAKu0E,+BAA+B3lC,EAAYnvB,EAAiB2iB,EAAQzoB,EAAiBre,GACtFY,aAAoB,EAAAsyC,gBAAgB,CACpC,MAAM,kBAAEjoC,GAAsBqoC,EAAW1nC,SACzC,IAAK,MAAMid,KAAYjX,EAAK0xC,YACxB,GAAIz6B,EAASnjB,WAAW,WAAY,CACd2Y,EAAgBy8D,oBACC14D,MAAM4H,IACrC,MAAM+wD,EAAqB,yBAAqB9vE,GAC1CitB,EAAclO,EAAGkO,YAAY6iD,GAC7BC,EAAkB,yBAAqBhxD,EAAGia,qBAChD,OAAO/L,GAAe8iD,IAAoBD,CAAkB,YAGrDnpE,EAAK0xC,YAAYz6B,EAEhC,CAER,OA5BAjX,EAAK0xC,YAAYz6B,GAAY,CACzBwf,SAAU,KACVs1C,KAAM,KACN9pE,IAAK,KACLm0B,KAAM,KACNC,OAAQ,KACRy1C,SAAU,MAEdh5E,KAAKw0E,sBAAsB5lC,EAAYnvB,EAAiB2iB,EAAQzoB,EAAiBre,GAsBrF,IAAKY,EAASiwB,qBAEV,OADA/b,QAAQC,KAAK,uCACNiwC,EAEX,IAAI4Z,EACJ,KAAK,IAAAC,qBAAoB5a,GACrB,SAOJ,IALK,IAAA2L,oBAAmB3L,IACnBv/C,KAAK++C,UACgB,OAAtB0Z,IACAyB,EAA2B,CAACxZ,EAAkB+X,KAE9CyB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAAjK,aAAe9P,EAAkBd,EAAe6a,EAAgBF,EAA0B,CACtF99D,SAER,CACA,MAAM0kD,EAAS,GAAGvB,SACZwB,EAAe,KACrB,2BAAYV,EAAkBd,EAAewB,EAAcL,EAAmB,CAC1EtkD,QACAwkD,WACAD,aACDG,GACHR,GAAe,EACf,MAAMl8C,EAAUpE,KAAKmzE,sBAAsB1yB,EAAgB7R,GAC3D,IAAKxqC,EAAQupB,WAAY,CACrBzgB,EAAKyxC,QAAQiqB,QAAU,CACnBlP,UAAU,EACVmP,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChBzzC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnByzC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM0R,EAAYz0E,KAAKyM,cAAcunE,aAAa9mE,EAAMiX,GACxD,IAAKswD,GAAkC,IAArBA,EAAU7zE,OACxB,SAEJ,IAAKsM,EAAKyxC,QAAQiqB,QAAQlP,SAAU,CAChC,MAAMgb,GAAsB,IAAAC,wBAAuBj0B,GACnDxzC,EAAKyxC,QAAQiqB,QAAQC,cACjB3sE,EAASkzB,cAAcslD,EAC/B,CACA,MAAME,EAAkB14E,EAASwjD,cAAcxyC,EAAKyxC,QAAQiqB,QAAQC,eAC9DuK,EAAa,IACbyB,GAAc,IAAAC,mBAAqBz0B,EAAkBd,EAAe6zB,EAAYqB,EAAWG,EAAiBl0B,EAAmB,CAAC,EAAGt8C,IACjI9G,EAAG6jD,EAAM3jD,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWg4E,EAC3C3nE,EAAKyxC,QAAQiqB,QAAQE,iBAAmB,CACpChG,QAAS5mE,EAASkzB,cAAc,CAAC+xB,EAAMxsC,IACvC0a,SAAUnzB,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,IAChD2a,WAAYpzB,EAASkzB,cAAc,CAAC+xB,EAAMxsC,EAAM9X,IAChDkmE,YAAa7mE,EAASkzB,cAAc,CAAC+xB,EAAOvkD,EAAO+X,EAAM9X,IAEjE,CACA,OAAOyjD,CAAY,EAEvBtgD,KAAKihG,8BAAiCxyF,IAClC,MAAO4yF,EAAQt4C,GAAUt6C,EACzB,MAAO,CACH0yC,KAAMlkD,KAAKa,IAAIujG,EAAO,GAAIt4C,EAAO,IACjCp0C,IAAK1X,KAAKa,IAAIujG,EAAO,GAAIt4C,EAAO,IAChCnsD,MAAOK,KAAK6e,IAAIulF,EAAO,GAAKt4C,EAAO,IACnClsD,OAAQI,KAAK6e,IAAIulF,EAAO,GAAKt4C,EAAO,IACvC,EAEL/oD,KAAKw0E,sBAAwB,CAAC5lC,EAAYnvB,EAAiB2iB,EAAQzoB,EAAiBre,KAChF,MAAM,KAAE4R,GAAS0hC,GACX,SAAE1yC,GAAaZ,GACf,QAAE6xB,GAAYjxB,EACdm5E,EAAYnoE,EAAKyxC,QAAQlwC,OAAO,GAChC6mE,EAAYpoE,EAAKyxC,QAAQlwC,OAAO,IAChC,YAAEmwC,GAAgB1xC,EAClBqoE,EAAY31E,OAAO4B,KAAKo9C,GAC9B,IAAK,IAAIl1C,EAAI,EAAGA,EAAI6rE,EAAU30E,OAAQ8I,IAAK,CACvC,MAAMya,EAAWoxD,EAAU7rE,GACrBlO,EAAQwE,KAAKgkE,mBAAmB7/C,GACtC,IAAK3oB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAEwa,EAAS,SAAEnb,EAAQ,aAAElC,GAAiBxJ,EACpD69E,EAAYv3C,EAAsBzf,EAAWgzD,GACnDgE,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpCA,EAAU,GAAKp8E,KAAK+Q,MAAMqrE,EAAU,IACpC,MAAMyB,EAAYh5C,EAAsBzf,EAAWizD,GAInD,GAHAwF,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IACpCA,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IACpCA,EAAU,GAAK79E,KAAK+Q,MAAM8sE,EAAU,IAChC96E,KAAK0zE,gBAAgB2F,EAAWyB,EAAWjzE,GAAa,CACxD7H,KAAKooE,sBAAuB,EAC5B,MAMMlzD,EAAY,CACd,CAPSjY,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,KAO1C,CANS79E,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,KAM1C,CALS79E,KAAKa,IAAIu7E,EAAU,GAAIyB,EAAU,IACjC79E,KAAKkS,IAAIkqE,EAAU,GAAIyB,EAAU,OAMxC,WAAEnB,EAAU,YAAEC,IAAgB,OAAkCn6D,EAAiB2iB,EAAQizC,EAAWC,GACpG32B,EAAU,CAAC06B,EAAWyB,IACtB,MAAEt+E,EAAK,SAAEw8E,IAAa,QAAiCx9E,EAAOmjD,GAC9Ds6B,EAAOh8E,KAAK6e,IAAI69D,EAAaC,IAAgBp9E,EAAQA,GACrDi6E,EAAoB,CACtBl4E,aAAa,OAAoBrC,EAAUioB,GAC3CwyD,YAAa32E,KAAK22E,YAAYz6E,EAAUioB,EAAUyqB,EAAW1nC,SAASX,oBAEpEswE,GAAe,OAAmB3vE,EAASy8B,SAAUiL,EAAW1nC,SAASX,kBAAmBkwE,GAC5FvtC,EAAgBlkC,EAAa/D,QAAQjB,KAAKyM,cAAcgrE,gBAAgBsC,cAAe,CACzF7kE,YACAmN,YACAumB,aAAc5oC,KAAKyM,cAAc8qE,iBAE/B57E,EAAQqE,KAAKyM,cAAcgrE,gBAAgB0C,gBACjDv7B,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SACnBs1C,OACA31C,KAAM3nC,EAAM2nC,MAAMrjC,MAClBsjC,OAAQ5nC,EAAM4nC,QAAQtjC,MACtBkP,IAAKxT,EAAMwT,KAAKlP,MAChBm6E,WAAYz+E,EAAMqR,MAClBk8B,cAAeA,EACf8vC,WACAnC,eAER,MAEI72E,KAAKooE,sBAAuB,EAC5BxpB,EAAYz6B,GAAY,CACpBwf,SAAUz8B,EAASy8B,SAG/B,CACA,MAAMpoC,EAAcqzC,EAAWrzC,YAK/B,OAJAqzC,EAAWrzC,aAAc,EACrBA,IACA,IAAAuzC,2BAA0BF,EAAYzhB,EAAS,EAAA4hB,YAAYymC,cAExD52B,CAAW,EAEtB5+C,KAAK0zE,gBAAkB,CAACC,EAAQC,EAAQ/rE,IAC5B,kCAA8B8rE,EAAQ9rE,IAC1C,kCAA8B+rE,EAAQ/rE,GAE9C7H,KAAKu0E,gCAAiC,OAASv0E,KAAKw0E,sBAAuB,IAAK,CAAEQ,UAAU,GAChG,QACSh1E,KAAKqzE,QAAU,CAACnmD,EAAYze,EAAQrK,KACzC,MAAM9I,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEkZ,EAAe,SAAE6zD,EAAQ,SAAEp3E,GAAc8D,KAAKi1E,YAAYqvC,EAAkBhpH,EAAgBmT,EAAQrK,GAC9IwqC,EAAa,CACf2Q,cAAen7C,GAASm7C,eAAiB,qBACzCryC,KAAM,CACFyxC,QAAS,CACLlwC,SACAgqD,kBAAmB,MAEvB9mC,MAAO,GACPitB,YAAa,CAAC,GAElBH,aAAa,EACb80B,eAAe,EACfh4E,aAAa,EACb+1E,UAAU,EACVC,WAAW,EACXrqE,SAAU,CACNuxC,SAAU66B,EAAS50B,cACnBj/B,kBACAzV,sBACAzD,uBACGnC,KAGX,QAAcwqC,EAAY1yC,EAASixB,UACnC,OAAsC,CAACjxB,EAASmN,IAAI,CACrD,EAEP,SAAS4qE,EAAoB/mE,EAAMiX,GAC/B,MAAMsxD,EAAoBvoE,EAAK0xC,YAAYz6B,IACrC,KAAE80D,EAAI,KAAE31C,EAAI,IAAEn0B,EAAG,OAAEo0B,EAAM,SAAEy1C,EAAQ,aAAEnC,GAAiBpB,EAC5D,QAAaz3E,IAATslC,EACA,OAEJ,MAAMmxC,EAAY,GAKlB,OAJAA,EAAU9rE,KAAK,SAAS,wBAAoBswE,MAASD,KACrDvE,EAAU9rE,KAAK,SAAS,wBAAoB26B,MAASuzC,KACrDpC,EAAU9rE,KAAK,QAAQ,wBAAoBwG,MAAQ0nE,KACnDpC,EAAU9rE,KAAK,YAAY,wBAAoB46B,MAAWszC,KACnDpC,CACX,CACA,S,oRC3iBA,MAAM8vC,UAAkB,IACpB,WAAA9kH,CAAYo4C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCtrC,cAAe,CACX4lF,WAAY,CACRmyB,mBAAoB,KACpBC,oBAAqB,IACrBC,mBAAoB,KACpBC,oBAAqB,IACrBC,wBAAyB,IACzBC,wBAAyB,KACzBC,4CAA6C,MAEjDtyB,gBAAiB,qBACjBC,eAAgB,qBAChBsyB,UAAW,GACXC,uBAAuB,EACvBC,QAAS,CACLn+D,SAAS,EACTo+D,cAAe,CACX,EAAG,CAAC,IAAK,IAAK,IAAK,MAEvBC,cAAe,IACfC,oBAAqB,EACrBC,iBAAkB,EAClBC,WAAY,KAEhB7tD,QAAS,CACL,CAAC,EAAA8tD,kBAAkBC,eAAgB,CAC/B7tD,OAAQ,EAAA4tD,kBAAkBC,cAC1B5tD,SAAU,CACN,CACIz3D,IAAK,WAIjB,CAAC,EAAAolH,kBAAkBE,eAAgB,CAC/B9tD,OAAQ,EAAA4tD,kBAAkBE,cAC1B7tD,SAAU,CACN,CACIz3D,IAAK,YAIjB,CAAC,EAAAolH,kBAAkBG,aAAc,CAC7B/tD,OAAQ,EAAA4tD,kBAAkBG,YAC1B9tD,SAAU,CACN,CACIz3D,IAAK,MAGbsM,cAAe,CACXk5G,2BAA2B,EAC3BC,wBAAwB,EACxBC,oBAAoB,IAG5BC,yBAA0B,CACtBnuD,OAAQ,EAAA4tD,kBAAkBG,YAC1B9tD,SAAU,CACN,CACIz3D,IAAK,MAGbsM,cAAe,CAAC,OAK5B2qC,MAAMS,EAAWC,GACjB93C,KAAKw0D,iBAAoBvc,IACrBj4C,KAAKmoE,eAAe,EAExBnoE,KAAKy0D,iBAAmB,KACpBz0D,KAAKmoE,eAAe,EAExBnoE,KAAKm6C,kBAAqBlC,IACtBj4C,KAAKmoE,eAAe,EAExBnoE,KAAK84C,qBAAwBb,IACzB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,EACdtkC,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAK+lH,UAAY/lH,KAAKgmH,eAAe74F,GACrCntB,KAAKg/C,cAAc7xB,IACnB,IAAA8xB,mBAAkB9xB,GAClB8qB,EAAIiH,iBACJl/C,KAAKimH,aAAaC,QAAS,EAC3BlmH,KAAKimH,aAAaE,WAAaC,KAAKC,MACpC,MAAMC,EAAYtmH,KAAKumH,YAAcvmH,KAAKwmH,gBAAgBr5F,IAC1D,OAAuCm5F,EAAUznE,qBACjD,MAAMs0C,EAAgBnzF,KAAKymH,iBAAiBt5F,GAE5C,OADAntB,KAAK0mH,4BAA4BprH,EAAgB63F,EAAe,EAAAoyB,kBAAkBoB,qBAC3E,CAAI,EAEf3mH,KAAK+qD,kBAAqB9S,IACtB,GAAIj4C,KAAK++D,OAAS,EAAA/yB,UAAUH,OAAQ,CAEhC,GADA7rC,KAAKyuE,aAAax2B,IACbj4C,KAAKyM,cAAcw4G,QAAQn+D,QAC5B,OAEJ,MAAM,cAAEq+D,EAAa,oBAAEC,EAAmB,iBAAEC,GAAqBrlH,KAAKyM,cAAcw4G,SAC9E,cAAEnqE,EAAa,QAAE3tB,GAAY8qB,EAAI3lB,QACjC,OAAE72B,GAAWq/C,GACb,WAAElN,EAAU,MAAEg5E,EAAK,WAAET,EAAU,OAAED,GAAWlmH,KAAKimH,aACvD,GAAIC,EACA,OAEJ,MAAM3wG,EAAQ,cAAc9Z,EAAQmyC,GAC9Bi5E,EAAOT,KAAKC,MAAQF,EAW1B,IAVI5wG,EAAQ6vG,GACPyB,EAAO1B,GAAiB5vG,EAAQ8vG,KAC7BuB,IACAr5F,OAAOuhE,aAAa83B,GACpB5mH,KAAKimH,aAAaW,MAAQ,MAEzBV,GACDlmH,KAAK8mH,cAAc35F,KAGtBntB,KAAKimH,aAAaW,MAAO,CAC1B,MAAMA,EAAQr5F,OAAOoC,WAAW3vB,KAAK+mH,gBAAiB,KACtDnnH,OAAOm7D,OAAO/6D,KAAKimH,aAAc,CAC7BE,WAAYC,KAAKC,MACjBO,QACAh5E,WAAYnyC,EACZ0xB,WAER,CACJ,GAEJntB,KAAK+mH,gBAAkB,KACnB,GAAI/mH,KAAKimH,aAAaC,OAElB,YADAlmH,KAAKimH,aAAaW,MAAQ,MAG9B5mH,KAAKimH,aAAaW,MAAQ,KAC1B,MAAMzzB,EAAgBnzF,KAAKymH,iBAAiBzmH,KAAKimH,aAAa94F,SACxD7xB,GAAiB,IAAA48B,mBAAkBl4B,KAAKimH,aAAa94F,SAC3D,IAAK7xB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACfm3F,EAAiBzyF,KAAKyM,cAAcgmF,eACpCu0B,GAAe,OAAgB,CACjC7zB,gBACAj3F,WACA+qH,SAAUx0B,IAEd,IAAKU,EACD,OAEJ,MAAM1gE,EAAOzyB,KAAK8yB,WAAWqgE,EAAc7yB,eAAgB0mD,EAAapgB,0BACxE5mG,KAAKimH,aAAahB,QAAUjlH,KAAK0mH,6BAA4B,IAAAxuF,mBAAkBl4B,KAAKimH,aAAa94F,SAAU,IACpGgmE,KACA6zB,EACHv0F,QACD,EAAA8yF,kBAAkB2B,QAAQ,EAEjClnH,KAAKk4C,cAAiBD,IAClB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,EAAO,cAAE2tB,GAAkBlb,EAC7BtkC,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAKyuE,aAAax2B,GAClB,MAAM,oBAAE4G,GAAwB7+C,KAAKumH,YACrC,OAAuC1nE,GACvC,MAAMtpC,EAAQ,cAAculC,EAAcr/C,OAAQuE,KAAKimH,aAAar4E,aAC9D,WAAE03E,EAAU,iBAAED,GAAqBrlH,KAAKyM,cAAcw4G,SACvDjlH,KAAKimH,aAAaC,QACnBE,KAAKC,MAAQrmH,KAAKimH,aAAaE,WAAab,GAC5C/vG,EAAQ8vG,IAGRrlH,KAAKimH,aAAaW,QAClBr5F,OAAOuhE,aAAa9uF,KAAKimH,aAAaW,OACtC5mH,KAAKimH,aAAaW,MAAQ,MAE9B5mH,KAAKimH,aAAahB,QAAUjlH,KAAKozF,oBAAoB93F,EAAgB0E,KAAKymH,iBAAiBt5F,IAC3FntB,KAAKimH,aAAa94F,QAAUA,EAC5BntB,KAAKimH,aAAaE,WAAaC,KAAKC,MAAQf,EAC5CtlH,KAAKimH,aAAaC,QAAS,EAC3BlmH,KAAKimH,aAAar4E,WAAakN,EAAcr/C,OAAM,EAEvDuE,KAAKo/C,aAAgBnH,IACjB,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,EACdtkC,GAAiB,IAAA48B,mBAAkB/K,GACnCgmE,EAAgBnzF,KAAKymH,iBAAiBt5F,GACvCntB,KAAKimH,aAAahB,SAAYjlH,KAAKimH,aAAaC,SACjDlmH,KAAKozF,oBAAoB93F,EAAgB63F,GACzCnzF,KAAKkzE,gBAETlzE,KAAKq/C,gBAAgBlyB,IACrB,IAAAmyB,oBAAmBnyB,GACnBntB,KAAKyuE,aAAax2B,GAClBj4C,KAAK+lH,UAAY,KACjB/lH,KAAK0mH,4BAA4BprH,EAAgB63F,EAAe,EAAAoyB,kBAAkB4B,kBAC7EnnH,KAAKimH,aAAaC,QACnBlmH,KAAKonH,cAAcj6F,EACvB,EAEJntB,KAAKg/C,cAAiB7xB,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAOowB,SAAU7/C,KAAKo/C,cAC/CjyB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwB,WAAY9/C,KAAKk4C,eACjD/qB,EAAQ1E,iBAAiB,EAAAgH,OAAOuwB,YAAahgD,KAAKo/C,aAAa,EAEnEp/C,KAAKq/C,gBAAmBlyB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOowB,SAAU7/C,KAAKo/C,cAClDjyB,EAAQrE,oBAAoB,EAAA2G,OAAOqwB,WAAY9/C,KAAKk4C,eACpD/qB,EAAQrE,oBAAoB,EAAA2G,OAAOuwB,YAAahgD,KAAKo/C,aAAa,CAE1E,CACA,aAAA+oB,GACInoE,KAAKumH,gBAAavoH,EAClBgC,KAAK8mH,eACT,CACA,YAAAr4C,CAAax2B,GACT,MAAMrY,EAAYqY,EAAI3lB,QAChB,QAAEnF,GAAYyS,GACd,cAAEkb,GAAkBlb,EACpB2jB,EAAezI,EAAcr/C,OACnCuE,KAAKumH,WAAavmH,KAAKwmH,gBAAgBr5F,EAASo2B,GAChDvjD,KAAKqnH,iBAAiBl6F,EAASo2B,GAC1BvjD,KAAKumH,aAGV,OAAuCvmH,KAAKumH,WAAW1nE,oBAC3D,CACA,gBAAAwoE,CAAiBl6F,EAASo2B,GACtB,MAAMjoD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,GACf,cAAE8zB,GAAkBlzB,EACpBukB,EAASvkB,EAASwkB,aAClB,UAAEqkG,GAAc/kH,KAAKyM,cACrB21B,EAAS,gBAAgB3hB,EAAO2hB,OAAO,GAAI3hB,EAAO2hB,OAAO,GAAI3hB,EAAO2hB,OAAO,IAC3E3iB,EAAkB,gBAAgBgB,EAAOhB,gBAAgB,GAAIgB,EAAOhB,gBAAgB,GAAIgB,EAAOhB,gBAAgB,IAC/G6nG,EAAY,cAClB,WAAWA,EAAWllF,EAAQ3iB,GAC9B,MAAM8nG,EAAsBn4F,EAAc,CACtCm0B,EAAa,GACbA,EAAa,KAEXikE,EAAsB,cACtBC,EAAmB,cACnBC,EAAoB,cACpBC,EAAqB,cAC3B,IAAK,IAAIj+G,EAAI,EAAGA,GAAK,EAAGA,IACpB89G,EAAoB99G,GAAK69G,EAAoB79G,GAAK04B,EAAO14B,GAAKq7G,EAC9D0C,EAAiB/9G,GAAK69G,EAAoB79G,GAAK04B,EAAO14B,GAAKq7G,EAC3D2C,EAAkBh+G,GAAK69G,EAAoB79G,GAAK49G,EAAU59G,GAAKq7G,EAC/D4C,EAAmBj+G,GAAK69G,EAAoB79G,GAAK49G,EAAU59G,GAAKq7G,EAEpE,IAAK/kH,KAAKumH,WACN,OAEJ,MAAM,YAAEqB,GAAgB5nH,KAAKumH,YACvB,KAAEr5G,GAAS06G,OACI5pH,IAAjBkP,EAAKyxC,UACLzxC,EAAKyxC,QAAU,CAAC,GAEpBzxC,EAAKyxC,QAAQlwC,OAAS,CAClB+4G,EACAC,EACAC,EACAC,GAEJ,MAAMl1B,EAAiBzyF,KAAKyM,cAAcgmF,eACpCw0B,EAAWjnH,KAAKyM,cAAc4lF,WAAWI,GACG,mBAAvCw0B,GAAUY,0BACjBZ,EAASY,yBAAyB,CAC9Bp7G,cAAezM,KAAKyM,cACpBvQ,aAGRgR,EAAK3R,aAAc,CACvB,CACA,aAAA4+E,CAAchtD,EAASu5E,GACnB,IAAKv5E,EACD,OAEJ,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GAEzC,OADcntB,KAAK0mH,4BAA4BprH,EAAgB0E,KAAKymH,iBAAiBt5F,GAAU,EAAAo4F,kBAAkBuC,cAAephB,EAEpI,CACA,aAAAogB,CAAc35F,EAAUntB,KAAKimH,aAAa94F,SACtC,IAAKA,EACD,OAEJntB,KAAKkzE,eACL,MAAM53E,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAK0mH,4BAA4BprH,EAAgB0E,KAAKymH,iBAAiBt5F,GAAU,EAAAo4F,kBAAkBE,eACnGzlH,KAAKimH,aAAahB,QAAU,KAC5BjlH,KAAKimH,aAAaC,QAAS,CAC/B,CACA,aAAAkB,CAAcj6F,EAAUntB,KAAKimH,aAAa94F,SACjCA,GAGLiqB,MAAMgwE,cAAcj6F,EACxB,CACA,WAAA46F,CAAY56F,EAASgrC,GACjB,IAAKhrC,EACD,OAEJ,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAKimH,aAAahB,QAAUjlH,KAAK0mH,4BAA4BprH,EAAgB0E,KAAKymH,iBAAiBt5F,GAAU,EAAAo4F,kBAAkBG,YAAavtD,EAAO1rD,eACnJzM,KAAKimH,aAAaC,QAAS,CAC/B,CACA,qBAAA8B,GACI,QAAwBhqH,IAApBgC,KAAKumH,WACL,OAEJ,MAAM,KAAEr5G,GAASlN,KAAKumH,WAAWqB,aAC3B,SAAE1rH,GAAa8D,KAAKumH,WAC1Br5G,EAAK3R,aAAc,EACnB,MAAM,aAAEu3F,GAAiB9yF,KAAKioH,0BAA0B/rH,IAAa,CAAC,EACtE8D,KAAKumH,WAAWqB,YAAY1gH,SAAS4rF,aAAeA,CACxD,CACA,gBAAA1yC,CAAiB9kD,EAAgB+kD,GAC7B,IAAKrgD,KAAKumH,WACN,OAEJ,MAAM,SAAErqH,GAAaZ,EAErB,IAD4B0E,KAAKumH,WAAW1nE,oBACnBhkC,SAAS3e,EAASmN,IACvC,OAEJ,MAAMu+G,EAAc5nH,KAAKumH,WAAWqB,YACpC,IAAqC,IAAjCA,EAAY16G,KAAK3R,YAAsB,CACvC,MAAM,aAAEgoD,GAAiBvjD,KAAKumH,YACxB,QAAEp5F,GAAYjxB,EACpB8D,KAAKqnH,iBAAiBl6F,EAASo2B,EACnC,CACA,MAAM8vC,EAAeu0B,EAAY1gH,SACjC,IAAKmsF,EACD,OAEJ,MAAM9zC,EAAgB8zC,EAAa60B,eAC7Bh7G,EAAO06G,EAAY16G,MACnB,OAAEuB,GAAWvB,EAAKyxC,QAClB+B,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,KAC7Dq8D,EAASrqB,EAAkB,GAC3B/rC,EAAM+rC,EAAkB,GACxB9pC,EAAS,CACX3Z,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,GAClC1X,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAEhCmuB,EAAS7lC,KAAK6e,IAAIivD,EAAO,GAAK9tE,KAAK+Q,OAAO+8D,EAAO,GAAKp2D,EAAI,IAAM,IAChEvY,EAAQ,OAAOi3F,EAAaP,cAAcpyF,MAAM,EAAG,IAAM,CAAC,EAAG,EAAG,MACtE,IAAKxE,EAASiwB,qBAEV,YADA/b,QAAQC,KAAK,wCAIjB,IAAAogD,YAAcpQ,EAAkBd,EADd,IACwC3oC,EAAQksB,EAAQ,CACtE1mC,QACAwkD,SAAuD,IAA7C5gD,KAAKmoH,uBAAuB55B,aAAqB,CAAC,EAAG,GAAK,OAExE,MAAM,sBAAE65B,GAA0BpoH,KAAKyM,eAAe47G,WAAa,CAC/DD,sBAAuB,GAE3B,GAAIA,EAAuB,CACvB,MAAME,EAAa,KACnB,IAAA73D,YAAcpQ,EAAkBd,EAAe+oE,EAAY1xG,EAAQwxG,EAAuB,CACtFhsH,SAER,CACJ,EAEJmoH,EAAU9rE,SAAW,QACrB,S,8OC7We,MAAM25C,UAAyB,YACjCpyF,KAAKuoH,YAAc,CACxBtD,QAAS,KACT93F,QAAS,KACTg5F,WAAY,EACZS,MAAO,KACPh5E,WAAY,CAAC46E,IAAKA,KAClBtC,QAAQ,EACT,CACH,WAAAzmH,CAAYo4C,EAAWC,GACnBV,MAAMS,EAAWC,GACjB93C,KAAKyoH,QAAU,IAAIj3G,IACnBxR,KAAK0oH,gBAAkB,IAAIl3G,IAC3BxR,KAAKmoH,uBAAyB,CAC1B55B,aAAc,KACdo6B,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAgB,GAExB,CACA,mBAAAC,CAAoB7wE,GAChB,MAAM,GAAE5uC,EAAE,cAAEmpB,GAAkBylB,EAAI3lB,OAClC,GAAsB,aAAlBE,EAAJ,CAGA,GAAIxyB,KAAK0oH,gBAAgBrlH,IAAIgG,GAAK,CAC9BrJ,KAAKumH,WAAa,KAClB,MAAMwC,EAAW/oH,KAAK0oH,gBAAgBtoH,IAAIiJ,GACpC8jB,EAAU47F,GAAU57F,QACpBgmE,EAAgBnzF,KAAKymH,iBAAiBt5F,GAC5CgmE,EAAc5E,aAAew6B,GAAUx6B,aACnCphE,GACAntB,KAAK0mH,6BAA4B,IAAAxuF,mBAAkB/K,GAAUgmE,EAAe,EAAAoyB,kBAAkBC,cAEtG,CACAxlH,KAAKimH,aAAaC,QAAS,CAX3B,CAYJ,CACA,gBAAID,GACA,OAAO7zB,EAAiBm2B,WAC5B,CACA,UAAAz1F,CAAWwtC,EAAgBsmC,GACvB,MAAMoiB,EAAiBpiB,EAAyBv9F,GAChD,GAAIrJ,KAAKyyB,MACLzyB,KAAKyyB,KAAKm0E,2BAA6BA,EACvC,OAAO5mG,KAAKyyB,KAEhB,IAAIA,EAAOzyB,KAAKyoH,QAAQroH,IAAI4oH,GAY5B,OAXKv2F,EAKGA,EAAKw2F,mBACLx2F,EAAO,qBAAgC6tC,EAAgBsmC,GACvD5mG,KAAKyoH,QAAQvoH,IAAI8oH,EAAgBv2F,KANrCA,EAAO,qBAAgC6tC,EAAgBsmC,GACvD5mG,KAAKyoH,QAAQvoH,IAAI8oH,EAAgBv2F,IAQrCzyB,KAAKyyB,KAAOA,EACLA,CACX,CACA,cAAAuzF,CAAe74F,GACX,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfq3F,GAAqB,OAAsBz2F,EAASmN,IAC1D,IAAKspF,EAAoB,CACrB,MAAMzS,EAAQ,IAAI7tD,YAAY,EAAA6Z,MAAA,OAAag9E,YAAa,CACpD52F,OAAQ,CACJxrB,KAAM,eACNqiH,QAAS,qGAEbC,YAAY,IAGhB,OADA,EAAAj3F,YAAYC,cAAc8tD,GACnB,IACX,CACA,MAAM,eAAE5f,GAAmBqyB,EACrBC,GAAiB,IAAA0pB,yBAAwBh8C,IACzC,mBAAEyyB,IAAuB,OAAgBzyB,GAO/C,OANiBtgE,KAAKyzF,YAAY,CAC9Bv3F,WACA62F,qBACAH,iBACAtyB,kBAGR,CACA,WAAAmzB,EAAY,SAAEv3F,EAAQ,mBAAE62F,EAAkB,eAAEH,EAAc,eAAEtyB,IACxD,GAAIpkE,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAaioF,EAAmB,IAA4BvyB,UAC9D6oD,EAASntH,EAAS2kB,YAExB,GADwB3kB,aAAoB,IACvB,CACjB,MAAMgkF,EAAQ,IAAI7tD,YAAY,EAAA6Z,MAAA,OAAag9E,YAAa,CACpD52F,OAAQ,CACJxrB,KAAM,eACNqiH,QAAS,2DAEbC,YAAY,IAGhB,OADA,EAAAj3F,YAAYC,cAAc8tD,GACnB,IACX,CACA,MAAMopC,EAAUD,EAAOhjH,KAAK0P,GAAe,EAAAub,MAAM7M,UAAU1O,EAAW+K,gBAChEk6F,EAAqB,EAAA1pF,MAAM7M,UAAU3Z,GACrCy+G,EAAgCD,EAAQ5rG,MAAMoG,GAAW,oBAAgBA,EAAOjc,WAAYmzG,EAAmBnzG,eAAciD,UAAYw+G,EAAQ,IAAIx+G,SAC3J,MAAO,CACHA,WACA41B,mBAAoB1gC,KAAKyM,cAAc47G,WAAWv9G,UAC9Cy+G,EACJ32B,iBAER,CACK,CACD,MAAMK,GAAsB,QAAqC/2F,EAASmN,GAAIi3D,GAC9E,IAAK2yB,EACD,OAEJ,MAAO,CACH9uF,QAAS8uF,EACTL,iBAER,CACJ,CACA,eAAA4zB,CAAgBr5F,EAASo2B,GACrB,MAAMjoD,GAAiB,IAAA48B,mBAAkB/K,IACnC,SAAEjxB,GAAaZ,EACfmlB,EAASvkB,EAASwkB,aAClB,gBAAEjB,EAAe,OAAE2iB,GAAW3hB,EAC9Bo+B,EAAsB,CAAC3iD,EAASmN,KAChC,aAAEklF,EAAY,eAAEjuB,EAAc,aAAEwyB,GAAiB9yF,KAAKioH,0BAA0B/rH,IAAa,CAAC,EAYpG,MAAO,CACH0rH,YAZgB,CAChB1gH,SAAU,CACNuY,gBAAiB,IAAIA,GACrB2iB,OAAQ,IAAIA,GACZp4B,oBAAqB9N,EAASsiD,yBAC9Bj4C,kBAAmB,GACnBkyC,SAAUz4C,KAAK0+C,cACfo0C,gBAEJ5lF,KAAM,CAAC,GAIPq2C,eACAgrC,eACAryF,WACAokE,iBACAwyB,eACAj0C,sBAER,CACA,yBAAAopE,CAA0B/rH,GACtB,MAAMgxB,EAAahxB,EAASmN,GACtBmgH,GAAuB,OAAsBt8F,GACnD,IAAKs8F,EACD,OAEJ,MAAM,eAAElpD,GAAmBkpD,EACrBj7B,GAAe,OAAsBjuB,GAC3C,IAAKiuB,EACD,OAGJ,MAAO,CACHA,eACAjuB,iBACAwyB,cAJiB,IAAAkN,sBAAqB9yE,EAAYozC,EAAgBiuB,GAM1E,CACA,gBAAAk4B,CAAiBt5F,GACb,MAAM4xB,EAAW/+C,KAAK+lH,WAAa/lH,KAAKgmH,eAAe74F,IACjD,aAAEohE,EAAY,eAAEjuB,EAAc,YAAEsnD,GAAgB5nH,KAAKumH,YAAcvmH,KAAKwmH,gBAAgBr5F,IACxF,KAAEjgB,EAAI,SAAEhG,EAAW,CAAC,GAAM0gH,GAAe,CAAC,GAC1C,gBAAEnoG,EAAe,OAAE2iB,GAAWl7B,EAC9BuiH,EAAczpH,KAAKyM,cAAcw4G,SAASC,gBAAgB32B,IAC1D,SAAEryF,IAAa,IAAAg8B,mBAAkB/K,GACjC2lE,GAAe,IAAAkN,sBAAqB9jG,EAASmN,GAAIi3D,EAAgBiuB,GACvE,IAAKk7B,IAAgB32B,EACjB,OAEJ,IAAI42B,EAAe,KAAMC,EAAsB,KAC3C3pH,KAAKyM,cAAcw4G,QAAQn+D,UAC3B4iE,EAAeD,GAqJ3B,SAAsBzyG,EAAGC,EAAGC,EAAGgF,EAAG0tG,EAAS,IACvC,MAAO,CACH3sH,KAAKkkB,MAAMnK,GAAK,IAAMA,GAAK4yG,GAC3B3sH,KAAKkkB,MAAMlK,GAAK,IAAMA,GAAK2yG,GAC3B3sH,KAAKkkB,MAAMjK,GAAK,IAAMA,GAAK0yG,GAC3B1tG,EAER,CA5J0C2tG,IAAgB/2B,GAC9C62B,EAAsB,KAkB1B,MAhBsB,IACf5qE,EACHtwC,OAAQvB,GAAMyxC,SAASlwC,OACvB8/E,eACA9uE,kBACAqqG,gBAAiB9pH,KAAKimH,aAAaC,OACnC1sE,YAAax5C,KAAKw5C,YAClB8mB,iBACAl+B,SACA+lF,uBAAwBnoH,KAAKmoH,uBAC7B11B,eAAgBzyF,KAAKyM,cAAcgmF,eACnChmF,cAAezM,KAAKyM,cACpBi9G,eACAC,sBACA72F,WAAY9yB,KAAK8yB,WAAWtiB,KAAKxQ,MAGzC,CACA,UAAA+pH,CAAW58F,EAAUntB,KAAKimH,aAAa94F,QAAS/oB,GAC5C,MAAM,aAAE6hH,GAAiBjmH,KACnBgqH,EAAe5lH,GAAS4lH,cACT,IAAjBA,EACAhqH,KAAKonH,cAAcj6F,IAEG,IAAjB68F,GACLhqH,KAAK8mH,cAAc35F,GAEvB,MAAM7xB,GAAiB,IAAA48B,mBAAkB/K,GACnCi5E,EAAUpmG,KAAK0mH,4BAA4BprH,EAAgB0E,KAAKymH,iBAAiBt5F,GAAU,EAAAo4F,kBAAkB0E,YAEnH,OADAhE,EAAaC,QAAS,EACf9f,CACX,CACA,aAAA0gB,CAAc35F,EAAUntB,KAAKimH,aAAa94F,SACtC,IAAKA,EACD,OAEJntB,KAAKkzE,eACL,MAAM53E,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAK0mH,4BAA4BprH,EAAgB0E,KAAKymH,iBAAiBt5F,GAAU,EAAAo4F,kBAAkBE,eACnGzlH,KAAKimH,aAAahB,QAAU,KAC5BjlH,KAAKimH,aAAaC,QAAS,CAC/B,CACA,aAAAkB,CAAcj6F,EAAUntB,KAAKimH,aAAa94F,SACtC,IAAKA,EACD,OAEJ,MAAMgmE,EAAgBnzF,KAAKymH,iBAAiBt5F,GACxCntB,KAAKyyB,MAAQzyB,KAAKyyB,KAAKppB,IACvBrJ,KAAK0oH,gBAAgBxoH,IAAIF,KAAKyyB,KAAKppB,GAAI,CACnC8jB,UACAohE,aAAc4E,EAAc5E,eAGpC,MAAMjzF,GAAiB,IAAA48B,mBAAkB/K,GACzCntB,KAAK0mH,4BAA4BprH,EAAgB63F,EAAe,EAAAoyB,kBAAkBC,eAClFxlH,KAAKkzE,eACLlzE,KAAKimH,aAAahB,QAAU,KAC5BjlH,KAAKimH,aAAaC,QAAS,CAC/B,CACA,iCAAOgE,CAA2BhuH,EAAUkI,GACxC,MAAM+lH,EAAiB/lH,GAAS+lH,iBAAkB,EAC5C5pE,GAAc,IAAAyY,qBACdoxD,GAAkB,IAAAxH,6BAA4B1mH,EAAUqkD,GAC9D,IAAK6pE,GAAiBxpH,OAClB,OAEJ,MAAMypH,EAAqBD,EAAgBt1G,QAAQ85B,GAAeA,EAAW1hC,KAAK2gC,SAASohC,UAAUruE,SACrG,IAAKypH,EAAmBzpH,OACpB,OAEJ,MAQMqkH,EARgB,IAAI7yB,EAAiB,CAAC,EAAG,CAC3C3lF,cAAe,CACX4lF,WAAY,CACRmyB,mBAAoB,EAAA8F,kBAExB73B,eAAgB,wBAGMs3B,WAAW7tH,EAASixB,UAC5C,KAAEsF,EAAI,eAAE6tC,GAAmB2kD,EAC3BsF,EAAgB93F,GAAMztB,aACtBwlH,EAAqBD,EAAcE,oBAAsBF,GACzD,WAAE1iH,GAAe0iH,EACjBloG,EAAYnmB,EACb88C,kBACA7iC,MAAMmM,YACNC,eACL,IAAK,MAAMqsB,KAAcy7E,EAAoB,CACzC,MAAMn1G,EAAY,CACd,CAACyB,KAAWA,KACZ,CAACA,KAAWA,KACZ,CAACA,KAAWA,OAEV,SAAEs4D,GAAargC,EAAW1hC,KAAK2gC,QACrC,IAAK,MAAMv/B,KAAS2gE,EAAU,CACP5sD,EAAUkV,aAAajpB,GAC/BrN,SAAQ,CAACwO,EAAGw9B,KACnB/3B,EAAU+3B,GAAK,GAAKhwC,KAAKa,IAAIoX,EAAU+3B,GAAK,GAAIx9B,GAChDyF,EAAU+3B,GAAK,GAAKhwC,KAAKkS,IAAI+F,EAAU+3B,GAAK,GAAIx9B,EAAE,GAE1D,CACAyF,EAAUjU,SAAQ,CAACypH,EAAOz9E,KACtBy9E,EAAM,GAAKztH,KAAKkkB,MAAMlkB,KAAKkS,IAAI,EAAGu7G,EAAM,KACxCA,EAAM,GAAKztH,KAAKkkB,MAAMlkB,KAAKa,IAAI+J,EAAWolC,GAAO,EAAGy9E,EAAM,IAAI,IAElE,MAAMC,GAAc,OAAsBrqD,GACpC1yB,EAAagB,EAAW1hC,KAAKyxC,UAAU,IAAMswB,EAAS,GACtD27C,EAAavoG,EAAUkV,aAAaqW,GAAYvnC,IAAIpJ,KAAKkkB,OACzD0pG,EAAaL,EAAmB1zC,cAAc8zC,IAAe,EACnE,IAAIE,GAAe,EACfC,GAAmB,EACvB,IAAK,MAAMC,KAAa/7C,EAAU,CAC9B,MAAMg8C,EAAY5oG,EAAUkV,aAAayzF,GAAW3kH,IAAIpJ,KAAKkkB,OACvD+pG,EAAYV,EAAmB1zC,cAAcm0C,GAC/CC,IAAcL,EACdC,GAAe,EAEVI,GAAa,IAClBH,GAAmB,EAE3B,CACA,MACMx8B,EADUu8B,GAAgBC,EAE1BF,EACe,IAAfA,EACIF,EACA,EACV,IAAK,IAAIjhH,EAAIwL,EAAU,GAAG,GAAIxL,GAAKwL,EAAU,GAAG,GAAIxL,IAChD,IAAK,IAAIuI,EAAIiD,EAAU,GAAG,GAAIjD,GAAKiD,EAAU,GAAG,GAAIjD,IAChD,IAAK,IAAII,EAAI6C,EAAU,GAAG,GAAI7C,GAAK6C,EAAU,GAAG,GAAI7C,IAAK,CACrD,MAAM64B,EAAa7oB,EAAUS,aAAa,CAACpZ,EAAGuI,EAAGI,KAC7B,IAAA84G,yBAAwBjgF,EAAY+jC,IAEpDs7C,EAAca,SAAS1hH,EAAGuI,EAAGI,EAAGk8E,EAExC,CAGJ47B,IACA,IAAAziE,kBAAiB9Y,EAAW2Q,cAEpC,CACA,MAAM8rE,EAASd,EAAce,4BAC7B,IAAArzB,iCAAgC33B,EAAgB+qD,EACpD,E,sKClVJ,MAAM,sBAAEvpF,EAAqB,QAAEnJ,GAAY,YACrC4yF,EAAmB,CACrB,CAAC,EAAAhG,kBAAkBiG,YAAcr4B,IAC7B,MAAM,OAAE1kF,EAAM,SAAEvS,EAAQ,sBAAEuvH,GAA2Bt4B,EACrD,IAAK1kF,EACD,OAEJ,MAAMmI,EAAS,gBAAgB,EAAG,EAAG,GACrCnI,EAAOxN,SAASqN,IACZ,SAASsI,EAAQA,EAAQtI,EAAM,IAEnC,WAAWsI,EAAQA,EAAQ,EAAInI,EAAO7N,QACtCuyF,EAAc74C,YAAc1jC,EAC5Bu8E,EAAcu4B,UAAY5pF,EAAsB2pF,EAAuB70G,GACvE,MAAM8pC,EAAoBjyC,EAAOpI,KAAKqI,GAAMxS,EAASwjD,cAAchxC,MAC5DixC,EAAe3oB,IAAqB,IAAA8gD,yBAAwBp3B,GAC7DxpB,EAAeh7B,EAASkzB,cAAcuwB,GACtCvoB,EAAmBl7B,EAASkzB,cAAc4H,GAC1C20F,EAAmBl9G,EAAOpI,KAAKiyC,GAC1BxW,EAAsB2pF,EAAuBnzE,KAElDpjC,GAAY,IAAA02G,8BAA6BD,EAAkBF,EAAsB5oG,iBACvFswE,EAAcnZ,WAAa6xC,EAAqB,CAC5C30F,eACAE,mBACAxgB,WAEJu8E,EAAc24B,oBAAsB52G,CAAS,GAGrD,SAAS22G,EAAqBE,GAC1B,MAAM,aAAE70F,EAAY,iBAAEE,EAAgB,OAAExgB,GAAWm1G,EAC7CvyC,EAAUv8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC5DqiD,EAAUx8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC5DsiD,EAAUz8E,KAAK6e,IAAIob,EAAa,GAAKE,EAAiB,IAAM,EAC5D0L,EAAS7lC,KAAKkS,IAAIqqE,EAASC,EAASC,GAC1C,GAAI/gD,EAAQ6gD,EAAS12C,IACjBnK,EAAQ8gD,EAAS32C,IACjBnK,EAAQ+gD,EAAS52C,GAAS,CAC1B,MAAMkpF,EAAY,CACdp1G,SACAksB,SACAmpF,QAASnpF,EAASA,GAEtB,OAAQiH,IAAa,OAAciiF,EAAWjiF,EAClD,CACA,MAAMwvC,EAAa,CACf3iE,OAAQA,EACR4iE,UACAC,UACAC,YAEE,cAAEwyC,IAAkB,IAAAC,4BAA2B5yC,EAAY,CAAC,GAClE,OAAO2yC,CACX,CACA,MAAME,EAAkB,IAAI,IAAc,SAAU,IAAaC,WAAY,IAAaC,SAAUf,EAAkB,IAAagB,sBAAuB,IAAatH,QAAS,IAAauH,oBACvLC,EAA4B,IAAI,IAAc,kBAAmB,IAAaJ,WAAY,IAAaC,SAAUf,EAAkB,IAAagB,sBAAuB,IAAaG,iBAAkB,IAAarE,UAAW,IAAapD,QAAS,IAAav2B,cAAe,IAAa89B,oBAC7RlC,EAAmB8B,EAAgBO,iBACnCC,EAAwBH,EAA0BE,gB,qJCzDxD,MAAM,sBAAE7qF,GAA0B,YAC5B+qF,EAAsB,CACxB,CAAC,EAAAtH,kBAAkBiG,YAAcr4B,IAC7B,MAAM,OAAE1kF,EAAM,kBAAEq+G,EAAiB,SAAE5wH,EAAQ,sBAAEuvH,EAAqB,yBAAE7kB,GAA8BzT,EAClG,IAAK1kF,EACD,OAEJ,MAAMmI,EAAS,gBAAgB,EAAG,EAAG,GACrCnI,EAAOxN,SAASqN,IACZ,SAASsI,EAAQA,EAAQtI,EAAM,IAEnC,WAAWsI,EAAQA,EAAQ,EAAInI,EAAO7N,QACtCuyF,EAAc74C,YAAc1jC,EAC5Bu8E,EAAcu4B,UAAY5pF,EAAsB2pF,EAAuB70G,GACvE,MAAM,UAAE1B,EAAS,eAAEyzB,GAK3B,SAAgCzsC,EAAUuS,EAAQg9G,GAC9C,IAAIsB,EAAsBt+G,EAAOpI,KAAKiyC,GAC3BxW,EAAsB2pF,EAAuBnzE,KAExDy0E,EAAsBA,EAAoB1mH,KAAKiI,GACpCA,EAAMjI,KAAK2mH,GACP/vH,KAAKkkB,MAAM6rG,OAG1B,MAAM93G,GAAY,IAAA02G,8BAA6BmB,EAAqBtB,EAAsB5oG,iBACpFoqG,EAAkB/wH,aAAoB,EAAAi8B,cACtC+0F,EAAYD,IAAmB,OAAuBF,GACtD9kH,EAAYwjH,EAAsBhpG,eAClC3a,EAAU2jH,EAAsB0B,cAChC,gBAAE1tG,GAAoBvjB,EAASwkB,YAC/B0sG,EAAM,wCAAoC,CAC5CnlH,YACAH,WACD2X,GACG4tG,GAAkB,IAAAtoB,gCAA+Bt2F,GACvD,KAAM6+G,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASN,EACjDC,GAAQF,EACRG,GAAQH,EACRI,GAAQJ,EACRK,GAAQL,EACRM,GAAQN,EACRO,GAAQP,EACR,MAAMzkF,EAAiBukF,EACjB,KAAM,EACLnjF,IACC,MAAOzsC,EAAGE,EAAGqR,GAAKk7B,EAIlB,OAHgBzsC,GAAKgwH,GAAQhwH,GAAKiwH,IAClB/vH,GAAKgwH,GAAQhwH,GAAKiwH,KAClB5+G,GAAK6+G,GAAQ7+G,GAAK8+G,EACE,EAE5C,MAAO,CAAEz4G,YAAWyzB,iBACxB,CA1C8CilF,CAAuB1xH,EAAUuS,EAAQg9G,GAC/Et4B,EAAcnZ,WAAarxC,EAC3BwqD,EAAc24B,oBAAsB52G,CAAS,GAyCrD,MAAM24G,EAAqB,IAAI,IAAc,YAAa,IAAaxB,WAAY,IAAaC,SAAUO,EAAqB,IAAaN,sBAAuB,IAAatH,QAAS,IAAauH,oBAChMsB,EAA+B,IAAI,IAAc,qBAAsB,IAAazB,WAAY,IAAaC,SAAUO,EAAqB,IAAaN,sBAAuB,IAAaG,iBAAkB,IAAarE,UAAW,IAAapD,QAAS,IAAav2B,cAAe,IAAa89B,oBACtSuB,EAAsBF,EAAmBlB,iBACdmB,EAA6BnB,gB,0LCP9D,SAASqB,EAAkC9xH,EAAUsjB,EAAUC,GAC3D,MAAMrZ,EAAWlK,EAASy3B,cAC1B,IAAKvtB,IAAaA,EAASxF,OACvB,OAEJ,MAAMmb,EAAqB3V,EAASC,KAAKlC,IACrC,MAAM,qBAAE6D,GAAyB,EAAAopB,SAAA,IAAa,mBAAoBjtB,GAC5D6X,EAMd,SAAkCwD,EAAUyuG,EAAsBxuG,GAC9D,MAAMM,EAAM,cACZ,SAASA,EAAKP,EAAUyuG,GACxB,MAAMjuG,EAAM,SAASD,EAAKN,GAC1B,OAAOxiB,KAAK6e,IAAIkE,EACpB,CAXyBkuG,CAAyB1uG,EAAUxX,EAAsByX,GAC1E,MAAO,CAAEtb,UAAS6X,WAAU,IAGhC,OADAD,EAAmBE,MAAK,CAACC,EAAGhF,IAAMgF,EAAEF,SAAW9E,EAAE8E,WAC1CD,EAAmB,GAAG5X,OACjC,C,gDCjEA,QATA,SAAuC+Q,EAAWi5G,GAC9C,MAAMC,EAAmBl5G,EAAU1C,WAAU,EAAE1U,EAAKqR,KAASrR,IAAQqR,IACrE,IAA0B,IAAtBi/G,EACA,MAAM,IAAIhwH,MAAM,uDAIpB,OAFA8W,EAAUk5G,GAAkB,IAAMD,EAClCj5G,EAAUk5G,GAAkB,IAAMD,EAC3Bj5G,CACX,C,2RCPO,SAASm5G,EAAiCz/E,GAC7C,GAAIA,EAAW0/E,oBACX,OAEJ,IAAK1/E,EAAW1hC,KAAK6gF,aACjB,MAAM,IAAI3vF,MAAM,kFAEpB,MAAM,eAAEkiE,EAAc,aAAEiuB,GAAiB3/C,EAAW1hC,KAAK6gF,aACnDA,GAAe,OAAgBztB,GAChCytB,EAAagF,mBAAmB0M,UACjC1R,EAAagF,mBAAmB0M,QAAU,CAAEka,kBAAmB,IAAInoG,MAEvE,IAAI,kBAAEmoG,GAAsB5rB,EAAagF,mBAAmB0M,QACvDka,IACDA,EAAoB,IAAInoG,KAE5B,IAAI+8G,EAAqB5U,GAAmBv5G,IAAImuF,GAC3CggC,IACDA,EAAqB,IAAI11F,IACzB8gF,EAAkBz5G,IAAIquF,EAAcggC,IAExC5U,EAAkBz5G,IAAIquF,EAAcggC,EAAmBjrH,IAAIsrC,EAAW2Q,eAC1E,C,+QCrBA,MAAM,QAAE5mB,GAAY,YACL,SAASssD,EAAwBr2C,EAAY2qB,GACxD,MAAM,SAAE0V,GAAargC,EAAW1hC,KAAK2gC,SAC/B,OAAEp/B,GAAWmgC,EAAW1hC,KAAKyxC,SAC7B,OAAE/9C,GAAW6N,EACnB,GAAI8qD,IAAgB34D,EAChB,OAAOquE,EAASruE,OAKpB,GAHI24D,EAAc,IACdA,GAAeA,EAAc34D,GAAUA,GAEvB,IAAhB24D,EACA,OAAO,EAEX,MAAMD,EAAS7qD,EAAO8qD,GAChB/wD,EAAQymE,EAASz8D,WAAWlE,GAAUqqB,EAAQ2gC,EAAQhrD,KAC5D,IAAe,IAAX9F,EACA,OAAOA,EAEX,IAAIgmH,EAAkB73G,IACtB,OAAOs4D,EAAS9yC,QAAO,CAACwtC,EAAcr7D,EAAOmgH,KACzC,MAAMzyG,EAAW,qBAAqB1N,EAAOgrD,GAC7C,OAAIt9C,EAAWwyG,GACXA,EAAkBxyG,EACXyyG,GAEJ9kD,CAAY,IACnB,EACR,C,6FCkFA,QA/GA,SAAkBx8D,EAAMuhH,EAAMtqH,GAC1B,IAAIuqH,EAAUC,EAAUC,EAASnzF,EAAQozF,EAASC,EAC9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACTl6C,GAAW,EACf,MAAMm6C,GAAUT,GAAiB,IAATA,GAAsD,mBAAjCnhG,OAAO8hE,sBACpD,GAAoB,mBAATliF,EACP,MAAM,IAAIiiH,UAAU,uBASxB,SAASC,EAAWxI,GAChB,MAAM/gB,EAAO6oB,EACPW,EAAUV,EAIhB,OAHAD,EAAWC,OAAW5wH,EACtBgxH,EAAiBnI,EACjBnrF,EAASvuB,EAAKgW,MAAMmsG,EAASxpB,GACtBpqE,CACX,CACA,SAAS6zF,EAAWC,EAAad,GAC7B,OAAIS,EACO5hG,OAAO8hE,sBAAsBmgC,GAEjC7/F,WAAW6/F,EAAad,EACnC,CAoBA,SAASe,EAAa5I,GAClB,MAAM6I,EAAoB7I,EAAOkI,EAEjC,YAAyB/wH,IAAjB+wH,GACJW,GAAqBhB,GACrBgB,EAAoB,GACnBR,GAJuBrI,EAAOmI,GAIGH,CAC1C,CACA,SAASc,IACL,MAAM9I,EAAOT,KAAKC,MAClB,GAAIoJ,EAAa5I,GACb,OAAO+I,EAAa/I,GAExBiI,EAAUS,EAAWI,EArBzB,SAAuB9I,GACnB,MACMgJ,EAAsBhJ,EAAOmI,EAC7Bc,EAAcpB,GAFM7H,EAAOkI,GAGjC,OAAOG,EACDjyH,KAAKa,IAAIgyH,EAAajB,EAAUgB,GAChCC,CACV,CAcuCC,CAAclJ,GACrD,CACA,SAAS+I,EAAa/I,GAElB,OADAiI,OAAU9wH,EACNg3E,GAAY25C,EACLU,EAAWxI,IAEtB8H,EAAWC,OAAW5wH,EACf09B,EACX,CAcA,SAASs0F,KAAalqB,GAClB,MAAM+gB,EAAOT,KAAKC,MACZ4J,EAAaR,EAAa5I,GAIhC,GAHA8H,EAAW7oB,EACX8oB,EAAW5uH,KACX+uH,EAAelI,EACXoJ,EAAY,CACZ,QAAgBjyH,IAAZ8wH,EACA,OAzDZ,SAAqBjI,GAGjB,OAFAmI,EAAiBnI,EACjBiI,EAAUS,EAAWI,EAAcjB,GAC5BO,EAAUI,EAAWxI,GAAQnrF,CACxC,CAqDmBw0F,CAAYnB,GAEvB,GAAIG,EAEA,OADAJ,EAAUS,EAAWI,EAAcjB,GAC5BW,EAAWN,EAE1B,CAIA,YAHgB/wH,IAAZ8wH,IACAA,EAAUS,EAAWI,EAAcjB,IAEhChzF,CACX,CAIA,OAnGAgzF,EAAO1iH,OAAO0iH,IAAS,GACnB,OAAStqH,KACT6qH,EAAUkB,QAAQ/rH,EAAQ6qH,SAC1BC,EAAS,YAAa9qH,EACtByqH,EAAUK,EAASjyH,KAAKkS,IAAInD,OAAO5H,EAAQyqH,UAAY,EAAGH,GAAQG,EAClE75C,EAAW,aAAc5wE,EAAU+rH,QAAQ/rH,EAAQ4wE,UAAYA,GA2FnEg7C,EAAU/kH,OAjCV,gBACoBjN,IAAZ8wH,GA3CR,SAAqBzlH,GACjB,GAAI8lH,EACA,OAAO5hG,OAAO6iG,qBAAqB/mH,GAEvCylF,aAAazlF,EACjB,CAuCQgnH,CAAYvB,GAEhBE,EAAiB,EACjBL,EAAWI,EAAeH,EAAWE,OAAU9wH,CACnD,EA4BAgyH,EAAUM,MA3BV,WACI,YAAmBtyH,IAAZ8wH,EAAwBpzF,EAASk0F,EAAaxJ,KAAKC,MAC9D,EA0BA2J,EAAUO,QAzBV,WACI,YAAmBvyH,IAAZ8wH,CACX,EAwBOkB,CACX,C,8BC/Ge,SAASr7C,EAAuB67C,GAC3C,MAAMhuG,EAKV,SAA2BukD,GACvB,MAAM0pD,EAAqB,CAAC1pD,EAAa,GAAIA,EAAa,IAAI9qD,KAAKy0G,GAC7DC,EAAqB,CAAC5pD,EAAa,GAAIA,EAAa,IAAI9qD,KAAK20G,GAC7DrnD,EAAQknD,EAAmBA,EAAmB7vH,OAAS,GACvD+T,EAAMg8G,EAAmB,GACzB5lD,EAAS4lD,EAAmBA,EAAmB/vH,OAAS,GAC9D,MAAO,CACH+T,MACAo2D,SACAxB,SAEJ,SAASmnD,EAAUx0G,EAAGhF,GAClB,OAAOgF,EAAE,GAAKhF,EAAE,IAAM,EAAI,CAC9B,CACA,SAAS05G,EAAU10G,EAAGhF,GAClB,OAAOgF,EAAE,GAAKhF,EAAE,IAAM,EAAI,CAC9B,CACJ,CAtBoB25G,CAAkBL,GAC5BM,GAAWtuG,EAAQ7N,IAAI,GAAK6N,EAAQuoD,OAAO,IAAM,EAEvD,MADsB,CAACvoD,EAAQ+mD,MAAM,GAAIunD,EAE7C,C,mLCJA,MAAM,iBAAEC,GAAqB,EAAA7kF,MACvB8kF,EAAc,KACdC,EAAc,SACdC,EAA8B,CAChC,EACA,EACA,EACA,GAEEC,EAA2B,CAC7B,MACA,OAEEC,EAA0B,CAC5B,MACA,OAEEC,EAAe,CACjB,EAAG,KACH,EAAG,UACH,EAAG,KACH,EAAG,KACH,EAAG,UACH,EAAG,QACH,EAAG,aACH,EAAG,SACH,EAAG,MACH,EAAG,QACH,GAAK,WAGHC,EAAS,IACTC,EAAmC,CAAC/1H,EAAOmjD,KAC7C,MAAM,YAAEnkC,EAAW,gBAAEg3G,GAAoBh2H,EACzC,IAAI84E,EAAOk9C,EAAkB,KAAOR,EACpC,MAAMS,EAAaD,EAAkB,MAAWP,EAChD,IAAIj4C,EAAW1E,EAAOg9C,EAClB90H,EAAQ,EACRk1H,EAAkB,GACtB,IAAKl3G,IACCA,EAAY1T,OAAS0T,EAAYm3G,4BACnC,MAAO,CAAEr9C,OAAM0E,WAAUx8E,QAAOi1H,cAEpC,GAAIj3G,EAAY1T,OAASiqH,EAAiBa,aACtC,MAAO,CACHt9C,KAAM08C,EACNh4C,SAAUg4C,EAAcM,EACxB90H,QACAi1H,WAAYR,GAGpB,GAAIz2G,EAAYm3G,4BAA6B,CACzC,IAAIjmC,EAAaC,EACjB,GAAIjtF,MAAMC,QAAQggD,IAA+B,IAAnBA,EAAQ/9C,QACjC8qF,EAAaC,GAAehtC,OAE5B,GAAuB,mBAAZA,EAAwB,CACpC,MAAMlwC,EAASkwC,IACf+sC,EAAcj9E,EAAO,GACrBk9E,EAAcl9E,EAAO,EACzB,CACA,IAAIojH,EAAUr3G,EAAYm3G,4BAA4B78G,QAAQg9G,GAAWpmC,EAAY,IAAMomC,EAAOC,qBAC9FrmC,EAAY,IAAMomC,EAAOE,qBACzBtmC,EAAY,IAAMomC,EAAOG,qBACzBvmC,EAAY,IAAMomC,EAAOI,qBACzBvmC,EAAY,IAAMmmC,EAAOC,qBACzBpmC,EAAY,IAAMmmC,EAAOE,qBACzBrmC,EAAY,IAAMmmC,EAAOG,qBACzBtmC,EAAY,IAAMmmC,EAAOI,sBAC7B,IAAKL,GAASjxH,OACV,MAAO,CAAE0zE,OAAM0E,WAAUx8E,QAAOi1H,cAIpC,GAFAI,EAAUA,EAAQ/8G,QAAQg9G,GAAWZ,EAA4Br2G,SAASi3G,EAAOK,iBAC7EhB,EAAyBt2G,SAAS,GAAGi3G,EAAOM,2BAA2BN,EAAOO,8BAC7ER,EAAQjxH,OACT,MAAO,CACH0zE,KAAM08C,EACNh4C,SAAUg4C,EAAcM,EACxB90H,QACAi1H,WAAYR,GAGpB,MAAMa,EAASD,EAAQ,GACjBS,EAAiBr1H,KAAK6e,IAAIg2G,EAAOQ,gBACjCC,EAAiBt1H,KAAK6e,IAAIg2G,EAAOS,gBAEvC,IAD4B,EAAAjmF,UAAA,QAAkBgmF,EAAgBC,EAvD1D,MA+DA,MAAO,CACHj+C,KAAM08C,EACNh4C,SAAUg4C,EAAcM,EACxB90H,QACAi1H,WAAYR,GAVhBz0H,EAAQ,EAAI81H,EACZZ,EAAkB,YAClBp9C,EAAO+8C,EAAaS,EAAOM,0BAA4B,UACvDp5C,EAAW1E,EAAOg9C,CAU1B,MACS92G,EAAYhe,QACjBA,EAAQge,EAAYhe,OAWxB,MATc,CACVu0H,EAAiByB,KACjBzB,EAAiB0B,KACjB1B,EAAiB2B,MACjB3B,EAAiB4B,YAEX93G,SAASL,GAAa1T,QAC5B4qH,EAAkBl3G,EAAY1T,MAE3B,CACHwtE,KAAMA,GAAQo9C,EAAkB,IAAIA,IAAoB,IACxD14C,SAAUA,GAAY04C,EAAkB,IAAIA,IAAoB,IAChEl1H,QACAi1H,WAAYA,GAAcC,EAAkB,IAAIA,IAAoB,IACvE,EAECkB,EAAkC,CAACp3H,EAAOmjD,KAC5C,MAAOv9B,GAAcu9B,GACf,YAAEnkC,GAAgBhf,EACxB,IAAIy7E,EAAQ,CAAC,OACTt8D,EAAS,CAAC,MACV+2G,EAAkB,GACtB,IAAKl3G,IACCA,EAAY1T,OAAS0T,EAAYm3G,4BACnC,MAAO,CAAE16C,QAAOt8D,UAEpB,GAAIH,EAAYm3G,4BAA6B,CACzC,MAAMkB,EAA2Br4G,EAAYm3G,4BAA4B78G,QAAQg9G,GAAWZ,EAA4Br2G,SAASi3G,EAAOK,iBACpIf,EAAwBv2G,SAAS,GAAGi3G,EAAOM,2BAA2BN,EAAOO,6BACjF,IAAKQ,GAA0BjyH,OAC3B,MAAO,CAAEq2E,QAAOt8D,UAEpB,MAAMm3G,EAASe,EAAyBn1G,MAAMo0G,GAAW1wG,EAAW,IAAM0wG,EAAOC,qBAC7E3wG,EAAW,IAAM0wG,EAAOE,qBACxB5wG,EAAW,IAAM0wG,EAAOG,qBACxB7wG,EAAW,IAAM0wG,EAAOI,sBAC5B,IAAKJ,EACD,MAAO,CAAE76C,QAAOt8D,UAEpB,MAAM,iBAAEm4G,EAAmB,EAAC,iBAAEC,EAAmB,GAAMjB,GACjD,eAAEQ,EAAc,eAAEC,GAAmBT,EACrCkB,GAAU5xG,EAAW,GAAK0wG,EAAOG,oBAAsBc,GACzDR,EAGJb,EAAkB,YAClB/2G,EAAS,EAHOyG,EAAW,GAAK0wG,EAAOC,oBAAsBe,GACzDR,EAEcU,GAClB/7C,EAAQ,CACJo6C,EAAaS,EAAOM,yBACpBf,EAAaS,EAAOO,yBAE5B,CACA,MAAO,CACHp7C,QACAt8D,SACA+2G,kBACH,EAECuB,EAAuBz3H,GAAUA,EAAMgf,aAAaugE,QAAU,C,2FChKpE,MAAM,sBAAEj5C,GAA0B,YAClC,SAASoxF,EAAqBC,EAAc9wG,EAAW+wG,GACnD,MAAOroD,EAAQp2D,GAAOw+G,EAChB74E,EAAc,iBAAiBywB,EAAO,GAAKp2D,EAAI,IAAM,GAAIo2D,EAAO,GAAKp2D,EAAI,IAAM,GAAIo2D,EAAO,GAAKp2D,EAAI,IAAM,GACzG0+G,EAAc,cAActoD,EAAQp2D,GAAO,GAC3C,UAAEO,EAAS,aAAEgiB,EAAY,iBAAEE,GAsCrC,SAA2B/U,EAAW+wG,EAAkBD,EAAc74E,EAAa+4E,GAC/E,MAAMxrH,EAAawa,EAAUQ,iBACrBxR,IAAKiiH,EAAW/xE,OAAQgyE,EAActsF,OAAQusF,GAAeJ,EAC/Dl8F,EAAe,cACfE,EAAmB,cACzB,iBAAiBF,EAAcojB,EAAak5E,EAAWH,GACvD,iBAAiBj8F,EAAkBkjB,EAAak5E,GAAYH,GAC5D,iBAAiBn8F,EAAcA,EAAcq8F,GAAeF,GAC5D,iBAAiBj8F,EAAkBA,EAAkBm8F,EAAcF,GACnE,iBAAiBn8F,EAAcA,EAAco8F,GAAYD,GACzD,iBAAiBj8F,EAAkBA,EAAkBk8F,EAAWD,GAChE,MAAMI,EAAa3xF,EAAsBzf,EAAW6U,GAC9Cw8F,EAAiB5xF,EAAsBzf,EAAW+U,GAClDu8F,EAAYR,EAAa9sH,KAAKqI,GAAMozB,EAAsBzf,EAAW3T,KACrEwG,GAAY,IAAA02G,8BAA6B,CAAC6H,EAAYC,KAAmBC,GAAY9rH,GAC3F,MAAO,CAAEqN,YAAWgiB,eAAcE,mBACtC,CAtD0Dw8F,CAAkBvxG,EAAW+wG,EAAkBD,EAAc74E,EAAa+4E,GAChI,MAAO,CACHn+G,YACAolC,YAAaA,EACb+4E,cACAn8F,aAAcA,EACdE,iBAAkBA,EAE1B,CACA,SAASy8F,EAAoBV,EAAc9wG,GACvC,MAAMpa,EAAYoa,EAAUI,eACtB6wG,EAAY,gBAAgBrrH,EAAU,GAAIA,EAAU,GAAIA,EAAU,IAClEsrH,EAAe,gBAAgBtrH,EAAU,GAAIA,EAAU,GAAIA,EAAU,IACrE6rH,EAAW,gBAAgB7rH,EAAU,GAAIA,EAAU,GAAIA,EAAU,IAOvE,OAAOirH,EAAqBC,EAAc9wG,EALjB,CACrBhR,IAAKiiH,EACL/xE,OAAQgyE,EACRtsF,OAJoB,YAAY,cAAe6sF,IAOvD,CACA,SAASC,EAAgCZ,EAAc9wG,EAAWnmB,GAC9D,IAAKA,EACD,MAAM,IAAIkC,MAAM,gEAEpB,MAAMqiB,EAASvkB,EAASwkB,YAClB0hB,EAAS,gBAAgB3hB,EAAO2hB,OAAO,GAAI3hB,EAAO2hB,OAAO,GAAI3hB,EAAO2hB,OAAO,IAC3E3iB,EAAkB,gBAAgBgB,EAAOhB,gBAAgB,GAAIgB,EAAOhB,gBAAgB,GAAIgB,EAAOhB,gBAAgB,IAC/G6nG,EAAY,cAClB,WAAWA,EAAWllF,EAAQ3iB,GAM9B,OAAOyzG,EAAqBC,EAAc9wG,EALjB,CACrBhR,IAAKi2G,EACLrgF,OAAQxnB,EACR8hC,OAAQ,YAAY,cAAenf,IAG3C,C,+DC5Ce,SAAS4xF,EAAyBplF,GAC7C,MAAMh1B,GAAY,OAA0Bg1B,GAC5C,OAAOh1B,EAAUhZ,OAASgZ,EAAU,QAAK5b,CAC7C,C,gDCAA,QAJA,SAAkBiC,GACd,MAAM6G,SAAc7G,EACpB,OAAiB,OAAVA,IAA4B,WAAT6G,GAA8B,aAATA,EACnD,C,oVCHe,SAASmtH,EAAcC,EAAQnqF,GAC1C,MAAM,OAAEnzB,EAAM,OAAEksB,GAAWoxF,EACrBjI,EAAUiI,EAAOjI,SAAWnpF,EAASA,EAC3C,OAASiH,EAAS,GAAKnzB,EAAO,KAAOmzB,EAAS,GAAKnzB,EAAO,KACrDmzB,EAAS,GAAKnzB,EAAO,KAAOmzB,EAAS,GAAKnzB,EAAO,KACjDmzB,EAAS,GAAKnzB,EAAO,KAAOmzB,EAAS,GAAKnzB,EAAO,KAClDq1G,CACR,C,yFCLA,MAAM,QAAEtzF,GAAY,YAIdw7F,EAAW,CAHH,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,IAEpC,SAASC,EAAuBrH,GAC5B,MAAMsH,EAAgB,cAAc,cAAetH,EAAoB,GAAIA,EAAoB,IACzFuH,EAAgB,cAAc,cAAevH,EAAoB,GAAIA,EAAoB,IAO/F,MAJkB,IAFCwH,EAAwBF,EAAeF,MACvCI,EAAwBD,EAAeH,IACT5nG,OAAOzvB,GAAU67B,EAAQ77B,EAAO,IAC7E67B,EAAQ77B,EAAO,KACf67B,EAAQ77B,EAAO,MACf67B,EAAQ77B,EAAO,MAEvB,CACA,SAASy3H,EAAwBC,EAAKj2B,GAClC,OAAOA,EAAKl4F,KAAKk0C,GAAkC,IAAxB,WAAWi6E,EAAKj6E,GAAet9C,KAAKC,IACnE,C,8CCnBe,MAAMu3H,SACRz0H,KAAK00H,YAAc,IAAIljH,GAAO,QAC9BxR,KAAK20H,QAAU,EAAI,QACnB30H,KAAK++D,KAAO,YAAc,CACnC,gBAAO61D,CAAUxwH,GACb,MAAM,eAAEmzE,EAAc,QAAEo9C,EAAO,KAAE51D,GAAS36D,EAC1CpE,KAAK++D,KAAOA,EACZ/+D,KAAK20H,QAAUA,EACf30H,KAAK00H,YAAY5gH,QACC,eAAd9T,KAAK++D,KACL41D,EAAQ1zH,SAASuH,IACbxI,KAAK00H,YAAYx0H,IAAIsI,EAAO,IAAI,KAA6B,CAAE+uE,mBAAkB,IAIrFv3E,KAAK00H,YAAYx0H,IAAIy0H,EAAS,IAAI,KAA6B,CAAEp9C,mBAEzE,CACA,oBAAOwC,CAAc7sE,GACjB,MAAM,aAAEqhF,KAAiBsmC,GAAc3nH,EACvC,IAAKqhF,EACD,MAAM,IAAInwF,MAAM,mDAEpB,MAAM02H,EAA2B,eAAd90H,KAAK++D,KAClB/+D,KAAK00H,YAAYt0H,IAAImuF,GACrBvuF,KAAK00H,YAAYt0H,IAAIJ,KAAK20H,SAChC,IAAKG,EACD,MAAM,IAAI12H,MAAM,mCAAmCmwF,KAEvDumC,EAAW/6C,cAAc86C,EAC7B,CACA,oBAAO16C,CAAc/1E,GACjB,GAAkB,eAAdpE,KAAK++D,KAAuB,CAC5B,MAAMrjC,EAAS,CAAC,EAIhB,OAHA17B,KAAK00H,YAAYzzH,SAAQ,CAAC6zH,EAAYvmC,KAClC7yD,EAAO6yD,GAAgBumC,EAAW36C,cAAc/1E,EAAQ,IAErDs3B,CACX,CAEA,OADmB17B,KAAK00H,YAAYt0H,IAAIJ,KAAK20H,SAC3Bx6C,cAAc/1E,EACpC,E,8ECwEJ,SAAS2wH,EAAKC,EAAQC,EAAWr0H,GAG7B,OAFc,IAAIlC,MAAMkC,EAAS,GACf8qB,KAAKupG,GACTD,GAAQt0H,OAAOE,EACjC,C,iBACA,QAvHA,SAAmBqU,EAAQigH,EAAM9wH,EAAU,CAAC,GACxC,MAAM+wH,EAAU/wH,EAAQ+wH,QAClBC,EAAahxH,EAAQgxH,WACrBC,EAASjxH,EAAQixH,OACjBvgH,EAAS1Q,EAAQ0Q,OACjBN,EAAYpQ,EAAQoQ,YAAa,EACjC8gH,EAAYl1H,EAAI80H,GAChBK,EA6EN,WACI,MAAMA,EAMV,SAAiB30H,GACb,MAAM40H,EAAQ,GACRC,EAAc,SAAUT,GAC1B,OAAOA,EAAO5yH,MAAM,IAAIiE,KAAI,SAAUi1B,GAClC,OAAOM,SAASN,EAAG,IAAM,CAC7B,GACJ,EACA,IAAK,IAAI5xB,EAAI,EAAGA,EAAIzM,KAAKy5D,IAAI,EAAG91D,GAAS8I,GAAK,EAAG,CAC7C,MAAMsrH,EAASD,EAAKrrH,EAAE2V,SAAS,GAAI,IAAKze,GACxC40H,EAAM7sH,KAAK8sH,EAAYT,GAC3B,CACA,OAAOQ,CACX,CAlByBE,CAAQR,EAAKt0H,QAClC,OAAO20H,EAAazgH,QAAO,SAAU6gH,GACjC,MAAM1mH,EAkBlB,SAAwBjC,GACpB,IAAIiC,EAAQ,EACZ,IAAK,IAAIvF,EAAI,EAAGA,EAAIsD,EAAMpM,OAAQ8I,GAAK,EAClB,IAAbsD,EAAMtD,KACNuF,GAAS,GAGjB,OAAOA,CACX,CA1B0B2mH,CAAeD,GAC7B,OAAiB,IAAV1mH,IAA0B,IAAVA,GAAeuF,EAC1C,GACJ,CAnFqBqhH,GACf3hH,EAAQ,GACR0jF,EAAU,GACVk+B,EAAS,IAAIj9F,IACbtS,EAASniB,EAAQmiB,OAEvB,IADArS,EAAMvL,KAAK,CAAEotH,YAAab,IACnBhhH,EAAMtT,OAAS,GAClBwT,EAAMF,EAAMrJ,OAEhB,MAAO,CACH+sF,WAEJ,SAASxjF,EAAM4hH,GACX,MAAMC,EAAUD,EAAID,YACdG,EAAWF,EAAIG,aACjB5zB,EAAQ0zB,KAiBhB,SAAuB91H,GACnB,MAAO7C,EAAGE,EAAGqR,EAAI,GAAK1O,EAChBi2H,EAAO94H,EAAI,MAAQ,OAASE,EAAI,MAAQ,OAASqR,EAAI,QAC3DinH,EAAOxyH,IAAI8yH,EACf,CAlBIC,CAAcJ,GAmBlB,SAAgBA,GACZ,MAAMlrF,EAAO3qC,EAAI61H,GACjB,OAAOZ,EAASA,EAAOtqF,EAAMuqF,GAAavqF,IAASuqF,CACvD,CArBQgB,CAAOL,IAsBf,SAAuBA,GACnBr+B,EAAQjvF,KAAKstH,GACTd,GACAA,KAAWc,EAEnB,CA1BQM,CAAcN,GAmCtB,SAAsBA,GAClB,IAAK,IAAIvsH,EAAI,EAAGA,EAAI6rH,EAAa30H,OAAQ8I,GAAK,EAAG,CAC7C,MAAMisH,EAAOJ,EAAa7rH,GACpB8sH,EAAWP,EAAQv1H,MAAM,GAC/B,IAAK,IAAIuR,EAAI,EAAGA,EAAIgkH,EAAQr1H,OAAQqR,GAAK,EACrCukH,EAASvkH,IAAM0jH,EAAK1jH,IAEG,IAAvB6C,IAAS0hH,KAGTj0B,EAAQi0B,IAGZtiH,EAAMvL,KAAK,CACPotH,YAAaS,EACbL,aAAcF,IAEtB,CACJ,CApDQQ,CAAaR,IA0BrB,SAAwBC,GACpB,MAAO54H,EAAGE,EAAGqR,EAAI,GAAKqnH,EAChBE,EAAO94H,EAAI,MAAQ,OAASE,EAAI,MAAQ,OAASqR,EAAI,QAC3D0X,GAAQrmB,IAAIk2H,EAAMF,GACdd,GACAA,KAAcc,EAEtB,CA9BQQ,CAAeR,GAEvB,CACA,SAAS3zB,EAAQpiG,GACb,MAAO7C,EAAGE,EAAGqR,EAAI,GAAK1O,EAChBi2H,EAAO94H,EAAI,MAAQ,OAASE,EAAI,MAAQ,OAASqR,EAAI,QAC3D,OAAOinH,EAAOzyH,IAAI+yH,EACtB,CA2CA,SAASh2H,EAAI61H,GACT,OAAOhhH,KAAUghH,EACrB,CAqBJ,C,yECtGO,SAASU,EAAsBn9E,EAAaf,GAC/C,MAAMk0C,GAAY,IAAApzC,cAAaC,GAC/B,QAAkBx7C,IAAd2uF,EACA,OAEJ,MAAMiqC,EAAgBjqC,EAAUE,eAChC,IAAKjtF,OAAO4B,KAAKo1H,GAAeh2H,OAC5B,OAEJ,GAAI63C,GAAYm+E,EAAcn+E,GAC1B,MAAO,CAACm+E,EAAcn+E,IAG1B,OADgC74C,OAAO+a,OAAOi8G,GAAe9hH,QAAQqrD,GAAiBA,aAAwB,KAElH,C,yECdO,SAASu/B,EAAwCp/B,GACpD,MAAMytB,GAAe,IAAAiF,iBAAgB1yB,IAC/B,kBAAEq5C,GAAsB5rB,EAAagF,mBAAmB0M,QAC9D,IAAK,MAAOlR,EAAcsoC,KAAmBld,EAAkB1wF,UAAW,CAEtE,GADiCvqB,MAAM6D,KAAKs0H,GAAgBn5G,MAAM6hC,IAAkB,QAAcA,GAAed,cAE7G,OAAO8vC,CAEf,CAEJ,C,qFCTO,SAASiR,EAAgCl/B,EAAgBp1B,GAAY,SAAEhvC,EAAQ,aAAE+iG,IACpF,MACMhO,GADe,IAAA+B,iBAAgB1yB,GACHyyB,mBAAmBvyB,SACrD,GAAItkE,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAammF,EACf+pB,EAAqB,EAAA1pF,MAAM7M,UAAU3Z,GAC3C,IAAKkwG,EACD,OAEJ,MAAMh2G,EAAeg2G,EAAmBh2G,aAClCqd,EAAY24F,EAAmB34F,UAC/By0G,EAAW,EAAAxqF,UAAA,sBAAgCjqB,EAAW6oB,GACtDqjD,EAAevpF,EAAaszF,SAASw+B,EAAS,GAAIA,EAAS,GAAIA,EAAS,IAExEC,EAiDd,SAA+B/rF,EAAaujD,EAAcryF,EAAUmmB,EAAW48E,GAC3E,MAAM+3B,EAAmB,CAACC,EAAQC,KAC9B,MAAMC,EAAiB,CAACnsF,EAAY,GAAKisF,EAAQjsF,EAAY,GAAKksF,GAC5DhsF,EAAahvC,EAASkzB,cAAc+nG,GACpCnyH,EAAeqd,EAAUjiB,IAAI,gBAAgB4E,aAC7C8xH,EAAW,EAAAxqF,UAAA,sBAAgCjqB,EAAW6oB,GAC5D,OAAOlmC,EAAaszF,SAASw+B,EAAS,GAAIA,EAAS,GAAIA,EAAS,GAAG,EAEvE,OAAOM,EAAgBJ,EAAkBzoC,EAAc0Q,EAC3D,CA1DuBo4B,CADKn7H,EAASwjD,cAAcxU,GACOqjD,EAAcryF,EAAUmmB,EAAW48E,GACrF,OAAO83B,EAASxoC,OAAevwF,CACnC,CACA,MAAMi1F,GAAsB,IAAAC,sCAAqCh3F,EAASmN,GAAIi3D,GAE9E,IADc,EAAAhvC,MAAM2lE,SAAShE,GAEzB,OAEJ,MAAMqkC,GAAyB,QAAsBp7H,EAASmN,GAAIi3D,GAC5Dj+C,EAAYi1G,GAAwBnhH,MAAMmM,YAAYC,eACtDu0G,EAAW,EAAAxqF,UAAA,sBAAgCjqB,EAAW6oB,GACtDrjC,EAAawa,EAAUQ,gBACvB7d,EAAgBqd,EAAUrd,cAC5B,EAAAsnC,UAAA,aAAuBu6D,+BAA+B,CAClDh/F,aACA1C,WAAYkd,EAAUymB,eAAeC,aAAaC,YAEpDulD,EAAevpF,EAAa8xE,cAAcggD,GAC1CC,EAoBV,SAA4BD,EAAUjvH,EAAY7C,EAAcupF,EAAc0Q,GAC1E,MAAM+3B,EAAmB,CAACC,EAAQC,EAAQK,KACtC,MAAMC,EAAc,CAChBV,EAAS,GAAKG,EACdH,EAAS,GAAKI,EACdJ,EAAS,GAAKS,GAElB,OAAOvyH,EAAaszF,SAASk/B,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAG,EAEhF,OAAOJ,EAAgBJ,EAAkBzoC,EAAc0Q,EAC3D,CA9BmBw4B,CAAmBX,EAAUjvH,EAAY7C,EAAcupF,GACtE,OAAOwoC,EAASxoC,OAAevwF,CACnC,CACA,SAASo5H,EAAgBJ,EAAkBzoC,EAAc0Q,EAAe,GACpE,MAAMy4B,EAAgBh5H,MAAM6D,KAAK,CAAE3B,OAAQ,EAAIq+F,EAAe,IAAK,CAAC1gF,EAAG7U,IAAMA,EAAIu1F,IACjF,IAAK,MAAMg4B,KAAUS,EACjB,IAAK,MAAMR,KAAUQ,EACjB,IAAK,MAAMH,KAAUG,EAAe,CAChC,GAAe,IAAXT,GAA2B,IAAXC,GAA2B,IAAXK,EAChC,SAEJ,MAAMI,EAAgBX,EAAiBC,EAAQC,EAAQK,GACvD,QAAsBv5H,IAAlB25H,GAA+BppC,IAAiBopC,EAChD,OAAO,CAEf,CAGR,OAAO,CACX,C,sHChDO,SAASp4B,EAA4Bj/B,EAAgBp1B,EAAY9mC,EAAU,CAAC,GAC/E,MAAM2pF,GAAe,IAAAiF,iBAAgB1yB,GAC/ByyB,EAAqBhF,EAAagF,mBAClC6kC,EAAwBxzH,GAASyzH,oBAAsBj4H,OAAO4B,KAAKuxF,GAAoB,GAC7F,IAAK6kC,EACD,MAAM,IAAIx5H,MAAM,gBAAgBkiE,uCAEpC,OAAQs3D,GACJ,KAAK,EAAAr3D,4BAA4BC,SAC7B,OAOL,SAA2CutB,EAAc7iD,GAAY,SAAEhvC,IAC1E,MAAM+0F,EAAelD,EAAagF,mBAAmBvyB,SACrD,GAAItkE,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAM,SAAEl4C,GAAammF,EACf+pB,EAAqB,EAAA1pF,MAAM7M,UAAU3Z,GAC3C,IAAKkwG,EACD,OAGJ,OADqBA,EAAmB34F,UAAUy1G,wBAAwB5sF,EAE9E,CACA,MAAMomE,GAAuB,IAAAmD,uCAAsCv4G,EAASmN,GAAI0kF,EAAaztB,gBAC7F,GAAIgxC,EAAqB1wG,OAAS,EAE9B,YADAwP,QAAQC,KAAK,mGAGjB,MAAM4iF,EAAsBqe,EAAqB,GAEjD,IADc,EAAAhgF,MAAM2lE,SAAShE,GAEzB,OAEJ,MAAMqkC,GAAyB,QAAsBp7H,EAASmN,GAAI0kF,EAAaztB,gBACzEj+C,EAAYi1G,GAAwBnhH,MAAMmM,YAAYC,eACtDu0G,EAAW,EAAAxqF,UAAA,sBAAgCjqB,EAAW6oB,GACtDrjC,EAAawa,EAAUQ,gBACvB7d,EAAgBqd,EAAUrd,cAC5B,EAAAsnC,UAAA,aAAuBu6D,+BAA+B,CAClDh/F,aACA1C,WAAYkd,EAAUymB,eAAeC,aAAaC,YAG1D,OADqBhkC,EAAa8xE,cAAcggD,EAEpD,CAvCmBiB,CAAkChqC,EAAc7iD,EAAY9mC,GACvE,KAAK,EAAAm8D,4BAA4Bk/B,QAC7B,OAsCL,SAA0C1R,EAAc7iD,GAAY,SAAEhvC,IACzE,MAAMu9G,EAAc1rB,EAAagF,mBAAmB0M,QAC9CiH,EAAiBhoG,MAAM6D,KAAKk3G,EAAYE,kBAAkBn4G,SAC1D,gBAAEie,GAAoBvjB,EAASwkB,YACrC,IAAK,MAAM6tE,KAAgBmY,EAAgB,CACvC,MAAMsxB,EAAiBve,EAAYE,kBAAkBv5G,IAAImuF,GACzD,GAAKypC,EAGL,IAAK,MAAMz4E,KAAiBy4E,EAAgB,CACxC,MAAMppF,GAAa,QAAc2Q,GACjC,IAAK3Q,EACD,SAEJ,MAAM,SAAEqgC,GAAargC,EAAW1hC,KAAK2gC,QACrC,GAAK,EAAAvB,UAAA,QAAkB7sB,EAAiBmvB,EAAW1nC,SAASuY,mBAGxD,IAAA0rG,yBAAwBjgF,EAAY+jC,GACpC,OAAOjjE,OAAOuiF,EAEtB,CACJ,CACJ,CA7DmB0pC,CAAiClqC,EAAc7iD,EAAY9mC,GACtE,QACI,OAEZ,C,+CCrBA,MAkJA,EAlJe,4+J,4QCEf,MACM8zH,EAAsB,cACtBC,EAA0B,CAC5BC,WAAY,EACZC,kBAAmB,IACnBC,WAAY,CACRC,kBAAmB,EACnBC,wBAAyB,EACzBnQ,UAAW,OAGnBrvF,eAAe40D,EAAW6qC,EAAmB3nC,EAAkB1sF,EAAU+zH,GACrE,MAAMO,EAAgB,CAAC,EAAG,EAAG,IACvB,WAAEN,EAAU,kBAAEC,GAAsBz4H,OAAOm7D,OAAO,CAAC,EAAGo9D,EAAyB/zH,GAC/Ek0H,EAAa14H,OAAOm7D,OAAO,CAAC,EAAGo9D,EAAwBG,WAAYl0H,EAAQk0H,YAC3Ex0G,EAAS,EAAAwN,MAAM7M,UAAUg0G,GACzBE,EAAW,EAAArnG,MAAM7M,UAAUqsE,IAC1B9xF,EAASC,EAAM8jC,GAAajf,EAAOjc,WAC1C,GAAI8wH,EAAS9wH,WAAW,KAAO7I,GAC3B25H,EAAS9wH,WAAW,KAAO5I,GAC3B05H,EAAS9wH,WAAW,KAAOk7B,EAC3B,MAAM,IAAI3kC,MAAM,+CAEpB,IAAIw6H,EAAgB37H,KAAK+Q,MAAM/Q,KAAKwmC,KAAKxkC,GAAQ,EAAID,GAAW,EAAI+jC,GAAa,GAAK,GACtF61F,EAAgB37H,KAAKa,IAAI86H,EAAe,KACxC,MAAM3nC,EAAe0nC,EAAS3zH,aAAaw8B,6BAC3C,IAAIq3F,EAAkB/0G,EAAO9e,aAAaw8B,6BACpCq3F,aAA2B5vH,eAC7B4vH,EAAkB,IAAI5vH,aAAa4vH,IAEvC,MAAMC,EAAiB,CACnBC,4BAA6Bb,EAC7Bc,cAAed,GAEbe,QAAgBC,UAAUC,KAAKC,kBAC/BC,QAAeJ,EAAQK,cAAc,CAAER,mBACvCS,EAAcV,EAAgB3uH,WAC9BsvH,EAAqCZ,EAAgBa,YAAYC,kBACjEC,EAAqB,EAAIC,WAAWF,kBACpCG,EAAeR,EAAOS,mBAAmB,CAC3CC,KAAM,MAGJC,EAAoB,IAAIP,YAAY,CACtCz6H,EACAC,EACA8jC,EACA,IAEEk3F,EAAkBZ,EAAOa,aAAa,CACxC1xG,KAAMwxG,EAAkB9vH,WACxBiwH,MAAOC,eAAeC,QAAUD,eAAeE,WAE7CC,EAA2BlB,EAAOa,aAAa,CACjD1xG,KAAM+wG,EACNY,MAAOC,eAAeI,QAAUJ,eAAeE,WAEnDjB,EAAOoB,MAAMC,YAAYH,EAA0B,EAAG1B,GACtD,MAAM8B,EAAqB,CAAC,EAAG,GAAGt0H,KAAI,IAAMgzH,EAAOa,aAAa,CAC5D1xG,KAAM+wG,EACNY,MAAOC,eAAeI,QAClBJ,eAAeQ,SACfR,eAAeE,aAEvBjB,EAAOoB,MAAMC,YAAYC,EAAmB,GAAI,EAAG,IAAIlB,YAAYxoC,IACnE,MAAM4pC,EAAqB,CAAC,EAAG,GAAGx0H,KAAI,IACXgzH,EAAOa,aAAa,CACvC1xG,KAAM+wG,EACNY,MAAOC,eAAeI,QAClBJ,eAAeQ,SACfR,eAAeE,aAIrBQ,EAAmBzB,EAAOa,aAAa,CACzC1xG,KAAMgxG,EACNW,MAAOC,eAAeI,QAClBJ,eAAeQ,SACfR,eAAeE,WAEjBS,EAAkB1B,EAAOa,aAAa,CACxC1xG,KAAMmxG,EACNQ,MAAOC,eAAeI,QAClBJ,eAAeQ,SACfR,eAAeE,WAEjBU,EAAgB,IAAIpB,WAAW,CACjC56H,EACAC,EACA8jC,GACC,GACA,GACA,IAELs2F,EAAOoB,MAAMC,YAAYK,EAAiB,EAAGC,GAC7C,MAAMC,EAAkB5B,EAAO6B,sBAAsB,CACjDjyG,QAAS,CACL,CACIkyG,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,YAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,sBAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,YAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,YAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,sBAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,sBAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,YAGd,CACIq0H,QAAS,EACTxtG,WAAYytG,eAAeC,QAC3Bz+E,OAAQ,CACJ91C,KAAM,eAKhBw0H,EAAa,CAAC,EAAG,GAAGj1H,KAAKqD,IAC3B,MAAM6xH,EAAuBZ,EAAmBjxH,GAC1C8xH,EAAuBX,EAAmBnxH,GAC1C+xH,EAAwBd,GAAoBjxH,EAAI,GAAK,GACrDgyH,EAAyBb,GAAoBnxH,EAAI,GAAK,GAC5D,OAAO2vH,EAAOsC,gBAAgB,CAC1BC,OAAQX,EACRhyG,QAAS,CACL,CACIkyG,QAAS,EACTU,SAAU,CACNj/E,OAAQq9E,IAGhB,CACIkB,QAAS,EACTU,SAAU,CACNj/E,OAAQ29E,IAGhB,CACIY,QAAS,EACTU,SAAU,CACNj/E,OAAQ2+E,IAGhB,CACIJ,QAAS,EACTU,SAAU,CACNj/E,OAAQ4+E,IAGhB,CACIL,QAAS,EACTU,SAAU,CACNj/E,OAAQ6+E,IAGhB,CACIN,QAAS,EACTU,SAAU,CACNj/E,OAAQ8+E,IAGhB,CACIP,QAAS,EACTU,SAAU,CACNj/E,OAAQk+E,IAGhB,CACIK,QAAS,EACTU,SAAU,CACNj/E,OAAQm+E,MAItB,IAEAe,EAAWzC,EAAO0C,sBAAsB,CAC1CH,OAAQvC,EAAO2C,qBAAqB,CAChCC,iBAAkB,CAAChB,KAEvBiB,QAAS,CACLC,OAAQtC,EACRuC,WAAY,OACZC,UAAW,CACPC,eAAgB5D,EAAc,GAC9B6D,eAAgB7D,EAAc,GAC9B8D,eAAgB9D,EAAc,GAC9BN,iBAINqE,EAAgB,CAClBx/H,KAAK2mH,KAAK5kH,EAAU05H,EAAc,IAClCz7H,KAAK2mH,KAAK3kH,EAAOy5H,EAAc,IAC/Bz7H,KAAK2mH,KAAK7gF,EAAY21F,EAAc,KAElCgE,EAAuCrD,EAAOa,aAAa,CAC7D1xG,KAAMgxG,EACNW,MAAOC,eAAeuC,SAAWvC,eAAeE,WAE9CsC,EAAsBvE,EACtBwE,YAAYxW,MAAQgS,EACpB,EACN,IAAIyE,EAAqCxE,EAAWC,kBAChDwE,EAAwB,EAC5B,IAAK,IAAIrzH,EAAI,EAAGA,EAAIkvH,EAAelvH,IAAK,CACpCswH,EA1MsB,GA0MiBtwH,EACvC2vH,EAAOoB,MAAMC,YAAYT,EAAiB,EAAGD,GAC7C,MAAMgD,EAAiB3D,EAAO4D,uBACxBC,EAAcF,EAAeG,mBACnCD,EAAYE,YAAYtB,GACxBoB,EAAYG,aAAa,EAAG/B,EAAW5xH,EAAI,IAC3CwzH,EAAYI,mBAAmBb,EAAc,GAAIA,EAAc,GAAIA,EAAc,IACjFS,EAAYlrH,MACZgrH,EAAeO,mBAAmBzC,EAAkBpxH,EAAI+vH,YAAYC,kBAAmBgD,EAAsChzH,EAAI+vH,YAAYC,kBAAmBD,YAAYC,mBAC5KL,EAAOoB,MAAM+C,OAAO,CAACR,EAAeS,WAEpC,GADgB/zH,EAAI,KAAOA,EAAIozH,GAClB,OACHJ,EAAqCgB,SAASC,WAAWC,KAAM,EAAGpE,GACxE,MAAMqE,EAAmCnB,EAAqCoB,eAAe,EAAGtE,GAE1FuE,EADiC,IAAItE,YAAYoE,EAAiCn9H,MAAM,IACpCgJ,GAAKmvH,EAAgBj4H,OAE/E,GADA87H,EAAqCsB,QACjCt0H,GAAK,GAAKq0H,EAAqBzF,EAAWjQ,WAG1C,GAFAyU,EAAqC,EACrCC,IACIA,IAA0BzE,EAAWE,wBACrC,WAIJsE,EAAqCxE,EAAWC,iBAExD,CACA,GAAIqE,GAAuBC,YAAYxW,MAAQuW,EAAqB,CAChExsH,QAAQC,KAAK,mCAAmCgoH,QAChD,KACJ,CACJ,CACA,MAAM2E,EAAiB3D,EAAO4D,uBACxBgB,GAA6BrF,EAAgB,GAAK,EAClDsF,EAAwB7E,EAAOa,aAAa,CAC9C1xG,KAAM+wG,EACNY,MAAOC,eAAeuC,SAAWvC,eAAeE,WAE9C6D,EAAsB9E,EAAOa,aAAa,CAC5C1xG,KAAMmxG,EACNQ,MAAOC,eAAeuC,SAAWvC,eAAeE,WAEpD0C,EAAeO,mBAAmB5C,EAAmBsD,GAA4B,EAAGC,EAAuB,EAAG3E,GAC9GyD,EAAeO,mBAAmBxC,EAAiB,EAAGoD,EAAqB,EAAGxE,GAC9EN,EAAOoB,MAAM+C,OAAO,CAACR,EAAeS,iBAC9BS,EAAsBR,SAASC,WAAWC,KAAM,EAAGrE,GACzD,MAAM6E,EAAuBF,EAAsBJ,eAAe,EAAGvE,GAC/D8E,EAAiB,IAAI5E,YAAY2E,GACvCntC,EAAa/wF,IAAIm+H,GACjBH,EAAsBF,cAChBG,EAAoBT,SAASC,WAAWC,KAAM,EAAGjE,GACvD,MAAM2E,EAAqBH,EAAoBL,eAAe,EAAGnE,GAC3D4E,EAAe,IAAI3E,WAAW0E,EAAmB59H,MAAM,IAC7Dy9H,EAAoBH,QACpB,MAAM16G,EAAOi7G,EAAa,GACpB19F,EAAO09F,EAAa,GACpBx9F,EAAOw9F,EAAa,GACpBh7G,EAAOg7G,EAAa,GACpBz9F,GAAOy9F,EAAa,GACpBv9F,GAAOu9F,EAAa,GAC1B5F,EAAS3zH,aAAak9B,2BAA2B+uD,GACjD0nC,EAAS3zH,aAAaw5H,cACtB7F,EAAS3zH,aAAay5H,UAAU,CAC5B,CAACn7G,EAAMC,GACP,CAACsd,EAAMC,IACP,CAACC,EAAMC,KAEf,C,0ECxTA,MAAM09F,EAAsB,IACtBC,EAAsB,IACtBlvC,EAAuB,EAAE94E,KAAW,KACpC+4E,EAAuB,CAAC,EAAG,MA8EjC12D,eAAe4lG,EAAmDv9F,EAAWj9B,GACzE,MAAMu0H,EAAW,EAAApnB,aAAA,oCAAiDlwE,EAAUv2B,UAG5E,OA7BJ,SAAgCu2B,EAAWs3F,EAAUv0H,GACjD,MAAM,kBAAEwsF,EAAoB8tC,EAAmB,mBAAE7uC,EAAqBH,GAA0BtrF,EAC1Fy6H,EAAkBx9F,EAAUr8B,aAAaw8B,8BAExC5kC,EAAOC,EAAQkmC,IADD41F,EAAS3zH,aAAaw8B,6BACRm3F,EAAS9wH,YACtC20C,EAAmBv/C,KAAK+Q,MAAM+0B,EAAY,GAC1C+7F,EAAkB7hI,KAAKkS,IAAIqtC,EAAmB,EAAG,GACjDuiF,EAAiB9hI,KAAKkS,IAAI2vH,EAAkB,EAAG/7F,GAC/Ci8F,EAAiBpiI,EAAQC,EAC/B,IAAK,IAAIgS,EAAIiwH,EAAiBjwH,EAAIkwH,EAAgBlwH,IAAK,CACnD,MAAMowH,EAAUpwH,EAAImwH,EACpB,IAAK,IAAIxhI,EAAI,EAAGA,EAAIX,EAAQW,IAAK,CAC7B,MAAM8yD,EAAU9yD,EAAIZ,EACpB,IAAK,IAAIU,EAAI,EAAGA,EAAIV,EAAOU,IAAK,CAC5B,MAAMkL,EAAQy2H,EAAU3uE,EAAUhzD,EAC5B6zF,EAAa0tC,EAAgBr2H,GACX2oF,GAActB,EAAmB,IACrDsB,GAActB,EAAmB,IAEjC8oC,EAAS3zH,aAAa8yF,WAAWtvF,EAAOooF,EAEhD,CACJ,CACJ,CACJ,CAGIsuC,CAAuB79F,EAAWs3F,EAAUv0H,GA/EhD,SAAgCi9B,EAAWs3F,EAAUv0H,GACjD,MAAM,kBAAEysF,EAAoB8tC,EAAmB,mBAAE7uC,EAAqBL,GAA0BrrF,EAC1Fy6H,EAAkBx9F,EAAUr8B,aAAaw8B,8BACxC5kC,EAAOC,EAAQkmC,GAAa41F,EAAS9wH,WACtC20C,EAAmBv/C,KAAK+Q,MAAM+0B,EAAY,GAC1Cw/D,EAAU,IAAI7jG,MAAM9B,EAAQC,GAAQiV,MAAK,GACzCqtH,EAAc3iF,EAAmB5/C,EAAQC,EACzCuiI,EAAM,CAAC3hB,EAAQC,KACjB,MAAM+c,EAAQ,CAAC,CAAChd,EAAQC,IACxB,KAAO+c,EAAM75H,QAAQ,CACjB,MAAOtD,EAAGE,GAAKi9H,EAAMrW,QACfib,EAAkB7hI,EAAIZ,EAAQU,EACpC,GAAIA,EAAI,GACJA,GAAKV,GACLY,EAAI,GACJA,GAAKX,GACL0lG,EAAQ88B,GACR,SAEJ98B,EAAQ88B,IAAmB,EAC3B,MAAMC,EAAmBH,EAAcE,EACjCE,EAAmBV,EAAgBS,GACrCC,EAAmBzvC,EAAmB,IACtCyvC,EAAmBzvC,EAAmB,KAG1C6oC,EAAS3zH,aAAa8yF,WAAWwnC,EAAkBzuC,GACnD4pC,EAAM9xH,KAAK,CAACrL,EAAI,EAAGE,IACnBi9H,EAAM9xH,KAAK,CAACrL,EAAI,EAAGE,IACnBi9H,EAAM9xH,KAAK,CAACrL,EAAGE,EAAI,IACnBi9H,EAAM9xH,KAAK,CAACrL,EAAGE,EAAI,IACvB,GAEEgiI,EAAW,CAAC/hB,EAAQgiB,EAAQC,EAAMliI,KACpC,IAAK,IAAIF,EAAImgH,EAAQngH,IAAMmiI,EAAQniI,GAAKoiI,EAAM,CAC1C,MAAML,EAAkB7hI,EAAIZ,EAAQU,EAE9BiiI,EAAmBV,EADAM,EAAcE,GAEvC,GAAIE,EAAmBzvC,EAAmB,IACtCyvC,EAAmBzvC,EAAmB,GACtC,MAECyS,EAAQ88B,IACTD,EAAI9hI,EAAGE,EAEf,GAEJ,IAAK,IAAIA,EAAI,EAAGA,EAAIX,EAAQW,IACxBgiI,EAAS,EAAG5iI,EAAQ,EAAG,EAAGY,GAC1BgiI,EAAS5iI,EAAQ,EAAG,GAAI,EAAGY,EAEnC,CA6BImiI,CAAuBt+F,EAAWs3F,EAAUv0H,GACrCu0H,CACX,CACA3/F,eAAe4mG,EAAyBl/F,EAAoBgwD,EAAiBtsF,GACzE,MAAM,YAAEywE,GAAgB6b,GAClB,WAAEzvD,EAAU,eAAE0vD,GAAmB9b,EACjCgrD,EAAqB,CACvBv8G,KAAM2d,EAAW,GACjB1d,KAAMotE,EAAe,GACrB9vD,KAAMI,EAAW,GACjBH,KAAM6vD,EAAe,GACrB5vD,KAAME,EAAW,GACjBD,KAAM2vD,EAAe,IAEnBtvD,EAAY,4BAAwBX,EAAoBm/F,EAAoB,CAC9Eh5H,aAAc,CACVC,KAAM,kBAGR6xH,QAAiBiG,EAAmDv9F,EAAWj9B,GAErF,aADM,OAAIi9B,EAAUv2B,SAAU6tH,EAAS7tH,UAChC6tH,CACX,C,8FCxGA,MAAM,sBAAE72F,GAA0B,YAC5B48F,EAAsB,IACtBC,EAAsB,IACtBmB,EAAyB,GACzBC,EAAyB,GAW/B,SAAS7M,EAAqBvyF,EAAkBqtD,GAC5C,MAAM/lF,EAAY04B,EAAiBte,UAAUI,eACvCu9G,EAAY,gBAAgB/3H,EAAU,GAAIA,EAAU,GAAIA,EAAU,KAChE2O,OAAQqpH,EAAmBn9F,OAAQo9F,GAAiBlyC,EACtDmyC,EAAkBx/F,EAAiBte,UACnC+9G,EAAiB,iBAAiB,cAAeH,EAAmBD,GAAYE,GAChFG,EAAoB,iBAAiB,cAAeJ,EAAmBD,EAAWE,GAExF,OAlBJ,SAAqCv/F,EAAkB2/F,GACnD,MAAM,aAAEppG,EAAY,iBAAEE,GAAqBkpG,EACrC7M,EAAa3xF,EAAsBnB,EAAiBte,UAAW6U,GAC/Dw8F,EAAiB5xF,EAAsBnB,EAAiBte,UAAW+U,GACzE,MAAO,IACAkpG,EACH7M,aACAC,iBAER,CASW6M,CAA4B5/F,GADV,OAAoB,CAAC0/F,EAAmBD,GAAiBD,GAEtF,CA0HAnnG,eAAewnG,EAA8Cn/F,EAAW2sD,EAAY9xF,EAAUkI,GAC1F,MAAMu0H,QAAiB,EAAApnB,aAAA,oCAAiDlwE,EAAUv2B,UAGlF,OAnGJ,SAAgC61B,EAAkBg4F,EAAU3qC,EAAY5pF,GACpE,MAAMq8H,EAAqB9/F,EAAiB37B,aAAaw8B,6BACnDk/F,EAAgB1yC,EAAWp3E,QAC1Bha,EAAOC,EAAQkmC,GAAapC,EAAiB94B,WAC9Cm7B,EAAoBpmC,EAAQC,EAC5B8jI,EAAmB7+F,EAAsBnB,EAAiBte,UAAWq+G,GACrEE,EAAsBH,EAAmBE,EAAiB,GAAK39F,EACjE29F,EAAiB,GAAK/jI,EACtB+jI,EAAiB,IACf/vC,EAAoBxsF,EAAQwsF,mBAAqB8tC,EACjDnxC,EAAuBnpF,EAAQmpF,sBAAwBuyC,EACvDe,EAA4B5jI,KAAK6e,IAAI8kH,EAAsBrzC,GAC3DuzC,EAAwBF,EAAsBC,EAC9CE,EAAwBH,EAAsBC,EAC9CG,EAAsB,CACxB,EAAE,EAAG,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IAELC,EAAkBN,EAAiB,GAAK39F,EAC1C29F,EAAiB,GAAK/jI,EACtB+jI,EAAiB,GACrBhI,EAAS3zH,aAAa8yF,WAAWmpC,EAAiBrwC,GAClD,MAAM6pC,EAAQ,CAACkG,GACf,KAAOlG,EAAM75H,QAAQ,CACjB,MAAMsgI,EAAWzG,EAAMrW,SAChB9mH,EAAGE,EAAGqR,GAAKqyH,EAClB,IAAK,IAAIx3H,EAAI,EAAG4nC,EAAM0vF,EAAoBpgI,OAAQ8I,EAAI4nC,EAAK5nC,IAAK,CAC5D,MAAMy3H,EAAqBH,EAAoBt3H,GACzC03H,EAAK9jI,EAAI6jI,EAAmB,GAC5BE,EAAK7jI,EAAI2jI,EAAmB,GAC5BG,EAAKzyH,EAAIsyH,EAAmB,GAClC,GAAIC,EAAK,GACLA,GAAMxkI,GACNykI,EAAK,GACLA,GAAMxkI,GACNykI,EAAK,GACLA,GAAMv+F,EACN,SAEJ,MAAMw+F,EAAqBD,EAAKt+F,EAAoBq+F,EAAKzkI,EAAQwkI,EAC3DI,EAAqBf,EAAmBc,GAChB5I,EAAS3zH,aAAaklC,WAAWq3F,KACjC3wC,GAC1B4wC,EAAqBV,GACrBU,EAAqBT,IAGzBpI,EAAS3zH,aAAa8yF,WAAWypC,EAAoB3wC,GACrD6pC,EAAM9xH,KAAK,CAACy4H,EAAIC,EAAIC,IACxB,CACJ,CACJ,CA0CIpC,CAAuB79F,EAAWs3F,EAAU3qC,EAAY5pF,GAzC5D,SAAgCi9B,EAAWs3F,EAAU3qC,EAAY9xF,EAAUkI,GACvE,MAAMy6H,EAAkBx9F,EAAUr8B,aAAaw8B,8BACxCxiC,EAASC,EAAM8jC,GAAa41F,EAAS9wH,WACtCm7B,EAAoBhkC,EAAUC,GAC9B,eAAEujC,EAAc,iBAAED,GAAqB,sCAAkCo2F,EAASt2G,UAAWnmB,EAASwkB,aACtG+gH,EAAkB3/F,EAAsBT,EAAUhf,UAAW2rE,EAAWp3E,QACxEgqH,EAAsB/B,EAAgB4C,EAAgB,GAAKziI,EAAUC,EACvEwiI,EAAgB,GAAKziI,EACrByiI,EAAgB,IACdj0C,EAAuBppF,EAAQopF,sBAAwBuyC,EACvDlvC,EAAoBzsF,GAASysF,mBAAqB8tC,EAClD+C,EAA4BzkI,KAAK6e,IAAI8kH,EAAsBpzC,GAC3Dm0C,EAAwBf,EAAsBc,EAC9CE,EAAwBhB,EAAsBc,EAE9CG,EAAiB,EAAI5kI,KAAKC,GADR,IAElB4kI,EAAY,kBAAkB,cAAev/F,EAAkBs/F,GAC/DE,EAAc,WAAWv/F,GAC/B,IAAK,IAAI94B,EAAI,EAAGA,EAJQ,IAIaA,IAAK,CACtC,MAAMs4H,EAAyB,iBAAiB,cAAeh0C,EAAWp3E,OAAQmrH,EAAa/zC,EAAWlrD,QACpGm/F,EAAuBngG,EAAsB62F,EAASt2G,UAAW2/G,IAChE1kI,EAAGE,EAAGqR,GAAKozH,EAElB,GADA,mBAAmBF,EAAaA,EAAaD,GACzCxkI,EAAI,GACJA,GAAK0B,GACLxB,EAAI,GACJA,GAAKyB,GACL4P,EAAI,GACJA,GAAKk0B,EACL,SAEJ,MAAMz1B,EAAShQ,EAAIE,EAAIwB,EAAU6P,EAAIm0B,EAC/BmuD,EAAa0tC,EAAgBvxH,IAC/B6jF,EAAawwC,GACbxwC,EAAaywC,IACbjJ,EAAS3zH,aAAa8yF,WAAWxqF,EAAQujF,EAEjD,CACJ,CAII8uC,CAAuBt+F,EAAWs3F,EAAU3qC,EAAY9xF,EAAUkI,GAC3Du0H,CACX,CACA3/F,eAAekpG,EAAoBxhG,EAAoBstD,EAAY9xF,EAAUkI,GACzE,MACMi9B,EAjIV,SAAoCV,EAAkBqtD,EAAY9xF,GAC9D,MAAMikI,EAAkBx/F,EAAiBte,UACnC5B,EAASvkB,EAASwkB,aAClB,aAAEiiB,EAAY,aAAEF,GAAiB,sCAAkC09F,EAAiB1/G,GAI1F,GAHoB,CAACkiB,EAAcF,GAAcxb,MAAMutG,IAAS,oBAAgBv3H,KAAK6e,IAAI04G,EAAI,IAAK,KAC7F,oBAAgBv3H,KAAK6e,IAAI04G,EAAI,IAAK,KAClC,oBAAgBv3H,KAAK6e,IAAI04G,EAAI,IAAK,KAGnC,YADApkH,QAAQC,KAAK,kCAGjB,MAAQ6E,UAAWitH,GAAoBjP,EAAqBvyF,EAAkBqtD,GACxE6xC,EAAqB,CACvBv8G,KAAM6+G,EAAgB,GAAG,GACzB5+G,KAAM4+G,EAAgB,GAAG,GAAK,EAC9BthG,KAAMshG,EAAgB,GAAG,GACzBrhG,KAAMqhG,EAAgB,GAAG,GAAK,EAC9BphG,KAAMohG,EAAgB,GAAG,GACzBnhG,KAAMmhG,EAAgB,GAAG,GAAK,GAElC,OAAO,4BAAwBxhG,EAAiB71B,SAAU+0H,EAAoB,CAC1Eh5H,aAAc,CACVC,KAAM,iBAGlB,CAwGsBs7H,CADO,EAAA9wG,MAAM7M,UAAUic,GACsBstD,EAAY9xF,GACrEy8H,QAAiB6H,EAA8Cn/F,EAAW2sD,EAAY9xF,EAAUkI,GAEtG,aADM,OAAIi9B,EAAUv2B,SAAU6tH,EAAS7tH,UAChC6tH,CACX,C,+FC/JA,MAAM,sBAAE72F,GAA0B,YAC5BugG,EAAqB,IAC3B,SAASC,EAAsB3hG,EAAkBkoC,EAAezkE,GAC5D,MAAM,WAAEyD,EAAYwa,UAAWkgH,GAAiB5hG,GACzC/jC,EAAOC,EAAQkmC,GAAal7B,EAC7B26H,EAA8B7hG,EAAiB37B,aAC/CG,EAAaq9H,EAA4BhhG,6BACzCwB,EAAoBpmC,EAAQC,EAC5B4lI,EAAqBr+H,GAASs+H,2BAA6B,KAC3DC,EAAYv+H,GAASw+H,0BAA4B,KACjDC,EAAYz+H,GAAS0+H,0BAA4B,KACjDC,EAAqB3+H,GAAS2+H,oBAAsB,KACpDC,EAA6B5+H,GAAS4+H,4BAA8B,KACpEC,EAAWnhG,EAAsBygG,EAAc15D,GAAexiE,IAAIpJ,KAAKkkB,OACvEypG,EAAa4X,EAA4BjvH,QAAQ0vH,GACvD,GAAIA,EAAS,GAAK,GACdA,EAAS,IAAMrmI,GACfqmI,EAAS,GAAK,GACdA,EAAS,IAAMpmI,GACfomI,EAAS,GAAK,GACdA,EAAS,IAAMlgG,EAEf,OADA3yB,QAAQC,KAAK,4CACN,KAEX,MAAM6yH,EAAe,uCAAmC/9H,EAAY0C,EAAYo7H,EAAUR,GAC/D,IAAvBS,EAAaj0H,QACbi0H,EAAa5/F,KAAOn+B,EAAWylH,GAC/BsY,EAAa3/F,OAAS,GAE1B,MAAM4/F,EAAuBD,EAAa5/F,KAAOq/F,EAAYO,EAAa3/F,OACpE6/F,EAAuBF,EAAa5/F,KAAOq/F,EAAYO,EAAa3/F,OACpEy9F,EAAsB,CACxB,EAAE,EAAG,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IAEX,IAAI19G,EAAO3M,IAAUkqB,EAAOlqB,IAAUoqB,EAAOpqB,IACzC4M,GAAQ5M,IAAUmqB,GAAQnqB,IAAUqqB,GAAQrqB,IAChD,MAAMw4E,EAAsB,IAAIt2D,IAC1B4hG,EAAQ,GACR5P,EAAa1lH,EAAWylH,GAC9B,KAAIC,GAAcsY,GACdtY,GAAcuY,GASd,OADAhzH,QAAQC,KAAK,kGACN,CAAE8+E,oBAAqB,IAAIt2D,IAAOu2D,oBAAqB,IAAIv2D,KARlEs2D,EAAoB7rF,IAAIsnH,GACxB6P,EAAM9xH,KAAKs6H,GACX3/G,EAAOC,EAAO0/G,EAAS,GACvBpiG,EAAOC,EAAOmiG,EAAS,GACvBliG,EAAOC,EAAOiiG,EAAS,GAM3B,IAAII,EAAoB,EACxB,KAAOA,EAAoB5I,EAAM75H,QAC7BuuF,EAAoB3mE,KAAO65G,GAAoB,CAC/C,MAAO/kI,EAAGE,EAAGqR,GAAK4rH,EAAM4I,KACxB//G,EAAOrmB,KAAKa,IAAIR,EAAGgmB,GACnBud,EAAO5jC,KAAKa,IAAIN,EAAGqjC,GACnBE,EAAO9jC,KAAKa,IAAI+Q,EAAGkyB,GACnBxd,EAAOtmB,KAAKkS,IAAI7R,EAAGimB,GACnBud,EAAO7jC,KAAKkS,IAAI3R,EAAGsjC,GACnBE,EAAO/jC,KAAKkS,IAAIN,EAAGmyB,GACnB,IAAK,IAAIt3B,EAAI,EAAGA,EAAIs3H,EAAoBpgI,OAAQ8I,IAAK,CACjD,MAAOgZ,EAAIC,EAAIC,GAAMo+G,EAAoBt3H,GACnC03H,EAAK9jI,EAAIolB,EACT2+G,EAAK7jI,EAAImlB,EACT2+G,EAAKzyH,EAAI+T,EACf,GAAIw+G,EAAK,GACLA,GAAMxkI,GACNykI,EAAK,GACLA,GAAMxkI,GACNykI,EAAK,GACLA,GAAMv+F,EACN,SAEJ,MAAM40F,EAAgB2J,EAAKt+F,EAAoBq+F,EAAKzkI,EAAQwkI,EAC5D,GAAIjyC,EAAoB9rF,IAAIs0H,GACxB,SAEJ,MAAM2L,EAAgBn+H,EAAWwyH,GAC7B2L,GAAiBH,GACjBG,GAAiBF,IACjBj0C,EAAoB7rF,IAAIq0H,GACpBxoC,EAAoB3mE,KAAO65G,GAC3B5H,EAAM9xH,KAAK,CAACy4H,EAAIC,EAAIC,IAGhC,CACJ,CAIA,GAHInyC,EAAoB3mE,MAAQ65G,GAC5BjyH,QAAQqM,MAAM,6CAA6C4lH,qBAE9B,IAA7BlzC,EAAoB3mE,KAEpB,OADApY,QAAQC,KAAK,sCACN,CAAE8+E,oBAAqB,IAAIt2D,IAAOu2D,oBAAqB,IAAIv2D,KAEtE,IAAI0qG,EAAc,EACdC,EAAgB,EACpBr0C,EAAoBluF,SAASuH,IACzB,MAAMvI,EAAQkF,EAAWqD,GACzB+6H,GAAetjI,EACfujI,GAAiBvjI,EAAQA,CAAK,IAElC,MAAMwjI,EAAgBt0C,EAAoB3mE,KACpCk7G,EAAeH,EAAcE,EAC7BE,EAAmBH,EAAgBC,EAAgBC,EAAeA,EAElEE,EAAwBf,EADP5lI,KAAKwmC,KAAKxmC,KAAKkS,IAAI,EAAGw0H,IAEvCE,EAAQ5mI,KAAKkS,IAAI,EAAGmU,EAAOy/G,GAC3Be,EAAQ7mI,KAAKkS,IAAI,EAAG0xB,EAAOkiG,GAC3BgB,EAAQ9mI,KAAKkS,IAAI,EAAG4xB,EAAOgiG,GAC3BiB,EAAQ/mI,KAAKa,IAAIlB,EAAQ,EAAG2mB,EAAOw/G,GACnCkB,EAAQhnI,KAAKa,IAAIjB,EAAS,EAAGikC,EAAOiiG,GACpCmB,EAAQjnI,KAAKa,IAAIilC,EAAY,EAAG/B,EAAO+hG,GACvC3zC,EAAsB,IAAIv2D,IAChC,IAAIsrG,EAAW,EACXC,EAAe,EACnB,MAAMC,EAAcrB,EAA6B,KACjD,KAAOoB,EAAepB,GAA8BmB,EAAWE,GAAa,CACxEF,IACA,MAAMz3B,EAAKzvG,KAAK+Q,MAAM/Q,KAAKm+B,UAAY4oG,EAAQH,EAAQ,GAAKA,GACtDl3B,EAAK1vG,KAAK+Q,MAAM/Q,KAAKm+B,UAAY6oG,EAAQH,EAAQ,GAAKA,GACtDQ,EAAKrnI,KAAK+Q,MAAM/Q,KAAKm+B,UAAY8oG,EAAQH,EAAQ,GAAKA,GACtD1gG,EAAcihG,EAAKthG,EAAoB2pE,EAAK/vG,EAAQ8vG,EAC1D,GAAIvd,EAAoB9rF,IAAIggC,IACxB+rD,EAAoB/rF,IAAIggC,GACxB,SAEJ,MAAMkhG,EAAcp/H,EAAWk+B,GAC/B,GAAIpmC,KAAK6e,IAAIyoH,EAAcb,GAAgBE,EAAuB,CAC9D,IAAIY,GAAmB,EACvB,IAAK,IAAI7hH,GAAM,EAAGA,GAAM,EAAGA,IAAM,CAC7B,MAAM0+G,EAAK10B,EAAKhqF,EAChB,KAAI0+G,EAAK,GAAKA,GAAMxkI,GAGpB,IAAK,IAAI6lB,GAAM,EAAGA,GAAM,EAAGA,IAAM,CAC7B,MAAM0+G,EAAK10B,EAAKhqF,EAChB,GAAI0+G,EAAK,GAAKA,GAAMxkI,EAChB,SAEJ,MAAM+6H,EAAgB2M,EAAKthG,EAAoBq+F,EAAKzkI,EAAQwkI,EACxDjyC,EAAoB9rF,IAAIs0H,IACxBvoC,EAAoB/rF,IAAIs0H,KAG5BvoC,EAAoB9rF,IAAIq0H,GACxB6M,GAAmB,EACvB,CACJ,CACIA,GACAJ,GAER,CACJ,CAMA,OALiC,IAA7Bh1C,EAAoB5mE,MACpBpY,QAAQC,KAAK,kFAEjBD,QAAQqM,MAAM,sBAAuB0yE,EAAoB3mE,MACzDpY,QAAQqM,MAAM,sBAAuB2yE,EAAoB5mE,MAClD,CAAE2mE,sBAAqBC,sBAClC,CACAp2D,eAAeyrG,GAAmB,mBAAE/jG,EAAkB,cAAEmoC,EAAa,QAAEzkE,IACnE,MAAMu8B,EAAmB,EAAArP,MAAM7M,UAAUic,GACnCi4F,EAAW,EAAApnB,aAAA,oCAAiD7wE,GAClEi4F,EAAS3zH,aAAa/D,SAAQ,EAAGuH,QAAOvI,YACtB,IAAVA,GACA04H,EAAS3zH,aAAa8yF,WAAWtvF,EAAO,EAC5C,IAEJ,MAAM0mF,EAAQ9qF,EAAQ8qF,OAClBozC,EAAsB3hG,EAAkBkoC,EAAezkE,GACrDsgI,EAAoBtgI,GAASwsF,mBAAqB,KAClD+zC,EAAoBvgI,GAASysF,mBAAqB,KACxD,IAAK3B,EACD,OAAO,KAEX,MAAM,oBAAEC,EAAmB,oBAAEC,GAAwBF,EACrD,OAAIC,EAAoB3mE,KAAO,IAC3B2mE,EAAoB3mE,KAAO65G,GAC3BjzC,EAAoB5mE,KAAO,IAC3BpY,QAAQC,KAAK,uEACNsoH,IAEXxpC,EAAoBluF,SAASuH,IACzBmwH,EAAS3zH,aAAa8yF,WAAWtvF,EAAOk8H,EAAkB,IAE9Dt1C,EAAoBnuF,SAASuH,IACzBmwH,EAAS3zH,aAAa8yF,WAAWtvF,EAAOm8H,EAAkB,UAExD,OAAIjkG,EAAoBi4F,EAAS7tH,SAAU1G,GAC1Cu0H,EACX,C,0lBCpMO,SAAS3Q,EAAsBxuE,GAClC,MAAMmzC,GAAY,IAAApzC,cAAaC,GAC/B,QAAkBx7C,IAAd2uF,EACA,QAE4B,OAAsBnzC,GAC9Bv4C,SAAS2jI,IAC7BA,EAAK5c,uBAAuB,IAEhC,MAAMvuE,EAAgBkzC,EAAUk4C,mBAEhC,IAD2BjlI,OAAO4B,KAAKi4C,GAAepzC,KAAKlG,GAAQs5C,EAAct5C,KACzDS,OACpB,OAEJ,MAAMiZ,EAAc8yE,EAAU/hC,kBAC9B,OAAsC/wC,EAC1C,C,yHCDA,QAhBA,SAAkB1M,EAAMuhH,EAAMtqH,GAC1B,IAAI6qH,GAAU,EACVj6C,GAAW,EACf,GAAoB,mBAAT7nE,EACP,MAAM,IAAIiiH,UAAU,uBAMxB,OAJI,OAAShrH,KACT6qH,EAAU,YAAa7qH,EAAU+rH,QAAQ/rH,EAAQ6qH,SAAWA,EAC5Dj6C,EAAW,aAAc5wE,EAAU+rH,QAAQ/rH,EAAQ4wE,UAAYA,IAE5D,OAAS7nE,EAAMuhH,EAAM,CACxBO,UACAj6C,WACA65C,QAASH,GAEjB,C,+BCjBA,SAASoW,EAAehqF,EAAeC,GACnC,MAAMgqF,EAAOC,EAAclqF,GACrBj4C,EAAOmiI,EAAcjqF,GAC3B,MAAO,CACHkqF,KAAMC,EAAkBH,EAAKE,KAAMpiI,EAAKoiI,MACxCE,OAAQD,EAAkBH,EAAKI,OAAQtiI,EAAKsiI,QAC5C1pI,OAAQypI,EAAkBH,EAAKtpI,OAAQoH,EAAKpH,QAC5C68C,OAyGmB+oD,EAzGM0jC,EAAKzsF,MAyGHyQ,EAzGUlmD,EAAKy1C,MA0GvC,CAAC+oD,EAAO,GAAKt4C,EAAO,GAAIs4C,EAAO,GAAKt4C,EAAO,GAAIs4C,EAAO,GAAKt4C,EAAO,MAD7E,IAA2Bs4C,EAAQt4C,CAvGnC,CACA,SAASq8E,EAAiBtqF,EAAeC,GACrC,MAAMgqF,EAAOC,EAAclqF,GACrBj4C,EAAOmiI,EAAcjqF,GAC3B,MAAO,CACHkqF,KAAMI,EAAeN,EAAKE,KAAMpiI,EAAKoiI,MACrCE,OAAQE,EAAeN,EAAKI,OAAQtiI,EAAKsiI,QACzC1pI,OAAQ4pI,EAAeN,EAAKtpI,OAAQoH,EAAKpH,QACzC68C,MAAOgtF,EAAeP,EAAKzsF,MAAOz1C,EAAKy1C,OAE/C,CAGA,SAASitF,EAA+BzqF,EAAeC,GACnD,MAAM6uB,EAAkB47D,EAAkC1qF,GACpD2qF,EAAeD,EAAkCzqF,GAOvD,MANsB,CAClBkqF,KAAMr7D,EAAgBq7D,KAAOQ,EAAaR,KAC1CE,OAAQv7D,EAAgBu7D,OAASM,EAAaN,OAC9C1pI,OAAQmuE,EAAgBnuE,OAASgqI,EAAahqI,OAC9C68C,MAAOsxB,EAAgBtxB,MAAQmtF,EAAantF,MAGpD,CACA,SAASotF,EAAej3H,GACpB,OAAOutB,KAAKs/E,MAAMt/E,KAAKC,UAAUxtB,GACrC,CACA,SAASk3H,EAAWl3H,GAChB,OAAOutB,KAAKs/E,MAAMt/E,KAAKC,UAAUxtB,GACrC,CACA,SAASu2H,EAAcv2H,GACnB,OAAOA,EAAO0tB,QAAO,CAACypG,EAAMb,KACjB,CACHE,KAAM,CACFW,EAAKX,KAAK,GAAKF,EAAKE,KAAK,GAAKx2H,EAAO7N,OACrCglI,EAAKX,KAAK,GAAKF,EAAKE,KAAK,GAAKx2H,EAAO7N,QAEzCukI,OAAQ,CACJS,EAAKT,OAAO,GAAKJ,EAAKI,OAAO,GAAK12H,EAAO7N,OACzCglI,EAAKT,OAAO,GAAKJ,EAAKI,OAAO,GAAK12H,EAAO7N,QAE7CnF,OAAQ,CACJmqI,EAAKnqI,OAAO,GAAKspI,EAAKtpI,OAAO,GAAKgT,EAAO7N,OACzCglI,EAAKnqI,OAAO,GAAKspI,EAAKtpI,OAAO,GAAKgT,EAAO7N,QAE7C03C,MAAO,CACHstF,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,OACvCglI,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,OACvCglI,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,WAGhD,CACCqkI,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZ1pI,OAAQ,CAAC,EAAG,GACZ68C,MAAO,CAAC,EAAG,EAAG,IAEtB,CACA,SAASutF,EAAmBp3H,GACxB,OAAOA,EAAO0tB,QAAO,CAACypG,EAAMb,KACjB,CACHE,KAAM,CACFW,EAAKX,KAAK,GAAKF,EAAKE,KAAK,GAAKx2H,EAAO7N,OACrCglI,EAAKX,KAAK,GAAKF,EAAKE,KAAK,GAAKx2H,EAAO7N,QAEzCukI,OAAQ,CACJS,EAAKT,OAAO,GAAKJ,EAAKI,OAAO,GAAK12H,EAAO7N,OACzCglI,EAAKT,OAAO,GAAKJ,EAAKI,OAAO,GAAK12H,EAAO7N,QAE7CnF,OAAQ,CACJmqI,EAAKnqI,OAAO,GAAKspI,EAAKtpI,OAAO,GAAKgT,EAAO7N,OACzCglI,EAAKnqI,OAAO,GAAKspI,EAAKtpI,OAAO,GAAKgT,EAAO7N,QAE7C03C,MAAO,CACHstF,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,OACvCglI,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,OACvCglI,EAAKttF,MAAM,GAAKysF,EAAKzsF,MAAM,GAAK7pC,EAAO7N,QAE3CklI,MAAO,CACHC,WAAY,KACZC,QAASJ,EAAKE,MAAME,QAAUjB,EAAKe,MAAME,QAAUv3H,EAAO7N,OAC1DqlI,QAASL,EAAKE,MAAMG,QAAUlB,EAAKe,MAAMG,QAAUx3H,EAAO7N,OAC1DslI,MAAON,EAAKE,MAAMI,MAAQnB,EAAKe,MAAMI,MAAQz3H,EAAO7N,OACpDihI,cAAe+D,EAAKE,MAAMjE,cAAgBkD,EAAKe,MAAMjE,cAAgBpzH,EAAO7N,WAGrF,CACCqkI,KAAM,CAAC,EAAG,GACVE,OAAQ,CAAC,EAAG,GACZ1pI,OAAQ,CAAC,EAAG,GACZ68C,MAAO,CAAC,EAAG,EAAG,GACdwtF,MAAO,CACHC,WAAY,KACZC,QAAS,EACTC,QAAS,EACTC,MAAO,EACPrE,cAAe,IAG3B,CACA,SAASqD,EAAkB7jC,EAAQt4C,GAC/B,MAAO,CAACs4C,EAAO,GAAKt4C,EAAO,GAAIs4C,EAAO,GAAKt4C,EAAO,GACtD,CAIA,SAASy8E,EAAkC/2H,GACvC,MAAM03H,EAAiB,GACvB,IAAK,IAAIz8H,EAAI,EAAGA,EAAI+E,EAAO7N,OAAQ8I,IAC/B,IAAK,IAAIuI,EAAI,EAAGA,EAAIxD,EAAO7N,OAAQqR,IAC3BvI,EAAIuI,GACJk0H,EAAex9H,KAAK,CAChBs8H,KAAMI,EAAe52H,EAAO/E,GAAGu7H,KAAMx2H,EAAOwD,GAAGgzH,MAC/CE,OAAQE,EAAe52H,EAAO/E,GAAGy7H,OAAQ12H,EAAOwD,GAAGkzH,QACnD1pI,OAAQ4pI,EAAe52H,EAAO/E,GAAGjO,OAAQgT,EAAOwD,GAAGxW,QACnD68C,MAAOgtF,EAAe72H,EAAO/E,GAAG4uC,MAAO7pC,EAAOwD,GAAGqmC,SAKjE,OAAO6tF,EAAehqG,QAAO,CAACypG,EAAMb,KACzB,CACHE,KAAMW,EAAKX,KAAOF,EAAKE,KAAOkB,EAAevlI,OAC7CukI,OAAQS,EAAKT,OAASJ,EAAKI,OAASgB,EAAevlI,OACnDnF,OAAQmqI,EAAKnqI,OAASspI,EAAKtpI,OAAS0qI,EAAevlI,OACnD03C,MAAOstF,EAAKttF,MAAQysF,EAAKzsF,MAAQ6tF,EAAevlI,UAErD,CACCqkI,KAAM,EACNE,OAAQ,EACR1pI,OAAQ,EACR68C,MAAO,GAEf,CACA,SAAS+sF,EAAehkC,EAAQt4C,GAC5B,OAAO9rD,KAAKwmC,KAAKxmC,KAAKy5D,IAAI2qC,EAAO,GAAKt4C,EAAO,GAAI,GAAK9rD,KAAKy5D,IAAI2qC,EAAO,GAAKt4C,EAAO,GAAI,GAC1F,CACA,SAASu8E,EAAejkC,EAAQt4C,GAC5B,OAAO9rD,KAAKwmC,KAAKxmC,KAAKy5D,IAAI2qC,EAAO,GAAKt4C,EAAO,GAAI,GAC7C9rD,KAAKy5D,IAAI2qC,EAAO,GAAKt4C,EAAO,GAAI,GAChC9rD,KAAKy5D,IAAI2qC,EAAO,GAAKt4C,EAAO,GAAI,GACxC,C,4OCnJO,SAASq9E,EAAuCC,GACnDA,EAAaplI,SAASu4C,IAClB,MAAMmzC,GAAY,IAAApzC,cAAaC,GAC/B,IAAKmzC,EAED,YADAv8E,QAAQC,KAAK,+BAA+BmpC,KAG1BmzC,EAAUk4C,mBAClB5jI,SAASknD,IACnB,MAAM,kBAAEj8B,EAAiB,WAAEgB,GAAei7B,EACpCxuC,GAAkB,IAAAwS,oBAAmBD,GAC3C,IAAKvS,EAED,YADAvJ,QAAQC,KAAK,qCAAqC6b,KAGtD,MAAMhwB,EAAWyd,EAAgByU,YAAYlB,IAC7C,OAAwBhxB,EAASixB,QAAQ,GAC3C,GAEV,C,kFCpBO,SAASgyB,EAAsCN,GAC7CA,EAAoBj+C,QAGzBi+C,EAAoB59C,SAASisB,IACzB,MAAM5xB,GAAiB,IAAA+gE,+BAA8BnvC,GACrD,IAAK5xB,EAED,YADA8U,QAAQC,KAAK,8BAA8B6c,KAG/C,MAAM,SAAEhxB,GAAaZ,EACrB,IAAKY,EAED,YADAkU,QAAQC,KAAK,8BAA8B6c,KAG/C,MAAMC,EAAUjxB,EAASixB,SACzB,OAAwBA,EAAQ,GAExC,CACA,S,gTCpBA,SAASupD,EAAoBx6E,EAAUioB,GACnC,GAAIjoB,aAAoB,EAAA8mD,mBAAoB,CACxC,MAAMl4C,EAAW,EAAAwhC,UAAA,YAAsBnoB,GACjCL,EAAS,EAAAwN,MAAM7M,UAAU3Z,GAC/B,QAASgZ,GAAQm5B,SAAWr9C,OAAO4B,KAAKsiB,EAAOm5B,SAASr8C,OAAS,CACrE,CACK,GAAI1E,aAAoB,EAAAi8B,cAAe,CACxC,MAAM,SAAE1L,GAAavwB,EAASw5B,gBAAkB,CAAC,EACjD,QAASjJ,GAAUC,MACvB,CAEI,OAAO,CAEf,C,+BCdO,IAAI0hB,E,iBACX,SAAWA,GACPA,EAA+B,IAAI,MACnCA,EAAgC,KAAI,OACpCA,EAAkC,OAAI,SACtCA,EAAiC,MAAI,OACxC,CALD,CAKGA,IAA8BA,EAA4B,CAAC,G,2JCN9D,MAAMk4F,EAAmB,CACvBC,UAAW,EACXv9H,WAAY,EACZoK,kBAAmB,EACnBjK,WAAY,EACZD,YAAa,EACb0wH,WAAY,EACZH,YAAa,EACbxwH,aAAc,EACdu9H,aAAc,GAEVC,EAAe,CACnBC,KAAM,GAENC,KAAM,YACNC,YAAa,YACbC,cAAe,aACfC,sBAAuB,oBAEvBC,MAAO,aACPC,eAAgB,cAChBC,IAAK,aACLC,aAAc,cACdC,MAAO,eACPC,OAAQ,gBAGV,IAAIC,EAAY,CACdC,gBAFsBb,EAAaU,MAGnCb,mBACAG,e,0DC9BF,MA4CMc,EAAyB,CAC7BC,QAAS,EAETC,OAAQ,EAERL,OAAQ,GAGV,IAAIC,EAAY,CACdK,wBAjB8B,CAC9BC,UAAW,EACXC,YAAa,EACbC,SAAU,EACVC,QAAS,GAcTC,oBA3C0B,CAC1BC,IAAK,EACLC,MAAO,EACPC,QAAS,GAyCTC,eAvDqB,CACrBC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,UAAW,EACXC,YAAa,EACbC,SAAU,EACVC,eAAgB,GA+ChBC,eAxCqB,CACrBC,cAAe,EAEfC,qBAAsB,EAEtBC,oBAAqB,EAErBC,YAAa,EAEbC,aAAc,GAEdC,WAAY,IA8BZ5B,yBACA6B,gBA5BsB,CACtBC,eAAgB,EAEhBC,YAAa,GA0BbC,eAhBqB,e,6ECtCvB,MAAM,cACJC,EAAa,cACbC,GACE,EAAA5mC,EAMJ,SAAS6mC,EAAwBjnC,EAAWC,GAmB1CA,EAAMinC,eAAehhI,KAAK,2BAM1B85F,EAAUmnC,iBAAmB,IAAMlnC,EAAMmnC,cAMzCpnC,EAAUqnC,iBAAmBC,IAC3BrnC,EAAMmnC,cAAgBE,EACtBtnC,EAAUj3D,UAAU,EAEtB,MAAMw+F,EAAM,GACNC,EAAe,GACfC,EAAW,GACXC,EAAc,IAAezlC,cAWnCjC,EAAU2nC,gBAAkB,CAACxzD,EAAKyzD,EAAMxhG,EAASyhG,EAAYC,EAASC,KACpE,MAAO9gI,EAAGuI,EAAGI,GAAKukE,EAGlBozD,EAAI,GAAK33H,EAAIg4H,EAAK,GAAKA,EAAK,GAAKp4H,EAAIo4H,EAAK,GAAK3gI,EAC/CsgI,EAAI,GAAKA,EAAI,GAAKM,EAAWC,GAC7BP,EAAI,GAAKA,EAAI,GAAKM,EAAWE,GAC7BR,EAAI,GAAKA,EAAI,GAAKM,EAAWC,GAG7B,IAAK,IAAIE,EAAK,EAAGA,EAAK,IAAKA,EACzBR,EAAaQ,GAAM5hG,EAAQmhG,EAAIS,GACjC,EAWFhoC,EAAUioC,eAAiB,CAAC9zD,EAAK7uE,EAAQD,EAASyiI,EAASC,KACzD,MAAM9gI,EAAIktE,EAAI2zD,GACRt4H,EAAI2kE,EAAI4zD,GAGdN,EAAS,GAAKniI,EAAOwiI,GAAW7gI,EAAI5B,EAAQyiI,GAC5CL,EAAS,GAAKniI,EAAOyiI,GAAWv4H,EAAInK,EAAQ0iI,GAC5CN,EAAS,GAAKA,EAAS,GAAKpiI,EAAQyiI,GACpCL,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GAAKpiI,EAAQ0iI,GACpCN,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,EAAE,EAiB3BznC,EAAUkoC,aAAe,CAACC,EAAMh0D,EAAKyzD,EAAMtiI,EAAQD,EAAS+gC,EAASp6B,EAAQg8F,EAAO6/B,EAAYC,EAASC,KACvG,MAAMn4H,EAAIukE,EAAI8rB,EAAMmoC,aACdC,EAAY,CAAC,EAAG,EAAG,EAAG,GACtBl8H,EAAM,GACZ,IAAIm8H,EACJtoC,EAAU2nC,gBAAgBxzD,EAAKyzD,EAAMxhG,EAASyhG,EAAYC,EAASC,GACnE,IAAIhiI,EAAQ,EACZ,IAAK,IAAIykC,EAAM,EAAGA,EAAM,EAAGA,IACrBg9F,EAAah9F,IAAQ29F,IACvBpiI,GAASsiI,EAAU79F,IAIvB,MAAM+9F,EAAa,IAAaC,QAAQziI,GACxC,GAAIwiI,EAAW,GAAK,EAClB,OAGFvoC,EAAUioC,eAAe9zD,EAAK7uE,EAAQD,EAASyiI,EAASC,GACxD,MAAM37H,EAAI9G,EAAO26F,EAAMmoC,aAAex4H,EAAIvK,EAAQ46F,EAAMmoC,aACxD,IAAK,IAAI59F,EAAM,EAAG+9F,EAAW/9F,IAAQ,EAAGA,GAAO,EAAG,CAChDw9D,EAAM9hG,KAAK,GACX,IAAK,IAAIuiI,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAY,IAAaC,QAAQJ,EAAW/9F,EAAMi+F,IAKxD,GAJAH,OAAM/sI,EACF0kG,EAAM2oC,cACRN,EAAMZ,EAAYmB,eAAetB,EAAImB,EAAU,IAAKnB,EAAImB,EAAU,MAAMlrI,YAE9DjC,IAAR+sI,EAAmB,CACrB,MAAM/jG,GAAK4jG,EAAOX,EAAakB,EAAU,MAAQlB,EAAakB,EAAU,IAAMlB,EAAakB,EAAU,KAC/F3kG,EAAK0jG,EAASxpI,MAAqB,EAAfyqI,EAAU,GAA6B,GAApBA,EAAU,GAAK,IACtDnlH,EAAKkkH,EAASxpI,MAAqB,EAAfyqI,EAAU,GAA6B,GAApBA,EAAU,GAAK,IAC5Dv8H,EAAI27H,GAAW/jG,EAAG,GAAKQ,GAAKhhB,EAAG,GAAKwgB,EAAG,IACvC53B,EAAI47H,GAAWhkG,EAAG,GAAKQ,GAAKhhB,EAAG,GAAKwgB,EAAG,IACvC53B,EAAI8zF,EAAMmoC,aAAeh8H,EACzBk8H,EAAMt8H,EAAO7N,OAAS,EACtB6N,EAAO9F,KAAKiG,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC5B8zF,EAAM2oC,aACRlB,EAAYoB,WAAWvB,EAAImB,EAAU,IAAKnB,EAAImB,EAAU,IAAKJ,EAEjE,CACAtgC,EAAM9hG,KAAKoiI,EACb,CACF,GAEFtoC,EAAUM,YAAc,CAACC,EAAQC,KAE/B,MAAM77E,EAAQ47E,EAAO,GACrB,IAAK57E,EAEH,YADAoiH,EAAc,4BAGhB,GAAyB,MAArB9mC,EAAMmoC,aAAuBnoC,EAAMmoC,YAAc,GAAKnoC,EAAMmoC,YAAc,EAE5E,YADArB,EAAc,mCAGhBp5H,QAAQy2G,KAAK,YAGb,MAAM9+G,EAASqf,EAAMokH,YACf1jI,EAAUsf,EAAM+lG,aAChBkd,EAAOjjH,EAAMvE,gBACbgmF,EAASzhF,EAAMX,YACf6jH,EAAaljH,EAAMqkH,kBAAkB5iC,GACrChgE,EAAUzhB,EAAM0hB,eAAeC,aAAaC,WAC3CuhG,EAASC,GAjKlB,WACE,IAAID,EAAU,EACVC,EAAU,EAQd,OAP0B,IAAtB9nC,EAAMmoC,aACRN,EAAU,EACVC,EAAU,GACqB,IAAtB9nC,EAAMmoC,cACfN,EAAU,EACVC,EAAU,GAEL,CAACD,EAASC,EACnB,CAsJ6BkB,GAGrBj9H,EAAS,GAGTg8F,EAAQ,GAGd,IAAIp4F,EAAIpV,KAAKkkB,MAAMuhF,EAAMhiG,OACrB2R,GAAKg4H,EAAK3nC,EAAMmoC,eAClBx4H,EAAI,GAIN,MAAMukE,EAAM,CAAC,EAAG,EAAG,GACnBA,EAAI8rB,EAAMmoC,aAAex4H,EACzB,IAAK,IAAIs5H,EAAK,EAAGA,EAAKjpC,EAAMmnC,cAAcjpI,SAAU+qI,EAAI,CACtD,IAAK,IAAI15H,EAAI,EAAGA,EAAIo4H,EAAKG,GAAW,IAAKv4H,EAAG,CAC1C2kE,EAAI4zD,GAAWv4H,EACf,IAAK,IAAIvI,EAAI,EAAGA,EAAI2gI,EAAKE,GAAW,IAAK7gI,EACvCktE,EAAI2zD,GAAW7gI,EACf+4F,EAAUkoC,aAAajoC,EAAMmnC,cAAc8B,GAAK/0D,EAAKyzD,EAAMtiI,EAAQD,EAAS+gC,EAASp6B,EAAQg8F,EAAO6/B,EAAYC,EAASC,EAE7H,CACAL,EAAYxkC,YACd,CAGA,MAAMimC,EAAW,mBACjBA,EAAS19F,YAAYk2D,QAAQ,IAAIn7F,aAAawF,GAAS,GACvDm9H,EAASt+F,WAAW82D,QAAQ,IAAIq1B,YAAYhvB,IAC5CxH,EAAQ,GAAK2oC,EACbnC,EAAc,mBACdr5H,QAAQy7H,QAAQ,WAAW,CAE/B,CAMA,MAAMrpC,EAAiB,CACrBqnC,cAAe,GACfgB,YAAa,EACbnqI,MAAO,EACP2qI,aAAa,GAKf,SAASjqI,EAAOqhG,EAAWC,GACzB,IAAIC,EAAgBC,UAAUhiG,OAAS,QAAsB5C,IAAjB4kG,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFhjG,OAAOm7D,OAAO2nC,EAAOF,EAAgBG,GAGrC,EAAAE,EAAM9jF,IAAI0jF,EAAWC,GAGrB,EAAAG,EAAMC,KAAKL,EAAWC,EAAO,EAAG,GAChC,EAAAG,EAAMipC,OAAOrpC,EAAWC,EAAO,CAAC,cAAe,QAAS,gBAGxD,EAAAG,EAAMC,KAAKL,EAAWC,EAAO,EAAG,GAChCgnC,EAAwBjnC,EAAWC,EACrC,CAIoB,EAAAG,EAAM6B,YAAYtjG,EAAQ,0B,ksBC7OvC,SAASvB,IACd,IAAIksI,EAAM,IAAI,aAAoB,GAQlC,OANI,cAAuB9iI,eACzB8iI,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,GAGJA,CACT,CAQO,SAASpkH,EAAMzL,GACpB,IAAI6vH,EAAM,IAAI,aAAoB,GAIlC,OAHAA,EAAI,GAAK7vH,EAAE,GACX6vH,EAAI,GAAK7vH,EAAE,GACX6vH,EAAI,GAAK7vH,EAAE,GACJ6vH,CACT,CAQO,SAASnrI,EAAOsb,GACrB,IAAI5e,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GACV,OAAOjf,KAAKsvG,MAAMjvG,EAAGE,EAAGqR,EAC1B,CAUO,SAASm9H,EAAW1uI,EAAGE,EAAGqR,GAC/B,IAAIk9H,EAAM,IAAI,aAAoB,GAIlC,OAHAA,EAAI,GAAKzuI,EACTyuI,EAAI,GAAKvuI,EACTuuI,EAAI,GAAKl9H,EACFk9H,CACT,CASO,SAASE,EAAKF,EAAK7vH,GAIxB,OAHA6vH,EAAI,GAAK7vH,EAAE,GACX6vH,EAAI,GAAK7vH,EAAE,GACX6vH,EAAI,GAAK7vH,EAAE,GACJ6vH,CACT,CAWO,SAAS7rI,EAAI6rI,EAAKzuI,EAAGE,EAAGqR,GAI7B,OAHAk9H,EAAI,GAAKzuI,EACTyuI,EAAI,GAAKvuI,EACTuuI,EAAI,GAAKl9H,EACFk9H,CACT,CAUO,SAASzoI,EAAIyoI,EAAK7vH,EAAGhF,GAI1B,OAHA60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GACX60H,CACT,CAUO,SAASG,EAASH,EAAK7vH,EAAGhF,GAI/B,OAHA60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GACX60H,CACT,CAUO,SAASI,EAASJ,EAAK7vH,EAAGhF,GAI/B,OAHA60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GACX60H,CACT,CAUO,SAASK,EAAOL,EAAK7vH,EAAGhF,GAI7B,OAHA60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAClB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GACX60H,CACT,CASO,SAASnoB,EAAKmoB,EAAK7vH,GAIxB,OAHA6vH,EAAI,GAAK9uI,KAAK2mH,KAAK1nG,EAAE,IACrB6vH,EAAI,GAAK9uI,KAAK2mH,KAAK1nG,EAAE,IACrB6vH,EAAI,GAAK9uI,KAAK2mH,KAAK1nG,EAAE,IACd6vH,CACT,CASO,SAAS/9H,EAAM+9H,EAAK7vH,GAIzB,OAHA6vH,EAAI,GAAK9uI,KAAK+Q,MAAMkO,EAAE,IACtB6vH,EAAI,GAAK9uI,KAAK+Q,MAAMkO,EAAE,IACtB6vH,EAAI,GAAK9uI,KAAK+Q,MAAMkO,EAAE,IACf6vH,CACT,CAUO,SAASjuI,EAAIiuI,EAAK7vH,EAAGhF,GAI1B,OAHA60H,EAAI,GAAK9uI,KAAKa,IAAIoe,EAAE,GAAIhF,EAAE,IAC1B60H,EAAI,GAAK9uI,KAAKa,IAAIoe,EAAE,GAAIhF,EAAE,IAC1B60H,EAAI,GAAK9uI,KAAKa,IAAIoe,EAAE,GAAIhF,EAAE,IACnB60H,CACT,CAUO,SAAS58H,EAAI48H,EAAK7vH,EAAGhF,GAI1B,OAHA60H,EAAI,GAAK9uI,KAAKkS,IAAI+M,EAAE,GAAIhF,EAAE,IAC1B60H,EAAI,GAAK9uI,KAAKkS,IAAI+M,EAAE,GAAIhF,EAAE,IAC1B60H,EAAI,GAAK9uI,KAAKkS,IAAI+M,EAAE,GAAIhF,EAAE,IACnB60H,CACT,CASO,SAAS5qH,EAAM4qH,EAAK7vH,GAIzB,OAHA6vH,EAAI,GAAK9uI,KAAKkkB,MAAMjF,EAAE,IACtB6vH,EAAI,GAAK9uI,KAAKkkB,MAAMjF,EAAE,IACtB6vH,EAAI,GAAK9uI,KAAKkkB,MAAMjF,EAAE,IACf6vH,CACT,CAUO,SAASvvI,EAAMuvI,EAAK7vH,EAAGhF,GAI5B,OAHA60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAChB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EAChB60H,EAAI,GAAK7vH,EAAE,GAAKhF,EACT60H,CACT,CAWO,SAASM,EAAYN,EAAK7vH,EAAGhF,EAAG1a,GAIrC,OAHAuvI,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAAK1a,EACvBuvI,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAAK1a,EACvBuvI,EAAI,GAAK7vH,EAAE,GAAKhF,EAAE,GAAK1a,EAChBuvI,CACT,CASO,SAAS/vH,EAASE,EAAGhF,GAC1B,IAAI5Z,EAAI4Z,EAAE,GAAKgF,EAAE,GACb1e,EAAI0Z,EAAE,GAAKgF,EAAE,GACbrN,EAAIqI,EAAE,GAAKgF,EAAE,GACjB,OAAOjf,KAAKsvG,MAAMjvG,EAAGE,EAAGqR,EAC1B,CASO,SAASy9H,EAAgBpwH,EAAGhF,GACjC,IAAI5Z,EAAI4Z,EAAE,GAAKgF,EAAE,GACb1e,EAAI0Z,EAAE,GAAKgF,EAAE,GACbrN,EAAIqI,EAAE,GAAKgF,EAAE,GACjB,OAAO5e,EAAIA,EAAIE,EAAIA,EAAIqR,EAAIA,CAC7B,CAQO,SAAS09H,EAAcrwH,GAC5B,IAAI5e,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GACV,OAAO5e,EAAIA,EAAIE,EAAIA,EAAIqR,EAAIA,CAC7B,CASO,SAAS29H,EAAOT,EAAK7vH,GAI1B,OAHA6vH,EAAI,IAAM7vH,EAAE,GACZ6vH,EAAI,IAAM7vH,EAAE,GACZ6vH,EAAI,IAAM7vH,EAAE,GACL6vH,CACT,CASO,SAASU,EAAQV,EAAK7vH,GAI3B,OAHA6vH,EAAI,GAAK,EAAM7vH,EAAE,GACjB6vH,EAAI,GAAK,EAAM7vH,EAAE,GACjB6vH,EAAI,GAAK,EAAM7vH,EAAE,GACV6vH,CACT,CASO,SAASW,EAAUX,EAAK7vH,GAC7B,IAAI5e,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GACNo1B,EAAMh0C,EAAIA,EAAIE,EAAIA,EAAIqR,EAAIA,EAU9B,OARIyiC,EAAM,IAERA,EAAM,EAAIr0C,KAAKwmC,KAAK6N,IAGtBy6F,EAAI,GAAK7vH,EAAE,GAAKo1B,EAChBy6F,EAAI,GAAK7vH,EAAE,GAAKo1B,EAChBy6F,EAAI,GAAK7vH,EAAE,GAAKo1B,EACTy6F,CACT,CASO,SAAS/rH,EAAI9D,EAAGhF,GACrB,OAAOgF,EAAE,GAAKhF,EAAE,GAAKgF,EAAE,GAAKhF,EAAE,GAAKgF,EAAE,GAAKhF,EAAE,EAC9C,CAUO,SAASusC,EAAMsoF,EAAK7vH,EAAGhF,GAC5B,IAAI86D,EAAK91D,EAAE,GACP+1D,EAAK/1D,EAAE,GACPg2D,EAAKh2D,EAAE,GACPywH,EAAKz1H,EAAE,GACP01H,EAAK11H,EAAE,GACP21H,EAAK31H,EAAE,GAIX,OAHA60H,EAAI,GAAK95D,EAAK46D,EAAK36D,EAAK06D,EACxBb,EAAI,GAAK75D,EAAKy6D,EAAK36D,EAAK66D,EACxBd,EAAI,GAAK/5D,EAAK46D,EAAK36D,EAAK06D,EACjBZ,CACT,CAWO,SAASe,EAAKf,EAAK7vH,EAAGhF,EAAG8vB,GAC9B,IAAIgrC,EAAK91D,EAAE,GACP+1D,EAAK/1D,EAAE,GACPg2D,EAAKh2D,EAAE,GAIX,OAHA6vH,EAAI,GAAK/5D,EAAKhrC,GAAK9vB,EAAE,GAAK86D,GAC1B+5D,EAAI,GAAK95D,EAAKjrC,GAAK9vB,EAAE,GAAK+6D,GAC1B85D,EAAI,GAAK75D,EAAKlrC,GAAK9vB,EAAE,GAAKg7D,GACnB65D,CACT,CAaO,SAASgB,EAAQhB,EAAK7vH,EAAGhF,EAAGokB,EAAG0xG,EAAGhmG,GACvC,IAAIimG,EAAejmG,EAAIA,EACnBkmG,EAAUD,GAAgB,EAAIjmG,EAAI,GAAK,EACvCmmG,EAAUF,GAAgBjmG,EAAI,GAAKA,EACnComG,EAAUH,GAAgBjmG,EAAI,GAC9BqmG,EAAUJ,GAAgB,EAAI,EAAIjmG,GAItC,OAHA+kG,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EACnEtB,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EACnEtB,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EAC5DtB,CACT,CAaO,SAASuB,EAAOvB,EAAK7vH,EAAGhF,EAAGokB,EAAG0xG,EAAGhmG,GACtC,IAAIumG,EAAgB,EAAIvmG,EACpBwmG,EAAwBD,EAAgBA,EACxCN,EAAejmG,EAAIA,EACnBkmG,EAAUM,EAAwBD,EAClCJ,EAAU,EAAInmG,EAAIwmG,EAClBJ,EAAU,EAAIH,EAAeM,EAC7BF,EAAUJ,EAAejmG,EAI7B,OAHA+kG,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EACnEtB,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EACnEtB,EAAI,GAAK7vH,EAAE,GAAKgxH,EAAUh2H,EAAE,GAAKi2H,EAAU7xG,EAAE,GAAK8xG,EAAUJ,EAAE,GAAKK,EAC5DtB,CACT,CASO,SAAS3wG,EAAO2wG,EAAKvvI,GAC1BA,EAAQA,GAAS,EACjB,IAAIwa,EAAwB,EAApB,WAA0B/Z,KAAKC,GACnC2R,EAAwB,EAApB,WAA0B,EAC9B4+H,EAASxwI,KAAKwmC,KAAK,EAAM50B,EAAIA,GAAKrS,EAItC,OAHAuvI,EAAI,GAAK9uI,KAAKy+E,IAAI1kE,GAAKy2H,EACvB1B,EAAI,GAAK9uI,KAAK0+E,IAAI3kE,GAAKy2H,EACvB1B,EAAI,GAAKl9H,EAAIrS,EACNuvI,CACT,CAWO,SAAS2B,EAAc3B,EAAK7vH,EAAG2mF,GACpC,IAAIvlG,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GACNowF,EAAIzJ,EAAE,GAAKvlG,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,IAAMh0F,EAAIg0F,EAAE,IAK5C,OAJAyJ,EAAIA,GAAK,EACTy/B,EAAI,IAAMlpC,EAAE,GAAKvlG,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,GAAKh0F,EAAIg0F,EAAE,KAAOyJ,EACpDy/B,EAAI,IAAMlpC,EAAE,GAAKvlG,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,GAAKh0F,EAAIg0F,EAAE,KAAOyJ,EACpDy/B,EAAI,IAAMlpC,EAAE,GAAKvlG,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,IAAMh0F,EAAIg0F,EAAE,KAAOyJ,EAC9Cy/B,CACT,CAUO,SAAS4B,EAAc5B,EAAK7vH,EAAG2mF,GACpC,IAAIvlG,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GAIV,OAHA6vH,EAAI,GAAKzuI,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,GAAKh0F,EAAIg0F,EAAE,GACrCkpC,EAAI,GAAKzuI,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,GAAKh0F,EAAIg0F,EAAE,GACrCkpC,EAAI,GAAKzuI,EAAIulG,EAAE,GAAKrlG,EAAIqlG,EAAE,GAAKh0F,EAAIg0F,EAAE,GAC9BkpC,CACT,CAWO,SAAS6B,EAAc7B,EAAK7vH,EAAG2xH,GAEpC,IAAIC,EAAKD,EAAE,GACPE,EAAKF,EAAE,GACPG,EAAKH,EAAE,GACPI,EAAKJ,EAAE,GACPvwI,EAAI4e,EAAE,GACN1e,EAAI0e,EAAE,GACNrN,EAAIqN,EAAE,GAGNgyH,EAAMH,EAAKl/H,EAAIm/H,EAAKxwI,EACpB2wI,EAAMH,EAAK1wI,EAAIwwI,EAAKj/H,EACpBu/H,EAAMN,EAAKtwI,EAAIuwI,EAAKzwI,EAEpB+wI,EAAON,EAAKK,EAAMJ,EAAKG,EACvBG,EAAON,EAAKE,EAAMJ,EAAKM,EACvBG,EAAOT,EAAKK,EAAMJ,EAAKG,EAEvBM,EAAU,EAALP,EAYT,OAXAC,GAAOM,EACPL,GAAOK,EACPJ,GAAOI,EAEPH,GAAQ,EACRC,GAAQ,EACRC,GAAQ,EAERxC,EAAI,GAAKzuI,EAAI4wI,EAAMG,EACnBtC,EAAI,GAAKvuI,EAAI2wI,EAAMG,EACnBvC,EAAI,GAAKl9H,EAAIu/H,EAAMG,EACZxC,CACT,CAUO,SAAS0C,EAAQ1C,EAAK7vH,EAAGhF,EAAGw3H,GACjC,IAAIhgI,EAAI,GACJsI,EAAI,GAaR,OAXAtI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAEhBF,EAAE,GAAKtI,EAAE,GACTsI,EAAE,GAAKtI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAAOhgI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAC9C13H,EAAE,GAAKtI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAAOhgI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAE9C3C,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GACX60H,CACT,CAUO,SAAS4C,EAAQ5C,EAAK7vH,EAAGhF,EAAGw3H,GACjC,IAAIhgI,EAAI,GACJsI,EAAI,GAaR,OAXAtI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAEhBF,EAAE,GAAKtI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAAOhgI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAC9C13H,EAAE,GAAKtI,EAAE,GACTsI,EAAE,GAAKtI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAAOhgI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAE9C3C,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GACX60H,CACT,CAUO,SAASjuC,EAAQiuC,EAAK7vH,EAAGhF,EAAGw3H,GACjC,IAAIhgI,EAAI,GACJsI,EAAI,GAaR,OAXAtI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAChBxI,EAAE,GAAKwN,EAAE,GAAKhF,EAAE,GAEhBF,EAAE,GAAKtI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAAOhgI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAC9C13H,EAAE,GAAKtI,EAAE,GAAKzR,KAAK0+E,IAAI+yD,GAAOhgI,EAAE,GAAKzR,KAAKy+E,IAAIgzD,GAC9C13H,EAAE,GAAKtI,EAAE,GAETq9H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GAClB60H,EAAI,GAAK/0H,EAAE,GAAKE,EAAE,GACX60H,CACT,CAQO,SAASjvI,EAAMof,EAAGhF,GACvB,IAAI86D,EAAK91D,EAAE,GACP+1D,EAAK/1D,EAAE,GACPg2D,EAAKh2D,EAAE,GACPywH,EAAKz1H,EAAE,GACP01H,EAAK11H,EAAE,GACP21H,EAAK31H,EAAE,GAGP03H,EAFO3xI,KAAKwmC,KAAKuuC,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GACnCj1E,KAAKwmC,KAAKkpG,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAE1CgC,EAASD,GAAO5uH,EAAI9D,EAAGhF,GAAK03H,EAChC,OAAO3xI,KAAK++C,KAAK/+C,KAAKa,IAAIb,KAAKkS,IAAI0/H,GAAS,GAAI,GAClD,CAQO,SAASC,EAAK/C,GAInB,OAHAA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACFA,CACT,CAQO,SAAS7sH,EAAIhD,GAClB,MAAO,QAAUA,EAAE,GAAK,KAAOA,EAAE,GAAK,KAAOA,EAAE,GAAK,GACtD,CASO,SAAS6yH,EAAY7yH,EAAGhF,GAC7B,OAAOgF,EAAE,KAAOhF,EAAE,IAAMgF,EAAE,KAAOhF,EAAE,IAAMgF,EAAE,KAAOhF,EAAE,EACtD,CASO,SAASm+G,EAAOn5G,EAAGhF,GACxB,IAAI83H,EAAK9yH,EAAE,GACPgpD,EAAKhpD,EAAE,GACPmpD,EAAKnpD,EAAE,GACP+yH,EAAK/3H,EAAE,GACPiuD,EAAKjuD,EAAE,GACPouD,EAAKpuD,EAAE,GACX,OAAOja,KAAK6e,IAAIkzH,EAAKC,IAAO,UAAmBhyI,KAAKkS,IAAI,EAAKlS,KAAK6e,IAAIkzH,GAAK/xI,KAAK6e,IAAImzH,KAAQhyI,KAAK6e,IAAIopD,EAAKC,IAAO,UAAmBloE,KAAKkS,IAAI,EAAKlS,KAAK6e,IAAIopD,GAAKjoE,KAAK6e,IAAIqpD,KAAQloE,KAAK6e,IAAIupD,EAAKC,IAAO,UAAmBroE,KAAKkS,IAAI,EAAKlS,KAAK6e,IAAIupD,GAAKpoE,KAAK6e,IAAIwpD,GAChQ,CAMO,IAmDDkvD,EAnDKthG,EAAMg5G,EAMNgD,EAAM/C,EAMNgD,EAAM/C,EAMNjrE,EAAOnlD,EAMPozH,EAAU9C,EAMVh7F,EAAM1wC,EAMNyuI,EAAS9C,EAcTtrI,GACLuzH,EAAM30H,IACH,SAAUqc,EAAGozH,EAAQhiI,EAAQ2B,EAAO28F,EAAI2jC,GAC7C,IAAI7lI,EAAG8lI,EAgBP,IAdKF,IACHA,EAAS,GAGNhiI,IACHA,EAAS,GAITkiI,EADEvgI,EACEhS,KAAKa,IAAImR,EAAQqgI,EAAShiI,EAAQ4O,EAAEtb,QAEpCsb,EAAEtb,OAGH8I,EAAI4D,EAAQ5D,EAAI8lI,EAAG9lI,GAAK4lI,EAC3B9a,EAAI,GAAKt4G,EAAExS,GACX8qH,EAAI,GAAKt4G,EAAExS,EAAI,GACf8qH,EAAI,GAAKt4G,EAAExS,EAAI,GACfkiG,EAAG4oB,EAAKA,EAAK+a,GACbrzH,EAAExS,GAAK8qH,EAAI,GACXt4G,EAAExS,EAAI,GAAK8qH,EAAI,GACft4G,EAAExS,EAAI,GAAK8qH,EAAI,GAGjB,OAAOt4G,CACT,E,+DC/wBa,SAASuzH,IACtB,OAAO,OAAU7sC,UACnB,C,+BCJe,WAAS8sC,EAAclkH,GAEpC,IADA,IAAImkH,EAAU,IAAIjxI,MAAM8sB,GACf9hB,EAAI,EAAGA,EAAI8hB,IAAK9hB,EAAGimI,EAAQjmI,GAAKgmI,EAAahmI,GAAK8hB,EAAI,IAC/D,OAAOmkH,CACT,C","sources":["webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/Settings.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/buildMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateSpacingBetweenImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/fnv1aHash.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageDataMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSubVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeDirectionVectors.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateNeighborhoodStats.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/logger.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ContourLoopExtraction.js","webpack:///../../../node_modules/@cornerstonejs/polymorphic-segmentation/dist/esm/workers/polySegConverters.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js","webpack:///../../../node_modules/gl-matrix/esm/vec3.js","webpack:///../../../node_modules/d3-array/src/zip.js","webpack:///../../../node_modules/d3-interpolate/src/quantize.js"],"sourcesContent":["import now from './rendering/now';\nimport { renderColorImage } from './rendering/renderColorImage';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\nexport default function (enabledElement, invalidated) {\n    const image = enabledElement.image;\n    if (!enabledElement.canvas || !enabledElement.image) {\n        return;\n    }\n    const start = now();\n    image.stats = {\n        lastGetPixelDataTime: -1.0,\n        lastStoredPixelDataToCanvasImageDataTime: -1.0,\n        lastPutImageDataTime: -1.0,\n        lastRenderTime: -1.0,\n        lastLutGenerateTime: -1.0,\n    };\n    if (image) {\n        let render = image.render;\n        if (!render) {\n            if (enabledElement.viewport.colormap) {\n                render = renderPseudoColorImage;\n            }\n            else if (image.color) {\n                render = renderColorImage;\n            }\n            else {\n                render = renderGrayscaleImage;\n            }\n        }\n        render(enabledElement, invalidated);\n    }\n    const renderTimeInMs = now() - start;\n    image.stats.lastRenderTime = renderTimeInMs;\n    enabledElement.invalid = false;\n    enabledElement.needsRedraw = false;\n}\n","import { Transform } from './transform';\nexport default function (enabledElement, scale) {\n    const transform = new Transform();\n    if (!enabledElement.viewport.displayedArea) {\n        return transform;\n    }\n    transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);\n    const angle = enabledElement.viewport.rotation;\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    let widthScale = enabledElement.viewport.scale;\n    let heightScale = enabledElement.viewport.scale;\n    const width = enabledElement.viewport.displayedArea.brhc.x -\n        (enabledElement.viewport.displayedArea.tlhc.x - 1);\n    const height = enabledElement.viewport.displayedArea.brhc.y -\n        (enabledElement.viewport.displayedArea.tlhc.y - 1);\n    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\n        if (enabledElement.image.rowPixelSpacing <\n            enabledElement.image.columnPixelSpacing) {\n            widthScale *=\n                enabledElement.image.columnPixelSpacing /\n                    enabledElement.image.rowPixelSpacing;\n        }\n        else if (enabledElement.image.columnPixelSpacing <\n            enabledElement.image.rowPixelSpacing) {\n            heightScale *=\n                enabledElement.image.rowPixelSpacing /\n                    enabledElement.image.columnPixelSpacing;\n        }\n    }\n    else {\n        widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\n        heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\n        if (enabledElement.viewport.displayedArea.presentationSizeMode ===\n            'SCALE TO FIT') {\n            const verticalScale = enabledElement.canvas.height / (height * heightScale);\n            const horizontalScale = enabledElement.canvas.width / (width * widthScale);\n            widthScale = heightScale = Math.min(horizontalScale, verticalScale);\n            if (enabledElement.viewport.displayedArea.rowPixelSpacing <\n                enabledElement.viewport.displayedArea.columnPixelSpacing) {\n                widthScale *=\n                    enabledElement.viewport.displayedArea.columnPixelSpacing /\n                        enabledElement.viewport.displayedArea.rowPixelSpacing;\n            }\n            else if (enabledElement.viewport.displayedArea.columnPixelSpacing <\n                enabledElement.viewport.displayedArea.rowPixelSpacing) {\n                heightScale *=\n                    enabledElement.viewport.displayedArea.rowPixelSpacing /\n                        enabledElement.viewport.displayedArea.columnPixelSpacing;\n            }\n        }\n    }\n    transform.scale(widthScale, heightScale);\n    if (angle !== 0) {\n        transform.rotate((-angle * Math.PI) / 180);\n    }\n    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    if (scale !== undefined) {\n        transform.scale(scale, scale);\n    }\n    if (enabledElement.viewport.hflip) {\n        transform.scale(-1, 1);\n    }\n    if (enabledElement.viewport.vflip) {\n        transform.scale(1, -1);\n    }\n    transform.translate(-width / 2, -height / 2);\n    return transform;\n}\n","import createViewport from './createViewport';\nimport getImageFitScale from './getImageFitScale';\nexport default function (canvas, image, modality, colormap) {\n    if (canvas === undefined) {\n        throw new Error('getDefaultViewport: parameter canvas must not be undefined');\n    }\n    if (image === undefined) {\n        return createViewport();\n    }\n    const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n    let voi;\n    if (modality === 'PT' && image.isPreScaled) {\n        voi = {\n            windowWidth: 5,\n            windowCenter: 2.5,\n        };\n    }\n    else if (image.windowWidth !== undefined &&\n        image.windowCenter !== undefined) {\n        voi = {\n            windowWidth: Array.isArray(image.windowWidth)\n                ? image.windowWidth[0]\n                : image.windowWidth,\n            windowCenter: Array.isArray(image.windowCenter)\n                ? image.windowCenter[0]\n                : image.windowCenter,\n        };\n    }\n    return {\n        scale,\n        translation: {\n            x: 0,\n            y: 0,\n        },\n        voi,\n        invert: image.invert,\n        pixelReplication: false,\n        rotation: 0,\n        hflip: false,\n        vflip: false,\n        modalityLUT: image.modalityLUT,\n        modality,\n        voiLUT: image.voiLUT,\n        colormap: colormap !== undefined ? colormap : image.colormap,\n        displayedArea: {\n            tlhc: {\n                x: 1,\n                y: 1,\n            },\n            brhc: {\n                x: image.columns,\n                y: image.rows,\n            },\n            rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\n            columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\n            presentationSizeMode: 'NONE',\n        },\n    };\n}\n","export var GenerateImageType;\n(function (GenerateImageType) {\n    GenerateImageType[\"SUM\"] = \"SUM\";\n    GenerateImageType[\"SUBTRACT\"] = \"SUBTRACT\";\n    GenerateImageType[\"AVERAGE\"] = \"AVERAGE\";\n})(GenerateImageType || (GenerateImageType = {}));\n","const DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\nexport default class Settings {\n    constructor(base) {\n        const dictionary = Object.create((base instanceof Settings && DICTIONARY in base\n            ? base[DICTIONARY]\n            : null));\n        Object.seal(Object.defineProperty(this, DICTIONARY, {\n            value: dictionary,\n        }));\n    }\n    set(key, value) {\n        return set(this[DICTIONARY], key, value, null);\n    }\n    get(key) {\n        return get(this[DICTIONARY], key);\n    }\n    unset(key) {\n        return unset(this[DICTIONARY], key + '');\n    }\n    forEach(callback) {\n        iterate(this[DICTIONARY], callback);\n    }\n    extend() {\n        return new Settings(this);\n    }\n    import(root) {\n        if (isPlainObject(root)) {\n            Object.keys(root).forEach((key) => {\n                set(this[DICTIONARY], key, root[key], null);\n            });\n        }\n    }\n    dump() {\n        const context = {};\n        iterate(this[DICTIONARY], (key, value) => {\n            if (typeof value !== 'undefined') {\n                deepSet(context, key, value);\n            }\n        });\n        return context;\n    }\n    static assert(subject) {\n        return subject instanceof Settings\n            ? subject\n            : Settings.getRuntimeSettings();\n    }\n    static getDefaultSettings(subfield = null) {\n        let defaultSettings = Settings[DEFAULT_SETTINGS];\n        if (!(defaultSettings instanceof Settings)) {\n            defaultSettings = new Settings();\n            Settings[DEFAULT_SETTINGS] = defaultSettings;\n        }\n        if (subfield) {\n            const settingObj = {};\n            defaultSettings.forEach((name) => {\n                if (name.startsWith(subfield)) {\n                    const setting = name.split(`${subfield}.`)[1];\n                    settingObj[setting] = defaultSettings.get(name);\n                }\n            });\n            return settingObj;\n        }\n        return defaultSettings;\n    }\n    static getRuntimeSettings() {\n        let runtimeSettings = Settings[RUNTIME_SETTINGS];\n        if (!(runtimeSettings instanceof Settings)) {\n            runtimeSettings = new Settings(Settings.getDefaultSettings());\n            Settings[RUNTIME_SETTINGS] = runtimeSettings;\n        }\n        return runtimeSettings;\n    }\n    static getObjectSettings(subject, from) {\n        let settings = null;\n        if (subject instanceof Settings) {\n            settings = subject;\n        }\n        else if (typeof subject === 'object' && subject !== null) {\n            let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n            if (!(objectSettingsMap instanceof WeakMap)) {\n                objectSettingsMap = new WeakMap();\n                Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n            }\n            settings = objectSettingsMap.get(subject);\n            if (!(settings instanceof Settings)) {\n                settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));\n                objectSettingsMap.set(subject, settings);\n            }\n        }\n        return settings;\n    }\n    static extendRuntimeSettings() {\n        return Settings.getRuntimeSettings().extend();\n    }\n}\nfunction unset(dictionary, name) {\n    if (name.endsWith('.')) {\n        let deleteCount = 0;\n        const namespace = name;\n        const base = namespace.slice(0, -1);\n        const deleteAll = base.length === 0;\n        for (const key in dictionary) {\n            if (Object.prototype.hasOwnProperty.call(dictionary, key) &&\n                (deleteAll || key.startsWith(namespace) || key === base)) {\n                delete dictionary[key];\n                ++deleteCount;\n            }\n        }\n        return deleteCount > 0;\n    }\n    return delete dictionary[name];\n}\nfunction iterate(dictionary, callback) {\n    for (const key in dictionary) {\n        callback(key, dictionary[key]);\n    }\n}\nfunction setAll(dictionary, prefix, record, references) {\n    let failCount;\n    if (references.has(record)) {\n        return set(dictionary, prefix, null, references);\n    }\n    references.add(record);\n    failCount = 0;\n    for (const field in record) {\n        if (Object.prototype.hasOwnProperty.call(record, field)) {\n            const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n            if (!set(dictionary, key, record[field], references)) {\n                ++failCount;\n            }\n        }\n    }\n    references.delete(record);\n    return failCount === 0;\n}\nfunction set(dictionary, key, value, references) {\n    if (isValidKey(key)) {\n        if (isPlainObject(value)) {\n            return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet());\n        }\n        dictionary[key] = value;\n        return true;\n    }\n    return false;\n}\nfunction get(dictionary, key) {\n    return dictionary[key];\n}\nfunction isValidKey(key) {\n    let last, current, previous;\n    if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n        return false;\n    }\n    previous = -1;\n    while ((current = key.indexOf('.', previous + 1)) >= 0) {\n        if (current - previous < 2 || current === last) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}\nfunction isPlainObject(subject) {\n    if (typeof subject === 'object' && subject !== null) {\n        const prototype = Object.getPrototypeOf(subject);\n        if (prototype === Object.prototype || prototype === null) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction deepSet(context, key, value) {\n    const separator = key.indexOf('.');\n    if (separator >= 0) {\n        const subKey = key.slice(0, separator);\n        let subContext = context[subKey];\n        if (typeof subContext !== 'object' || subContext === null) {\n            const subContextValue = subContext;\n            subContext = {};\n            if (typeof subContextValue !== 'undefined') {\n                subContext[''] = subContextValue;\n            }\n            context[subKey] = subContext;\n        }\n        deepSet(subContext, key.slice(separator + 1, key.length), value);\n    }\n    else {\n        context[key] = value;\n    }\n}\nSettings.getDefaultSettings().set('useCursors', true);\n","import cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport genericMetadataProvider from '../utilities/genericMetadataProvider';\nimport { getBufferConfiguration } from '../utilities/getBufferConfiguration';\nimport triggerEvent from '../utilities/triggerEvent';\nimport uuidv4 from '../utilities/uuidv4';\nimport VoxelManager from '../utilities/VoxelManager';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport * as metaData from '../metaData';\nimport VoxelManagerEnum from '../enums/VoxelManagerEnum';\nconst imageLoaders = {};\nlet unknownImageLoader;\nfunction loadImageFromImageLoader(imageId, options) {\n    const cachedImageLoadObject = cache.getImageLoadObject(imageId);\n    if (cachedImageLoadObject) {\n        handleImageLoadPromise(cachedImageLoadObject.promise, imageId);\n        return cachedImageLoadObject;\n    }\n    const scheme = imageId.split(':')[0];\n    const loader = imageLoaders[scheme] || unknownImageLoader;\n    if (!loader) {\n        throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);\n    }\n    const imageLoadObject = loader(imageId, options);\n    handleImageLoadPromise(imageLoadObject.promise, imageId);\n    return imageLoadObject;\n}\nfunction handleImageLoadPromise(imagePromise, imageId) {\n    Promise.resolve(imagePromise)\n        .then((image) => {\n        ensureVoxelManager(image);\n        triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    })\n        .catch((error) => {\n        const errorDetails = {\n            imageId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorDetails);\n    });\n}\nfunction ensureVoxelManager(image) {\n    if (!image.voxelManager) {\n        const { width, height, numberOfComponents } = image;\n        const voxelManager = VoxelManager.createImageVoxelManager({\n            scalarData: image.getPixelData(),\n            width,\n            height,\n            numberOfComponents,\n        });\n        image.voxelManager = voxelManager;\n        image.getPixelData = () => voxelManager.getScalarData();\n        delete image.imageFrame.pixelData;\n    }\n}\nexport function loadImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadImage: parameter imageId must not be undefined');\n    }\n    return loadImageFromImageLoader(imageId, options).promise;\n}\nexport function loadAndCacheImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadAndCacheImage: parameter imageId must not be undefined');\n    }\n    const imageLoadObject = loadImageFromImageLoader(imageId, options);\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageLoadObject(imageId, imageLoadObject);\n    }\n    return imageLoadObject.promise;\n}\nexport function loadAndCacheImages(imageIds, options = { priority: 0, requestType: 'prefetch' }) {\n    if (!imageIds || imageIds.length === 0) {\n        throw new Error('loadAndCacheImages: parameter imageIds must be list of image Ids');\n    }\n    const allPromises = imageIds.map((imageId) => {\n        return loadAndCacheImage(imageId, options);\n    });\n    return allPromises;\n}\nexport function createAndCacheDerivedImage(referencedImageId, options = {}) {\n    if (referencedImageId === undefined) {\n        throw new Error('createAndCacheDerivedImage: parameter imageId must not be undefined');\n    }\n    if (options.imageId === undefined) {\n        options.imageId = `derived:${uuidv4()}`;\n    }\n    const { imageId, skipCreateBuffer, onCacheAdd, voxelRepresentation } = options;\n    const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n    const length = imagePlaneModule.rows * imagePlaneModule.columns;\n    const { TypedArrayConstructor } = getBufferConfiguration(options.targetBuffer?.type, length);\n    const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length);\n    const derivedImageId = imageId;\n    const referencedImagePlaneMetadata = metaData.get('imagePlaneModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePlaneModule',\n        metadata: referencedImagePlaneMetadata,\n    });\n    const referencedImageGeneralSeriesMetadata = metaData.get('generalSeriesModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalSeriesModule',\n        metadata: referencedImageGeneralSeriesMetadata,\n    });\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalImageModule',\n        metadata: {\n            instanceNumber: options.instanceNumber,\n        },\n    });\n    const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePixelModule',\n        metadata: {\n            ...imagePixelModule,\n            bitsAllocated: 8,\n            bitsStored: 8,\n            highBit: 7,\n            samplesPerPixel: 1,\n            pixelRepresentation: 0,\n        },\n    });\n    const localImage = createAndCacheLocalImage(imageId, {\n        scalarData: imageScalarData,\n        onCacheAdd,\n        skipCreateBuffer,\n        targetBuffer: {\n            type: imageScalarData.constructor.name,\n        },\n        voxelRepresentation,\n        dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],\n        spacing: [\n            imagePlaneModule.columnPixelSpacing,\n            imagePlaneModule.rowPixelSpacing,\n        ],\n        origin: imagePlaneModule.imagePositionPatient,\n        direction: imagePlaneModule.imageOrientationPatient,\n        frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        referencedImageId: referencedImageId,\n    });\n    localImage.referencedImageId = referencedImageId;\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageSync(imageId, localImage);\n    }\n    return localImage;\n}\nexport function createAndCacheDerivedImages(referencedImageIds, options = {}) {\n    if (referencedImageIds.length === 0) {\n        throw new Error('createAndCacheDerivedImages: parameter imageIds must be list of image Ids');\n    }\n    const derivedImageIds = [];\n    const images = referencedImageIds.map((referencedImageId, index) => {\n        const newOptions = {\n            imageId: options?.getDerivedImageId?.(referencedImageId) ||\n                `derived:${uuidv4()}`,\n            ...options,\n        };\n        derivedImageIds.push(newOptions.imageId);\n        return createAndCacheDerivedImage(referencedImageId, {\n            ...newOptions,\n            instanceNumber: index + 1,\n        });\n    });\n    return images;\n}\nexport function createAndCacheLocalImage(imageId, options) {\n    const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, voxelRepresentation, referencedImageId, } = options;\n    const dimensions = options.dimensions;\n    const spacing = options.spacing;\n    if (!dimensions || !spacing) {\n        throw new Error('createAndCacheLocalImage: dimensions and spacing are required');\n    }\n    const width = dimensions[0];\n    const height = dimensions[1];\n    const columnPixelSpacing = spacing[0];\n    const rowPixelSpacing = spacing[1];\n    const imagePlaneModule = {\n        frameOfReferenceUID,\n        rows: height,\n        columns: width,\n        imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],\n        rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],\n        columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],\n        imagePositionPatient: origin ?? [0, 0, 0],\n        pixelSpacing: [rowPixelSpacing, columnPixelSpacing],\n        rowPixelSpacing: rowPixelSpacing,\n        columnPixelSpacing: columnPixelSpacing,\n    };\n    const length = width * height;\n    const numberOfComponents = scalarData.length / length;\n    let scalarDataToUse;\n    if (scalarData) {\n        if (!(scalarData instanceof Uint8Array ||\n            scalarData instanceof Float32Array ||\n            scalarData instanceof Uint16Array ||\n            scalarData instanceof Int16Array)) {\n            throw new Error('createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array');\n        }\n        scalarDataToUse = scalarData;\n    }\n    else if (!skipCreateBuffer) {\n        const { TypedArrayConstructor } = getBufferConfiguration(targetBuffer?.type, length);\n        const imageScalarData = new TypedArrayConstructor(length);\n        scalarDataToUse = imageScalarData;\n    }\n    let bitsAllocated, bitsStored, highBit;\n    if (scalarDataToUse instanceof Uint8Array) {\n        bitsAllocated = 8;\n        bitsStored = 8;\n        highBit = 7;\n    }\n    else if (scalarDataToUse instanceof Uint16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Int16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Float32Array) {\n        bitsAllocated = 32;\n        bitsStored = 32;\n        highBit = 31;\n    }\n    else {\n        throw new Error('Unsupported scalarData type');\n    }\n    const imagePixelModule = {\n        samplesPerPixel: 1,\n        photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1]\n            ? 'RGB'\n            : 'MONOCHROME2',\n        rows: height,\n        columns: width,\n        bitsAllocated,\n        bitsStored,\n        highBit,\n    };\n    const metadata = {\n        imagePlaneModule,\n        imagePixelModule,\n    };\n    ['imagePlaneModule', 'imagePixelModule'].forEach((type) => {\n        genericMetadataProvider.add(imageId, {\n            type,\n            metadata: metadata[type] || {},\n        });\n    });\n    const id = imageId;\n    const voxelManager = (voxelRepresentation === VoxelManagerEnum.RLE &&\n        VoxelManager.createRLEImageVoxelManager({ dimensions, id })) ||\n        VoxelManager.createImageVoxelManager({\n            height,\n            width,\n            numberOfComponents,\n            scalarData: scalarDataToUse,\n            id,\n        });\n    let minPixelValue = scalarDataToUse[0];\n    let maxPixelValue = scalarDataToUse[0];\n    for (let i = 1; i < scalarDataToUse.length; i++) {\n        if (scalarDataToUse[i] < minPixelValue) {\n            minPixelValue = scalarDataToUse[i];\n        }\n        if (scalarDataToUse[i] > maxPixelValue) {\n            maxPixelValue = scalarDataToUse[i];\n        }\n    }\n    const image = {\n        imageId: imageId,\n        intercept: 0,\n        windowCenter: 0,\n        windowWidth: 0,\n        color: imagePixelModule.photometricInterpretation === 'RGB',\n        numberOfComponents: imagePixelModule.samplesPerPixel,\n        dataType: targetBuffer?.type,\n        slope: 1,\n        minPixelValue,\n        maxPixelValue,\n        rows: imagePixelModule.rows,\n        columns: imagePixelModule.columns,\n        getCanvas: undefined,\n        height: imagePixelModule.rows,\n        width: imagePixelModule.columns,\n        rgba: undefined,\n        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n        FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        invert: false,\n        getPixelData: () => voxelManager.getScalarData(),\n        voxelManager,\n        sizeInBytes: scalarData.byteLength,\n        referencedImageId,\n    };\n    onCacheAdd?.(image);\n    cache.putImageSync(image.imageId, image);\n    return image;\n}\nexport function cancelLoadImage(imageId) {\n    const filterFunction = ({ additionalDetails }) => {\n        if (additionalDetails.imageId) {\n            return additionalDetails.imageId !== imageId;\n        }\n        return true;\n    };\n    imageLoadPoolManager.filterRequests(filterFunction);\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n    if (imageLoadObject) {\n        imageLoadObject.cancelFn();\n    }\n}\nexport function cancelLoadImages(imageIds) {\n    imageIds.forEach((imageId) => {\n        cancelLoadImage(imageId);\n    });\n}\nexport function cancelLoadAll() {\n    const requestPool = imageLoadPoolManager.getRequestPool();\n    Object.keys(requestPool).forEach((type) => {\n        const requests = requestPool[type];\n        Object.keys(requests).forEach((priority) => {\n            const requestDetails = requests[priority].pop();\n            if (!requestDetails) {\n                return;\n            }\n            const additionalDetails = requestDetails.additionalDetails;\n            const { imageId, volumeId } = additionalDetails;\n            let loadObject;\n            if (imageId) {\n                loadObject = cache.getImageLoadObject(imageId);\n            }\n            else if (volumeId) {\n                loadObject = cache.getVolumeLoadObject(volumeId);\n            }\n            if (loadObject) {\n                loadObject.cancel();\n            }\n        });\n        imageLoadPoolManager.clearRequestStack(type);\n    });\n}\nexport function registerImageLoader(scheme, imageLoader) {\n    imageLoaders[scheme] = imageLoader;\n}\nexport function registerUnknownImageLoader(imageLoader) {\n    const oldImageLoader = unknownImageLoader;\n    unknownImageLoader = imageLoader;\n    return oldImageLoader;\n}\nexport function unregisterAllImageLoaders() {\n    Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);\n    unknownImageLoader = undefined;\n}\nexport function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {\n    return createAndCacheDerivedImages(referencedImageIds, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\nexport function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {\n    return createAndCacheDerivedImage(referencedImageId, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\n","export default class FrameRange {\n    static { this.frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i; }\n    static imageIdToFrames(imageId) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const range = match[2].split('-').map((it) => Number(it));\n        if (range.length === 1) {\n            return range[0];\n        }\n        return range;\n    }\n    static imageIdToFrameEnd(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[1] : range;\n    }\n    static imageIdToFrameStart(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[0] : range;\n    }\n    static framesToString(range) {\n        if (Array.isArray(range)) {\n            return `${range[0]}-${range[1]}`;\n        }\n        return String(range);\n    }\n    static framesToImageId(imageId, range) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const newRangeString = this.framesToString(range);\n        return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);\n    }\n}\n","export default class PointsManager {\n    constructor(configuration = {}) {\n        this._dimensions = 3;\n        this._length = 0;\n        this._byteSize = 4;\n        this.growSize = 128;\n        const { initialSize = 1024, dimensions = 3, growSize = 128, } = configuration;\n        const itemLength = initialSize * dimensions;\n        this.growSize = growSize;\n        this.array = new ArrayBuffer(itemLength * this._byteSize);\n        this.data = new Float32Array(this.array);\n        this._dimensions = dimensions;\n    }\n    forEach(func) {\n        for (let i = 0; i < this._length; i++) {\n            func(this.getPoint(i), i);\n        }\n    }\n    get length() {\n        return this._length;\n    }\n    get dimensions() {\n        return this._dimensions;\n    }\n    get dimensionLength() {\n        return this._length * this._dimensions;\n    }\n    getPoint(index) {\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        return this.data.subarray(offset, offset + this._dimensions);\n    }\n    getPointArray(index) {\n        const array = [];\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        for (let i = 0; i < this._dimensions; i++) {\n            array.push(this.data[i + offset]);\n        }\n        return array;\n    }\n    grow(additionalSize = 1, growSize = this.growSize) {\n        if (this.dimensionLength + additionalSize * this._dimensions <=\n            this.data.length) {\n            return;\n        }\n        const newSize = this.data.length + growSize;\n        const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);\n        const newData = new Float32Array(newArray);\n        newData.set(this.data);\n        this.data = newData;\n        this.array = newArray;\n    }\n    reverse() {\n        const midLength = Math.floor(this._length / 2);\n        for (let i = 0; i < midLength; i++) {\n            const indexStart = i * this._dimensions;\n            const indexEnd = (this._length - 1 - i) * this._dimensions;\n            for (let dimension = 0; dimension < this._dimensions; dimension++) {\n                const valueStart = this.data[indexStart + dimension];\n                this.data[indexStart + dimension] = this.data[indexEnd + dimension];\n                this.data[indexEnd + dimension] = valueStart;\n            }\n        }\n    }\n    getTypedArray() {\n        return this.data;\n    }\n    push(point) {\n        this.grow(1);\n        const offset = this.length * this._dimensions;\n        for (let i = 0; i < this._dimensions; i++) {\n            this.data[i + offset] = point[i];\n        }\n        this._length++;\n    }\n    map(f) {\n        const mapData = [];\n        for (let i = 0; i < this._length; i++) {\n            mapData.push(f(this.getPoint(i), i));\n        }\n        return mapData;\n    }\n    get points() {\n        return this.map((p) => p);\n    }\n    toXYZ() {\n        const xyz = { x: [], y: [] };\n        if (this._dimensions >= 3) {\n            xyz.z = [];\n        }\n        const { x, y, z } = xyz;\n        this.forEach((p) => {\n            x.push(p[0]);\n            y.push(p[1]);\n            if (z) {\n                z.push(p[2]);\n            }\n        });\n        return xyz;\n    }\n    static fromXYZ({ x, y, z }) {\n        const array = PointsManager.create3(x.length);\n        let offset = 0;\n        for (let i = 0; i < x.length; i++) {\n            array.data[offset++] = x[i];\n            array.data[offset++] = y[i];\n            array.data[offset++] = z ? z[i] : 0;\n        }\n        array._length = x.length;\n        return array;\n    }\n    subselect(count = 10, offset = 0) {\n        const selected = new PointsManager({\n            initialSize: count,\n            dimensions: this._dimensions,\n        });\n        for (let i = 0; i < count; i++) {\n            const index = (offset + Math.floor((this.length * i) / count)) % this.length;\n            selected.push(this.getPoint(index));\n        }\n        return selected;\n    }\n    static create3(initialSize = 128, points) {\n        initialSize = Math.max(initialSize, points?.length || 0);\n        const newPoints = new PointsManager({ initialSize, dimensions: 3 });\n        if (points) {\n            points.forEach((point) => newPoints.push(point));\n        }\n        return newPoints;\n    }\n    static create2(initialSize = 128) {\n        return new PointsManager({ initialSize, dimensions: 2 });\n    }\n}\n","export class PromiseIterator extends Promise {\n}\nexport default class ProgressiveIterator {\n    constructor(name) {\n        this.name = name || 'unknown';\n    }\n    static as(promise) {\n        if (promise.iterator) {\n            return promise.iterator;\n        }\n        const iterator = new ProgressiveIterator('as iterator');\n        promise.then((v) => {\n            try {\n                iterator.add(v, true);\n            }\n            catch (e) {\n                iterator.reject(e);\n            }\n        }, (reason) => {\n            iterator.reject(reason);\n        });\n        return iterator;\n    }\n    add(x, done = false) {\n        this.nextValue = x;\n        this.done ||= done;\n        if (this.waiting) {\n            this.waiting.resolve(x);\n            this.waiting = undefined;\n        }\n    }\n    resolve() {\n        this.done = true;\n        if (this.waiting) {\n            this.waiting.resolve(this.nextValue);\n            this.waiting = undefined;\n        }\n    }\n    reject(reason) {\n        this.rejectReason = reason;\n        this.waiting?.reject(reason);\n    }\n    getRecent() {\n        if (this.rejectReason) {\n            throw this.rejectReason;\n        }\n        return this.nextValue;\n    }\n    async *[Symbol.asyncIterator]() {\n        while (!this.done) {\n            if (this.rejectReason) {\n                throw this.rejectReason;\n            }\n            if (this.nextValue !== undefined) {\n                yield this.nextValue;\n                if (this.done) {\n                    break;\n                }\n            }\n            if (!this.waiting) {\n                this.waiting = {};\n                this.waiting.promise = new Promise((resolve, reject) => {\n                    this.waiting.resolve = resolve;\n                    this.waiting.reject = reject;\n                });\n            }\n            await this.waiting.promise;\n        }\n        yield this.nextValue;\n    }\n    async forEach(callback, errorCallback) {\n        let index = 0;\n        try {\n            for await (const value of this) {\n                const { done } = this;\n                try {\n                    await callback(value, done, index);\n                    index++;\n                }\n                catch (e) {\n                    if (!done) {\n                        console.warn('Caught exception in intermediate value', e);\n                        continue;\n                    }\n                    if (errorCallback) {\n                        errorCallback(e, done);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            if (errorCallback) {\n                errorCallback(e, true);\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    generate(processFunction, errorCallback) {\n        return processFunction(this, this.reject.bind(this)).then(() => {\n            if (!this.done) {\n                this.resolve();\n            }\n        }, (reason) => {\n            this.reject(reason);\n            if (errorCallback) {\n                errorCallback(reason);\n            }\n            else {\n                console.warn(\"Couldn't process because\", reason);\n            }\n        });\n    }\n    async nextPromise() {\n        for await (const i of this) {\n            if (i) {\n                return i;\n            }\n        }\n        return this.nextValue;\n    }\n    async donePromise() {\n        for await (const i of this) {\n        }\n        return this.nextValue;\n    }\n    getNextPromise() {\n        const promise = this.nextPromise();\n        promise.iterator = this;\n        return promise;\n    }\n    getDonePromise() {\n        const promise = this.donePromise();\n        promise.iterator = this;\n        return promise;\n    }\n}\n","const ADJACENT_ALL = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n    [0, 0, 1],\n];\nconst ADJACENT_SINGLE_PLANE = [\n    [0, -1, 0],\n    [0, 1, 0],\n];\nconst ADJACENT_IN = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n];\nconst ADJACENT_OUT = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n];\nexport default class RLEVoxelMap {\n    static copyMap(destination, source) {\n        for (const [index, row] of source.rows) {\n            destination.rows.set(index, structuredClone(row));\n        }\n    }\n    constructor(width, height, depth = 1) {\n        this.rows = new Map();\n        this.height = 1;\n        this.width = 1;\n        this.depth = 1;\n        this.jMultiple = 1;\n        this.kMultiple = 1;\n        this.numComps = 1;\n        this.pixelDataConstructor = Uint8Array;\n        this.updateScalarData = function (scalarData) {\n            scalarData.fill(0);\n            const callback = (index, rle, row) => {\n                const { start, end, value } = rle;\n                for (let i = start; i < end; i++) {\n                    scalarData[index + i] = value;\n                }\n            };\n            this.forEach(callback);\n        };\n        this.get = (index) => {\n            const i = index % this.jMultiple;\n            const j = (index - i) / this.jMultiple;\n            const rle = this.getRLE(i, j);\n            return rle?.value ?? this.defaultValue;\n        };\n        this.getRun = (j, k) => {\n            const runIndex = j + k * this.height;\n            return this.rows.get(runIndex);\n        };\n        this.set = (index, value) => {\n            if (value === undefined) {\n                return;\n            }\n            const i = index % this.width;\n            const j = (index - i) / this.width;\n            const row = this.rows.get(j);\n            if (!row) {\n                this.rows.set(j, [{ start: i, end: i + 1, value }]);\n                return;\n            }\n            const rleIndex = this.findIndex(row, i);\n            const rle1 = row[rleIndex];\n            const rle0 = row[rleIndex - 1];\n            if (!rle1) {\n                if (!rle0 || rle0.value !== value || rle0.end !== i) {\n                    row[rleIndex] = { start: i, end: i + 1, value };\n                    return;\n                }\n                rle0.end++;\n                return;\n            }\n            const { start, end, value: oldValue } = rle1;\n            if (value === oldValue && i >= start) {\n                return;\n            }\n            const rleInsert = { start: i, end: i + 1, value };\n            const isAfter = i > start;\n            const insertIndex = isAfter ? rleIndex + 1 : rleIndex;\n            const rlePrev = isAfter ? rle1 : rle0;\n            let rleNext = isAfter ? row[rleIndex + 1] : rle1;\n            if (rlePrev?.value === value && rlePrev?.end === i) {\n                rlePrev.end++;\n                if (rleNext?.value === value && rleNext.start === i + 1) {\n                    rlePrev.end = rleNext.end;\n                    row.splice(rleIndex, 1);\n                }\n                else if (rleNext?.start === i) {\n                    rleNext.start++;\n                    if (rleNext.start === rleNext.end) {\n                        row.splice(rleIndex, 1);\n                        rleNext = row[rleIndex];\n                        if (rleNext?.start === i + 1 && rleNext.value === value) {\n                            rlePrev.end = rleNext.end;\n                            row.splice(rleIndex, 1);\n                        }\n                    }\n                }\n                return;\n            }\n            if (rleNext?.value === value && rleNext.start === i + 1) {\n                rleNext.start--;\n                if (rlePrev?.end > i) {\n                    rlePrev.end = i;\n                    if (rlePrev.end === rlePrev.start) {\n                        row.splice(rleIndex, 1);\n                    }\n                }\n                return;\n            }\n            if (rleNext?.start === i && rleNext.end === i + 1) {\n                rleNext.value = value;\n                const nextnext = row[rleIndex + 1];\n                if (nextnext?.start == i + 1 && nextnext.value === value) {\n                    row.splice(rleIndex + 1, 1);\n                    rleNext.end = nextnext.end;\n                }\n                return;\n            }\n            if (i === rleNext?.start) {\n                rleNext.start++;\n            }\n            if (isAfter && end > i + 1) {\n                row.splice(insertIndex, 0, rleInsert, {\n                    start: i + 1,\n                    end: rlePrev.end,\n                    value: rlePrev.value,\n                });\n            }\n            else {\n                row.splice(insertIndex, 0, rleInsert);\n            }\n            if (rlePrev?.end > i) {\n                rlePrev.end = i;\n            }\n        };\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.jMultiple = width;\n        this.kMultiple = this.jMultiple * height;\n    }\n    static { this.getScalarData = function (ArrayType = Uint8ClampedArray) {\n        const scalarData = new ArrayType(this.frameSize);\n        this.map.updateScalarData(scalarData);\n        return scalarData;\n    }; }\n    toIJK(index) {\n        const i = index % this.jMultiple;\n        const j = ((index - i) / this.jMultiple) % this.height;\n        const k = Math.floor(index / this.kMultiple);\n        return [i, j, k];\n    }\n    toIndex([i, j, k]) {\n        return i + k * this.kMultiple + j * this.jMultiple;\n    }\n    getRLE(i, j, k = 0) {\n        const row = this.rows.get(j + k * this.height);\n        if (!row) {\n            return;\n        }\n        const index = this.findIndex(row, i);\n        const rle = row[index];\n        return i >= rle?.start ? rle : undefined;\n    }\n    has(index) {\n        const i = index % this.jMultiple;\n        const j = (index - i) / this.jMultiple;\n        const rle = this.getRLE(i, j);\n        return rle?.value !== undefined;\n    }\n    delete(index) {\n        const i = index % this.width;\n        const j = (index - i) / this.width;\n        const row = this.rows.get(j);\n        if (!row) {\n            return;\n        }\n        const rleIndex = this.findIndex(row, i);\n        const rle = row[rleIndex];\n        if (!rle || rle.start > i) {\n            return;\n        }\n        if (rle.end === i + 1) {\n            rle.end--;\n            if (rle.start >= rle.end) {\n                row.splice(rleIndex, 1);\n                if (!row.length) {\n                    this.rows.delete(j);\n                }\n            }\n            return;\n        }\n        if (rle.start === i) {\n            rle.start++;\n            return;\n        }\n        const newRle = {\n            value: rle.value,\n            start: i + 1,\n            end: rle.end,\n        };\n        rle.end = i;\n        row.splice(rleIndex + 1, 0, newRle);\n    }\n    findIndex(row, i) {\n        for (let index = 0; index < row.length; index++) {\n            const { end: iEnd } = row[index];\n            if (i < iEnd) {\n                return index;\n            }\n        }\n        return row.length;\n    }\n    forEach(callback, options) {\n        const rowModified = options?.rowModified;\n        for (const [baseIndex, row] of this.rows) {\n            const rowToUse = rowModified ? [...row] : row;\n            for (const rle of rowToUse) {\n                callback(baseIndex * this.width, rle, row);\n            }\n        }\n    }\n    forEachRow(callback) {\n        for (const [baseIndex, row] of this.rows) {\n            callback(baseIndex * this.width, row);\n        }\n    }\n    clear() {\n        this.rows.clear();\n    }\n    keys() {\n        return [...this.rows.keys()];\n    }\n    getPixelData(k = 0, pixelData) {\n        if (!pixelData) {\n            pixelData = new this.pixelDataConstructor(this.width * this.height * this.numComps);\n        }\n        else {\n            pixelData.fill(0);\n        }\n        const { width, height, numComps } = this;\n        for (let j = 0; j < height; j++) {\n            const row = this.getRun(j, k);\n            if (!row) {\n                continue;\n            }\n            if (numComps === 1) {\n                for (const rle of row) {\n                    const rowOffset = j * width;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i++) {\n                        pixelData[rowOffset + i] = value;\n                    }\n                }\n            }\n            else {\n                for (const rle of row) {\n                    const rowOffset = j * width * numComps;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i += numComps) {\n                        for (let comp = 0; comp < numComps; comp++) {\n                            pixelData[rowOffset + i + comp] = value[comp];\n                        }\n                    }\n                }\n            }\n        }\n        return pixelData;\n    }\n    floodFill(i, j, k, value, options) {\n        const rle = this.getRLE(i, j, k);\n        if (!rle) {\n            throw new Error(`Initial point ${i},${j},${k} isn't in the RLE`);\n        }\n        const stack = [[rle, j, k]];\n        const replaceValue = rle.value;\n        if (replaceValue === value) {\n            throw new Error(`source (${replaceValue}) and destination (${value}) are identical`);\n        }\n        return this.flood(stack, replaceValue, value, options);\n    }\n    flood(stack, sourceValue, value, options) {\n        let sum = 0;\n        const { planar = true, diagonals = true, singlePlane = false, } = options || {};\n        const childOptions = { planar, diagonals, singlePlane };\n        while (stack.length) {\n            const top = stack.pop();\n            const [current] = top;\n            if (current.value !== sourceValue) {\n                continue;\n            }\n            current.value = value;\n            sum += current.end - current.start;\n            const adjacents = this.findAdjacents(top, childOptions).filter((adjacent) => adjacent && adjacent[0].value === sourceValue);\n            stack.push(...adjacents);\n        }\n        return sum;\n    }\n    fillFrom(getter, boundsIJK) {\n        for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n            for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                let rle;\n                let row;\n                for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                    const value = getter(i, j, k);\n                    if (value === undefined) {\n                        rle = undefined;\n                        continue;\n                    }\n                    if (!row) {\n                        row = [];\n                        this.rows.set(j + k * this.height, row);\n                    }\n                    if (rle && rle.value !== value) {\n                        rle = undefined;\n                    }\n                    if (!rle) {\n                        rle = { start: i, end: i, value };\n                        row.push(rle);\n                    }\n                    rle.end++;\n                }\n            }\n        }\n    }\n    findAdjacents(item, { diagonals = true, planar = true, singlePlane = false }) {\n        const [rle, j, k, adjacentsDelta] = item;\n        const { start, end } = rle;\n        const leftRle = start > 0 && this.getRLE(start - 1, j, k);\n        const rightRle = end < this.width && this.getRLE(end, j, k);\n        const range = diagonals\n            ? [start > 0 ? start - 1 : start, end < this.width ? end + 1 : end]\n            : [start, end];\n        const adjacents = [];\n        if (leftRle) {\n            adjacents.push([leftRle, j, k]);\n        }\n        if (rightRle) {\n            adjacents.push([rightRle, j, k]);\n        }\n        for (const delta of adjacentsDelta ||\n            (singlePlane ? ADJACENT_SINGLE_PLANE : ADJACENT_ALL)) {\n            const [, delta1, delta2] = delta;\n            const testJ = delta1 + j;\n            const testK = delta2 + k;\n            if (testJ < 0 || testJ >= this.height) {\n                continue;\n            }\n            if (testK < 0 || testK >= this.depth) {\n                continue;\n            }\n            const row = this.getRun(testJ, testK);\n            if (!row) {\n                continue;\n            }\n            for (const testRle of row) {\n                const newAdjacentDelta = adjacentsDelta ||\n                    (singlePlane && ADJACENT_SINGLE_PLANE) ||\n                    (planar && delta2 > 0 && ADJACENT_OUT) ||\n                    (planar && delta2 < 0 && ADJACENT_IN) ||\n                    ADJACENT_ALL;\n                if (!(testRle.end <= range[0] || testRle.start >= range[1])) {\n                    adjacents.push([testRle, testJ, testK, newAdjacentDelta]);\n                }\n            }\n        }\n        return adjacents;\n    }\n}\n","export function isImageActor(actorEntry) {\n    return (actorIsA(actorEntry, 'vtkVolume') || actorIsA(actorEntry, 'vtkImageSlice'));\n}\nexport function actorIsA(actorEntry, actorType) {\n    const actorToCheck = 'isA' in actorEntry ? actorEntry : actorEntry.actor;\n    if (!actorToCheck) {\n        return false;\n    }\n    return !!actorToCheck.isA(actorType);\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nexport default function applyPreset(actor, preset) {\n    const colorTransferArray = preset.colorTransfer\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const { shiftRange } = getShiftRange(colorTransferArray);\n    const min = shiftRange[0];\n    const width = shiftRange[1] - shiftRange[0];\n    const cfun = vtkColorTransferFunction.newInstance();\n    const normColorTransferValuePoints = [];\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        let value = colorTransferArray[i];\n        const r = colorTransferArray[i + 1];\n        const g = colorTransferArray[i + 2];\n        const b = colorTransferArray[i + 3];\n        value = (value - min) / width;\n        normColorTransferValuePoints.push([value, r, g, b]);\n    }\n    applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);\n    actor.getProperty().setRGBTransferFunction(0, cfun);\n    const scalarOpacityArray = preset.scalarOpacity\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const ofun = vtkPiecewiseFunction.newInstance();\n    const normPoints = [];\n    for (let i = 0; i < scalarOpacityArray.length; i += 2) {\n        let value = scalarOpacityArray[i];\n        const opacity = scalarOpacityArray[i + 1];\n        value = (value - min) / width;\n        normPoints.push([value, opacity]);\n    }\n    applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);\n    const property = actor.getProperty();\n    property.setScalarOpacity(0, ofun);\n    const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity,] = preset.gradientOpacity.split(' ').splice(1).map(parseFloat);\n    property.setUseGradientOpacity(0, true);\n    property.setGradientOpacityMinimumValue(0, gradientMinValue);\n    property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);\n    property.setGradientOpacityMaximumValue(0, gradientMaxValue);\n    property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);\n    if (preset.interpolation === '1') {\n        property.setInterpolationTypeToFastLinear();\n    }\n    property.setShade(preset.shade === '1');\n    const ambient = parseFloat(preset.ambient);\n    const diffuse = parseFloat(preset.diffuse);\n    const specular = parseFloat(preset.specular);\n    const specularPower = parseFloat(preset.specularPower);\n    property.setAmbient(ambient);\n    property.setDiffuse(diffuse);\n    property.setSpecular(specular);\n    property.setSpecularPower(specularPower);\n}\nfunction getShiftRange(colorTransferArray) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        min = Math.min(min, colorTransferArray[i]);\n        max = Math.max(max, colorTransferArray[i]);\n    }\n    const center = (max - min) / 2;\n    return {\n        shiftRange: [-center, center],\n        min,\n        max,\n    };\n}\nfunction applyPointsToRGBFunction(points, range, cfun) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, r, g, b]) => [\n        x * width + range[0],\n        r,\n        g,\n        b,\n    ]);\n    cfun.removeAllPoints();\n    rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));\n    return rescaled;\n}\nfunction applyPointsToPiecewiseFunction(points, range, pwf) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, y]) => [x * width + range[0], y]);\n    pwf.removeAllPoints();\n    rescaled.forEach(([x, y]) => pwf.addPoint(x, y));\n    return rescaled;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nconst autoLoad = (volumeId) => {\n    const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);\n    if (!renderingEngineAndViewportIds?.length) {\n        return;\n    }\n    renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {\n        if (!renderingEngine.hasBeenDestroyed) {\n            renderingEngine.renderViewports(viewportIds);\n        }\n    });\n};\nfunction getRenderingEngineAndViewportsContainingVolume(volumeId) {\n    const renderingEnginesArray = getRenderingEngines();\n    const renderingEngineAndViewportIds = [];\n    renderingEnginesArray.forEach((renderingEngine) => {\n        const viewports = getViewportsWithVolumeId(volumeId);\n        if (viewports.length) {\n            renderingEngineAndViewportIds.push({\n                renderingEngine,\n                viewportIds: viewports.map((viewport) => viewport.id),\n            });\n        }\n    });\n    return renderingEngineAndViewportIds;\n}\nexport default autoLoad;\n","import * as metaData from '../metaData';\nimport { MetadataModules, VOILUTFunctionType } from '../enums';\nexport function getValidVOILUTFunction(voiLUTFunction) {\n    if (!Object.values(VOILUTFunctionType).includes(voiLUTFunction)) {\n        return VOILUTFunctionType.LINEAR;\n    }\n    return voiLUTFunction;\n}\nexport function getImagePlaneModule(imageId) {\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\n    const newImagePlaneModule = {\n        ...imagePlaneModule,\n    };\n    if (!newImagePlaneModule.columnPixelSpacing) {\n        newImagePlaneModule.columnPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.rowPixelSpacing) {\n        newImagePlaneModule.rowPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.columnCosines) {\n        newImagePlaneModule.columnCosines = [0, 1, 0];\n    }\n    if (!newImagePlaneModule.rowCosines) {\n        newImagePlaneModule.rowCosines = [1, 0, 0];\n    }\n    if (!newImagePlaneModule.imagePositionPatient) {\n        newImagePlaneModule.imagePositionPatient = [0, 0, 0];\n    }\n    if (!newImagePlaneModule.imageOrientationPatient) {\n        newImagePlaneModule.imageOrientationPatient = new Float32Array([\n            1, 0, 0, 0, 1, 0,\n        ]);\n    }\n    return newImagePlaneModule;\n}\nexport function calibrateImagePlaneModule(imageId, imagePlaneModule, currentCalibration) {\n    const calibration = metaData.get('calibratedPixelSpacing', imageId);\n    const isUpdated = currentCalibration !== calibration;\n    const { scale } = calibration || {};\n    const hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;\n    imagePlaneModule.calibration = calibration;\n    if (!isUpdated) {\n        return { imagePlaneModule, hasPixelSpacing };\n    }\n    return {\n        imagePlaneModule,\n        hasPixelSpacing,\n        calibrationEvent: {\n            scale,\n            calibration,\n        },\n    };\n}\nexport function buildMetadata(image) {\n    const imageId = image.imageId;\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = metaData.get('imagePixelModule', imageId);\n    const { windowWidth, windowCenter, voiLUTFunction } = image;\n    const { modality } = metaData.get('generalSeriesModule', imageId);\n    const imageIdScalingFactor = metaData.get('scalingModule', imageId);\n    const calibration = metaData.get(MetadataModules.CALIBRATION, imageId);\n    const voiLUTFunctionEnum = getValidVOILUTFunction(voiLUTFunction);\n    const imagePlaneModule = getImagePlaneModule(imageId);\n    return {\n        calibration,\n        scalingFactor: imageIdScalingFactor,\n        voiLUTFunction: voiLUTFunctionEnum,\n        modality,\n        imagePlaneModule,\n        imagePixelModule: {\n            bitsAllocated,\n            bitsStored,\n            samplesPerPixel,\n            highBit,\n            photometricInterpretation,\n            pixelRepresentation,\n            windowWidth: windowWidth,\n            windowCenter: windowCenter,\n            modality,\n            voiLUTFunction: voiLUTFunctionEnum,\n        },\n    };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { getConfiguration } from '../init';\nexport default function calculateSpacingBetweenImageIds(imageIds) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n    const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    const refIppVec = vec3.fromValues(referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    let spacing;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        const ippVec = vec3.fromValues(imagePositionPatient[0], imagePositionPatient[1], imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, ippVec);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        const numImages = distanceImagePairs.length;\n        spacing =\n            Math.abs(distanceImagePairs[numImages - 1].distance -\n                distanceImagePairs[0].distance) /\n                (numImages - 1);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        const metadataForMiddleImage = metaData.get('imagePlaneModule', prefetchedImageIds[1]);\n        if (!metadataForMiddleImage) {\n            throw new Error('Incomplete metadata required for volume construction.');\n        }\n        const positionVector = vec3.create();\n        const middleIppVec = vec3.fromValues(metadataForMiddleImage.imagePositionPatient[0], metadataForMiddleImage.imagePositionPatient[1], metadataForMiddleImage.imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, middleIppVec);\n        const distanceBetweenFirstAndMiddleImages = vec3.dot(positionVector, scanAxisNormal);\n        spacing =\n            Math.abs(distanceBetweenFirstAndMiddleImages) /\n                Math.floor(imageIds.length / 2);\n    }\n    const { sliceThickness, spacingBetweenSlices } = metaData.get('imagePlaneModule', imageIds[0]);\n    const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;\n    if ((spacing === 0 || isNaN(spacing)) && !strictZSpacingForVolumeViewport) {\n        if (spacingBetweenSlices) {\n            console.debug('Could not calculate spacing. Using spacingBetweenSlices');\n            spacing = spacingBetweenSlices;\n        }\n        else if (sliceThickness) {\n            console.debug('Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness');\n            spacing = sliceThickness;\n        }\n        else {\n            console.debug('Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render');\n            spacing = 1;\n        }\n    }\n    return spacing;\n}\n","function clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nexport { clamp as default, clamp };\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport isEqual from './isEqual';\nimport { actorIsA } from './actorCheck';\nconst _colormaps = new Map();\nfunction registerColormap(colormap) {\n    _colormaps.set(colormap.Name, colormap);\n}\nfunction getColormap(name) {\n    return _colormaps.get(name);\n}\nfunction getColormapNames() {\n    return Array.from(_colormaps.keys());\n}\nfunction findMatchingColormap(rgbPoints, actor) {\n    const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) => vtkColorMaps.getPresetByName(presetName));\n    const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));\n    const colormaps = colormapsVTK.concat(colormapsCS3D);\n    const matchedColormap = colormaps.find((colormap) => {\n        const { RGBPoints: presetRGBPoints } = colormap;\n        if (presetRGBPoints.length !== rgbPoints.length) {\n            return false;\n        }\n        for (let i = 0; i < presetRGBPoints.length; i += 4) {\n            if (!isEqual(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {\n                return false;\n            }\n        }\n        return true;\n    });\n    if (!matchedColormap) {\n        return null;\n    }\n    const opacity = [];\n    if (actorIsA(actor, 'vtkVolume')) {\n        const opacityPoints = actor\n            .getProperty()\n            .getScalarOpacity(0)\n            .getDataPointer();\n        if (!opacityPoints) {\n            return {\n                name: matchedColormap.Name,\n            };\n        }\n        for (let i = 0; i < opacityPoints.length; i += 2) {\n            opacity.push({\n                value: opacityPoints[i],\n                opacity: opacityPoints[i + 1],\n            });\n        }\n    }\n    return {\n        name: matchedColormap.Name,\n        opacity,\n    };\n}\nexport { getColormap, getColormapNames, registerColormap, findMatchingColormap, };\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nexport default function createLinearRGBTransferFunction(voiRange) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    let lower = 0;\n    let upper = 1024;\n    if (voiRange.lower !== undefined && voiRange.upper !== undefined) {\n        lower = voiRange.lower;\n        upper = voiRange.upper;\n    }\n    cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\n    cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\n    return cfun;\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport * as windowLevelUtil from './windowLevel';\nimport { logit } from './logit';\nexport default function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {\n    const { windowWidth, windowCenter } = windowLevelUtil.toWindowLevel(voiRange.lower, voiRange.upper);\n    const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));\n    const table = range.flatMap((y) => {\n        const x = logit(y, windowCenter, windowWidth);\n        return [x, y, y, y, 0.5, 0.0];\n    });\n    const cfun = vtkColorTransferFunction.newInstance();\n    cfun.buildFunctionFromArray(vtkDataArray.newInstance({\n        values: table,\n        numberOfComponents: 6,\n    }));\n    return cfun;\n}\n","export default function decimate(list, interleave, offset = 0) {\n    const interleaveIndices = [];\n    for (let i = offset; i < list.length; i += interleave) {\n        interleaveIndices.push(i);\n    }\n    return interleaveIndices;\n}\n","export function deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (typeof obj === 'function') {\n        return obj;\n    }\n    if (typeof structuredClone === 'function') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(deepClone);\n    }\n    else {\n        const clonedObj = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clonedObj[key] = deepClone(obj[key]);\n            }\n        }\n        return clonedObj;\n    }\n}\n","export default function fnv1aHash(str) {\n    let hash = 0x811c9dc5;\n    for (let i = 0; i < str.length; i++) {\n        hash ^= str.charCodeAt(i);\n        hash +=\n            (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n    return (hash >>> 0).toString(36);\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { EPSILON } from '../constants';\nexport default function getClosestImageId(imageVolume, worldPos, viewPlaneNormal) {\n    const { direction, spacing, imageIds } = imageVolume;\n    if (!imageIds.length) {\n        return;\n    }\n    const kVector = direction.slice(6, 9);\n    const dotProducts = vec3.dot(kVector, viewPlaneNormal);\n    if (Math.abs(dotProducts) < 1 - EPSILON) {\n        return;\n    }\n    const spacingInNormalDirection = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    let imageIdForTool;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const dir = vec3.create();\n        vec3.sub(dir, worldPos, imagePositionPatient);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            imageIdForTool = imageId;\n        }\n    }\n    return imageIdForTool;\n}\n","import { vec3 } from 'gl-matrix';\nimport { EPSILON } from '../constants';\nimport { buildMetadata } from './buildMetadata';\nexport function getImageDataMetadata(image) {\n    const { imagePlaneModule, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = buildMetadata(image);\n    let { rowCosines, columnCosines } = imagePlaneModule;\n    if (rowCosines == null || columnCosines == null) {\n        rowCosines = [1, 0, 0];\n        columnCosines = [0, 1, 0];\n    }\n    const rowCosineVec = vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);\n    const colCosineVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    let origin = imagePlaneModule.imagePositionPatient;\n    if (origin == null) {\n        origin = [0, 0, 0];\n    }\n    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;\n    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;\n    const xVoxels = image.columns;\n    const yVoxels = image.rows;\n    const zSpacing = EPSILON;\n    const zVoxels = 1;\n    const numberOfComponents = image.numberOfComponents ||\n        _getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);\n    return {\n        numberOfComponents,\n        origin,\n        direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\n        dimensions: [xVoxels, yVoxels, zVoxels],\n        spacing: [xSpacing, ySpacing, zSpacing],\n        numVoxels: xVoxels * yVoxels * zVoxels,\n        imagePlaneModule,\n        imagePixelModule,\n        bitsAllocated: imagePixelModule.bitsAllocated,\n        voiLUTFunction,\n        modality,\n        scalingFactor,\n        calibration,\n    };\n}\nfunction _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {\n    let numberOfComponents = 1;\n    if (photometricInterpretation === 'RGB' ||\n        photometricInterpretation.includes('YBR') ||\n        photometricInterpretation === 'PALETTE COLOR') {\n        numberOfComponents = 3;\n    }\n    return numberOfComponents;\n}\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getImageSliceDataForVolumeViewport(viewport) {\n    const camera = viewport.getCamera();\n    const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n    if (!imageVolume) {\n        return;\n    }\n    const { viewPlaneNormal, focalPoint } = camera;\n    const actorEntry = viewport\n        .getActors()\n        .find((a) => a.referencedId === imageVolume.volumeId ||\n        a.uid === imageVolume.volumeId);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', imageVolume.volumeId);\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    const { min, max, current } = sliceRange;\n    const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\n    let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\n    imageIndex = Math.floor(imageIndex);\n    if (imageIndex > numberOfSlices - 1) {\n        imageIndex = numberOfSlices - 1;\n    }\n    else if (imageIndex < 0) {\n        imageIndex = 0;\n    }\n    return {\n        numberOfSlices,\n        imageIndex,\n    };\n}\nexport default getImageSliceDataForVolumeViewport;\n","import * as metaData from '../metaData';\nexport default function getScalingParameters(imageId) {\n    const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId) || {};\n    const { modality } = generalSeriesModule;\n    const scalingParameters = {\n        rescaleSlope: modalityLutModule.rescaleSlope || 1,\n        rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,\n        modality,\n    };\n    const suvFactor = metaData.get('scalingModule', imageId) || {};\n    return {\n        ...scalingParameters,\n        ...(modality === 'PT' && {\n            suvbw: suvFactor.suvbw,\n            suvbsa: suvFactor.suvbsa,\n            suvlbm: suvFactor.suvlbm,\n        }),\n    };\n}\n","import vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport { EPSILON } from '../constants';\nconst SMALL_EPSILON = EPSILON * EPSILON;\nconst isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;\nconst isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);\nconst isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);\nexport default function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {\n    const imageData = volumeActor.getMapper().getInputData();\n    let corners;\n    const direction = imageData.getDirection();\n    if (isOrthonormal(direction)) {\n        corners = getVolumeActorCorners(volumeActor);\n    }\n    else {\n        const [dx, dy, dz] = imageData.getDimensions();\n        const cornersIdx = [\n            [0, 0, 0],\n            [dx - 1, 0, 0],\n            [0, dy - 1, 0],\n            [dx - 1, dy - 1, 0],\n            [0, 0, dz - 1],\n            [dx - 1, 0, dz - 1],\n            [0, dy - 1, dz - 1],\n            [dx - 1, dy - 1, dz - 1],\n        ];\n        corners = cornersIdx.map((it) => imageData.indexToWorld(it));\n    }\n    const transform = vtkMatrixBuilder\n        .buildFromDegree()\n        .identity()\n        .rotateFromDirections(viewPlaneNormal, [1, 0, 0]);\n    corners.forEach((pt) => transform.apply(pt));\n    const transformedFocalPoint = [...focalPoint];\n    transform.apply(transformedFocalPoint);\n    const currentSlice = transformedFocalPoint[0];\n    let minX = Infinity;\n    let maxX = -Infinity;\n    for (let i = 0; i < 8; i++) {\n        const x = corners[i][0];\n        if (x > maxX) {\n            maxX = x;\n        }\n        if (x < minX) {\n            minX = x;\n        }\n    }\n    return {\n        min: minX,\n        max: maxX,\n        current: currentSlice,\n        actor: volumeActor,\n        viewPlaneNormal,\n        focalPoint,\n    };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {\n    const { direction, spacing } = imageVolume;\n    const iVector = direction.slice(0, 3);\n    const jVector = direction.slice(3, 6);\n    const kVector = direction.slice(6, 9);\n    const dotProducts = [\n        vec3.dot(iVector, viewPlaneNormal),\n        vec3.dot(jVector, viewPlaneNormal),\n        vec3.dot(kVector, viewPlaneNormal),\n    ];\n    const projectedSpacing = vec3.create();\n    vec3.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);\n    const spacingInNormalDirection = vec3.length(projectedSpacing);\n    return spacingInNormalDirection;\n}\n","import cache from '../cache/cache';\nimport { EPSILON } from '../constants';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { getVolumeLoaderSchemes } from '../loaders/volumeLoader';\nimport { getVolumeId } from './getVolumeId';\nconst EPSILON_PART = 1 + EPSILON;\nconst startsWith = (str, starts) => starts === str.substring(0, Math.min(str.length, starts.length));\nconst isPrimaryVolume = (volume) => !!getVolumeLoaderSchemes().find((scheme) => startsWith(volume.volumeId, scheme));\nexport default function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {\n    const { viewPlaneNormal } = camera;\n    const volumeActors = viewport.getActors();\n    if (!volumeActors.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const imageVolumes = volumeActors\n        .map((va) => {\n        const actorUID = va.referencedId ?? va.uid;\n        return cache.getVolume(actorUID);\n    })\n        .filter((iv) => !!iv);\n    if (targetId) {\n        const targetVolumeId = getVolumeId(targetId);\n        const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));\n        const imageVolume = imageVolumes[imageVolumeIndex];\n        const { uid: actorUID } = volumeActors[imageVolumeIndex];\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);\n        return { imageVolume, spacingInNormalDirection, actorUID };\n    }\n    if (!imageVolumes.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const smallest = {\n        spacingInNormalDirection: Infinity,\n        imageVolume: null,\n        actorUID: null,\n    };\n    const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);\n    for (let i = 0; i < imageVolumes.length; i++) {\n        const imageVolume = imageVolumes[i];\n        if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {\n            continue;\n        }\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);\n        if (spacingInNormalDirection * EPSILON_PART <\n            smallest.spacingInNormalDirection) {\n            smallest.spacingInNormalDirection = spacingInNormalDirection;\n            smallest.imageVolume = imageVolume;\n            smallest.actorUID = volumeActors[i].uid;\n        }\n    }\n    return smallest;\n}\nfunction getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {\n    const { slabThickness } = viewport.getProperties();\n    let spacingInNormalDirection = slabThickness;\n    if (!slabThickness || !useSlabThickness) {\n        spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n    }\n    return spacingInNormalDirection;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nfunction getViewportsWithVolumeId(volumeId) {\n    const renderingEngines = getRenderingEngines();\n    const targetViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getVolumeViewports();\n        const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));\n        targetViewports.push(...filteredViewports);\n    });\n    return targetViewports;\n}\nexport default getViewportsWithVolumeId;\n","export default function getVoiFromSigmoidRGBTransferFunction(cfun) {\n    let cfunRange = [];\n    const [lower, upper] = cfun.getRange();\n    cfun.getTable(lower, upper, 1024, cfunRange);\n    cfunRange = cfunRange.filter((v, k) => k % 3 === 0);\n    const cfunDomain = [...Array(1024).keys()].map((v, k) => {\n        return lower + ((upper - lower) / (1024 - 1)) * k;\n    });\n    const y1 = cfunRange[256];\n    const logy1 = Math.log((1 - y1) / y1);\n    const x1 = cfunDomain[256];\n    const y2 = cfunRange[256 * 3];\n    const logy2 = Math.log((1 - y2) / y2);\n    const x2 = cfunDomain[256 * 3];\n    const ww = Math.round((4 * (x2 - x1)) / (logy1 - logy2));\n    const wc = Math.round(x1 + (ww * logy1) / 4);\n    return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];\n}\n","export default function getVolumeActorCorners(volumeActor) {\n    const imageData = volumeActor.getMapper().getInputData();\n    const bounds = imageData.extentToBounds(imageData.getExtent());\n    return [\n        [bounds[0], bounds[2], bounds[4]],\n        [bounds[0], bounds[2], bounds[5]],\n        [bounds[0], bounds[3], bounds[4]],\n        [bounds[0], bounds[3], bounds[5]],\n        [bounds[1], bounds[2], bounds[4]],\n        [bounds[1], bounds[2], bounds[5]],\n        [bounds[1], bounds[3], bounds[4]],\n        [bounds[1], bounds[3], bounds[5]],\n    ];\n}\n","export const getVolumeId = (targetId) => {\n    const prefix = 'volumeId:';\n    const str = targetId.includes(prefix)\n        ? targetId.substring(prefix.length)\n        : targetId;\n    const index = str.indexOf('sliceIndex=');\n    return index === -1 ? str : str.substring(0, index - 1);\n};\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {\n    const camera = viewport.getCamera();\n    const { focalPoint, viewPlaneNormal } = camera;\n    const { spacingInNormalDirection, actorUID } = getTargetVolumeAndSpacingInNormalDir(viewport, camera, volumeId, useSlabThickness);\n    if (!actorUID) {\n        throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);\n    }\n    const actorEntry = viewport.getActor(actorUID);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', actorUID);\n        return null;\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    return {\n        sliceRange,\n        spacingInNormalDirection,\n        camera,\n    };\n}\nexport default getVolumeSliceRangeInfo;\n","import getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nfunction getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {\n    const { sliceRange, spacingInNormalDirection, camera } = getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness);\n    const { min, max, current } = sliceRange;\n    const numScrollSteps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * numScrollSteps;\n    const currentStepIndex = Math.round(floatingStepNumber);\n    return {\n        numScrollSteps,\n        currentStepIndex,\n        sliceRangeInfo: {\n            sliceRange,\n            spacingInNormalDirection,\n            camera,\n        },\n    };\n}\nexport default getVolumeViewportScrollInfo;\n","export const hasFloatScalingParameters = (scalingParameters) => {\n    const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === 'number' && !Number.isInteger(value));\n    return hasFloatRescale;\n};\n","export default function hasNaNValues(input) {\n    if (Array.isArray(input)) {\n        return input.some((value) => Number.isNaN(value));\n    }\n    return Number.isNaN(input);\n}\n","export default function imageIdToURI(imageId) {\n    const colonIndex = imageId.indexOf(':');\n    return imageId.substring(colonIndex + 1);\n}\n","import { addProvider } from '../metaData';\nconst retrieveConfigurationState = new Map();\nconst IMAGE_RETRIEVE_CONFIGURATION = 'imageRetrieveConfiguration';\nconst imageRetrieveMetadataProvider = {\n    IMAGE_RETRIEVE_CONFIGURATION,\n    clear: () => {\n        retrieveConfigurationState.clear();\n    },\n    add: (key, payload) => {\n        retrieveConfigurationState.set(key, payload);\n    },\n    clone: () => {\n        return new Map(retrieveConfigurationState);\n    },\n    restore: (state) => {\n        retrieveConfigurationState.clear();\n        state.forEach((value, key) => {\n            retrieveConfigurationState.set(key, value);\n        });\n    },\n    get: (type, ...queries) => {\n        if (type === IMAGE_RETRIEVE_CONFIGURATION) {\n            return queries\n                .map((query) => retrieveConfigurationState.get(query))\n                .find((it) => it !== undefined);\n        }\n    },\n};\naddProvider(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));\nexport default imageRetrieveMetadataProvider;\n","var EventListenerPhases;\n(function (EventListenerPhases) {\n    EventListenerPhases[EventListenerPhases[\"None\"] = 0] = \"None\";\n    EventListenerPhases[EventListenerPhases[\"Capture\"] = 1] = \"Capture\";\n    EventListenerPhases[EventListenerPhases[\"Bubble\"] = 2] = \"Bubble\";\n})(EventListenerPhases || (EventListenerPhases = {}));\nclass TargetEventListeners {\n    constructor(target) {\n        this._eventListeners = new Map();\n        this._children = new Map();\n        this._target = target;\n    }\n    get isEmpty() {\n        return this._eventListeners.size === 0 && this._children.size === 0;\n    }\n    addEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            let childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                childElementEventListener = new TargetEventListeners(this._target);\n                this._children.set(namespaceToken, childElementEventListener);\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.addEventListener(type, callback, options);\n        }\n        else {\n            this._addEventListener(type, callback, options);\n        }\n    }\n    removeEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            const childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                return;\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.removeEventListener(type, callback, options);\n            if (childElementEventListener.isEmpty) {\n                this._children.delete(namespaceToken);\n            }\n        }\n        else {\n            this._removeEventListener(type, callback, options);\n        }\n    }\n    reset() {\n        Array.from(this._children.entries()).forEach(([namespace, child]) => {\n            child.reset();\n            if (child.isEmpty) {\n                this._children.delete(namespace);\n            }\n            else {\n                throw new Error('Child is not empty and cannot be removed');\n            }\n        });\n        this._unregisterAllEvents();\n    }\n    _addEventListener(type, callback, options) {\n        let listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            listenersMap = new Map();\n            this._eventListeners.set(type, listenersMap);\n        }\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;\n        if (registeredPhases & listenerPhase) {\n            console.warn('A listener is already registered for this phase');\n            return;\n        }\n        listenersMap.set(callback, registeredPhases | listenerPhase);\n        this._target.addEventListener(type, callback, options);\n    }\n    _removeEventListener(type, callback, options) {\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            return;\n        }\n        const callbacks = callback ? [callback] : Array.from(listenersMap.keys());\n        callbacks.forEach((callbackItem) => {\n            const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;\n            const phaseRegistered = !!(registeredPhases & listenerPhase);\n            if (!phaseRegistered) {\n                return;\n            }\n            this._target.removeEventListener(type, callbackItem, options);\n            const newListenerPhase = registeredPhases ^ listenerPhase;\n            if (newListenerPhase === EventListenerPhases.None) {\n                listenersMap.delete(callbackItem);\n            }\n            else {\n                listenersMap.set(callbackItem, newListenerPhase);\n            }\n        });\n        if (!listenersMap.size) {\n            this._eventListeners.delete(type);\n        }\n    }\n    _unregisterAllListeners(type, listenersMap) {\n        Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {\n            const startPhase = EventListenerPhases.Capture;\n            for (let currentPhase = startPhase; eventPhases; currentPhase <<= 1) {\n                if (!(eventPhases & currentPhase)) {\n                    continue;\n                }\n                const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;\n                this.removeEventListener(type, listener, { capture: useCapture });\n                eventPhases ^= currentPhase;\n            }\n        });\n    }\n    _unregisterAllEvents() {\n        Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {\n            this._unregisterAllListeners(type, listenersMap);\n        });\n    }\n}\nexport { TargetEventListeners as default, TargetEventListeners };\n","import TargetEventListeners from './TargetEventListeners';\nclass MultiTargetEventListenerManager {\n    constructor() {\n        this._targetsEventListeners = new Map();\n    }\n    addEventListener(target, type, callback, options) {\n        let eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            eventListeners = new TargetEventListeners(target);\n            this._targetsEventListeners.set(target, eventListeners);\n        }\n        eventListeners.addEventListener(type, callback, options);\n    }\n    removeEventListener(target, type, callback, options) {\n        const eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            return;\n        }\n        eventListeners.removeEventListener(type, callback, options);\n        if (eventListeners.isEmpty) {\n            this._targetsEventListeners.delete(target);\n        }\n    }\n    reset() {\n        Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {\n            targetEventListeners.reset();\n            this._targetsEventListeners.delete(target);\n        });\n    }\n}\nexport { MultiTargetEventListenerManager as default, MultiTargetEventListenerManager, };\n","export default function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = nodeValue1[1] * scalingFactor;\n        nodeValue1[2] = nodeValue1[2] * scalingFactor;\n        nodeValue1[3] = nodeValue1[3] * scalingFactor;\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","export default function getMinMax(storedPixelData) {\n    let min = storedPixelData[0];\n    let max = storedPixelData[0];\n    let storedPixel;\n    const numPixels = storedPixelData.length;\n    for (let index = 1; index < numPixels; index++) {\n        storedPixel = storedPixelData[index];\n        min = Math.min(min, storedPixel);\n        max = Math.max(max, storedPixel);\n    }\n    return {\n        min,\n        max,\n    };\n}\n","const LAST_RUNTIME_ID = Symbol('LastRuntimeId');\nconst GLOBAL_CONTEXT = {};\nconst DEFAULT_MAX = 0xffffffff;\nconst DEFAULT_SEPARATOR = '-';\nexport default function getRuntimeId(context, separator, max) {\n    return getNextRuntimeId(context !== null && typeof context === 'object' ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max === 'number' && max > 0 ? max : DEFAULT_MAX) >>> 0).join(typeof separator === 'string' ? separator : DEFAULT_SEPARATOR);\n}\nfunction getNextRuntimeId(context, symbol, max) {\n    let idComponents = context[symbol];\n    if (!(idComponents instanceof Array)) {\n        idComponents = [0];\n        Object.defineProperty(context, symbol, { value: idComponents });\n    }\n    for (let carry = true, i = 0; carry && i < idComponents.length; ++i) {\n        let n = idComponents[i] | 0;\n        if (n < max) {\n            carry = false;\n            n = n + 1;\n        }\n        else {\n            n = 0;\n            if (i + 1 === idComponents.length) {\n                idComponents.push(0);\n            }\n        }\n        idComponents[i] = n;\n    }\n    return idComponents;\n}\n","import imageIdToURI from './imageIdToURI';\nconst state = {};\nconst metadataProvider = {\n    add: (imageId, payload) => {\n        const imageURI = imageIdToURI(imageId);\n        state[imageURI] = payload;\n    },\n    get: (type, imageId) => {\n        if (type === 'calibratedPixelSpacing') {\n            const imageURI = imageIdToURI(imageId);\n            return state[imageURI];\n        }\n    },\n};\nexport default metadataProvider;\n","export default function isOpposite(v1, v2, tolerance = 1e-5) {\n    return (Math.abs(v1[0] + v2[0]) < tolerance &&\n        Math.abs(v1[1] + v2[1]) < tolerance &&\n        Math.abs(v1[2] + v2[2]) < tolerance);\n}\n","export default function indexWithinDimensions(index, dimensions) {\n    if (index[0] < 0 ||\n        index[0] >= dimensions[0] ||\n        index[1] < 0 ||\n        index[1] >= dimensions[1] ||\n        index[2] < 0 ||\n        index[2] >= dimensions[2]) {\n        return false;\n    }\n    return true;\n}\n","import { getRenderingEngines, getRenderingEngine, } from '../RenderingEngine/getRenderingEngine';\nfunction getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {\n    let renderingEngines;\n    if (renderingEngineId) {\n        renderingEngines = [getRenderingEngine(renderingEngineId)];\n    }\n    else {\n        renderingEngines = getRenderingEngines();\n    }\n    const sameVolumesViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const targetActors = targetViewport.getActors();\n        const viewports = renderingEngine.getVolumeViewports();\n        for (const vp of viewports) {\n            const vpActors = vp.getActors();\n            if (vpActors.length !== targetActors.length) {\n                continue;\n            }\n            const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));\n            if (sameVolumes) {\n                sameVolumesViewports.push(vp);\n            }\n        }\n    });\n    return sameVolumesViewports;\n}\nexport default getVolumeViewportsContainingSameVolumes;\n","const isPTPrescaledWithSUV = (image) => {\n    return image.preScale.scaled && image.preScale.scalingParameters.suvbw;\n};\nexport default isPTPrescaledWithSUV;\n","import { vec3 } from 'gl-matrix';\nimport getOrCreateCanvas, { EPSILON, } from '../RenderingEngine/helpers/getOrCreateCanvas';\nimport { ViewportType, Events } from '../enums';\nimport { getRenderingEngine } from '../RenderingEngine/getRenderingEngine';\nimport RenderingEngine from '../RenderingEngine';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nexport default function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = '_thumbnails', viewportOptions = {\n    displayArea: { imageArea: [1, 1] },\n}) {\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('canvas element is required');\n    }\n    const isVolume = !imageOrVolume.imageId;\n    const image = !isVolume && imageOrVolume;\n    const volume = isVolume && imageOrVolume;\n    const imageIdToPrint = image.imageId || volume.volumeId;\n    const viewportId = `renderGPUViewport-${imageIdToPrint}`;\n    const element = document.createElement('div');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    if (!viewportOptions.displayArea) {\n        viewportOptions.displayArea = { imageArea: [1, 1] };\n    }\n    const originalWidth = canvas.width;\n    const originalHeight = canvas.height;\n    element.style.width = `${originalWidth / devicePixelRatio + EPSILON}px`;\n    element.style.height = `${originalHeight / devicePixelRatio + EPSILON}px`;\n    element.style.visibility = 'hidden';\n    element.style.position = 'absolute';\n    document.body.appendChild(element);\n    const uniqueId = viewportId.split(':').join('-');\n    element.setAttribute('viewport-id-for-remove', uniqueId);\n    const temporaryCanvas = getOrCreateCanvas(element);\n    const renderingEngine = getRenderingEngine(renderingEngineId) ||\n        new RenderingEngine(renderingEngineId);\n    let viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n        const viewportInput = {\n            viewportId,\n            type: isVolume ? ViewportType.ORTHOGRAPHIC : ViewportType.STACK,\n            element,\n            defaultOptions: {\n                ...viewportOptions,\n                suppressEvents: true,\n            },\n        };\n        renderingEngine.enableElement(viewportInput);\n        viewport = renderingEngine.getViewport(viewportId);\n    }\n    return new Promise((resolve) => {\n        let elementRendered = false;\n        let { viewReference } = viewportOptions;\n        const onImageRendered = (eventDetail) => {\n            if (elementRendered) {\n                return;\n            }\n            if (viewReference) {\n                const useViewRef = viewReference;\n                viewReference = null;\n                viewport.setViewReference(useViewRef);\n                viewport.render();\n                return;\n            }\n            const context = canvas.getContext('2d');\n            context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);\n            const origin = viewport.canvasToWorld([0, 0]);\n            const topRight = viewport.canvasToWorld([\n                temporaryCanvas.width / devicePixelRatio,\n                0,\n            ]);\n            const bottomLeft = viewport.canvasToWorld([\n                0,\n                temporaryCanvas.height / devicePixelRatio,\n            ]);\n            const rightVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([1 / devicePixelRatio, 0]), origin);\n            const downVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([0, 1 / devicePixelRatio]), origin);\n            const thicknessMm = 1;\n            elementRendered = true;\n            element.removeEventListener(Events.IMAGE_RENDERED, onImageRendered);\n            setTimeout(() => {\n                renderingEngine.disableElement(viewportId);\n                const elements = document.querySelectorAll(`[viewport-id-for-remove=\"${uniqueId}\"]`);\n                elements.forEach((element) => {\n                    element.remove();\n                });\n            }, 0);\n            resolve({\n                origin,\n                bottomLeft,\n                topRight,\n                thicknessMm,\n                rightVector,\n                downVector,\n            });\n        };\n        element.addEventListener(Events.IMAGE_RENDERED, onImageRendered);\n        if (isVolume) {\n            viewport.setVolumes([volume], false, true);\n        }\n        else {\n            viewport.renderImageObject(imageOrVolume);\n        }\n        viewport.resetCamera();\n        if (modality === 'PT' && !isPTPrescaledWithSUV(image)) {\n            viewport.setProperties({\n                voiRange: {\n                    lower: image.minPixelValue,\n                    upper: image.maxPixelValue,\n                },\n            });\n        }\n        viewport.render();\n    });\n}\n","import getDefaultViewport from '../RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport';\nimport calculateTransform from '../RenderingEngine/helpers/cpuFallback/rendering/calculateTransform';\nimport drawImageSync from '../RenderingEngine/helpers/cpuFallback/drawImageSync';\nexport default function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {\n    const volume = imageOrVolume;\n    if (volume.volumeId) {\n        throw new Error('Unsupported volume rendering for CPU');\n    }\n    const image = imageOrVolume;\n    const viewport = getDefaultViewport(canvas, image, modality);\n    const enabledElement = {\n        canvas,\n        viewport,\n        image,\n        renderingTools: {},\n    };\n    enabledElement.transform = calculateTransform(enabledElement);\n    const invalidated = true;\n    return new Promise((resolve, reject) => {\n        drawImageSync(enabledElement, invalidated);\n        resolve(null);\n    });\n}\n","import { loadAndCacheImage } from '../loaders/imageLoader';\nimport * as metaData from '../metaData';\nimport { RequestType } from '../enums';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport cache from '../cache/cache';\nexport default function loadImageToCanvas(options) {\n    const { canvas, imageId, viewReference, requestType = RequestType.Thumbnail, priority = -5, renderingEngineId = '_thumbnails', useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions, } = options;\n    const volumeId = viewReference?.volumeId;\n    const isVolume = volumeId && !imageId;\n    const viewportOptions = viewReference && baseViewportOptions\n        ? { ...baseViewportOptions, viewReference }\n        : baseViewportOptions;\n    const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;\n    return new Promise((resolve, reject) => {\n        function successCallback(imageOrVolume, imageId) {\n            const { modality } = metaData.get('generalSeriesModule', imageId) || {};\n            const image = !isVolume && imageOrVolume;\n            const volume = isVolume && imageOrVolume;\n            if (image) {\n                image.isPreScaled = image.isPreScaled || image.preScale?.scaled;\n            }\n            if (thumbnail) {\n                canvas.height = 256;\n                canvas.width = 256;\n            }\n            if (imageAspect && image) {\n                canvas.width = image && (canvas.height * image.width) / image.height;\n            }\n            canvas.style.width = `${canvas.width / devicePixelRatio}px`;\n            canvas.style.height = `${canvas.height / devicePixelRatio}px`;\n            if (volume && useCPURendering) {\n                reject(new Error('CPU rendering of volume not supported'));\n            }\n            renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);\n        }\n        function errorCallback(error, imageId) {\n            console.error(error, imageId);\n            reject(error);\n        }\n        function sendRequest(imageId, imageIdIndex, options) {\n            return loadAndCacheImage(imageId, options).then((image) => {\n                successCallback.call(this, image, imageId);\n            }, (error) => {\n                errorCallback.call(this, error, imageId);\n            });\n        }\n        const options = {\n            useRGBA: !!useCPURendering,\n            requestType,\n        };\n        if (volumeId) {\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                reject(new Error(`Volume id ${volumeId} not found in cache`));\n            }\n            const useImageId = volume.imageIds[0];\n            successCallback(volume, useImageId);\n        }\n        else {\n            imageLoadPoolManager.addRequest(sendRequest.bind(null, imageId, null, options), requestType, { imageId }, priority);\n        }\n    });\n}\n","import eventTarget from '../../eventTarget';\nconst Events = {\n    HISTORY_UNDO: 'CORNERSTONE_TOOLS_HISTORY_UNDO',\n    HISTORY_REDO: 'CORNERSTONE_TOOLS_HISTORY_REDO',\n};\nexport class HistoryMemo {\n    constructor(label = 'Tools', size = 50) {\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n        this.ring = new Array();\n        this.label = label;\n        this._size = size;\n    }\n    get size() {\n        return this._size;\n    }\n    set size(newSize) {\n        this.ring = new Array(newSize);\n        this._size = newSize;\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n    }\n    undo(items = 1) {\n        while (items > 0 && this.undoAvailable > 0) {\n            const item = this.ring[this.position];\n            item.restoreMemo(true);\n            if (item.id) {\n                eventTarget.dispatchEvent(new CustomEvent(Events.HISTORY_UNDO, {\n                    detail: {\n                        isUndo: true,\n                        id: item.id,\n                        operationType: item.operationType || 'annotation',\n                        memo: item,\n                    },\n                }));\n            }\n            items--;\n            this.redoAvailable++;\n            this.undoAvailable--;\n            this.position = (this.position - 1 + this.size) % this.size;\n        }\n    }\n    undoIf(condition) {\n        if (this.undoAvailable > 0 && condition(this.ring[this.position])) {\n            this.undo();\n            return true;\n        }\n        return false;\n    }\n    redo(items = 1) {\n        while (items > 0 && this.redoAvailable > 0) {\n            const newPosition = (this.position + 1) % this.size;\n            const item = this.ring[newPosition];\n            item.restoreMemo(false);\n            if (item.id) {\n                eventTarget.dispatchEvent(new CustomEvent(Events.HISTORY_REDO, {\n                    detail: {\n                        isUndo: false,\n                        id: item.id,\n                        operationType: item.operationType || 'annotation',\n                        memo: item,\n                    },\n                }));\n            }\n            items--;\n            this.position = newPosition;\n            this.undoAvailable++;\n            this.redoAvailable--;\n        }\n    }\n    push(item) {\n        if (!item) {\n            return;\n        }\n        const memo = item.restoreMemo\n            ? item\n            : item.createMemo?.();\n        if (!memo) {\n            return;\n        }\n        this.redoAvailable = 0;\n        if (this.undoAvailable < this._size) {\n            this.undoAvailable++;\n        }\n        this.position = (this.position + 1) % this._size;\n        this.ring[this.position] = memo;\n        return memo;\n    }\n}\nconst DefaultHistoryMemo = new HistoryMemo();\nexport { DefaultHistoryMemo };\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nfunction worldToImageCoords(imageId, worldCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const newOrigin = vec3.create();\n    vec3.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);\n    vec3.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);\n    const sub = vec3.create();\n    vec3.sub(sub, worldCoords, newOrigin);\n    const rowDistance = vec3.dot(sub, rowCosines);\n    const columnDistance = vec3.dot(sub, columnCosines);\n    const imageCoords = [\n        rowDistance / rowPixelSpacing,\n        columnDistance / columnPixelSpacing,\n    ];\n    return imageCoords;\n}\nexport default worldToImageCoords;\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nexport default function imageToWorldCoords(imageId, imageCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const imageCoordsInWorld = vec3.create();\n    vec3.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));\n    vec3.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));\n    return Array.from(imageCoordsInWorld);\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nexport default function getViewportsWithImageURI(imageURI) {\n    const renderingEngines = getRenderingEngines();\n    const viewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewportsForRenderingEngine = renderingEngine.getViewports();\n        viewportsForRenderingEngine.forEach((viewport) => {\n            if (viewport.hasImageURI(imageURI)) {\n                viewports.push(viewport);\n            }\n        });\n    });\n    return viewports;\n}\n","import { vec3 } from 'gl-matrix';\nimport * as planar from './planar';\nimport * as metaData from '../metaData';\nexport default function getClosestStackImageIndexForPoint(point, viewport) {\n    const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);\n    return minimalDistance ? minimalDistance.index : null;\n}\nexport function calculateMinimalDistanceForStackViewport(point, viewport) {\n    const imageIds = viewport.getImageIds();\n    const currentImageIdIndex = viewport.getCurrentImageIdIndex();\n    if (imageIds.length === 0) {\n        return null;\n    }\n    const getDistance = (imageId) => {\n        const planeMetadata = getPlaneMetadata(imageId);\n        if (!planeMetadata) {\n            return null;\n        }\n        const plane = planar.planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);\n        const distance = planar.planeDistanceToPoint(plane, point);\n        return distance;\n    };\n    const closestStack = {\n        distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,\n        index: currentImageIdIndex,\n    };\n    const higherImageIds = imageIds.slice(currentImageIdIndex + 1);\n    for (let i = 0; i < higherImageIds.length; i++) {\n        const id = higherImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null) {\n            continue;\n        }\n        if (distance <= closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i + currentImageIdIndex + 1;\n        }\n        else {\n            break;\n        }\n    }\n    const lowerImageIds = imageIds.slice(0, currentImageIdIndex);\n    for (let i = lowerImageIds.length - 1; i >= 0; i--) {\n        const id = lowerImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null || distance === closestStack.distance) {\n            continue;\n        }\n        if (distance < closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i;\n        }\n        else {\n            break;\n        }\n    }\n    return closestStack.distance === Infinity ? null : closestStack;\n}\nfunction getPlaneMetadata(imageId) {\n    const targetImagePlane = metaData.get('imagePlaneModule', imageId);\n    if (!targetImagePlane ||\n        !(targetImagePlane.rowCosines instanceof Array &&\n            targetImagePlane.rowCosines.length === 3) ||\n        !(targetImagePlane.columnCosines instanceof Array &&\n            targetImagePlane.columnCosines.length === 3) ||\n        !(targetImagePlane.imagePositionPatient instanceof Array &&\n            targetImagePlane.imagePositionPatient.length === 3)) {\n        return null;\n    }\n    const { rowCosines, columnCosines, imagePositionPatient, } = targetImagePlane;\n    const rowVec = vec3.set(vec3.create(), ...rowCosines);\n    const colVec = vec3.set(vec3.create(), ...columnCosines);\n    const planeNormal = vec3.cross(vec3.create(), rowVec, colVec);\n    return { rowCosines, columnCosines, imagePositionPatient, planeNormal };\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { transformCanvasToIJK } from './transformCanvasToIJK';\nfunction getCurrentVolumeViewportSlice(viewport) {\n    const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();\n    const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();\n    const ijkOriginPoint = transformCanvasToIJK(viewport, [0, 0]);\n    const ijkRowPoint = transformCanvasToIJK(viewport, [canvasWidth - 1, 0]);\n    const ijkColPoint = transformCanvasToIJK(viewport, [0, canvasHeight - 1]);\n    const ijkRowVec = vec3.sub(vec3.create(), ijkRowPoint, ijkOriginPoint);\n    const ijkColVec = vec3.sub(vec3.create(), ijkColPoint, ijkOriginPoint);\n    const ijkSliceVec = vec3.cross(vec3.create(), ijkRowVec, ijkColVec);\n    vec3.normalize(ijkRowVec, ijkRowVec);\n    vec3.normalize(ijkColVec, ijkColVec);\n    vec3.normalize(ijkSliceVec, ijkSliceVec);\n    const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));\n    const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));\n    if (!glMatrix.equals(1, maxIJKRowVec) || !glMatrix.equals(1, maxIJKColVec)) {\n        throw new Error('Livewire is not available for rotate/oblique viewports');\n    }\n    const { voxelManager } = viewport.getImageData();\n    const sliceViewInfo = viewport.getSliceViewInfo();\n    const scalarData = voxelManager.getSliceData(sliceViewInfo);\n    return {\n        width: sliceViewInfo.width,\n        height: sliceViewInfo.height,\n        scalarData,\n        sliceToIndexMatrix,\n        indexToSliceMatrix,\n    };\n}\nexport { getCurrentVolumeViewportSlice as default, getCurrentVolumeViewportSlice, };\n","import { mat4 } from 'gl-matrix';\nimport { addProvider } from '../metaData';\nconst state = {};\nconst spatialRegistrationMetadataProvider = {\n    add: (query, payload) => {\n        const [viewportId1, viewportId2] = query;\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (!state[entryId]) {\n            state[entryId] = {};\n        }\n        state[entryId] = payload;\n    },\n    get: (type, viewportId1, viewportId2) => {\n        if (type !== 'spatialRegistrationModule') {\n            return;\n        }\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (state[entryId]) {\n            return state[entryId];\n        }\n        const entryIdReverse = `${viewportId2}_${viewportId1}`;\n        if (state[entryIdReverse]) {\n            return mat4.invert(mat4.create(), state[entryIdReverse]);\n        }\n    },\n};\naddProvider(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));\nexport default spatialRegistrationMetadataProvider;\n","import { vec3, mat4 } from 'gl-matrix';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport { get } from '../metaData';\nconst ALLOWED_DELTA = 0.05;\nfunction calculateViewportsSpatialRegistration(viewport1, viewport2) {\n    const imageId1 = viewport1.getSliceIndex();\n    const imageId2 = viewport2.getSliceIndex();\n    const imagePlaneModule1 = get('imagePlaneModule', imageId1.toString());\n    const imagePlaneModule2 = get('imagePlaneModule', imageId2.toString());\n    if (!imagePlaneModule1 || !imagePlaneModule2) {\n        console.log('Viewport spatial registration requires image plane module');\n        return;\n    }\n    const { imageOrientationPatient: iop2 } = imagePlaneModule2;\n    const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);\n    if (!isSameImagePlane) {\n        console.log('Viewport spatial registration only supported for same orientation (hence translation only) for now', imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);\n        return;\n    }\n    const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;\n    const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;\n    const translation = vec3.subtract(vec3.create(), imagePositionPatient1, imagePositionPatient2);\n    const mat = mat4.fromTranslation(mat4.create(), translation);\n    spatialRegistrationMetadataProvider.add([viewport1.id, viewport2.id], mat);\n}\nexport default calculateViewportsSpatialRegistration;\n","export default function getViewportImageCornersInWorld(viewport) {\n    const { imageData, dimensions } = viewport.getImageData() || {};\n    if (!imageData || !dimensions) {\n        return [];\n    }\n    const { canvas } = viewport;\n    const ratio = window.devicePixelRatio;\n    const topLeftCanvas = [0, 0];\n    const topRightCanvas = [canvas.width / ratio, 0];\n    const bottomRightCanvas = [\n        canvas.width / ratio,\n        canvas.height / ratio,\n    ];\n    const bottomLeftCanvas = [0, canvas.height / ratio];\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const topRightWorld = viewport.canvasToWorld(topRightCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);\n    const topLeftImage = imageData.worldToIndex(topLeftWorld);\n    const topRightImage = imageData.worldToIndex(topRightWorld);\n    const bottomRightImage = imageData.worldToIndex(bottomRightWorld);\n    const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);\n    return _getStackViewportImageCorners({\n        dimensions,\n        imageData,\n        topLeftImage,\n        topRightImage,\n        bottomRightImage,\n        bottomLeftImage,\n        topLeftWorld,\n        topRightWorld,\n        bottomRightWorld,\n        bottomLeftWorld,\n    });\n}\nfunction _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld, }) {\n    const topLeftImageWorld = _isInBounds(topLeftImage, dimensions)\n        ? topLeftWorld\n        : imageData.indexToWorld([0, 0, 0]);\n    const topRightImageWorld = _isInBounds(topRightImage, dimensions)\n        ? topRightWorld\n        : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);\n    const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions)\n        ? bottomRightWorld\n        : imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n        ]);\n    const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions)\n        ? bottomLeftWorld\n        : imageData.indexToWorld([0, dimensions[1] - 1, 0]);\n    return [\n        topLeftImageWorld,\n        topRightImageWorld,\n        bottomLeftImageWorld,\n        bottomRightImageWorld,\n    ];\n}\nfunction _isInBounds(imageCoord, dimensions) {\n    return (imageCoord[0] > 0 ||\n        imageCoord[0] < dimensions[0] - 1 ||\n        imageCoord[1] > 0 ||\n        imageCoord[1] < dimensions[1] - 1 ||\n        imageCoord[2] > 0 ||\n        imageCoord[2] < dimensions[2] - 1);\n}\n","import StackViewport from '../RenderingEngine/StackViewport';\nimport getEnabledElement from '../getEnabledElement';\nfunction getImageLegacy(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);\n    }\n    return viewport.getCornerstoneImage();\n}\nexport default getImageLegacy;\n","import * as metaData from '../metaData';\nimport isEqual from './isEqual';\nfunction isValidVolume(imageIds) {\n    if (imageIds.length <= 1) {\n        return false;\n    }\n    const imageId0 = imageIds[0];\n    const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, usingDefaultValues, } = metaData.get('imagePlaneModule', imageId0);\n    if (usingDefaultValues) {\n        return false;\n    }\n    const baseMetadata = {\n        modality,\n        imageOrientationPatient,\n        pixelSpacing,\n        frameOfReferenceUID,\n        columns,\n        rows,\n        seriesInstanceUID,\n    };\n    let validVolume = true;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId);\n        const { imageOrientationPatient, pixelSpacing, columns, rows } = metaData.get('imagePlaneModule', imageId);\n        if (seriesInstanceUID !== baseMetadata.seriesInstanceUID) {\n            validVolume = false;\n            break;\n        }\n        if (modality !== baseMetadata.modality) {\n            validVolume = false;\n            break;\n        }\n        if (columns !== baseMetadata.columns) {\n            validVolume = false;\n            break;\n        }\n        if (rows !== baseMetadata.rows) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(imageOrientationPatient, baseMetadata.imageOrientationPatient)) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(pixelSpacing, baseMetadata.pixelSpacing)) {\n            validVolume = false;\n            break;\n        }\n    }\n    return validVolume;\n}\nexport { isValidVolume };\n","export const videoUIDs = new Set([\n    '1.2.840.10008.1.2.4.100',\n    '1.2.840.10008.1.2.4.100.1',\n    '1.2.840.10008.1.2.4.101',\n    '1.2.840.10008.1.2.4.101.1',\n    '1.2.840.10008.1.2.4.102',\n    '1.2.840.10008.1.2.4.102.1',\n    '1.2.840.10008.1.2.4.103',\n    '1.2.840.10008.1.2.4.103.1',\n    '1.2.840.10008.1.2.4.104',\n    '1.2.840.10008.1.2.4.104.1',\n    '1.2.840.10008.1.2.4.105',\n    '1.2.840.10008.1.2.4.105.1',\n    '1.2.840.10008.1.2.4.106',\n    '1.2.840.10008.1.2.4.106.1',\n    '1.2.840.10008.1.2.4.107',\n    '1.2.840.10008.1.2.4.108',\n]);\nexport default function isVideoTransferSyntax(uidOrUids) {\n    if (!uidOrUids) {\n        return false;\n    }\n    const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];\n    return uids.find((uid) => videoUIDs.has(uid));\n}\n","import { setVolumesForViewports } from '../RenderingEngine/helpers';\nimport { createAndCacheVolume, getUnknownVolumeLoaderSchema, } from '../loaders/volumeLoader';\nimport { Events, ViewportType } from '../enums';\nimport uuidv4 from './uuidv4';\nasync function convertStackToVolumeViewport({ viewport, options = {}, }) {\n    const renderingEngine = viewport.getRenderingEngine();\n    let volumeId = options.volumeId || `${uuidv4()}`;\n    if (volumeId.split(':').length === 0) {\n        const schema = getUnknownVolumeLoaderSchema();\n        volumeId = `${schema}:${volumeId}`;\n    }\n    const { id, element } = viewport;\n    const viewportId = options.viewportId || id;\n    const imageIds = viewport.getImageIds();\n    const prevViewPresentation = viewport.getViewPresentation();\n    const prevViewReference = viewport.getViewReference();\n    renderingEngine.enableElement({\n        viewportId,\n        type: ViewportType.ORTHOGRAPHIC,\n        element,\n        defaultOptions: {\n            background: options.background,\n            orientation: options.orientation,\n        },\n    });\n    const volume = (await createAndCacheVolume(volumeId, {\n        imageIds,\n    }));\n    volume.load();\n    const volumeViewport = renderingEngine.getViewport(viewportId);\n    await setVolumesForViewports(renderingEngine, [\n        {\n            volumeId,\n        },\n    ], [viewportId]);\n    const volumeViewportNewVolumeHandler = () => {\n        volumeViewport.render();\n        element.removeEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    const addVolumeViewportNewVolumeListener = () => {\n        element.addEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    addVolumeViewportNewVolumeListener();\n    volumeViewport.setViewPresentation(prevViewPresentation);\n    volumeViewport.setViewReference(prevViewReference);\n    volumeViewport.render();\n    return volumeViewport;\n}\nexport { convertStackToVolumeViewport };\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport { ViewportType } from '../enums';\nasync function convertVolumeToStackViewport({ viewport, options, }) {\n    const volumeViewport = viewport;\n    const { id, element } = volumeViewport;\n    const renderingEngine = viewport.getRenderingEngine();\n    const { background } = options;\n    const viewportId = options.viewportId || id;\n    const volume = cache.getVolume(volumeViewport.getVolumeId());\n    if (!(volume instanceof ImageVolume)) {\n        throw new Error('Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.');\n    }\n    const viewportInput = {\n        viewportId,\n        type: ViewportType.STACK,\n        element,\n        defaultOptions: {\n            background,\n        },\n    };\n    const prevView = volumeViewport.getViewReference();\n    renderingEngine.enableElement(viewportInput);\n    const stackViewport = renderingEngine.getViewport(viewportId);\n    await stackViewport.setStack(volume.imageIds);\n    stackViewport.setViewReference(prevView);\n    stackViewport.render();\n    return stackViewport;\n}\nexport { convertVolumeToStackViewport };\n","import { EPSILON } from '../constants';\nfunction roundNumber(value, precision = 2) {\n    if (Array.isArray(value)) {\n        return value.map((v) => roundNumber(v, precision)).join(', ');\n    }\n    if (value === undefined || value === null || value === '') {\n        return 'NaN';\n    }\n    value = Number(value);\n    const absValue = Math.abs(value);\n    if (absValue < 0.0001) {\n        return `${value}`;\n    }\n    const fixedPrecision = absValue >= 100\n        ? precision - 2\n        : absValue >= 10\n            ? precision - 1\n            : absValue >= 1\n                ? precision\n                : absValue >= 0.1\n                    ? precision + 1\n                    : absValue >= 0.01\n                        ? precision + 2\n                        : absValue >= 0.001\n                            ? precision + 3\n                            : precision + 4;\n    return value.toFixed(fixedPrecision);\n}\nfunction roundToPrecision(value) {\n    return Math.round(value / EPSILON) * EPSILON;\n}\nexport { roundToPrecision };\nexport default roundNumber;\n","export default function convertToGrayscale(scalarData, width, height) {\n    const isRGBA = scalarData.length === width * height * 4;\n    const isRGB = scalarData.length === width * height * 3;\n    if (isRGBA || isRGB) {\n        const newScalarData = new Float32Array(width * height);\n        let offset = 0;\n        let destOffset = 0;\n        const increment = isRGBA ? 4 : 3;\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                const r = scalarData[offset];\n                const g = scalarData[offset + 1];\n                const b = scalarData[offset + 2];\n                newScalarData[destOffset] = (r + g + b) / 3;\n                offset += increment;\n                destOffset++;\n            }\n        }\n        return newScalarData;\n    }\n    else {\n        return scalarData;\n    }\n}\n","import { VolumeViewport } from '../RenderingEngine';\nimport cache from '../cache/cache';\nfunction getViewportImageIds(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        const volume = cache.getVolume(viewport.getVolumeId());\n        return volume.imageIds;\n    }\n    else if (viewport.getImageIds) {\n        return viewport.getImageIds();\n    }\n}\nexport default getViewportImageIds;\n","export function getRandomSampleFromArray(array, size) {\n    const clonedArray = [...array];\n    if (size >= clonedArray.length) {\n        shuffleArray(clonedArray);\n        return clonedArray;\n    }\n    shuffleArray(clonedArray);\n    return clonedArray.slice(0, size);\n}\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n","function componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(r, g, b) {\n    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n        }\n        : null;\n}\nexport { hexToRgb, rgbToHex };\n","export function deepEqual(obj1, obj2) {\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n    try {\n        return JSON.stringify(obj1) === JSON.stringify(obj2);\n    }\n    catch (error) {\n        console.debug('Error in JSON.stringify during deep comparison:', error);\n        return obj1 === obj2;\n    }\n}\n","import * as metaData from '../metaData';\nconst groupBy = (array, key) => {\n    return array.reduce((rv, x) => {\n        (rv[x[key]] = rv[x[key]] || []).push(x);\n        return rv;\n    }, {});\n};\nfunction getIPPGroups(imageIds) {\n    const ippMetadata = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId) || {};\n        return { imageId, imagePositionPatient };\n    });\n    if (!ippMetadata.every((item) => item.imagePositionPatient)) {\n        return null;\n    }\n    const positionGroups = groupBy(ippMetadata, 'imagePositionPatient');\n    const positions = Object.keys(positionGroups);\n    const frame_count = positionGroups[positions[0]].length;\n    if (frame_count === 1) {\n        return null;\n    }\n    const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);\n    if (!frame_count_equal) {\n        return null;\n    }\n    return positionGroups;\n}\nfunction test4DTag(IPPGroups, value_getter) {\n    const frame_groups = {};\n    let first_frame_value_set = [];\n    const positions = Object.keys(IPPGroups);\n    for (let i = 0; i < positions.length; i++) {\n        const frame_value_set = new Set();\n        const frames = IPPGroups[positions[i]];\n        for (let j = 0; j < frames.length; j++) {\n            const frame_value = value_getter(frames[j].imageId) || 0;\n            frame_groups[frame_value] = frame_groups[frame_value] || [];\n            frame_groups[frame_value].push({ imageId: frames[j].imageId });\n            frame_value_set.add(frame_value);\n            if (frame_value_set.size - 1 < j) {\n                return undefined;\n            }\n        }\n        if (i == 0) {\n            first_frame_value_set = Array.from(frame_value_set);\n        }\n        else if (!setEquals(first_frame_value_set, frame_value_set)) {\n            return undefined;\n        }\n    }\n    return frame_groups;\n}\nfunction getTagValue(imageId, tag) {\n    const value = metaData.get(tag, imageId);\n    try {\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getPhilipsPrivateBValue(imageId) {\n    const value = metaData.get('20011003', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            const value_bytes = atob(InlineBinary);\n            const ary_buf = new ArrayBuffer(value_bytes.length);\n            const dv = new DataView(ary_buf);\n            for (let i = 0; i < value_bytes.length; i++) {\n                dv.setUint8(i, value_bytes.charCodeAt(i));\n            }\n            return new Float32Array(ary_buf)[0];\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getSiemensPrivateBValue(imageId) {\n    let value = metaData.get('0019100c', imageId) || metaData.get('0019100C', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary);\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getGEPrivateBValue(imageId) {\n    let value = metaData.get('00431039', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary).split('//');\n        }\n        return parseFloat(value[0]) % 100000;\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction setEquals(set_a, set_b) {\n    if (set_a.length != set_b.size) {\n        return false;\n    }\n    for (let i = 0; i < set_a.length; i++) {\n        if (!set_b.has(set_a[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPetFrameReferenceTime(imageId) {\n    const moduleInfo = metaData.get('petImageModule', imageId);\n    return moduleInfo ? moduleInfo['frameReferenceTime'] : 0;\n}\nfunction splitImageIdsBy4DTags(imageIds) {\n    const positionGroups = getIPPGroups(imageIds);\n    if (!positionGroups) {\n        return { imageIdGroups: [imageIds], splittingTag: null };\n    }\n    const tags = [\n        'TemporalPositionIdentifier',\n        'DiffusionBValue',\n        'TriggerTime',\n        'EchoTime',\n        'EchoNumber',\n        'PhilipsPrivateBValue',\n        'SiemensPrivateBValue',\n        'GEPrivateBValue',\n        'PetFrameReferenceTime',\n    ];\n    const fncList2 = [\n        (imageId) => getTagValue(imageId, tags[0]),\n        (imageId) => getTagValue(imageId, tags[1]),\n        (imageId) => getTagValue(imageId, tags[2]),\n        (imageId) => getTagValue(imageId, tags[3]),\n        (imageId) => getTagValue(imageId, tags[4]),\n        getPhilipsPrivateBValue,\n        getSiemensPrivateBValue,\n        getGEPrivateBValue,\n        getPetFrameReferenceTime,\n    ];\n    for (let i = 0; i < fncList2.length; i++) {\n        const frame_groups = test4DTag(positionGroups, fncList2[i]);\n        if (frame_groups) {\n            const sortedKeys = Object.keys(frame_groups)\n                .map(Number.parseFloat)\n                .sort((a, b) => a - b);\n            const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));\n            return { imageIdGroups, splittingTag: tags[i] };\n        }\n    }\n    return { imageIdGroups: [imageIds], splittingTag: null };\n}\nexport default splitImageIdsBy4DTags;\n","import splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nfunction getDynamicVolumeInfo(imageIds) {\n    const { imageIdGroups: timePoints, splittingTag } = splitImageIdsBy4DTags(imageIds);\n    const isDynamicVolume = timePoints.length > 1;\n    return { isDynamicVolume, timePoints, splittingTag };\n}\nexport default getDynamicVolumeInfo;\n","export default function scaleArray(array, scalingParameters) {\n    const arrayLength = array.length;\n    const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;\n    if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = array[i] * rescaleSlope + rescaleIntercept;\n        }\n    }\n    return array;\n}\n","export function clip(val, low, high) {\n    return Math.min(Math.max(low, val), high);\n}\nexport function clipToBox(point, box) {\n    point.x = clip(point.x, 0, box.width);\n    point.y = clip(point.y, 0, box.height);\n}\nexport default clip;\n","import { Events } from '../enums';\nimport { StackViewport, VolumeViewport } from '../RenderingEngine';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getEnabledElement from '../getEnabledElement';\nimport triggerEvent from './triggerEvent';\nimport eventTarget from '../eventTarget';\nexport default function scroll(viewport, options) {\n    const enabledElement = getEnabledElement(viewport.element);\n    if (!enabledElement) {\n        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n    }\n    if (viewport instanceof StackViewport &&\n        viewport.getImageIds().length === 0) {\n        throw new Error('Scroll::Stack Viewport has no images');\n    }\n    const { volumeId, delta, scrollSlabs } = options;\n    if (viewport instanceof VolumeViewport) {\n        scrollVolume(viewport, volumeId, delta, scrollSlabs);\n    }\n    else {\n        const imageIdIndex = viewport.getCurrentImageIdIndex();\n        if (imageIdIndex + delta >\n            viewport.getImageIds().length - 1 ||\n            imageIdIndex + delta < 0) {\n            const eventData = {\n                imageIdIndex,\n                direction: delta,\n            };\n            triggerEvent(eventTarget, Events.STACK_SCROLL_OUT_OF_BOUNDS, eventData);\n        }\n        viewport.scroll(delta, options.debounceLoading, options.loop);\n    }\n}\nexport function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {\n    const useSlabThickness = scrollSlabs;\n    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n    if (!sliceRangeInfo) {\n        return;\n    }\n    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n    const { focalPoint, viewPlaneNormal, position } = camera;\n    const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);\n    viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n    });\n    viewport.render();\n    const desiredStepIndex = currentStepIndex + delta;\n    const VolumeScrollEventDetail = {\n        volumeId,\n        viewport,\n        delta,\n        desiredStepIndex,\n        currentStepIndex,\n        numScrollSteps,\n        currentImageId: viewport.getCurrentImageId(),\n    };\n    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n        viewport.getCurrentImageId()) {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);\n    }\n    else {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);\n    }\n}\n","import clip from './clip';\nimport scroll from './scroll';\nimport getEnabledElement from '../getEnabledElement';\nimport StackViewport from '../RenderingEngine/StackViewport';\nasync function jumpToSlice(element, options = {}) {\n    const { imageIndex, debounceLoading, volumeId } = options;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('Element has been disabled');\n    }\n    const { viewport } = enabledElement;\n    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);\n    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n    const delta = imageIndexToJump - currentImageIndex;\n    scroll(viewport, { delta, debounceLoading, volumeId });\n}\nfunction _getImageSliceData(viewport, debounceLoading) {\n    if (viewport instanceof StackViewport) {\n        return {\n            numberOfSlices: viewport.getImageIds().length,\n            imageIndex: debounceLoading\n                ? viewport.getTargetImageIdIndex()\n                : viewport.getCurrentImageIdIndex(),\n        };\n    }\n    return {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getSliceIndex(),\n    };\n}\nfunction _getImageIndexToJump(numberOfSlices, imageIndex) {\n    const lastSliceIndex = numberOfSlices - 1;\n    return clip(imageIndex, 0, lastSliceIndex);\n}\nexport { jumpToSlice };\n","import transformWorldToIndex from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport uuidv4 from './uuidv4';\nimport { createLocalVolume } from '../loaders/volumeLoader';\nimport cache from '../cache/cache';\nfunction createSubVolume(referencedVolumeId, boundsIJK, options = {}) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (!referencedVolume) {\n        throw new Error(`Referenced volume with id ${referencedVolumeId} does not exist.`);\n    }\n    const { metadata, spacing, direction, dimensions: refVolumeDim, } = referencedVolume;\n    const { minX, maxX, minY, maxY, minZ, maxZ } = boundsIJK;\n    const ijkTopLeft = [\n        Math.min(minX, maxX),\n        Math.min(minY, maxY),\n        Math.min(minZ, maxZ),\n    ];\n    const boundingBoxOriginWorld = transformIndexToWorld(referencedVolume.imageData, ijkTopLeft);\n    const dimensions = [\n        Math.abs(maxX - minX) + 1,\n        Math.abs(maxY - minY) + 1,\n        Math.abs(maxZ - minZ) + 1,\n    ];\n    const { targetBuffer } = options;\n    const subVolumeOptions = {\n        metadata,\n        dimensions,\n        spacing,\n        origin: boundingBoxOriginWorld,\n        direction,\n        targetBuffer,\n        scalarData: targetBuffer?.type === 'Float32Array'\n            ? new Float32Array(dimensions[0] * dimensions[1] * dimensions[2])\n            : undefined,\n    };\n    const subVolume = createLocalVolume(uuidv4(), subVolumeOptions);\n    const subVolumeData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const subVolumeSliceSize = dimensions[0] * dimensions[1];\n    const refVolumeSliceSize = refVolumeDim[0] * refVolumeDim[1];\n    const refVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    for (let z = 0; z < dimensions[2]; z++) {\n        for (let y = 0; y < dimensions[1]; y++) {\n            const rowStartWorld = transformIndexToWorld(subVolume.imageData, [\n                0,\n                y,\n                z,\n            ]);\n            const refVolumeRowStartIJK = transformWorldToIndex(referencedVolume.imageData, rowStartWorld);\n            const refVolumeRowStartOffset = refVolumeRowStartIJK[2] * refVolumeSliceSize +\n                refVolumeRowStartIJK[1] * refVolumeDim[0] +\n                refVolumeRowStartIJK[0];\n            const rowData = refVolumeData.slice(refVolumeRowStartOffset, refVolumeRowStartOffset + dimensions[0]);\n            const subVolumeLineStartOffset = z * subVolumeSliceSize + y * dimensions[0];\n            subVolumeData.set(rowData, subVolumeLineStartOffset);\n        }\n    }\n    subVolume.voxelManager.setCompleteScalarDataArray(subVolumeData);\n    return subVolume;\n}\nexport { createSubVolume as default, createSubVolume };\n","import { vec3 } from 'gl-matrix';\nimport { transformWorldToIndexContinuous } from './transformWorldToIndex';\nfunction getVolumeDirectionVectors(imageData, camera) {\n    const { viewUp, viewPlaneNormal } = camera;\n    const ijkOrigin = transformWorldToIndexContinuous(imageData, [0, 0, 0]);\n    const worldVecColDir = vec3.negate(vec3.create(), viewUp);\n    const worldVecSliceDir = vec3.negate(vec3.create(), viewPlaneNormal);\n    const worldVecRowDir = vec3.cross(vec3.create(), worldVecColDir, worldVecSliceDir);\n    const ijkVecColDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecColDir), ijkOrigin);\n    const ijkVecSliceDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecSliceDir), ijkOrigin);\n    vec3.normalize(ijkVecColDir, ijkVecColDir);\n    vec3.normalize(ijkVecSliceDir, ijkVecSliceDir);\n    const ijkVecRowDir = vec3.cross(vec3.create(), ijkVecColDir, ijkVecSliceDir);\n    return {\n        worldVecRowDir,\n        worldVecColDir,\n        worldVecSliceDir,\n        ijkVecRowDir,\n        ijkVecColDir,\n        ijkVecSliceDir,\n    };\n}\nexport { getVolumeDirectionVectors as default, getVolumeDirectionVectors };\n","export function calculateNeighborhoodStats(scalarData, dimensions, centerIjk, radius) {\n    const [width, height, numSlices] = dimensions;\n    const numPixelsPerSlice = width * height;\n    let sum = 0;\n    let sumSq = 0;\n    let count = 0;\n    const [cx, cy, cz] = centerIjk.map(Math.round);\n    for (let z = cz - radius; z <= cz + radius; z++) {\n        if (z < 0 || z >= numSlices) {\n            continue;\n        }\n        for (let y = cy - radius; y <= cy + radius; y++) {\n            if (y < 0 || y >= height) {\n                continue;\n            }\n            for (let x = cx - radius; x <= cx + radius; x++) {\n                if (x < 0 || x >= width) {\n                    continue;\n                }\n                const index = z * numPixelsPerSlice + y * width + x;\n                const value = scalarData[index];\n                sum += value;\n                sumSq += value * value;\n                count++;\n            }\n        }\n    }\n    if (count === 0) {\n        const centerIndex = cz * numPixelsPerSlice + cy * width + cx;\n        if (centerIndex >= 0 && centerIndex < scalarData.length) {\n            const centerValue = scalarData[centerIndex];\n            return { mean: centerValue, stdDev: 0, count: 1 };\n        }\n        else {\n            return { mean: 0, stdDev: 0, count: 0 };\n        }\n    }\n    const mean = sum / count;\n    const variance = sumSq / count - mean * mean;\n    const stdDev = Math.sqrt(Math.max(0, variance));\n    return { mean, stdDev, count };\n}\n","import * as eventListener from './eventListener';\nimport csUtils from './invertRgbTransferFunction';\nimport createSigmoidRGBTransferFunction from './createSigmoidRGBTransferFunction';\nimport getVoiFromSigmoidRGBTransferFunction from './getVoiFromSigmoidRGBTransferFunction';\nimport createLinearRGBTransferFunction from './createLinearRGBTransferFunction';\nimport scaleRgbTransferFunction from './scaleRgbTransferFunction';\nimport triggerEvent from './triggerEvent';\nimport uuidv4 from './uuidv4';\nimport getMinMax from './getMinMax';\nimport getRuntimeId from './getRuntimeId';\nimport imageIdToURI from './imageIdToURI';\nimport calibratedPixelSpacingMetadataProvider from './calibratedPixelSpacingMetadataProvider';\nimport clamp from './clamp';\nimport { isEqual, isEqualAbs, isEqualNegative } from './isEqual';\nimport isOpposite from './isOpposite';\nimport getClosestImageId from './getClosestImageId';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport indexWithinDimensions from './indexWithinDimensions';\nimport getVolumeViewportsContainingSameVolumes from './getVolumeViewportsContainingSameVolumes';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nimport transformWorldToIndex, { transformWorldToIndexContinuous, } from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport loadImageToCanvas from './loadImageToCanvas';\nimport * as HistoryMemo from './historyMemo';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport worldToImageCoords from './worldToImageCoords';\nimport imageToWorldCoords from './imageToWorldCoords';\nimport getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport getSliceRange from './getSliceRange';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getImageSliceDataForVolumeViewport from './getImageSliceDataForVolumeViewport';\nimport { isImageActor, actorIsA } from './actorCheck';\nimport getViewportsWithImageURI from './getViewportsWithImageURI';\nimport getClosestStackImageIndexForPoint from './getClosestStackImageIndexForPoint';\nimport getCurrentVolumeViewportSlice from './getCurrentVolumeViewportSlice';\nimport calculateViewportsSpatialRegistration from './calculateViewportsSpatialRegistration';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport getViewportImageCornersInWorld from './getViewportImageCornersInWorld';\nimport hasNaNValues from './hasNaNValues';\nimport applyPreset from './applyPreset';\nimport PointsManager from './PointsManager';\nimport deepMerge from './deepMerge';\nimport getScalingParameters from './getScalingParameters';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nimport getImageLegacy from './getImageLegacy';\nimport sortImageIdsAndGetSpacing from './sortImageIdsAndGetSpacing';\nimport makeVolumeMetadata from './makeVolumeMetadata';\nimport genericMetadataProvider from './genericMetadataProvider';\nimport { isValidVolume } from './isValidVolume';\nimport { updateVTKImageDataWithCornerstoneImage } from './updateVTKImageDataWithCornerstoneImage';\nimport ProgressiveIterator from './ProgressiveIterator';\nimport decimate from './decimate';\nimport imageRetrieveMetadataProvider from './imageRetrieveMetadataProvider';\nimport isVideoTransferSyntax from './isVideoTransferSyntax';\nimport { getBufferConfiguration } from './getBufferConfiguration';\nimport { generateVolumePropsFromImageIds } from './generateVolumePropsFromImageIds';\nimport { convertStackToVolumeViewport } from './convertStackToVolumeViewport';\nimport { convertVolumeToStackViewport } from './convertVolumeToStackViewport';\nimport VoxelManager from './VoxelManager';\nimport RLEVoxelMap from './RLEVoxelMap';\nimport roundNumber, { roundToPrecision } from './roundNumber';\nimport convertToGrayscale from './convertToGrayscale';\nimport getViewportImageIds from './getViewportImageIds';\nimport { getRandomSampleFromArray } from './getRandomSampleFromArray';\nimport { getVolumeId } from './getVolumeId';\nimport { hasFloatScalingParameters } from './hasFloatScalingParameters';\nimport { pointInShapeCallback } from './pointInShapeCallback';\nexport * as planar from './planar';\nimport * as windowLevel from './windowLevel';\nimport * as colormap from './colormap';\nimport * as transferFunctionUtils from './transferFunctionUtils';\nimport * as color from './color';\nimport { deepEqual } from './deepEqual';\nimport FrameRange from './FrameRange';\nimport fnv1aHash from './fnv1aHash';\nimport { getImageDataMetadata } from './getImageDataMetadata';\nimport { buildMetadata } from './buildMetadata';\nimport { _getViewportModality } from './getViewportModality';\nimport cache from '../cache/cache';\nimport getDynamicVolumeInfo from './getDynamicVolumeInfo';\nimport autoLoad from './autoLoad';\nimport scaleArray from './scaleArray';\nimport splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nimport { deepClone } from './deepClone';\nimport { jumpToSlice } from './jumpToSlice';\nimport scroll from './scroll';\nimport clip from './clip';\nimport createSubVolume from './createSubVolume';\nimport getVolumeDirectionVectors from './getVolumeDirectionVectors';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport * as logger from './logger';\nimport { calculateNeighborhoodStats } from './calculateNeighborhoodStats';\nconst getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache.getVolume);\nexport { FrameRange, eventListener, csUtils as invertRgbTransferFunction, createSigmoidRGBTransferFunction, getVoiFromSigmoidRGBTransferFunction, createLinearRGBTransferFunction, scaleRgbTransferFunction, triggerEvent, imageIdToURI, fnv1aHash, calibratedPixelSpacingMetadataProvider, clamp, uuidv4, getMinMax, getRuntimeId, isEqual, isEqualAbs, isEqualNegative, isOpposite, getViewportModality, windowLevel, convertToGrayscale, getClosestImageId, getSpacingInNormalDirection, getTargetVolumeAndSpacingInNormalDir, getVolumeActorCorners, indexWithinDimensions, getVolumeViewportsContainingSameVolumes, getViewportsWithVolumeId, transformWorldToIndex, transformIndexToWorld, loadImageToCanvas, renderToCanvasCPU, renderToCanvasGPU, worldToImageCoords, imageToWorldCoords, getVolumeSliceRangeInfo, getVolumeViewportScrollInfo, getSliceRange, snapFocalPointToSlice, getImageSliceDataForVolumeViewport, isImageActor, isPTPrescaledWithSUV, actorIsA, getViewportsWithImageURI, getClosestStackImageIndexForPoint, getCurrentVolumeViewportSlice, calculateViewportsSpatialRegistration, spatialRegistrationMetadataProvider, getViewportImageCornersInWorld, hasNaNValues, applyPreset, deepMerge, PointsManager, getScalingParameters, colormap, getImageLegacy, ProgressiveIterator, decimate, imageRetrieveMetadataProvider, transferFunctionUtils, updateVTKImageDataWithCornerstoneImage, sortImageIdsAndGetSpacing, makeVolumeMetadata, isValidVolume, genericMetadataProvider, isVideoTransferSyntax, HistoryMemo, generateVolumePropsFromImageIds, getBufferConfiguration, VoxelManager, RLEVoxelMap, convertStackToVolumeViewport, convertVolumeToStackViewport, roundNumber, roundToPrecision, getViewportImageIds, getRandomSampleFromArray, getVolumeId, color, hasFloatScalingParameters, getDynamicVolumeInfo, autoLoad, scaleArray, deepClone, splitImageIdsBy4DTags, pointInShapeCallback, deepEqual, jumpToSlice, scroll, clip, transformWorldToIndexContinuous, createSubVolume, getVolumeDirectionVectors, calculateSpacingBetweenImageIds, getImageDataMetadata, buildMetadata, calculateNeighborhoodStats, };\n","function _getViewportModality(viewport, volumeId, getVolume) {\n    if (!getVolume) {\n        throw new Error('getVolume is required, use the utilities export instead ');\n    }\n    if (viewport.modality) {\n        return viewport.modality;\n    }\n    if (viewport.setVolumes) {\n        volumeId = volumeId ?? viewport.getVolumeId();\n        if (!volumeId || !getVolume) {\n            return;\n        }\n        const volume = getVolume(volumeId);\n        return volume.metadata.Modality;\n    }\n    throw new Error('Invalid viewport type');\n}\nexport { _getViewportModality };\n","export default function invertRgbTransferFunction(rgbTransferFunction) {\n    if (!rgbTransferFunction) {\n        return;\n    }\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = 1 - nodeValue1[1];\n        nodeValue1[2] = 1 - nodeValue1[2];\n        nodeValue1[3] = 1 - nodeValue1[3];\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","function areNumbersEqualWithTolerance(num1, num2, tolerance) {\n    return Math.abs(num1 - num2) <= tolerance;\n}\nfunction areArraysEqual(arr1, arr2, tolerance = 1e-5) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isNumberType(value) {\n    return typeof value === 'number';\n}\nfunction isNumberArrayLike(value) {\n    return (value &&\n        typeof value === 'object' &&\n        'length' in value &&\n        typeof value.length === 'number' &&\n        value.length > 0 &&\n        typeof value[0] === 'number');\n}\nexport default function isEqual(v1, v2, tolerance = 1e-5) {\n    if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {\n        return false;\n    }\n    if (isNumberType(v1) && isNumberType(v2)) {\n        return areNumbersEqualWithTolerance(v1, v2, tolerance);\n    }\n    if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {\n        return areArraysEqual(v1, v2, tolerance);\n    }\n    return false;\n}\nconst negative = (v) => typeof v === 'number' ? -v : v?.map ? v.map(negative) : !v;\nconst abs = (v) => typeof v === 'number' ? Math.abs(v) : v?.map ? v.map(abs) : v;\nconst isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);\nconst isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);\nexport { isEqualNegative, isEqual, isEqualAbs };\n","import loglevelImport from 'loglevel';\nconst loglevel = loglevelImport.noConflict();\nif (typeof window !== 'undefined') {\n    window.log = loglevel;\n}\nexport function getRootLogger(name) {\n    const logger = loglevel.getLogger(name[0]);\n    logger.getLogger = (...names) => {\n        return getRootLogger(`${name}.${names.join('.')}`);\n    };\n    return logger;\n}\nexport function getLogger(...name) {\n    return getRootLogger(name.join('.'));\n}\nexport const cs3dLog = getRootLogger('cs3d');\nexport const coreLog = cs3dLog.getLogger('core');\nexport const toolsLog = cs3dLog.getLogger('tools');\nexport const loaderLog = cs3dLog.getLogger('dicomImageLoader');\nexport const aiLog = cs3dLog.getLogger('ai');\nexport const examplesLog = cs3dLog.getLogger('examples');\nexport const dicomConsistencyLog = getLogger('consistency', 'dicom');\nexport const imageConsistencyLog = getLogger('consistency', 'image');\n","import { get } from '../metaData';\nexport default function makeVolumeMetadata(imageIds) {\n    const imageId0 = imageIds[0];\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = get('imagePixelModule', imageId0);\n    const voiLut = [];\n    const voiLutModule = get('voiLutModule', imageId0);\n    let voiLUTFunction;\n    if (voiLutModule) {\n        const { windowWidth, windowCenter } = voiLutModule;\n        voiLUTFunction = voiLutModule?.voiLUTFunction;\n        if (Array.isArray(windowWidth)) {\n            for (let i = 0; i < windowWidth.length; i++) {\n                voiLut.push({\n                    windowWidth: windowWidth[i],\n                    windowCenter: windowCenter[i],\n                });\n            }\n        }\n        else {\n            voiLut.push({\n                windowWidth: windowWidth,\n                windowCenter: windowCenter,\n            });\n        }\n    }\n    else {\n        voiLut.push({\n            windowWidth: undefined,\n            windowCenter: undefined,\n        });\n    }\n    const { modality, seriesInstanceUID } = get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = get('imagePlaneModule', imageId0);\n    return {\n        BitsAllocated: bitsAllocated,\n        BitsStored: bitsStored,\n        SamplesPerPixel: samplesPerPixel,\n        HighBit: highBit,\n        PhotometricInterpretation: photometricInterpretation,\n        PixelRepresentation: pixelRepresentation,\n        Modality: modality,\n        ImageOrientationPatient: imageOrientationPatient,\n        PixelSpacing: pixelSpacing,\n        FrameOfReferenceUID: frameOfReferenceUID,\n        Columns: columns,\n        Rows: rows,\n        voiLut,\n        VOILUTFunction: voiLUTFunction,\n        SeriesInstanceUID: seriesInstanceUID,\n    };\n}\n","import { mat3 } from 'gl-matrix';\nfunction linePlaneIntersection(p0, p1, plane) {\n    const [x0, y0, z0] = p0;\n    const [x1, y1, z1] = p1;\n    const [A, B, C, D] = plane;\n    const a = x1 - x0;\n    const b = y1 - y0;\n    const c = z1 - z0;\n    const t = (-1 * (A * x0 + B * y0 + C * z0 - D)) / (A * a + B * b + C * c);\n    const X = a * t + x0;\n    const Y = b * t + y0;\n    const Z = c * t + z0;\n    return [X, Y, Z];\n}\nfunction planeEquation(normal, point, normalized = false) {\n    const [A, B, C] = normal;\n    const D = A * point[0] + B * point[1] + C * point[2];\n    if (normalized) {\n        const length = Math.sqrt(A * A + B * B + C * C);\n        return [A / length, B / length, C / length, D / length];\n    }\n    return [A, B, C, D];\n}\nfunction threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {\n    const [A1, B1, C1, D1] = firstPlane;\n    const [A2, B2, C2, D2] = secondPlane;\n    const [A3, B3, C3, D3] = thirdPlane;\n    const m0 = mat3.fromValues(A1, A2, A3, B1, B2, B3, C1, C2, C3);\n    const m1 = mat3.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);\n    const m2 = mat3.fromValues(A1, A2, A3, D1, D2, D3, C1, C2, C3);\n    const m3 = mat3.fromValues(A1, A2, A3, B1, B2, B3, D1, D2, D3);\n    const x = mat3.determinant(m1) / mat3.determinant(m0);\n    const y = mat3.determinant(m2) / mat3.determinant(m0);\n    const z = mat3.determinant(m3) / mat3.determinant(m0);\n    return [x, y, z];\n}\nfunction planeDistanceToPoint(plane, point, signed = false) {\n    const [A, B, C, D] = plane;\n    const [x, y, z] = point;\n    const numerator = A * x + B * y + C * z - D;\n    const distance = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);\n    const sign = signed ? Math.sign(numerator) : 1;\n    return sign * distance;\n}\nexport { linePlaneIntersection, planeEquation, threePlaneIntersection, planeDistanceToPoint, };\n","import { createPositionCallback } from './createPositionCallback';\nexport function pointInShapeCallback(imageData, options) {\n    const { pointInShapeFn, callback, boundsIJK, returnPoints = false } = options;\n    let scalarData;\n    if (imageData.getScalarData) {\n        scalarData = imageData.getScalarData();\n    }\n    else {\n        const scalars = imageData.getPointData().getScalars();\n        if (scalars) {\n            scalarData = scalars.getData();\n        }\n        else {\n            const { voxelManager } = imageData.get('voxelManager') || {};\n            if (voxelManager) {\n                scalarData = voxelManager.getCompleteScalarDataArray();\n            }\n        }\n    }\n    const dimensions = imageData.getDimensions();\n    const defaultBoundsIJK = [\n        [0, dimensions[0]],\n        [0, dimensions[1]],\n        [0, dimensions[2]],\n    ];\n    const bounds = boundsIJK || defaultBoundsIJK;\n    const pointsInShape = iterateOverPointsInShape({\n        imageData,\n        bounds,\n        scalarData,\n        pointInShapeFn,\n        callback,\n    });\n    return returnPoints ? pointsInShape : undefined;\n}\nexport function iterateOverPointsInShape({ imageData, bounds, scalarData, pointInShapeFn, callback, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const { numComps } = imageData;\n    const dimensions = imageData.getDimensions();\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const xMultiple = numComps ||\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n    const yMultiple = dimensions[0] * xMultiple;\n    const zMultiple = dimensions[1] * yMultiple;\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        const indexK = k * zMultiple;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            const indexJK = indexK + j * yMultiple;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = indexJK + i * xMultiple;\n                    let value;\n                    if (xMultiple > 2) {\n                        value = [\n                            scalarData[index],\n                            scalarData[index + 1],\n                            scalarData[index + 2],\n                        ];\n                    }\n                    else {\n                        value = scalarData[index];\n                    }\n                    pointsInShape.push({\n                        value,\n                        index,\n                        pointIJK,\n                        pointLPS: pointLPS.slice(),\n                    });\n                    callback({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\nexport function iterateOverPointsInShapeVoxelManager({ voxelManager, bounds, imageData, pointInShapeFn, callback, returnPoints, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = voxelManager.toIndex(pointIJK);\n                    const value = voxelManager.getAtIndex(index);\n                    if (returnPoints) {\n                        pointsInShape.push({\n                            value,\n                            index,\n                            pointIJK: [...pointIJK],\n                            pointLPS: pointLPS.slice(),\n                        });\n                    }\n                    callback?.({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\n","import { vec3 } from 'gl-matrix';\nexport default function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {\n    const { min, max, current } = sliceRange;\n    const posDiffFromFocalPoint = vec3.create();\n    vec3.sub(posDiffFromFocalPoint, position, focalPoint);\n    const steps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * steps;\n    let frameIndex = Math.round(floatingStepNumber);\n    let newFocalPoint = [\n        focalPoint[0] -\n            viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[1] -\n            viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[2] -\n            viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection,\n    ];\n    frameIndex += deltaFrames;\n    if (frameIndex > steps) {\n        frameIndex = steps;\n    }\n    else if (frameIndex < 0) {\n        frameIndex = 0;\n    }\n    const newSlicePosFromMin = frameIndex * spacingInNormalDirection;\n    newFocalPoint = [\n        newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,\n        newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,\n        newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin,\n    ];\n    const newPosition = [\n        newFocalPoint[0] + posDiffFromFocalPoint[0],\n        newFocalPoint[1] + posDiffFromFocalPoint[1],\n        newFocalPoint[2] + posDiffFromFocalPoint[2],\n    ];\n    return { newFocalPoint, newPosition };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport default function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    if (!scanAxisNormal) {\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        scanAxisNormal = vec3.create();\n        vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    }\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    const zSpacing = calculateSpacingBetweenImageIds(imageIds);\n    let sortedImageIds;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        vec3.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        sortedImageIds = distanceImagePairs.map((a) => a.imageId);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        sortedImageIds = imageIds;\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        if (firstImageDistance - middleImageDistance < 0) {\n            sortedImageIds.reverse();\n        }\n    }\n    const { imagePositionPatient: origin } = metaData.get('imagePlaneModule', sortedImageIds[0]);\n    const result = {\n        zSpacing,\n        origin,\n        sortedImageIds,\n    };\n    return result;\n}\n","function getTransferFunctionNodes(transferFunction) {\n    const size = transferFunction.getSize();\n    const values = [];\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        transferFunction.getNodeValue(index, nodeValue1);\n        values.push(nodeValue1);\n    }\n    return values;\n}\nfunction setTransferFunctionNodes(transferFunction, nodes) {\n    if (!nodes?.length) {\n        return;\n    }\n    transferFunction.removeAllPoints();\n    nodes.forEach((node) => {\n        transferFunction.addRGBPoint(...node);\n    });\n}\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\n","import transformWorldToIndex from './transformWorldToIndex';\nexport function transformCanvasToIJK(viewport, canvasPoint) {\n    const { imageData: vtkImageData } = viewport.getImageData();\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return transformWorldToIndex(vtkImageData, worldPoint);\n}\n","export default function transformIndexToWorld(imageData, voxelPos) {\n    return imageData.indexToWorld(voxelPos);\n}\n","export default function transformWorldToIndex(imageData, worldPos) {\n    const continuousIndex = imageData.worldToIndex(worldPos);\n    const index = continuousIndex.map(Math.round);\n    return index;\n}\nexport function transformWorldToIndexContinuous(imageData, worldPos) {\n    return imageData.worldToIndex(worldPos);\n}\n","function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {\n    const pixelData = image.voxelManager.getScalarData();\n    if (!sourceImageData.getPointData) {\n        return;\n    }\n    const scalarData = sourceImageData\n        .getPointData()\n        .getScalars()\n        .getData();\n    if (image.color && image.rgba) {\n        const newPixelData = new Uint8Array(image.columns * image.rows * 3);\n        for (let i = 0; i < image.columns * image.rows; i++) {\n            newPixelData[i * 3] = pixelData[i * 4];\n            newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];\n            newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];\n        }\n        image.rgba = false;\n        image.getPixelData = () => newPixelData;\n        scalarData.set(newPixelData);\n    }\n    else {\n        scalarData.set(pixelData);\n    }\n    sourceImageData.modified();\n}\nexport { updateVTKImageDataWithCornerstoneImage };\n","import VOILUTFunctionType from '../enums/VOILUTFunctionType';\nimport { logit } from './logit';\nfunction toWindowLevel(low, high) {\n    const windowWidth = Math.abs(high - low) + 1;\n    const windowCenter = (low + high + 1) / 2;\n    return { windowWidth, windowCenter };\n}\nfunction toLowHighRange(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType.LINEAR) {\n    if (voiLUTFunction === VOILUTFunctionType.LINEAR) {\n        return {\n            lower: windowCenter - 0.5 - (windowWidth - 1) / 2,\n            upper: windowCenter - 0.5 + (windowWidth - 1) / 2,\n        };\n    }\n    else if (voiLUTFunction === VOILUTFunctionType.LINEAR_EXACT) {\n        return {\n            lower: windowCenter - windowWidth / 2,\n            upper: windowCenter + windowWidth / 2,\n        };\n    }\n    else if (voiLUTFunction === VOILUTFunctionType.SAMPLED_SIGMOID) {\n        const xLower = logit(0.01, windowCenter, windowWidth);\n        const xUpper = logit(0.99, windowCenter, windowWidth);\n        return {\n            lower: xLower,\n            upper: xUpper,\n        };\n    }\n    else {\n        throw new Error('Invalid VOI LUT function');\n    }\n}\nexport { toWindowLevel, toLowHighRange };\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {\n    if (typeof calibrationOrScale === 'number') {\n        calibrationOrScale = {\n            type: Enums.CalibrationTypes.USER,\n            scale: calibrationOrScale,\n        };\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n","var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VideoViewport, VolumeViewport, cache, BaseVolumeViewport, Enums, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    if (!playClipOptions) {\n        playClipOptions = {};\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, {\n            stopDynamicCine: !isDynamicCinePlaying,\n            viewportId: viewport.id,\n        });\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const newStepIndexOutOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (!playClipData.loop && newStepIndexOutOfRange) {\n            _stopClip(element, {\n                stopDynamicCine: !isDynamicCinePlaying,\n                viewportId: viewport.id,\n            });\n            const eventDetail = { element };\n            triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n            return;\n        }\n        if (newStepIndex >= numScrollSteps) {\n            newStepIndex = 0;\n        }\n        else if (newStepIndex < 0) {\n            newStepIndex = numScrollSteps - 1;\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            try {\n                playClipContext.scroll(delta);\n            }\n            catch (e) {\n                console.warn('Play clip not scrolling', e);\n                _stopClipWithData(playClipData);\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n                return;\n            }\n        }\n    };\n    if (isDynamicCinePlaying) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume) {\n            dynamicVolumesPlayingMap.set(volume.volumeId, element);\n        }\n    }\n    if (playClipContext.play) {\n        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);\n    }\n    else if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element, options = {}) {\n    _stopClip(element, {\n        stopDynamicCine: true,\n        ...options,\n    });\n}\nfunction _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {\n    const { stopDynamicCine, viewportId } = options;\n    const enabledElement = getEnabledElement(element);\n    let toolState;\n    const viewport = enabledElement?.viewport;\n    if (!enabledElement) {\n        if (viewportId) {\n            toolState = getToolStateByViewportId(viewportId);\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        const { viewport } = enabledElement;\n        toolState = getToolState(viewport.element);\n    }\n    if (toolState) {\n        _stopClipWithData(toolState);\n    }\n    if (viewport instanceof VideoViewport) {\n        viewport.pause();\n    }\n    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume?.isDynamicVolume()) {\n            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n            dynamicVolumesPlayingMap.delete(volume.volumeId);\n            if (dynamicCineElement && dynamicCineElement !== element) {\n                stopClip(dynamicCineElement);\n            }\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumeFromViewport(viewport) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return undefined;\n    }\n    const volumeIds = viewport.getAllVolumeIds();\n    if (!volumeIds?.length) {\n        return undefined;\n    }\n    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());\n    const volumeId = dynamicVolumeId ?? volumeIds[0];\n    return cache.getVolume(volumeId);\n}\nfunction _createStackViewportCinePlayContext(viewport, waitForRendered) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVideoViewportCinePlayContext(viewport, waitForRendered) {\n    return {\n        get numScrollSteps() {\n            return viewport.getNumberOfSlices();\n        },\n        get currentStepIndex() {\n            return viewport.getSliceIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n        play(fps) {\n            if (fps) {\n                viewport.setPlaybackRate(fps / 24);\n            }\n            viewport.play();\n            return viewport.getFrameRate();\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            csUtils.scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numDimensionGroups;\n        },\n        get currentStepIndex() {\n            return volume.dimensionGroupNumber - 1;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.scroll(delta);\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    if (viewport instanceof VideoViewport) {\n        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n","import smoothAnnotation from './smoothAnnotation';\nexport default {\n    smoothAnnotation,\n};\nexport { smoothAnnotation };\n","import { Enums } from '@cornerstonejs/core';\nfunction sumOverDimensionGroups(voxelManager, dimensionGroups) {\n    const arrayLength = voxelManager.getScalarDataLength();\n    const resultArray = new Float32Array(arrayLength);\n    for (const dimensionGroupNumber of dimensionGroups) {\n        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);\n        for (let i = 0; i < arrayLength; i++) {\n            resultArray[i] += scalarData[i];\n        }\n    }\n    return resultArray;\n}\nfunction averageOverDimensionGroups(voxelManager, dimensionGroups) {\n    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n    const numDimensionGroups = dimensionGroups.length;\n    for (let i = 0; i < sumArray.length; i++) {\n        sumArray[i] /= numDimensionGroups;\n    }\n    return sumArray;\n}\nconst operationFunctions = {\n    [Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {\n        if (dimensionGroups.length !== 2) {\n            throw new Error('Please provide only 2 dimension groups for subtraction.');\n        }\n        const arrayLength = voxelManager.getScalarDataLength();\n        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);\n        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);\n        for (let i = 0; i < arrayLength; i++) {\n            const difference = scalarData1[i] - scalarData2[i];\n            callback(i, difference);\n        }\n    },\n};\nfunction generateImageFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers } = options;\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const arrayLength = voxelManager.getScalarDataLength();\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    const resultArray = new Float32Array(arrayLength);\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        resultArray[index] = value;\n    });\n    return resultArray;\n}\nfunction updateVolumeFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;\n    if (!targetVolume) {\n        throw new Error('A target volume must be provided');\n    }\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const targetVoxelManager = targetVolume.voxelManager;\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        targetVoxelManager.setAtIndex(index, value);\n    });\n    targetVoxelManager.resetModifiedSlices();\n    for (let k = 0; k < targetVolume.dimensions[2]; k++) {\n        targetVoxelManager.modifiedSlices.add(k);\n    }\n}\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n","import { vec3 } from 'gl-matrix';\nexport function getPoint(points, idx) {\n    const idx3 = idx * 3;\n    if (idx3 < points.length) {\n        return vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);\n    }\n}\nexport function getPolyDataPointIndexes(polyData) {\n    const linesData = polyData.getLines().getData();\n    let idx = 0;\n    const lineSegments = new Map();\n    while (idx < linesData.length) {\n        const segmentSize = linesData[idx++];\n        const segment = [];\n        for (let i = 0; i < segmentSize; i++) {\n            segment.push(linesData[idx + i]);\n        }\n        lineSegments.set(segment[0], segment);\n        idx += segmentSize;\n    }\n    const contours = [];\n    const findStartingPoint = (map) => {\n        for (const [key, value] of map.entries()) {\n            if (value !== undefined) {\n                return key;\n            }\n        }\n        return -1;\n    };\n    let startPoint = findStartingPoint(lineSegments);\n    while (startPoint !== -1) {\n        const contour = [startPoint];\n        while (lineSegments.has(startPoint)) {\n            const nextPoint = lineSegments.get(startPoint)[1];\n            if (lineSegments.has(nextPoint)) {\n                contour.push(nextPoint);\n            }\n            lineSegments.delete(startPoint);\n            startPoint = nextPoint;\n        }\n        contours.push(contour);\n        startPoint = findStartingPoint(lineSegments);\n    }\n    return contours.length ? contours : undefined;\n}\nexport function getPolyDataPoints(polyData) {\n    const contoursIndexes = getPolyDataPointIndexes(polyData);\n    if (!contoursIndexes) {\n        return;\n    }\n    const rawPointsData = polyData.getPoints().getData();\n    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));\n}\n","import { vec2 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\nconst DEFAULTS = {\n    MULTIPLIER: 1,\n    RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n    TICKS_BAR_SIZE: 50,\n};\nclass Colorbar extends Widget {\n    constructor(props) {\n        super(props);\n        this._isMouseOver = false;\n        this._isInteracting = false;\n        this._mouseOverCallback = (evt) => {\n            this._isMouseOver = true;\n            this.showTicks();\n            evt.stopPropagation();\n        };\n        this._mouseOutCallback = (evt) => {\n            this._isMouseOver = false;\n            this.hideTicks();\n            evt.stopPropagation();\n        };\n        this._mouseDownCallback = (evt) => {\n            this._isInteracting = true;\n            this.showTicks();\n            this._addVOIEventListeners(evt);\n            evt.stopPropagation();\n        };\n        this._mouseDragCallback = (evt, initialState) => {\n            const multipliers = this.getVOIMultipliers();\n            const currentPoints = this._getPointsFromMouseEvent(evt);\n            const { points: startPoints, voiRange: startVOIRange } = initialState;\n            const canvasDelta = vec2.sub(vec2.create(), currentPoints.local, startPoints.local);\n            const wwDelta = canvasDelta[0] * multipliers[0];\n            const wcDelta = canvasDelta[1] * multipliers[1];\n            if (!wwDelta && !wcDelta) {\n                return;\n            }\n            const { lower: voiLower, upper: voiUpper } = startVOIRange;\n            let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(voiLower, voiUpper);\n            windowWidth = Math.max(windowWidth + wwDelta, 1);\n            windowCenter += wcDelta;\n            const newVoiRange = csUtils.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            this.voiRange = newVoiRange;\n            evt.stopPropagation();\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            this._isInteracting = false;\n            this.hideTicks();\n            this._removeVOIEventListeners();\n            evt.stopPropagation();\n        };\n        this._eventListenersManager =\n            new csUtils.eventListener.MultiTargetEventListenerManager();\n        this._colormaps = Colorbar.getColormapsMap(props);\n        this._activeColormapName = Colorbar.getInitialColormapName(props);\n        this._canvas = this._createCanvas(props);\n        this._ticksBar = this._createTicksBar(props);\n        this._rangeTextPosition =\n            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n        this._canvas.appendTo(this.rootElement);\n        this._ticksBar.appendTo(this.rootElement);\n        this._addRootElementEventListeners();\n    }\n    get activeColormapName() {\n        return this._activeColormapName;\n    }\n    set activeColormapName(colormapName) {\n        if (colormapName === this._activeColormapName) {\n            return;\n        }\n        const colormap = this._colormaps.get(colormapName);\n        if (!colormap) {\n            console.warn(`Invalid colormap name (${colormapName})`);\n            return;\n        }\n        this._activeColormapName = colormapName;\n        this._canvas.colormap = colormap;\n    }\n    get imageRange() {\n        return this._canvas.imageRange;\n    }\n    set imageRange(imageRange) {\n        this._canvas.imageRange = imageRange;\n        this._ticksBar.imageRange = imageRange;\n    }\n    get voiRange() {\n        return this._canvas.voiRange;\n    }\n    set voiRange(voiRange) {\n        const { voiRange: currentVoiRange } = this._canvas;\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, currentVoiRange)) {\n            return;\n        }\n        this._canvas.voiRange = voiRange;\n        this._ticksBar.voiRange = voiRange;\n        this.onVoiChange(voiRange);\n    }\n    get showFullImageRange() {\n        return this._canvas.showFullImageRange;\n    }\n    set showFullImageRange(value) {\n        this._canvas.showFullImageRange = value;\n        this._ticksBar.showFullPixelValueRange = value;\n    }\n    destroy() {\n        super.destroy();\n        this._eventListenersManager.reset();\n    }\n    createRootElement() {\n        const rootElement = document.createElement('div');\n        Object.assign(rootElement.style, {\n            position: 'relative',\n            fontSize: '0',\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n        super.onContainerResize();\n        this.updateTicksBar();\n        this._canvas.size = this.containerSize;\n    }\n    getVOIMultipliers() {\n        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n    }\n    onVoiChange(voiRange) {\n    }\n    showTicks() {\n        this.updateTicksBar();\n        this._ticksBar.visible = true;\n    }\n    hideTicks() {\n        if (this._isInteracting || this._isMouseOver) {\n            return;\n        }\n        this._ticksBar.visible = false;\n    }\n    static getColormapsMap(props) {\n        const { colormaps } = props;\n        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());\n    }\n    static getInitialColormapName(props) {\n        const { activeColormapName, colormaps } = props;\n        const colormapExists = !!activeColormapName &&\n            colormaps.some((cm) => cm.Name === activeColormapName);\n        return colormapExists ? activeColormapName : colormaps[0].Name;\n    }\n    _createCanvas(props) {\n        const { imageRange, voiRange, showFullPixelValueRange } = props;\n        const colormap = this._colormaps.get(this._activeColormapName);\n        return new ColorbarCanvas({\n            colormap,\n            imageRange,\n            voiRange: voiRange,\n            showFullPixelValueRange,\n        });\n    }\n    _createTicksBar(props) {\n        const ticksProps = props.ticks;\n        return new ColorbarTicks({\n            imageRange: props.imageRange,\n            voiRange: props.voiRange,\n            ticks: ticksProps,\n            showFullPixelValueRange: props.showFullPixelValueRange,\n        });\n    }\n    _getPointsFromMouseEvent(evt) {\n        const { rootElement: element } = this;\n        const clientPoint = [evt.clientX, evt.clientY];\n        const pagePoint = [evt.pageX, evt.pageY];\n        const rect = element.getBoundingClientRect();\n        const localPoints = [\n            pagePoint[0] - rect.left - window.pageXOffset,\n            pagePoint[1] - rect.top - window.pageYOffset,\n        ];\n        return { client: clientPoint, page: pagePoint, local: localPoints };\n    }\n    updateTicksBar() {\n        const { width: containerWidth, height: containerHeight } = this.containerSize;\n        if (containerWidth === 0 && containerHeight === 0) {\n            return;\n        }\n        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n        const isHorizontal = containerWidth >= containerHeight;\n        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n        if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {\n            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');\n        }\n        let ticksBarTop;\n        let ticksBarLeft;\n        ticksBar.size = { width, height };\n        if (isHorizontal) {\n            ticksBarLeft = 0;\n            ticksBarTop =\n                rangeTextPosition === ColorbarRangeTextPosition.Top\n                    ? -height\n                    : containerHeight;\n        }\n        else {\n            ticksBarTop = 0;\n            ticksBarLeft =\n                rangeTextPosition === ColorbarRangeTextPosition.Left\n                    ? -width\n                    : containerWidth;\n        }\n        ticksBar.top = ticksBarTop;\n        ticksBar.left = ticksBarLeft;\n    }\n    _addRootElementEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        const { rootElement: element } = this;\n        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);\n    }\n    _addVOIEventListeners(evt) {\n        const { _eventListenersManager: manager } = this;\n        const points = this._getPointsFromMouseEvent(evt);\n        const voiRange = { ...this._canvas.voiRange };\n        const initialDragState = { points, voiRange };\n        this._removeVOIEventListeners();\n        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));\n    }\n    _removeVOIEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        manager.removeEventListener(document, 'voi.mouseup');\n        manager.removeEventListener(document, 'voi.mousemove');\n    }\n}\nexport { Colorbar as default, Colorbar };\n","import { eventTarget, VolumeViewport, StackViewport, Enums, utilities, getEnabledElement, cache, } from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\nclass ViewportColorbar extends Colorbar {\n    constructor(props) {\n        const { element, volumeId } = props;\n        const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n        super({ ...props, imageRange, voiRange });\n        this.autoHideTicks = () => {\n            if (this._hideTicksTimeoutId) {\n                return;\n            }\n            const timeLeft = this._hideTicksTime - Date.now();\n            if (timeLeft <= 0) {\n                this.hideTicks();\n            }\n            else {\n                this._hideTicksTimeoutId = window.setTimeout(() => {\n                    this._hideTicksTimeoutId = 0;\n                    this.autoHideTicks();\n                }, timeLeft);\n            }\n        };\n        this._stackNewImageCallback = () => {\n            this.imageRange = ViewportColorbar._getImageRange(this._element);\n        };\n        this._imageVolumeModifiedCallback = (evt) => {\n            const { volumeId } = evt.detail;\n            if (volumeId !== this._volumeId) {\n                return;\n            }\n            const { _element: element } = this;\n            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        };\n        this._viewportVOIModifiedCallback = (evt) => {\n            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.voiRange = voiRange;\n            if (colormap) {\n                this.activeColormapName = colormap.name;\n            }\n            this.showAndAutoHideTicks();\n        };\n        this._viewportColormapModifiedCallback = (evt) => {\n            const { viewportId, colormap, volumeId } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.activeColormapName = colormap.name;\n        };\n        this._element = element;\n        this._volumeId = volumeId;\n        this._addCornerstoneEventListener();\n    }\n    get element() {\n        return this._element;\n    }\n    get enabledElement() {\n        return getEnabledElement(this._element);\n    }\n    getVOIMultipliers() {\n        const { viewport } = this.enabledElement;\n        return getVOIMultipliers(viewport, this._volumeId);\n    }\n    onVoiChange(voiRange) {\n        super.onVoiChange(voiRange);\n        const { viewport } = this.enabledElement;\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: voiRange,\n            });\n            viewport.render();\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { _volumeId: volumeId } = this;\n            const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId);\n            viewport.setProperties({ voiRange }, volumeId);\n            viewportsContainingVolumeUID.forEach((vp) => vp.render());\n        }\n    }\n    static _getImageRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const imageData = actor.getMapper().getInputData();\n        const scalarData = imageData.getPointData().getScalars();\n        let imageRange;\n        if (!scalarData) {\n            if (!volumeId) {\n                throw new Error('volumeId is required when scalarData is not available');\n            }\n            const volume = cache.getVolume(volumeId);\n            const [minValue, maxValue] = volume.voxelManager.getRange();\n            imageRange = [minValue, maxValue];\n        }\n        else {\n            imageRange = scalarData.getRange();\n        }\n        return imageRange[0] === 0 && imageRange[1] === 0\n            ? defaultImageRange\n            : { lower: imageRange[0], upper: imageRange[1] };\n    }\n    static _getVOIRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();\n        return voiRange[0] === 0 && voiRange[1] === 0\n            ? defaultImageRange\n            : { lower: voiRange[0], upper: voiRange[1] };\n    }\n    showAndAutoHideTicks(interval = 1000) {\n        this._hideTicksTime = Date.now() + interval;\n        this.showTicks();\n        this.autoHideTicks();\n    }\n    _addCornerstoneEventListener() {\n        const { _element: element } = this;\n        eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n    destroy() {\n        super.destroy();\n        const { _element: element } = this;\n        eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n}\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { utilities as csUtils, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nfunction extractWindowLevelRegionToolData(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        return extractImageDataVolume(viewport);\n    }\n    if (viewport instanceof StackViewport) {\n        return extractImageDataStack(viewport);\n    }\n    throw new Error('Viewport not supported');\n}\nfunction extractImageDataVolume(viewport) {\n    const { scalarData, width, height } = csUtils.getCurrentVolumeViewportSlice(viewport);\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    return {\n        scalarData,\n        minPixelValue,\n        maxPixelValue,\n        width,\n        height,\n        rows: width,\n        columns: height,\n    };\n}\nfunction extractImageDataStack(viewport) {\n    const imageData = viewport.getImageData();\n    const { scalarData } = imageData;\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    const width = imageData.dimensions[0];\n    const height = imageData.dimensions[1];\n    const { rows, columns, color } = viewport.getCornerstoneImage();\n    return {\n        scalarData,\n        width,\n        height,\n        minPixelValue,\n        maxPixelValue,\n        rows,\n        columns,\n        color,\n    };\n}\nexport { extractWindowLevelRegionToolData };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    const dimensions = imageData.getDimensions();\n    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({\n        dimensions: dimensions,\n        scalarData: imageData.getPointData().getScalars().getData(),\n    });\n    voxelManager.forEach(callback, {\n        boundsIJK,\n        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),\n        imageData,\n    });\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n","import { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../enums';\nexport default function setAnnotationLabel(annotation, element, updatedLabel) {\n    annotation.data.label = updatedLabel;\n    triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n}\n","import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport AnnotationMultiSlice from './AnnotationMultiSlice';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nimport normalizeViewportPlane from './normalizeViewportPlane';\nimport IslandRemoval from './segmentation/islandRemoval';\nimport { getPixelValueUnits, getPixelValueUnitsImageId, } from './getPixelValueUnits';\nimport * as geometricSurfaceUtils from './geometricSurfaceUtils';\nimport setAnnotationLabel from './setAnnotationLabel';\nimport { moveAnnotationToViewPlane } from './moveAnnotationToViewPlane';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, getPixelValueUnits, getPixelValueUnitsImageId, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, AnnotationMultiSlice, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, normalizeViewportPlane, IslandRemoval, geometricSurfaceUtils, setAnnotationLabel, moveAnnotationToViewPlane, };\n","import * as math from '../../../utilities/math';\nclass Spline {\n    constructor(props) {\n        this._controlPoints = [];\n        this._invalidated = false;\n        this._length = 0;\n        this._controlPoints = [];\n        this._resolution = props?.resolution ?? 20;\n        this._fixedResolution = props?.fixedResolution ?? false;\n        this._closed = props?.closed ?? false;\n        this._invalidated = true;\n    }\n    get controlPoints() {\n        return this._controlPoints;\n    }\n    get numControlPoints() {\n        return this._controlPoints.length;\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._fixedResolution || this._resolution === resolution) {\n            return;\n        }\n        this._resolution = resolution;\n        this.invalidated = true;\n    }\n    get fixedResolution() {\n        return this._fixedResolution;\n    }\n    get closed() {\n        return this._closed;\n    }\n    set closed(closed) {\n        if (this._closed === closed) {\n            return;\n        }\n        this._closed = closed;\n        this.invalidated = true;\n    }\n    get aabb() {\n        this._update();\n        return this._aabb;\n    }\n    get length() {\n        this._update();\n        return this._length;\n    }\n    get invalidated() {\n        return this._invalidated;\n    }\n    set invalidated(invalidated) {\n        this._invalidated = invalidated;\n    }\n    hasTangentPoints() {\n        return false;\n    }\n    addControlPoint(point) {\n        this._controlPoints.push([point[0], point[1]]);\n        this.invalidated = true;\n    }\n    addControlPoints(points) {\n        points.forEach((point) => this.addControlPoint(point));\n    }\n    addControlPointAtU(u) {\n        const lineSegment = this._getLineSegmentAt(u);\n        const { start: startPoint, end: endPoint } = lineSegment.points;\n        const curveSegmentIndex = Math.floor(u);\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const t = u - Math.floor(curveSegmentIndex);\n        const controlPointPos = [\n            startPoint[0] + t * (endPoint[0] - startPoint[0]),\n            startPoint[1] + t * (endPoint[1] - startPoint[1]),\n        ];\n        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n        this._controlPoints.splice(insertIndex, 0, controlPointPos);\n        this.invalidated = true;\n        return {\n            index: insertIndex,\n            point: controlPointPos,\n        };\n    }\n    deleteControlPointByIndex(index) {\n        const minControlPoints = this._closed ? 3 : 1;\n        const canDelete = index >= 0 &&\n            index < this._controlPoints.length &&\n            this._controlPoints.length > minControlPoints;\n        if (!canDelete) {\n            return false;\n        }\n        this._controlPoints.splice(index, 1);\n        this.invalidated = true;\n        return true;\n    }\n    clearControlPoints() {\n        this._controlPoints = [];\n        this.invalidated = true;\n    }\n    setControlPoints(points) {\n        this.clearControlPoints();\n        this.addControlPoints(points);\n    }\n    updateControlPoint(index, newControlPoint) {\n        if (index < 0 || index >= this._controlPoints.length) {\n            throw new Error('Index out of bounds');\n        }\n        this._controlPoints[index] = [...newControlPoint];\n        this.invalidated = true;\n    }\n    getControlPoints() {\n        return this._controlPoints.map((controlPoint) => [\n            controlPoint[0],\n            controlPoint[1],\n        ]);\n    }\n    getClosestControlPoint(point) {\n        const controlPoints = this._controlPoints;\n        let minSquaredDist = Infinity;\n        let closestPointIndex = -1;\n        for (let i = 0, len = controlPoints.length; i < len; i++) {\n            const controlPoint = controlPoints[i];\n            const dx = point[0] - controlPoint[0];\n            const dy = point[1] - controlPoint[1];\n            const squaredDist = dx * dx + dy * dy;\n            if (squaredDist < minSquaredDist) {\n                minSquaredDist = squaredDist;\n                closestPointIndex = i;\n            }\n        }\n        return {\n            index: closestPointIndex,\n            point: closestPointIndex === -1\n                ? undefined\n                : [...controlPoints[closestPointIndex]],\n            distance: Math.sqrt(minSquaredDist),\n        };\n    }\n    getClosestControlPointWithinDistance(point, maxDist) {\n        const closestControlPoint = this.getClosestControlPoint(point);\n        return closestControlPoint.distance <= maxDist\n            ? closestControlPoint\n            : undefined;\n    }\n    getClosestPoint(point) {\n        this._update();\n        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        if (!curveSegmentsDistInfo.length) {\n            return;\n        }\n        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);\n        let closestPoint;\n        let closestPointCurveSegmentIndex = -1;\n        let minDistSquared = Infinity;\n        let minDistCurveSegment;\n        let minDistLineSegment;\n        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n            const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n                continue;\n            }\n            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n            const { lineSegments } = curveSegment;\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineSegDistSquared < minDistSquared) {\n                    minDistLineSegment = lineSegment;\n                    closestPointCurveSegmentIndex = curveSegmentIndex;\n                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n                    closestPoint = lineSegPoint;\n                    minDistSquared = lineSegDistSquared;\n                }\n            }\n        }\n        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +\n            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n        const u = closestPointCurveSegmentIndex + t;\n        return {\n            point: closestPoint,\n            uValue: u,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getClosestPointOnControlPointLines(point) {\n        const linePoints = [...this._controlPoints];\n        if (this._closed) {\n            linePoints.push(this._controlPoints[0]);\n        }\n        if (!linePoints.length) {\n            return;\n        }\n        let closestPoint;\n        let minDistSquared = Infinity;\n        let startPoint = linePoints[0];\n        for (let i = 1, len = linePoints.length; i < len; i++) {\n            const endPoint = linePoints[i];\n            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);\n            if (lineSegDistSquared < minDistSquared) {\n                closestPoint = lineSegPoint;\n                minDistSquared = lineSegDistSquared;\n            }\n            startPoint = endPoint;\n        }\n        return {\n            point: closestPoint,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getPolylinePoints() {\n        this._update();\n        return this._convertCurveSegmentsToPolyline(this._curveSegments);\n    }\n    getPreviewPolylinePoints(controlPointPreview, closeDistance) {\n        if (this._closed) {\n            return [];\n        }\n        this._update();\n        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);\n        const closeSpline = closestControlPoint?.index === 0;\n        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);\n        return previewCurveSegments?.length\n            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n            : [];\n    }\n    isPointNearCurve(point, maxDist) {\n        this._update();\n        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n        const maxDistSquared = maxDist * maxDist;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const { lineSegments } = curveSegments[i];\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineDistSquared <= maxDistSquared) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    containsPoint(point) {\n        this._update();\n        const controlPoints = this._controlPoints;\n        if (controlPoints.length < 3) {\n            return false;\n        }\n        const curveSegments = [...this._curveSegments];\n        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();\n        if (closingCurveSegment) {\n            curveSegments.push(closingCurveSegment);\n        }\n        let numIntersections = 0;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const { aabb: curveSegAABB } = curveSegment;\n            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&\n                point[1] >= curveSegAABB.minY &&\n                point[1] < curveSegAABB.maxY;\n            if (!mayIntersectCurveSegment) {\n                continue;\n            }\n            const { lineSegments } = curveSegment;\n            for (let i = 0; i < lineSegments.length; i++) {\n                const lineSegment = lineSegments[i];\n                const { aabb: lineSegmentAABB } = lineSegment;\n                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&\n                    point[1] >= lineSegmentAABB.minY &&\n                    point[1] < lineSegmentAABB.maxY;\n                if (mayIntersectLineSegment) {\n                    const { start: p1, end: p2 } = lineSegment.points;\n                    const isVerticalLine = p1[0] === p2[0];\n                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                    numIntersections +=\n                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n                }\n            }\n        }\n        return numIntersections % 2 === 1;\n    }\n    _update() {\n        if (!this._invalidated) {\n            return;\n        }\n        const curveSegments = this.getSplineCurves();\n        let length = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for (let i = 0, len = curveSegments.length; i < len; i++) {\n            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n            length += curveSegLength;\n        }\n        this._curveSegments = curveSegments;\n        this._aabb = { minX, minY, maxX, maxY };\n        this._length = length;\n        this._invalidated = false;\n    }\n    _convertCurveSegmentsToPolyline(curveSegments) {\n        this._update();\n        const polylinePoints = [];\n        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n            lineSegments.forEach((lineSegment, lineSegIndex) => {\n                if (curveSegIndex === 0 && lineSegIndex === 0) {\n                    polylinePoints.push([...lineSegment.points.start]);\n                }\n                polylinePoints.push([...lineSegment.points.end]);\n            });\n        });\n        return polylinePoints;\n    }\n    _getCurveSegmmentsDistanceSquaredInfo(point) {\n        this._update();\n        const curveSegmentsDistanceSquared = [];\n        const { _curveSegments: curveSegments } = this;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);\n            curveSegmentsDistanceSquared.push({\n                curveSegmentIndex: i,\n                curveSegment,\n                distanceSquared,\n            });\n        }\n        return curveSegmentsDistanceSquared;\n    }\n    _getCurveSegmmentsWithinDistance(point, maxDist) {\n        this._update();\n        const maxDistSquared = maxDist * maxDist;\n        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n            return [];\n        }\n        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        const curveSegmentsWithinRange = [];\n        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];\n            if (curveSegmentDistSquared <= maxDistSquared) {\n                curveSegmentsWithinRange.push(curveSegment);\n            }\n        }\n        return curveSegmentsWithinRange;\n    }\n    _getLineSegmentAt(u) {\n        this._update();\n        const curveSegmentIndex = Math.floor(u);\n        const t = u - curveSegmentIndex;\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const { lineSegments } = curveSegment;\n        const pointLength = curveSegment.length * t;\n        for (let i = 0; i < lineSegments.length; i++) {\n            const lineSegment = lineSegments[i];\n            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;\n            if (pointLength >= lineSegment.previousLineSegmentsLength &&\n                pointLength <= lengthEnd) {\n                return lineSegment;\n            }\n        }\n    }\n    _getClosingCurveSegmentWithStraightLineSegment() {\n        if (this.closed) {\n            return;\n        }\n        const controlPoints = this._controlPoints;\n        const startControlPoint = controlPoints[0];\n        const endControlPoint = controlPoints[controlPoints.length - 1];\n        const closingLineSegment = {\n            points: {\n                start: [...startControlPoint],\n                end: [...endControlPoint],\n            },\n            aabb: {\n                minX: Math.min(startControlPoint[0], endControlPoint[0]),\n                minY: Math.min(startControlPoint[1], endControlPoint[1]),\n                maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n                maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n            },\n        };\n        return {\n            aabb: {\n                minX: closingLineSegment.aabb.minX,\n                minY: closingLineSegment.aabb.minY,\n                maxX: closingLineSegment.aabb.maxX,\n                maxY: closingLineSegment.aabb.maxY,\n            },\n            lineSegments: [closingLineSegment],\n        };\n    }\n}\nexport { Spline as default, Spline };\n","import { vec4 } from 'gl-matrix';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nconst MAX_U_ERROR = 1e-8;\nclass CubicSpline extends Spline {\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n        const endCurveSegIndex = closeSpline\n            ? previewNumCurveSegments\n            : previewNumCurveSegments - 1;\n        const transformMatrix = this.getTransformMatrix();\n        const controlPoints = [...this.controlPoints];\n        const curveSegments = [];\n        if (!closeSpline) {\n            controlPoints.push(controlPointPreview);\n        }\n        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);\n            curveSegments.push(curveSegment);\n        }\n        return curveSegments;\n    }\n    getSplineCurves() {\n        const numCurveSegments = this._getNumCurveSegments();\n        const curveSegments = new Array(numCurveSegments);\n        if (numCurveSegments <= 0) {\n            return [];\n        }\n        const transformMatrix = this.getTransformMatrix();\n        let previousCurveSegmentsLength = 0;\n        for (let i = 0; i < numCurveSegments; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix);\n            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n            curveSegments[i] = curveSegment;\n            previousCurveSegmentsLength += curveSegment.length;\n        }\n        return curveSegments;\n    }\n    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {\n        return closed\n            ? controlPoints.length\n            : Math.max(0, controlPoints.length - 1);\n    }\n    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const uInt = Math.floor(u);\n        let curveSegmentIndex = uInt % numCurveSegments;\n        const t = u - uInt;\n        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n        if (curveSegmentIndexOutOfBounds) {\n            if (this.closed) {\n                curveSegmentIndex =\n                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n            }\n            else {\n                return;\n            }\n        }\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const tt = t * t;\n        const ttt = tt * t;\n        const tValues = vec4.fromValues(1, t, tt, ttt);\n        const qValues = vec4.transformMat4(vec4.create(), tValues, transformMatrix);\n        return [\n            vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n            vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n        ];\n    }\n    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const p1Index = curveSegmentIndex;\n        const p0Index = p1Index - 1;\n        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n        const p3Index = p2Index + 1;\n        const p1 = controlPoints[p1Index];\n        const p2 = controlPoints[p2Index];\n        let p0;\n        let p3;\n        if (p0Index >= 0) {\n            p0 = controlPoints[p0Index];\n        }\n        else {\n            p0 = closed\n                ? controlPoints[controlPoints.length - 1]\n                : math.point.mirror(p2, p1);\n        }\n        if (p3Index < controlPoints.length) {\n            p3 = controlPoints[p3Index];\n        }\n        else {\n            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n        }\n        return { p0, p1, p2, p3 };\n    }\n    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const numLineSegments = this.resolution + 1;\n        const inc = 1 / numLineSegments;\n        const minU = curveSegmentIndex;\n        let maxU = minU + 1;\n        if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n            maxU -= MAX_U_ERROR;\n        }\n        const lineSegments = [];\n        let startPoint;\n        let endPoint;\n        let previousLineSegmentsLength = 0;\n        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n            u = u > maxU ? maxU : u;\n            const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n            if (!i) {\n                startPoint = point;\n                continue;\n            }\n            endPoint = point;\n            const dx = endPoint[0] - startPoint[0];\n            const dy = endPoint[1] - startPoint[1];\n            const length = Math.sqrt(dx ** 2 + dy ** 2);\n            const aabb = {\n                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n            };\n            lineSegments.push({\n                points: {\n                    start: startPoint,\n                    end: endPoint,\n                },\n                aabb,\n                length,\n                previousLineSegmentsLength,\n            });\n            startPoint = endPoint;\n            previousLineSegmentsLength += length;\n        }\n        return lineSegments;\n    }\n    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);\n        let curveSegmentLength = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n            minX = Math.min(minX, lineSegAABB.minX);\n            minY = Math.min(minY, lineSegAABB.minY);\n            maxX = Math.max(maxX, lineSegAABB.maxX);\n            maxY = Math.max(maxY, lineSegAABB.maxY);\n            curveSegmentLength += lineSegLength;\n        });\n        return {\n            controlPoints: { p0, p1, p2, p3 },\n            aabb: { minX, minY, maxX, maxY },\n            length: curveSegmentLength,\n            previousCurveSegmentsLength: 0,\n            lineSegments,\n        };\n    }\n}\nexport { CubicSpline as default, CubicSpline };\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(mat4.create(), mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);\nclass BSpline extends CubicSpline {\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { BSpline as default, BSpline };\n","import { CubicSpline } from './CubicSpline';\nclass CardinalSpline extends CubicSpline {\n    constructor(props) {\n        super(props);\n        this._scale = props?.scale ?? 0.5;\n        this._fixedScale = props?.fixedScale ?? false;\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        if (this._fixedScale || this._scale === scale) {\n            return;\n        }\n        this._scale = scale;\n        this.invalidated = true;\n    }\n    get fixedScale() {\n        return this._fixedScale;\n    }\n    getTransformMatrix() {\n        const { scale: s } = this;\n        const s2 = 2 * s;\n        return [\n            0, 1, 0, 0,\n            -s, 0, s, 0,\n            s2, s - 3, 3 - s2, -s,\n            -s, 2 - s, s - 2, s\n        ];\n    }\n}\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass CatmullRomSpline extends CardinalSpline {\n    constructor() {\n        super({ scale: 0.5, fixedScale: true });\n    }\n}\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass LinearSpline extends CardinalSpline {\n    constructor() {\n        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n    }\n}\nexport { LinearSpline as default, LinearSpline };\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                mapper.setSampleDistance(originalSampleDistance * 2);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        const voiLutFunction = viewport.getProperties().VOILUTFunction;\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return ratio > 1 ? Math.round(ratio) : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiLutFunction = viewport.getProperties().VOILUTFunction;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","function getLuminanceFromRegion(imageData, x, y, width, height) {\n    const luminance = [];\n    let index = 0;\n    const pixelData = imageData.scalarData;\n    let spIndex, row, column;\n    if (imageData.color) {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n                const red = pixelData[spIndex];\n                const green = pixelData[spIndex + 1];\n                const blue = pixelData[spIndex + 2];\n                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            }\n        }\n    }\n    else {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = (row + y) * imageData.columns + (column + x);\n                luminance[index++] = pixelData[spIndex];\n            }\n        }\n    }\n    return luminance;\n}\nexport { getLuminanceFromRegion };\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n    const numPixels = pixelLuminance.length;\n    let min = globalMax;\n    let max = globalMin;\n    let sum = 0;\n    if (numPixels < 2) {\n        return {\n            min,\n            max,\n            mean: (globalMin + globalMax) / 2,\n        };\n    }\n    for (let index = 0; index < numPixels; index++) {\n        const spv = pixelLuminance[index];\n        min = Math.min(min, spv);\n        max = Math.max(max, spv);\n        sum += spv;\n    }\n    return {\n        min,\n        max,\n        mean: sum / numPixels,\n    };\n}\nexport { calculateMinMaxMean };\n","import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            if (imageData) {\n                spacing = imageData.spacing;\n            }\n            const { minZoomScale, maxZoomScale } = this.configuration;\n            const t = element.clientHeight * spacing[1] * 0.5;\n            const scale = t / parallelScaleToSet;\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                if (scale < minZoomScale) {\n                    cappedParallelScale = t / minZoomScale;\n                    thresholdExceeded = true;\n                }\n                else if (scale >= maxZoomScale) {\n                    cappedParallelScale = t / maxZoomScale;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nconst EPSILON = 1e-3;\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            handleRadius: 3,\n            enableHDPIHandles: false,\n            referenceLinesCenterGapRadius: 20,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            const toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            this.setToolCenter(toolCenter);\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                    triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                        toolGroupId: this.toolGroupId,\n                        toolCenter: this.toolCenter,\n                    });\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const centerGap = this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    let handleRadius = this.configuration.handleRadius *\n                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);\n                    let opacity = 1;\n                    if (this.configuration.mobile?.enabled) {\n                        handleRadius = this.configuration.mobile.handleRadius;\n                        opacity = this.configuration.mobile.opacity;\n                    }\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = this.editData.annotation.data.handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    setToolCenter(toolCenter, suppressEvents = false) {\n        this.toolCenter = toolCenter;\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        if (!suppressEvents) {\n            triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                toolCenter: this.toolCenter,\n            });\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { rotation: originalViewportRotation } = viewport.getViewPresentation();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                magnifyViewport.setViewPresentation({\n                    rotation: originalViewportRotation,\n                });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            const { element } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => actor.uid !== actor.referencedId;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.uid }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","export function pointToString(point, decimals = 5) {\n    return (parseFloat(point[0]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[1]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[2]).toFixed(decimals) +\n        ',');\n}\n","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates, ChangeTypes, } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n","import { vec2 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass LabelTool extends AnnotationTool {\n    static { this.toolName = 'Label'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotationUID } = annotation;\n            const point = annotation.data.handles.points[0];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const dist = vec2.distance(canvasCoords, annotationCanvasCoordinate);\n            if (dist < proximity) {\n                return true;\n            }\n            const svgLayer = element.querySelector('svg');\n            if (!svgLayer) {\n                return false;\n            }\n            const textGroup = svgLayer.querySelector(`g[data-annotation-uid=\"${annotationUID}\"]`);\n            if (!textGroup) {\n                return false;\n            }\n            const textGroupElement = textGroup;\n            const bbox = textGroupElement.getBBox();\n            const transform = textGroupElement.getAttribute('transform');\n            let translateX = 0;\n            let translateY = 0;\n            if (transform) {\n                const matches = transform.match(/translate\\(([-\\d.]+)\\s+([-\\d.]+)\\)/);\n                if (matches) {\n                    translateX = parseFloat(matches[1]);\n                    translateY = parseFloat(matches[2]);\n                }\n            }\n            const x = bbox.x + translateX;\n            const y = bbox.y + translateY;\n            const isNear = canvasCoords[0] >= x &&\n                canvasCoords[0] <= x + bbox.width &&\n                canvasCoords[1] >= y &&\n                canvasCoords[1] <= y + bbox.height;\n            return isNear;\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID: null,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n                offset: [0, 0, 0],\n            };\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((text) => {\n                if (!text) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                resetElementCursor(element);\n                annotation.data.text = text;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            let offset = [0, 0, 0];\n            if (currentPoints && currentPoints.world) {\n                const initialWorldPos = currentPoints.world;\n                const anchorWorldPos = annotation.data.handles.points[0];\n                offset = [\n                    anchorWorldPos[0] - initialWorldPos[0],\n                    anchorWorldPos[1] - initialWorldPos[1],\n                    anchorWorldPos[2] - initialWorldPos[2],\n                ];\n            }\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                offset,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, offset } = this.editData;\n            if (offset) {\n                annotation.data.handles.points[0] = [\n                    worldPos[0] + offset[0],\n                    worldPos[1] + offset[1],\n                    worldPos[2] + offset[2],\n                ];\n            }\n            else {\n                annotation.data.handles.points[0] = [...worldPos];\n            }\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const point = data.handles.points[0];\n                styleSpecifier.annotationUID = annotationUID;\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!data.text) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                const textBoxUID = '1';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [data.text], canvasCoordinates, {\n                    ...options,\n                    padding: 0,\n                });\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, position, text, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                text,\n                handles: {\n                    points: [position],\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle, interactionType) { }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nLabelTool.toolName = 'Label';\nexport default LabelTool;\n","import { Events, ChangeTypes } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    static { this.toolName = 'Length'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            if (this._isInsideVolume(index1, index2, dimensions)) {\n                this.isHandleOutsideImage = false;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n            }\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nexport default LengthTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    static { this.toolName = 'Height'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nexport default HeightTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    static { this.toolName = 'Probe'; }\n    static { this.probeDefaults = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            handleRadius: '6',\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps) {\n        super(toolProps, AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value === null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes.StatsUpdated);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + 6,\n                        canvasCoordinates[1] - 6,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        return vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes.StatsUpdated) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, changeType);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined || !index) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default ProbeTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    static { this.toolName = 'DragProbe'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value === null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    static { this.toolName = 'EllipticalROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    initialRotation: viewport.getRotation(),\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n            const [canvasPoint1, canvasPoint2] = canvasCorners;\n            const minorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n            };\n            const majorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const post2Index = transformWorldToIndex(imageData, worldPos2);\n                post2Index[0] = Math.floor(post2Index[0]);\n                post2Index[1] = Math.floor(post2Index[1]);\n                post2Index[2] = Math.floor(post2Index[2]);\n                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);\n                const iMin = Math.min(pos1Index[0], post2Index[0]);\n                const iMax = Math.max(pos1Index[0], post2Index[0]);\n                const jMin = Math.min(pos1Index[1], post2Index[1]);\n                const jMax = Math.max(pos1Index[1], post2Index[1]);\n                const kMin = Math.min(pos1Index[2], post2Index[2]);\n                const kMax = Math.max(pos1Index[2], post2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = [\n                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                ];\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                const handles = [pos1Index, post2Index];\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n                    scale /\n                    scale;\n                const pixelUnitsOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                    returnPoints: this.configuration.storePointData,\n                });\n                const stats = this.configuration.statsCalculator.getStatistics();\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    mean: stats.mean?.value,\n                    max: stats.max?.value,\n                    stdDev: stats.stdDev?.value,\n                    statsArray: stats.array,\n                    pointsInShape,\n                    isEmptyArea,\n                    areaUnit,\n                    modalityUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    _pointInEllipseCanvas(ellipse, location) {\n        const xRadius = ellipse.width / 2;\n        const yRadius = ellipse.height / 2;\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n        const normalized = [location[0] - center[0], location[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (max) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default EllipticalROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    static { this.toolName = 'CircleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const radius = getCanvasCircleRadius(canvasCoordinates);\n            const radiusPoint = getCanvasCircleRadius([\n                canvasCoordinates[0],\n                canvasCoords,\n            ]);\n            if (Math.abs(radiusPoint - radius) < proximity / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            data.handles.points = [\n                data.handles.points[0],\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0) {\n                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n                const canvasCenter = currentCanvasPoints;\n                const canvasEnd = [\n                    canvasCoordinates[1][0] + dXCanvas,\n                    canvasCoordinates[1][1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasCenter);\n                points[1] = canvasToWorld(canvasEnd);\n            }\n            else {\n                points[1] = canvasToWorld(currentCanvasPoints);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { element } = viewport;\n            const wasInvalidated = annotation.invalidated;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                        boundsIJK,\n                        imageData,\n                        returnPoints: this.configuration.storePointData,\n                    });\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        pointsInShape,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            if (wasInvalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (radius) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (max) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default CircleROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    static { this.toolName = 'ETDRSGrid'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nexport default ETDRSGridTool;\n","import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'SplineROI'; }\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length) {\n                this.createMemo(element, annotation, {\n                    newAnnotation: data.handles.points.length === 1,\n                });\n            }\n            if (data.handles.points.length >= 3) {\n                this.createMemo(element, annotation);\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints > 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                color: '#9EA0CA',\n                lineDash: lineDash,\n                lineWidth: 1,\n            });\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nexport default SplineROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nclass SplineContourSegmentationTool extends SplineROITool {\n    static { this.toolName = 'SplineContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nexport default SplineContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'LivewireContour'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                cancelInProgress: {\n                    method: 'cancelInProgress',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            this.doneEditMemo();\n            this.createMemo(element, annotation, {\n                newAnnotation: newAnnotation && controlPoints.length === 1,\n            });\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    cancelInProgress(element, config, evt) {\n        if (!this.editData) {\n            this.undo();\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId]?.areaUnit === null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    static { this.toolName = 'LivewireContourSegmentationTool'; }\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nexport default LivewireContourSegmentationTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { setAnnotationLabel } from '../../utilities';\nclass ArrowAnnotateTool extends AnnotationTool {\n    static { this.toolName = 'ArrowAnnotate'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n            arrowHeadStyle: 'legacy',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const { arrowFirst } = this.configuration;\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        arrowFirst,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((text) => {\n                    if (!text) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.text = text;\n                    triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n                    triggerAnnotationCompleted(annotation);\n                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });\n                    setAnnotationLabel(annotation, element, text);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else if (!movingTextBox) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, text } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                renderStatus = true;\n                if (!text) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, points, text, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                text: text || '',\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const enabledElement = getEnabledElement(element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default ArrowAnnotateTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass AngleTool extends AnnotationTool {\n    static { this.toolName = 'Angle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nexport default AngleTool;\n","import { vec3 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass CobbAngleTool extends AnnotationTool {\n    static { this.toolName = 'CobbAngle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nexport default CobbAngleTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { lineSegment } from '../../utilities/math';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundDirectionalTool'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nexport default UltrasoundDirectionalTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg, drawHandles as drawHandlesSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    static { this.toolName = 'KeyImage'; }\n    static { this.dataSeries = {\n        data: {\n            seriesLevel: true,\n        },\n    }; }\n    static { this.dataPoint = {\n        data: {\n            isPoint: true,\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n            handleRadius: '6',\n            seriesLevel: false,\n            isPoint: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const worldPos = currentPoints.world;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                    seriesLevel: this.configuration.seriesLevel,\n                    isPoint: this.configuration.isPoint,\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((text) => {\n                if (!text) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.text = text;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            if (!data?.isPoint) {\n                return false;\n            }\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.createMemo(element, annotation);\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            this.doneEditMemo();\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                const arrowUID = '1';\n                if (data?.isPoint) {\n                    const point = data.handles.points[0];\n                    const canvasCoordinates = viewport.worldToCanvas(point);\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {\n                        color,\n                        lineWidth,\n                        handleRadius: this.configuration.handleRadius,\n                    });\n                }\n                else if (canvasPosition?.length) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {\n        annotation.data.isPoint = isPoint;\n        triggerAnnotationModified(annotation, element);\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    cancel(element) {\n        if (this.isDrawing) {\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default KeyImageTool;\n","import { BaseTool, AnnotationTool } from './base';\nimport { getAnnotations, getAnnotation, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);\n            if (!interactableAnnotations) {\n                continue;\n            }\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            AnnotationTool.createAnnotationMemo(element, annotation, {\n                deleting: true,\n            });\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nclass RegionSegmentTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegment'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positiveSeedVariance: 0.5,\n            negativeSeedVariance: 0.9,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.growCutData.circleBorderPoint = currentWorldPoint;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        await super.preMouseDownCallback(evt);\n        Object.assign(this.growCutData, {\n            circleCenterPoint: worldPoint,\n            circleBorderPoint: worldPoint,\n        });\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));\n        const sphereInfo = {\n            center: circleCenterPoint,\n            radius: worldCircleRadius,\n        };\n        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;\n        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);\n        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);\n        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);\n        const circleRadius = vec2.len(vecCenterToBorder);\n        if (csUtils.isEqual(circleRadius, 0)) {\n            return;\n        }\n        const annotationUID = 'growcut';\n        const circleUID = '0';\n        const { color } = this.getSegmentStyle({\n            segmentationId: segmentationData.segmentationId,\n            segmentIndex: segmentationData.segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {\n            color,\n        });\n    }\n}\nexport default RegionSegmentTool;\n","import { cache, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nimport { calculateGrowCutSeeds } from '../../utilities/segmentation/growCut/runOneClickGrowCut';\nclass RegionSegmentPlusTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegmentPlus'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: false,\n            positiveSeedVariance: 0.4,\n            negativeSeedVariance: 0.9,\n            subVolumePaddingPercentage: 0.1,\n            islandRemoval: {\n                enabled: false,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseTimer = null;\n        this.allowedToProceed = false;\n    }\n    mouseMoveCallback(evt) {\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const { world: worldPoint } = currentPoints;\n        element.style.cursor = 'default';\n        if (this.mouseTimer !== null) {\n            window.clearTimeout(this.mouseTimer);\n            this.mouseTimer = null;\n        }\n        this.mouseTimer = window.setTimeout(() => {\n            this.onMouseStable(evt, worldPoint, element);\n        }, this.configuration.mouseStabilityDelay || 500);\n    }\n    async onMouseStable(evt, worldPoint, element) {\n        await super.preMouseDownCallback(evt);\n        const refVolume = cache.getVolume(this.growCutData.segmentation.referencedVolumeId);\n        const seeds = calculateGrowCutSeeds(refVolume, worldPoint, {});\n        const { positiveSeedIndices, negativeSeedIndices } = seeds;\n        let cursor;\n        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||\n            negativeSeedIndices.size < 30) {\n            cursor = 'not-allowed';\n            this.allowedToProceed = false;\n        }\n        else {\n            cursor = 'copy';\n            this.allowedToProceed = true;\n        }\n        const enabledElement = getEnabledElement(element);\n        if (element) {\n            element.style.cursor = cursor;\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== cursor) {\n                    element.style.cursor = cursor;\n                }\n            });\n        }\n        if (this.allowedToProceed) {\n            this.seeds = seeds;\n        }\n        if (enabledElement && enabledElement.viewport) {\n            enabledElement.viewport.render();\n        }\n    }\n    async preMouseDownCallback(evt) {\n        if (!this.allowedToProceed) {\n            return false;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        if (enabledElement) {\n            element.style.cursor = 'wait';\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== 'wait') {\n                    element.style.cursor = 'wait';\n                }\n            });\n        }\n        const { world: worldPoint } = currentPoints;\n        await super.preMouseDownCallback(evt);\n        this.growCutData = csUtils.deepMerge(this.growCutData, {\n            worldPoint,\n            islandRemoval: {\n                worldIslandPoints: [worldPoint],\n            },\n        });\n        this.growCutData.worldPoint = worldPoint;\n        this.growCutData.islandRemoval = {\n            worldIslandPoints: [worldPoint],\n        };\n        await this.runGrowCut();\n        if (element) {\n            element.style.cursor = 'default';\n        }\n        return true;\n    }\n    getRemoveIslandData(growCutData) {\n        const { worldPoint } = growCutData;\n        return {\n            worldIslandPoints: [worldPoint],\n        };\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;\n        const { subVolumePaddingPercentage } = this.configuration;\n        const mergedOptions = {\n            ...options,\n            subVolumePaddingPercentage,\n            seeds: this.seeds,\n        };\n        return growCut.runOneClickGrowCut({\n            referencedVolumeId,\n            worldPosition: worldPoint,\n            options: mergedOptions,\n        });\n    }\n}\nexport default RegionSegmentPlusTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nconst ISLAND_PIXEL_RANGE = [1000, 1900];\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass WholeBodySegmentTool extends GrowCutBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positivePixelRange: POSITIVE_PIXEL_RANGE,\n            negativePixelRange: NEGATIVE_PIXEL_RANGE,\n            islandRemoval: {\n                enabled: true,\n                islandPixelRange: ISLAND_PIXEL_RANGE,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);\n            this.growCutData.horizontalLines[1] = linePoints;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            await this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);\n        await super.preMouseDownCallback(evt);\n        this.growCutData.horizontalLines = [linePoints, linePoints];\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { segmentation: segmentationData, horizontalLines } = this.growCutData;\n        if (horizontalLines.length !== 2) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentationId, segmentIndex } = segmentationData;\n        const [line1, line2] = horizontalLines;\n        const [worldLine1P1, worldLine1P2] = line1;\n        const [worldLine2P1, worldLine2P2] = line2;\n        const canvasPoints = [\n            worldLine1P1,\n            worldLine1P2,\n            worldLine2P2,\n            worldLine2P1,\n        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));\n        const annotationUID = 'growCutRect';\n        const squareGroupUID = '0';\n        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({\n            segmentationId,\n            segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawPolylineSvg(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {\n            color,\n            fillColor,\n            fillOpacity,\n            lineWidth,\n            lineDash,\n            closePath: true,\n        });\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const [line1, line2] = horizontalLines;\n        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);\n        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);\n        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);\n        const boundingBoxInfo = {\n            boundingBox: {\n                ijkTopLeft,\n                ijkBottomRight,\n            },\n        };\n        const config = this.configuration;\n        const options = {\n            positiveSeedValue: segmentIndex,\n            negativeSeedValue: 255,\n            negativePixelRange: config.negativePixelRange,\n            positivePixelRange: config.positivePixelRange,\n        };\n        return growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);\n    }\n    getRemoveIslandData() {\n        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const labelmapVolume = cache.getVolume(labelmapVolumeId);\n        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();\n        const { islandPixelRange } = this.configuration.islandRemoval;\n        const islandPointIndexes = [];\n        for (let i = 0, len = labelmapData.length; i < len; i++) {\n            if (labelmapData[i] !== segmentIndex) {\n                continue;\n            }\n            const pixelValue = referencedVolumeData[i];\n            if (pixelValue >= islandPixelRange[0] &&\n                pixelValue <= islandPixelRange[1]) {\n                islandPointIndexes.push(i);\n            }\n        }\n        return {\n            islandPointIndexes,\n        };\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);\n        const axis = vecDirection.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        if (axis === -1) {\n            throw new Error('Non-orthogonal direction vector');\n        }\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {\n        const { viewPlaneNormal } = viewport.getCamera();\n        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);\n    }\n    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {\n        const cuboidPoints = [];\n        const volume = this._getViewportVolume(viewport);\n        worldSquarePoints.forEach((worldSquarePoint) => {\n            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);\n            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));\n            cuboidPoints.push(...worldEdgePoints);\n        });\n        return cuboidPoints;\n    }\n    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {\n        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);\n        const topLeft = [...worldCuboidPoints[0]];\n        const bottomRight = [...worldCuboidPoints[0]];\n        worldCuboidPoints.forEach((worldPoint) => {\n            vec3.min(topLeft, topLeft, worldPoint);\n            vec3.max(bottomRight, bottomRight, worldPoint);\n        });\n        return { topLeft, bottomRight };\n    }\n    _getViewportVolume(viewport) {\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            throw new Error('Viewport is not a BaseVolumeViewport');\n        }\n        const volumeId = viewport.getAllVolumeIds()[0];\n        return cache.getVolume(volumeId);\n    }\n    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);\n        const { viewUp, viewPlaneNormal } = viewport.getCamera();\n        const vecRow = vec3.cross(vec3.create(), viewUp, viewPlaneNormal);\n        const axis = vecRow.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);\n        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);\n        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);\n        return [worldPoint1, worldPoint2];\n    }\n}\nWholeBodySegmentTool.toolName = 'WholeBodySegment';\nexport default WholeBodySegmentTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass RectangleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass CircleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass SphereScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const editData = this.getEditData({\n                viewport,\n                representationData,\n                segmentsLocked,\n                segmentationId,\n            });\n            this.editData = {\n                ...this.editData,\n                ...editData,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: false,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            if (this.configuration.calculatePointsInsideVolume) {\n                this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox == true &&\n                    this.configuration.calculatePointsInsideVolume == true) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, 100, { trailing: true });\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const handlesToStart = csUtils.deepClone(points);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n            handlesToStart[0][2] = startCoordinate;\n            handlesToStart[1][2] = startCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n            handlesToStart[0][0] = startCoordinate;\n            handlesToStart[1][0] = startCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n            handlesToStart[0][1] = startCoordinate;\n            handlesToStart[1][1] = startCoordinate;\n        }\n        const distance = vec3.distance(startWorld, endWorld);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(handlesToStart.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n        const pos1 = viewport.canvasToWorld(topLeftCanvas);\n        const pos2 = viewport.canvasToWorld(bottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, pos1, pos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let index;\n            let voxelManager;\n            this.doneEditMemo();\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { flooded: boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport BidirectionalTool from '../annotation/BidirectionalTool';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nclass SegmentBidirectionalTool extends BidirectionalTool {\n    static { this.toolName = 'SegmentBidirectional'; }\n    constructor(toolProps = {}) {\n        super(toolProps);\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportId = viewport.id;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { segmentIndex, segmentationId } = annotation.metadata;\n                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const colorArray = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                options.color = color;\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const existingAnnotations = getAllAnnotations();\n        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');\n        const existingAnnotation = toolAnnotations.find((annotation) => {\n            const { metadata } = annotation;\n            if (metadata.segmentIndex === options?.segmentIndex &&\n                metadata.segmentationId === options?.segmentationId) {\n                return true;\n            }\n            return false;\n        });\n        if (existingAnnotation) {\n            removeAnnotation(existingAnnotation.annotationUID);\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                segmentIndex: options?.segmentIndex,\n                segmentationId: options?.segmentationId,\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n}\nexport default SegmentBidirectionalTool;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    static { this.toolName = 'VideoRedaction'; }\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportUID,\n                    renderingEngineUID,\n                    sceneUID: sceneUID,\n                    changeType: ChangeTypes.StatsUpdated,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.metadata.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nexport default VideoRedactionTool;\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst Dir = {\n  Forward: 1,\n  Backward: -1\n};\nconst visited = new Set();\nfunction vtkContourLoopExtraction(publicAPI, model) {\n  publicAPI.requestData = (inData, outData) => {\n    const [input] = inData;\n    if (!outData[0]) {\n      outData[0] = vtkPolyData.newInstance();\n    }\n    const [output] = outData;\n    publicAPI.extractContours(input, output);\n    output.modified();\n  };\n  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {\n    let lineId = startLineId;\n    let lastPtId = startPtId;\n    let terminated = false;\n    let numInserted = 0;\n    while (!terminated) {\n      const {\n        cellPointIds\n      } = pd.getCellPoints(lineId);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];\n      numInserted++;\n\n      // parametric point value\n      const t = dir * numInserted;\n      loopPoints.push({\n        t,\n        ptId: lastPtId\n      });\n      const lineCell = pd.getPointCells(lastPtId);\n      if (lineCell.length !== 2 || lastPtId === startPtId) {\n        // looped\n        return lastPtId;\n      }\n      if (lineCell.length === 2) {\n        // continue along loop\n        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];\n        visited.add(lineId);\n      } else {\n        // empty or invalid cell\n        terminated = true;\n      }\n    }\n    return lastPtId;\n  };\n  publicAPI.extractContours = (input, output) => {\n    const loops = [];\n    visited.clear();\n    const inLines = input.getLines();\n    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));\n\n    // TODO skip if cached input mtime hasn't changed.\n    // iterate over input lines\n    for (let li = 0; li < inLines.getNumberOfCells(); li++) {\n      if (visited.has(li)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        cellPointIds\n      } = input.getCellPoints(li);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      visited.add(li);\n      const startPtId = cellPointIds[0];\n      const loopPoints = [];\n      loopPoints.push({\n        t: 0,\n        ptId: startPtId\n      });\n      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);\n      if (startPtId !== endPtId) {\n        // didn't find a loop. Go other direction to see where we end up\n        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);\n        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);\n        // make closed contour\n        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {\n          loopPoints.push({\n            ...loopPoints[loopPoints.length - 1]\n          });\n        }\n      }\n      if (loopPoints.length) {\n        loops.push(loopPoints);\n      }\n    }\n\n    // clear output lines\n    const outLines = output.getLines();\n    outLines.resize(0);\n    loops.forEach(loop => {\n      outLines.insertNextCell(loop.map(pt => pt.ptId));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkContourLoopExtraction(publicAPI);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourLoopExtraction');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\nexport { index as default, extend, newInstance };\n","import { expose } from 'comlink';\nimport { utilities } from '@cornerstonejs/core';\nimport { utilities as ToolsUtilities } from '@cornerstonejs/tools';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\nconst { math: { polyline: { containsPoint, getAABB, projectTo2D }, }, geometricSurfaceUtils: { checkStandardBasis, rotatePoints }, boundingBox: { getBoundingBoxAroundShapeWorld }, planar: { isPlaneIntersectingAABB }, } = ToolsUtilities;\nasync function peerImport(moduleId) {\n    try {\n        if (moduleId === '@icr/polyseg-wasm') {\n            return import('@icr/polyseg-wasm');\n        }\n    }\n    catch (error) {\n        console.warn('Error importing module:', error);\n        return null;\n    }\n}\nconst polySegConverters = {\n    polySeg: null,\n    polySegInitializing: false,\n    polySegInitializingPromise: null,\n    async initializePolySeg(progressCallback) {\n        let ICRPolySeg;\n        try {\n            ICRPolySeg = (await peerImport('@icr/polyseg-wasm')).default;\n        }\n        catch (error) {\n            console.error(error);\n            console.debug(\"Warning: '@icr/polyseg-wasm' module not found. Please install it separately.\");\n            return;\n        }\n        if (this.polySegInitializing) {\n            await this.polySegInitializingPromise;\n            return;\n        }\n        if (this.polySeg?.instance) {\n            return;\n        }\n        this.polySegInitializing = true;\n        this.polySegInitializingPromise = new Promise((resolve) => {\n            this.polySeg = new ICRPolySeg();\n            this.polySeg\n                .initialize({\n                updateProgress: progressCallback,\n            })\n                .then(() => {\n                this.polySegInitializing = false;\n                resolve();\n            });\n        });\n        await this.polySegInitializingPromise;\n    },\n    async convertContourToSurface(args, ...callbacks) {\n        const { polylines, numPointsArray } = args;\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = await this.polySeg.instance.convertContourRoiToSurface(polylines, numPointsArray);\n        return results;\n    },\n    async convertLabelmapToSurface(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertLabelmapToSurface(args.scalarData, args.dimensions, args.spacing, args.direction, args.origin, [args.segmentIndex]);\n        const rotationInfo = checkStandardBasis(args.direction);\n        if (!rotationInfo.isStandard) {\n            const rotatedPoints = rotatePoints(rotationInfo.rotationMatrix, args.origin, results.points);\n            results.points = [...rotatedPoints];\n        }\n        return results;\n    },\n    async convertContourToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentIndices, scalarData, annotationUIDsInSegmentMap, dimensions, origin, direction, spacing, } = args;\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(dimensions);\n        imageData.setOrigin(origin);\n        imageData.setDirection(direction);\n        imageData.setSpacing(spacing);\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: scalarData,\n        });\n        imageData.getPointData().setScalars(scalarArray);\n        imageData.modified();\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                    dimensions,\n                    scalarData,\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        return segmentationVoxelManager.scalarData;\n    },\n    async convertContourToStackLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } = args;\n        const segmentationVoxelManagers = new Map();\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { dimensions, scalarData, direction, spacing, origin } = segmentationInfo;\n            const manager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData,\n            });\n            const imageData = vtkImageData.newInstance();\n            imageData.setDimensions(dimensions);\n            imageData.setOrigin(origin);\n            imageData.setDirection(direction);\n            imageData.setSpacing(spacing);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: scalarData,\n            });\n            imageData.getPointData().setScalars(scalarArray);\n            imageData.modified();\n            segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\n        });\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline, referencedImageId } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const { manager: segmentationVoxelManager, imageData } = segmentationVoxelManagers.get(referencedImageId);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createImageVoxelManager({\n                    width: imageData.getDimensions()[0],\n                    height: imageData.getDimensions()[1],\n                    scalarData: imageData.getPointData().getScalars().getData(),\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { manager: segmentationVoxelManager } = segmentationVoxelManagers.get(referencedImageId);\n            segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\n        });\n        return segmentationsInfo;\n    },\n    async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertSurfaceToLabelmap(args.points, args.polys, args.dimensions, args.spacing, args.direction, args.origin);\n        return results;\n    },\n    async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentsInfo } = args;\n        const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\n            const { points, polys } = segmentsInfo.get(segmentIndex);\n            const result = this.polySeg.instance.convertSurfaceToLabelmap(points, polys, args.dimensions, args.spacing, args.direction, args.origin);\n            return {\n                ...result,\n                segmentIndex,\n            };\n        });\n        const results = await Promise.all(promises);\n        const targetImageData = vtkImageData.newInstance();\n        targetImageData.setDimensions(args.dimensions);\n        targetImageData.setOrigin(args.origin);\n        targetImageData.setSpacing(args.spacing);\n        targetImageData.setDirection(args.direction);\n        const totalSize = args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: new Uint8Array(totalSize),\n        });\n        targetImageData.getPointData().setScalars(scalarArray);\n        targetImageData.modified();\n        const { dimensions } = args;\n        const scalarData = targetImageData.getPointData().getScalars().getData();\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const outputVolumesInfo = results.map((result) => {\n            const { data, dimensions, direction, origin, spacing } = result;\n            const volume = vtkImageData.newInstance();\n            volume.setDimensions(dimensions);\n            volume.setOrigin(origin);\n            volume.setSpacing(spacing);\n            volume.setDirection(direction);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: data,\n            });\n            volume.getPointData().setScalars(scalarArray);\n            volume.modified();\n            const voxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData: data,\n            });\n            const extent = volume.getExtent();\n            return {\n                volume,\n                voxelManager,\n                extent,\n                scalarData: data,\n                segmentIndex: result.segmentIndex,\n            };\n        });\n        const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions: targetImageData.getDimensions(),\n            scalarData: targetImageData.getPointData().getScalars().getData(),\n        });\n        voxels.forEach(({ pointIJK, pointLPS }) => {\n            try {\n                for (const volumeInfo of outputVolumesInfo) {\n                    const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\n                    const index = volume.worldToIndex(pointLPS);\n                    if (index[0] < extent[0] ||\n                        index[0] > extent[1] ||\n                        index[1] < extent[2] ||\n                        index[1] > extent[3] ||\n                        index[2] < extent[4] ||\n                        index[2] > extent[5]) {\n                        continue;\n                    }\n                    const roundedIndex = index.map(Math.round);\n                    const value = voxelManager.getAtIJK(...roundedIndex);\n                    if (value > 0) {\n                        segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\n                        break;\n                    }\n                }\n            }\n            catch (error) {\n            }\n        }, { imageData: targetImageData });\n        return segmentationVoxelManager.scalarData;\n    },\n    getSurfacesAABBs({ surfacesInfo }) {\n        const aabbs = new Map();\n        for (const { points, id } of surfacesInfo) {\n            const aabb = getAABB(points, { numDimensions: 3 });\n            aabbs.set(id, aabb);\n        }\n        return aabbs;\n    },\n    cutSurfacesIntoPlanes({ planesInfo, surfacesInfo, surfacesAABB = new Map() }, progressCallback, updateCacheCallback) {\n        const numberOfPlanes = planesInfo.length;\n        const cutter = vtkCutter.newInstance();\n        const plane1 = vtkPlane.newInstance();\n        cutter.setCutFunction(plane1);\n        const surfacePolyData = vtkPolyData.newInstance();\n        try {\n            for (const [index, planeInfo] of planesInfo.entries()) {\n                const { sliceIndex, planes } = planeInfo;\n                const polyDataResults = new Map();\n                for (const polyDataInfo of surfacesInfo) {\n                    const { points, polys, id, segmentIndex } = polyDataInfo;\n                    const aabb3 = surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\n                    if (!surfacesAABB.has(id)) {\n                        surfacesAABB.set(id, aabb3);\n                    }\n                    const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\n                    const { origin, normal } = planes[0];\n                    if (!isPlaneIntersectingAABB(origin, normal, minX, minY, minZ, maxX, maxY, maxZ)) {\n                        continue;\n                    }\n                    surfacePolyData.getPoints().setData(points, 3);\n                    surfacePolyData.getPolys().setData(polys, 3);\n                    surfacePolyData.modified();\n                    cutter.setInputData(surfacePolyData);\n                    plane1.setOrigin(origin);\n                    plane1.setNormal(normal);\n                    try {\n                        cutter.update();\n                    }\n                    catch (e) {\n                        console.warn('Error during clipping', e);\n                        continue;\n                    }\n                    const polyData = cutter.getOutputData();\n                    const cutterOutput = polyData;\n                    cutterOutput.buildLinks();\n                    const loopExtraction = vtkContourLoopExtraction.newInstance();\n                    loopExtraction.setInputData(cutterOutput);\n                    const loopOutput = loopExtraction.getOutputData();\n                    if (polyData) {\n                        polyDataResults.set(segmentIndex, {\n                            points: loopOutput.getPoints().getData(),\n                            lines: loopOutput.getLines().getData(),\n                            numberOfCells: loopOutput.getLines().getNumberOfCells(),\n                            segmentIndex,\n                        });\n                    }\n                }\n                progressCallback({ progress: (index + 1) / numberOfPlanes });\n                updateCacheCallback({ sliceIndex, polyDataResults });\n            }\n        }\n        catch (e) {\n            console.warn('Error during processing', e);\n        }\n        finally {\n            surfacesInfo = null;\n            plane1.delete();\n        }\n    },\n};\nexpose(polySegConverters);\n","const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n","import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import drawLine from './drawLine';\nconst svgns = 'http://www.w3.org/2000/svg';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;\n    if (!viaMarker) {\n        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n        return;\n    }\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const markerBaseId = `arrow-${annotationUID}`;\n    const markerFullId = `${markerBaseId}-${layerId}`;\n    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');\n    let arrowMarker = defs.querySelector(`#${markerFullId}`);\n    if (!arrowMarker) {\n        arrowMarker = document.createElementNS(svgns, 'marker');\n        arrowMarker.setAttribute('id', markerFullId);\n        arrowMarker.setAttribute('viewBox', '0 0 10 10');\n        arrowMarker.setAttribute('refX', '8');\n        arrowMarker.setAttribute('refY', '5');\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        arrowMarker.setAttribute('orient', 'auto');\n        const arrowPath = document.createElementNS(svgns, 'path');\n        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        arrowPath.setAttribute('fill', color);\n        arrowMarker.appendChild(arrowPath);\n        defs.appendChild(arrowMarker);\n    }\n    else {\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        const arrowPath = arrowMarker.querySelector('path');\n        if (arrowPath) {\n            arrowPath.setAttribute('fill', color);\n        }\n    }\n    options.markerEndId = markerFullId;\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n}\nfunction legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport * as math from '../../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport { addAnnotation, removeAnnotation, getAllAnnotations, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { addContourSegmentationAnnotation, areSameSegment, isContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../../utilities/contourSegmentation';\nimport { getToolGroupForViewport } from '../../../store/ToolGroupManager';\nimport { hasTool, hasToolByName } from '../../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default async function contourSegmentationCompletedListener(evt) {\n    const sourceAnnotation = evt.detail\n        .annotation;\n    if (!isContourSegmentationAnnotation(sourceAnnotation)) {\n        return;\n    }\n    const viewport = getViewport(sourceAnnotation);\n    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);\n    if (!contourSegmentationAnnotations.length) {\n        return;\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);\n    if (!targetAnnotationInfo) {\n        return;\n    }\n    const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;\n    if (isContourHole) {\n        const { contourHoleProcessingEnabled = false } = evt.detail;\n        if (!contourHoleProcessingEnabled) {\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {\n    const toolName = 'PlanarFreehandContourSegmentationTool';\n    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n    let errorMessage;\n    if (!toolGroup.hasTool(toolName)) {\n        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n    }\n    else if (!toolGroup.getToolOptions(toolName)) {\n        errorMessage = `Tool ${toolName} must be in active/passive state`;\n    }\n    if (errorMessage && !silent) {\n        console.warn(errorMessage);\n    }\n    return !errorMessage;\n}\nfunction getViewport(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));\n    return viewportWithToolRegistered ?? viewports[0];\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nfunction getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {\n    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n    const allAnnotations = getAllAnnotations();\n    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&\n        targetAnnotation.annotationUID !== sourceAnnotationUID &&\n        isContourSegmentationAnnotation(targetAnnotation) &&\n        areSameSegment(targetAnnotation, sourceAnnotation) &&\n        viewport.isReferenceViewable(targetAnnotation.metadata));\n}\nfunction findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n        const targetAnnotation = contourSegmentationAnnotations[i];\n        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n        const targetAABB = math.polyline.getAABB(targetPolyline);\n        const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n        const lineSegmentsIntersect = aabbIntersect &&\n            math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n        const isContourHole = aabbIntersect &&\n            !lineSegmentsIntersect &&\n            math.polyline.containsPoints(targetPolyline, sourcePolyline);\n        if (lineSegmentsIntersect || isContourHole) {\n            return { targetAnnotation, targetPolyline, isContourHole };\n        }\n    }\n}\nexport function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;\n    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolyline,\n        closed: holeContour.closed,\n    }, viewport);\n    const { element } = viewport;\n    const updatedToolNames = new Set([\n        DEFAULT_CONTOUR_SEG_TOOL_NAME,\n        targetAnnotation.metadata.toolName,\n        holeAnnotation.metadata.toolName,\n    ]);\n    for (const toolName of updatedToolNames.values()) {\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n}\nfunction getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);\n        return { annotation: holeAnnotation, polyline };\n    });\n}\nfunction combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);\n        return;\n    }\n    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\n        return;\n    }\n    const sourceStartPoint = sourcePolyline[0];\n    const mergePolylines = math.polyline.containsPoint(targetPolyline, sourceStartPoint);\n    const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n    const unassignedContourHolesSet = new Set(contourHolesData);\n    const reassignedContourHolesMap = new Map();\n    const assignHoleToPolyline = (parentPolyline, holeData) => {\n        let holes = reassignedContourHolesMap.get(parentPolyline);\n        if (!holes) {\n            holes = [];\n            reassignedContourHolesMap.set(parentPolyline, holes);\n        }\n        holes.push(holeData);\n        unassignedContourHolesSet.delete(holeData);\n    };\n    const newPolylines = [];\n    if (mergePolylines) {\n        const mergedPolyline = math.polyline.mergePolylines(targetPolyline, sourcePolyline);\n        newPolylines.push(mergedPolyline);\n        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));\n    }\n    else {\n        const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n        subtractedPolylines.forEach((newPolyline) => {\n            newPolylines.push(newPolyline);\n            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n                const containsHole = math.polyline.containsPoints(newPolyline, holeData.polyline);\n                if (containsHole) {\n                    assignHoleToPolyline(newPolyline, holeData);\n                    unassignedContourHolesSet.delete(holeData);\n                }\n            });\n        });\n    }\n    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));\n    const { element } = viewport;\n    const enabledElement = getEnabledElement(element);\n    const { metadata, data } = targetAnnotation;\n    const { handles, segmentation } = data;\n    const { textBox } = handles;\n    removeAnnotation(sourceAnnotation.annotationUID);\n    removeAnnotation(targetAnnotation.annotationUID);\n    for (let i = 0; i < newPolylines.length; i++) {\n        const polyline = newPolylines[i];\n        const startPoint = viewport.canvasToWorld(polyline[0]);\n        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\n        const newAnnotation = {\n            metadata: {\n                ...metadata,\n                toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n                originalToolName: metadata.originalToolName || metadata.toolName,\n            },\n            data: {\n                cachedStats: {},\n                handles: {\n                    points: [startPoint, endPoint],\n                    textBox: textBox ? { ...textBox } : undefined,\n                },\n                contour: {\n                    polyline: [],\n                    closed: true,\n                },\n                spline: targetAnnotation.data.spline,\n                segmentation: {\n                    ...segmentation,\n                },\n            },\n            annotationUID: csUtils.uuidv4(),\n            highlighted: true,\n            invalidated: true,\n            isLocked: false,\n            isVisible: undefined,\n            interpolationUID: targetAnnotation.interpolationUID,\n            interpolationCompleted: targetAnnotation.interpolationCompleted,\n        };\n        updateContourPolyline(newAnnotation, {\n            points: polyline,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        reassignedContourHolesMap\n            .get(polyline)\n            ?.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));\n    }\n    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\n}\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const updatedTtoolNames = new Set([\n        DEFAULT_CONTOUR_SEG_TOOL_NAME,\n        targetAnnotation.metadata.toolName,\n        sourceAnnotation.metadata.toolName,\n    ]);\n    for (const toolName of updatedTtoolNames.values()) {\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntries } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    if (!element) {\n        return;\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .flatMap((representation) => {\n        return getLabelmapActorEntries(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, representation.segmentationId);\n            return derivedImageIds?.includes(actor.referencedId);\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n        if (!derivedImageIds) {\n            return;\n        }\n        const updateSegmentationActor = (derivedImageId) => {\n            const derivedImage = cache.getImage(derivedImageId);\n            if (!derivedImage) {\n                console.warn('No derived image found in the cache for segmentation representation', representation);\n                return;\n            }\n            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n            if (!segmentationActorInput) {\n                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n                const currentImage = cache.getImage(currentImageId) ||\n                    {\n                        imageId: currentImageId,\n                    };\n                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n                const originToUse = currentOrigin;\n                const constructor = derivedImage.voxelManager.getConstructor();\n                const newPixelData = derivedImage.voxelManager.getScalarData();\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: new constructor(newPixelData),\n                });\n                const imageData = vtkImageData.newInstance();\n                imageData.setDimensions(dimensions[0], dimensions[1], 1);\n                imageData.setSpacing(spacing);\n                imageData.setDirection(direction);\n                imageData.setOrigin(originToUse);\n                imageData.getPointData().setScalars(scalarArray);\n                imageData.modified();\n                viewport.addImages([\n                    {\n                        imageId: derivedImageId,\n                        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,\n                        callback: ({ imageActor }) => {\n                            imageActor.getMapper().setInputData(imageData);\n                        },\n                    },\n                ]);\n                triggerSegmentationRender(viewportId);\n                return;\n            }\n            else {\n                const segmentationImageData = segmentationActorInput.actor\n                    .getMapper()\n                    .getInputData();\n                if (segmentationImageData.setDerivedImage) {\n                    segmentationImageData.setDerivedImage(derivedImage);\n                }\n                else {\n                    utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n                }\n            }\n        };\n        derivedImageIds.forEach(updateSegmentationActor);\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const viewportRenderList = [];\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            try {\n                const viewportId = display.render(viewport, representation);\n                viewportRenderList.push(viewportId);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n","import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n","import { SegmentationRepresentations } from '../../../enums';\nimport { cache } from '@cornerstonejs/core';\nfunction normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation, config } = segmentationInput;\n    const { type, data: inputData } = representation;\n    const data = inputData ? { ...inputData } : {};\n    if (!data) {\n        throw new Error('Segmentation representation data may not be undefined');\n    }\n    if (type === SegmentationRepresentations.Contour) {\n        normalizeContourData(data);\n    }\n    const normalizedSegments = normalizeSegments(config?.segments, type, data);\n    delete config?.segments;\n    return {\n        segmentationId,\n        label: config?.label ?? null,\n        cachedStats: config?.cachedStats ?? {},\n        segments: normalizedSegments,\n        representationData: {\n            [type]: {\n                ...data,\n            },\n        },\n    };\n}\nfunction normalizeContourData(contourData) {\n    contourData.geometryIds = contourData.geometryIds ?? [];\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n}\nfunction normalizeSegments(segmentsConfig, type, data) {\n    const normalizedSegments = {};\n    if (segmentsConfig) {\n        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {\n            normalizedSegments[segmentIndex] = {\n                segmentIndex: Number(segmentIndex),\n                label: segment.label ?? `Segment ${segmentIndex}`,\n                locked: segment.locked ?? false,\n                cachedStats: segment.cachedStats ?? {},\n                active: segment.active ?? false,\n            };\n        });\n    }\n    else if (type === SegmentationRepresentations.Surface) {\n        normalizeSurfaceSegments(normalizedSegments, data);\n    }\n    else {\n        normalizedSegments[1] = createDefaultSegment();\n    }\n    return normalizedSegments;\n}\nfunction normalizeSurfaceSegments(normalizedSegments, surfaceData) {\n    const { geometryIds } = surfaceData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction createDefaultSegment() {\n    return {\n        segmentIndex: 1,\n        label: 'Segment 1',\n        locked: false,\n        cachedStats: {},\n        active: true,\n    };\n}\nexport default normalizeSegmentationInput;\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nexport function addSegmentations(segmentationInputArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationInputArray.forEach((segmentationInput) => {\n        const segmentation = normalizeSegmentationInput(segmentationInput);\n        segmentationStateManager.addSegmentation(segmentation);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentation.segmentationId);\n        }\n    });\n}\nexport default addSegmentations;\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportSegmentations(viewportId, type) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportRepresentations = state.viewportSegRepresentations[viewportId];\n    const segmentations = viewportRepresentations.map((representation) => {\n        if (type && representation.type === type) {\n            return getSegmentation(representation.segmentationId);\n        }\n        return getSegmentation(representation.segmentationId);\n    });\n    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);\n    return filteredSegmentations;\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { updateStackSegmentationState } from '../helpers/updateStackSegmentationState';\nexport async function computeStackLabelmapFromVolume({ volumeId, }) {\n    const segmentationVolume = cache.getVolume(volumeId);\n    return { imageIds: segmentationVolume.imageIds };\n}\nexport function convertVolumeToStackLabelmap({ segmentationId, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const { volumeId } = segmentation.representationData\n        .Labelmap;\n    const segmentationVolume = cache.getVolume(volumeId);\n    return updateStackSegmentationState({\n        segmentationId,\n        viewportId: options.viewportId,\n        imageIds: segmentationVolume.imageIds,\n        options,\n    });\n}\n","import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n","import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport addRepresentationData from './internalAddRepresentationData';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport * as strategies from './../../tools/segmentation/strategies';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, } from './getCurrentLabelmapImageIdForViewport';\nimport { getActiveSegmentation } from './getActiveSegmentation';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, helpers, removeSegment, getLabelmapImageIds, addRepresentationData, strategies, segmentationStyle, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, getActiveSegmentation, };\n","import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n","import CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getColorLUT } from './getColorLUT';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n        ...config,\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationRemoved } from './triggerSegmentationEvents';\nimport { removeSegmentationRepresentations } from './removeSegmentationRepresentations';\nexport function removeSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const viewportsWithSegmentation = segmentationStateManager\n        .getAllViewportSegmentationRepresentations()\n        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))\n        .map(({ viewportId }) => viewportId);\n    viewportsWithSegmentation.forEach((viewportId) => {\n        removeSegmentationRepresentations(viewportId, { segmentationId });\n    });\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nexport function removeAllSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentations = segmentationStateManager.getState().segmentations;\n    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);\n    segmentationIds.forEach((segmentationId) => {\n        removeSegmentation(segmentationId);\n    });\n    segmentationStateManager.resetState();\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\nfunction removeSegmentationRepresentation(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction _removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    const { segmentationId, type } = specifier;\n    _removeRepresentationObject(viewportId, segmentationId, type, immediate);\n    return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n}\nfunction removeAllSegmentationRepresentations() {\n    const state = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();\n    state.forEach(({ viewportId, representations }) => {\n        representations.forEach(({ segmentationId, type }) => {\n            removeSegmentationRepresentation(viewportId, {\n                segmentationId,\n                type,\n            });\n        });\n    });\n    defaultSegmentationStateManager.resetState();\n}\nfunction removeLabelmapRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    }, immediate);\n}\nfunction removeContourRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    }, immediate);\n}\nfunction removeSurfaceRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Surface,\n    }, immediate);\n}\nfunction _removeRepresentationObject(viewportId, segmentationId, type, immediate) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n    representations.forEach((representation) => {\n        if (representation.type === SegmentationRepresentations.Labelmap) {\n            labelmapDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Contour) {\n            contourDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Surface) {\n            surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n    });\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        viewport.render();\n    }\n}\nexport { removeSegmentationRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, };\n","import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n","import { getSegmentation } from './getSegmentation';\nimport { getSegmentations } from './getSegmentations';\nimport { addSegmentations } from './addSegmentations';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addColorLUT } from './addColorLUT';\nimport { getColorLUT } from './getColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { removeColorLUT } from './removeColorLUT';\nimport { getViewportSegmentations } from './getViewportSegmentations';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, } from './getCurrentLabelmapImageIdForViewport';\nimport { updateLabelmapSegmentationImageReferences } from './updateLabelmapSegmentationImageReferences';\nimport { getStackSegmentationImageIdsForViewport } from './getStackSegmentationImageIdsForViewport';\nimport { getSegmentationRepresentation, getSegmentationRepresentations, getSegmentationRepresentationsBySegmentationId, } from './getSegmentationRepresentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction destroy() {\n    defaultSegmentationStateManager.resetState();\n}\nexport { getColorLUT, getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, getNextColorLUTIndex, getSegmentation, getSegmentations, getStackSegmentationImageIdsForViewport, getViewportIdsWithSegmentation, getSegmentationRepresentation, getSegmentationRepresentations, removeColorLUT, getViewportSegmentations, removeSegmentation, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, removeAllSegmentations, addColorLUT, addSegmentations, updateLabelmapSegmentationImageReferences, getSegmentationRepresentationsBySegmentationId, destroy, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, [], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n","import { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        canvasCoordinates,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const canvasPoint = canvasCoordinates[0];\n        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n        const deltaXPoint = viewport.canvasToWorld([\n            canvasPoint[0] + 1,\n            canvasPoint[1],\n        ]);\n        const deltaYPoint = viewport.canvasToWorld([\n            canvasPoint[0],\n            canvasPoint[1] + 1,\n        ]);\n        const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n        const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n            imageData,\n            isInObject: (pointLPS, _pointIJK) => {\n                let result = true;\n                const point = viewport.worldToCanvas(pointLPS);\n                if (point[1] != curRow) {\n                    intersectionCounter = 0;\n                    curRow = point[1];\n                    intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                    intersections.sort((function (index) {\n                        return function (a, b) {\n                            return a[index] === b[index]\n                                ? 0\n                                : a[index] < b[index]\n                                    ? -1\n                                    : 1;\n                        };\n                    })(0));\n                }\n                if (intersections.length && point[0] > intersections[0][0]) {\n                    intersections.shift();\n                    intersectionCounter++;\n                }\n                if (intersectionCounter % 2 === 0) {\n                    result = false;\n                }\n                return result;\n            },\n            boundsIJK,\n            returnPoints: this.configuration.storePointData,\n        });\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter: calculatePerimeter(canvasCoordinates, closed) / scale,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, }) {\n        const { scale, unit } = calibratedScale;\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length: calculatePerimeter(canvasCoordinates, false) / scale,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (Number.isFinite(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (perimeter) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (length) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        boundsIJK,\n                        imageData,\n                        returnPoints: this.configuration.storePointData,\n                    });\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nexport default RectangleROITool;\n","import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentPoints.canvas;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n                this.doneEditMemo();\n            }\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getClosestImageIdForStackViewport } from '../../utilities/annotationHydration';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks, Events } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof getClosestImageIdForStackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getCanvasEllipseCorners, precalculatePointInEllipse, } from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, isEqual } = csUtils;\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);\n        const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n        const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n        const circleCornersIJK = points.map((world) => {\n            return transformWorldToIndex(segmentationImageData, world);\n        });\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.isInObject = createPointInEllipse({\n            topLeftWorld,\n            bottomRightWorld,\n            center,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(worldInfo) {\n    const { topLeftWorld, bottomRightWorld, center } = worldInfo;\n    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n    const radius = Math.max(xRadius, yRadius, zRadius);\n    if (isEqual(xRadius, radius) &&\n        isEqual(yRadius, radius) &&\n        isEqual(zRadius, radius)) {\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS) => pointInSphere(sphereObj, pointLPS);\n    }\n    const ellipseObj = {\n        center: center,\n        xRadius,\n        yRadius,\n        zRadius,\n    };\n    const { precalculated } = precalculatePointInEllipse(ellipseObj, {});\n    return precalculated;\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse as createEllipseInPoint, };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK, getBoundingBoxAroundShapeWorld, } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { isAxisAlignedRectangle } from '../../../utilities/rectangleROITool/isAxisAlignedRectangle';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const isStackViewport = viewport instanceof StackViewport;\n    const isAligned = isStackViewport || isAxisAlignedRectangle(rectangleCornersIJK);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointsBoundsLPS = getBoundingBoxAroundShapeWorld(points);\n    let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;\n    xMin -= EPS;\n    xMax += EPS;\n    yMin -= EPS;\n    yMax += EPS;\n    zMin -= EPS;\n    zMax += EPS;\n    const pointInShapeFn = isAligned\n        ? () => true\n        : (pointLPS) => {\n            const [x, y, z] = pointLPS;\n            const xInside = x >= xMin && x <= xMax;\n            const yInside = y >= yMin && y <= yMax;\n            const zInside = z >= zMin && z <= zMax;\n            return xInside && yInside && zInside;\n        };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n","import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function addContourSegmentationAnnotation(annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    if (!annotation.data.segmentation) {\n        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation.representationData.Contour) {\n        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };\n    }\n    let { annotationUIDsMap } = segmentation.representationData.Contour;\n    if (!annotationUIDsMap) {\n        annotationUIDsMap = new Map();\n    }\n    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        annotationsUIDsSet = new Set();\n        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n","import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    return viewports.length ? viewports[0] : undefined;\n}\n","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n","import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n","function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals;\n    const filter = options.filter;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = new Set();\n    const bounds = options.bounds;\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        return visits.has(iKey);\n    }\n    function markAsVisited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        visits.add(iKey);\n    }\n    function member(getArgs) {\n        const node = get(getArgs);\n        return equals ? equals(node, startNode) : node === startNode;\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        const [x, y, z = 0] = prevArgs;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        bounds?.set(iKey, prevArgs);\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            if (filter?.(nextArgs) === false) {\n                continue;\n            }\n            if (visited(nextArgs)) {\n                continue;\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nexport function getBrushToolInstances(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    if (toolName && toolInstances[toolName]) {\n        return [toolInstances[toolName]];\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);\n        if (highlightedAnnotationUID) {\n            return segmentIndex;\n        }\n    }\n    return undefined;\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { getSegmentation, getCurrentLabelmapImageIdForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers';\nexport function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {\n    const segmentation = getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const voxelManager = segmentationVolume.voxelManager;\n        const imageData = segmentationVolume.imageData;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n        const canvasPoint = viewport.worldToCanvas(worldPoint);\n        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);\n        return onEdge ? segmentIndex : undefined;\n    }\n    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);\n    return onEdge ? segmentIndex : undefined;\n}\nfunction isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {\n    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);\n    for (const deltaI of neighborRange) {\n        for (const deltaJ of neighborRange) {\n            for (const deltaK of neighborRange) {\n                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n                    continue;\n                }\n                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {\n        const neighborIJK = [\n            indexIJK[0] + deltaI,\n            indexIJK[1] + deltaJ,\n            indexIJK[2] + deltaK,\n        ];\n        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\nfunction isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ) => {\n        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n        const worldPoint = viewport.canvasToWorld(neighborCanvas);\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getSegmentation, getCurrentLabelmapImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nexport function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];\n    if (!desiredRepresentation) {\n        throw new Error(`Segmentation ${segmentationId} does not have any representations`);\n    }\n    switch (desiredRepresentation) {\n        case SegmentationRepresentations.Labelmap:\n            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);\n        case SegmentationRepresentations.Contour:\n            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);\n        default:\n            return;\n    }\n}\nexport function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n        return segmentIndex;\n    }\n    const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentation.segmentationId);\n    if (segmentationImageIds.length > 1) {\n        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');\n        return;\n    }\n    const segmentationImageId = segmentationImageIds[0];\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    return segmentIndex;\n}\nexport function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {\n    const contourData = segmentation.representationData.Contour;\n    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n    const { viewPlaneNormal } = viewport.getCamera();\n    for (const segmentIndex of segmentIndices) {\n        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n        if (!annotationsSet) {\n            continue;\n        }\n        for (const annotationUID of annotationsSet) {\n            const annotation = getAnnotation(annotationUID);\n            if (!annotation) {\n                continue;\n            }\n            const { polyline } = annotation.data.contour;\n            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {\n                continue;\n            }\n            if (isPointInsidePolyline3D(worldPoint, polyline)) {\n                return Number(segmentIndex);\n            }\n        }\n    }\n}\n","const shader = `\nconst MAX_STRENGTH = 65535f;\n\n// Workgroup size - X*Y*Z must be multiple of 32 for better performance\noverride workGroupSizeX = 1u;\noverride workGroupSizeY = 1u;\noverride workGroupSizeZ = 1u;\n\n// Compare the current voxel to neighbors using a 9x9x9 window\noverride windowSize = 9i;\n\nstruct Params {\n  size: vec3u,\n  iteration: u32,\n}\n\n// New structure to track bounds of modified voxels\nstruct Bounds {\n  minX: atomic<i32>,\n  minY: atomic<i32>,\n  minZ: atomic<i32>,\n  maxX: atomic<i32>,\n  maxY: atomic<i32>,\n  maxZ: atomic<i32>,\n}\n\n@group(0) @binding(0) var<uniform> params: Params;\n@group(0) @binding(1) var<storage> volumePixelData: array<f32>;\n@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;\n@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;\n@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;\n@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;\n@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;\n@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;\n\nfn getPixelIndex(ijkPos: vec3u) -> u32 {\n  let numPixelsPerSlice = params.size.x * params.size.y;\n  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;\n}\n\nfn updateBounds(position: vec3i) {\n  // Atomically update min bounds (use min operation)\n  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);\n  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);\n  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);\n\n  // Atomically update max bounds (use max operation)\n  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);\n  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);\n  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);\n}\n\n@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\nfn main(\n  @builtin(global_invocation_id) globalId: vec3u,\n) {\n  // Make sure it will not get out of bounds for volume with sizes that\n  // are not multiple of workGroupSize\n  if (\n    globalId.x >= params.size.x ||\n    globalId.y >= params.size.y ||\n    globalId.z >= params.size.z\n  ) {\n    return;\n  }\n\n  // Initialize bounds for the first iteration\n  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {\n    // Initialize to opposite extremes to ensure any update will improve the bounds\n    atomicStore(&modifiedBounds.minX, i32(params.size.x));\n    atomicStore(&modifiedBounds.minY, i32(params.size.y));\n    atomicStore(&modifiedBounds.minZ, i32(params.size.z));\n    atomicStore(&modifiedBounds.maxX, -1);\n    atomicStore(&modifiedBounds.maxY, -1);\n    atomicStore(&modifiedBounds.maxZ, -1);\n  }\n\n  let currentCoord = vec3i(globalId);\n  let currentPixelIndex = getPixelIndex(globalId);\n\n  let numPixels = arrayLength(&volumePixelData);\n  let currentPixelValue = volumePixelData[currentPixelIndex];\n\n  if (params.iteration == 0) {\n    // All non-zero initial labels are given maximum strength\n    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);\n\n    // Update bounds for non-zero initial labels\n    if (labelmap[currentPixelIndex] != 0) {\n      updateBounds(currentCoord);\n    }\n    return;\n  }\n\n  // It should at least copy the values from previous state\n  var newLabel = prevLabelmap[currentPixelIndex];\n  var newStrength = prevStrengthData[currentPixelIndex];\n\n  let window = i32(ceil(f32(windowSize - 1) * .5));\n  let minWindow = -1i * window;\n  let maxWindow = 1i * window;\n\n  for (var k = minWindow; k <= maxWindow; k++) {\n    for (var j = minWindow; j <= maxWindow; j++) {\n      for (var i = minWindow; i <= maxWindow; i++) {\n        // Skip current voxel\n        if (i == 0 && j == 0 && k == 0) {\n          continue;\n        }\n\n        let neighborCoord = currentCoord + vec3i(i, j, k);\n\n        //  Boundary conditions. Do not grow outside of the volume\n        if (\n          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||\n          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||\n          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)\n        ) {\n          continue;\n        }\n\n        let neighborIndex = getPixelIndex(vec3u(neighborCoord));\n        let neighborPixelValue = volumePixelData[neighborIndex];\n        let prevNeighborStrength = prevStrengthData[neighborIndex];\n        let strengthCost = abs(neighborPixelValue - currentPixelValue);\n        let takeoverStrength = prevNeighborStrength - strengthCost;\n\n        if (takeoverStrength > newStrength) {\n          newLabel = prevLabelmap[neighborIndex];\n          newStrength = takeoverStrength;\n        }\n      }\n    }\n  }\n\n  if (labelmap[currentPixelIndex] != newLabel) {\n    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);\n\n    // Update bounds for modified voxels\n    updateBounds(currentCoord);\n  }\n\n  labelmap[currentPixelIndex] = newLabel;\n  strengthData[currentPixelIndex] = newStrength;\n}\n`;\nexport default shader;\n","import { cache } from '@cornerstonejs/core';\nimport shaderCode from './growCutShader';\nconst GB = 1024 * 1024 * 1024;\nconst WEBGPU_MEMORY_LIMIT = 1.99 * GB;\nconst DEFAULT_GROWCUT_OPTIONS = {\n    windowSize: 3,\n    maxProcessingTime: 30000,\n    inspection: {\n        numCyclesInterval: 5,\n        numCyclesBelowThreshold: 3,\n        threshold: 1e-4,\n    },\n};\nasync function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {\n    const workGroupSize = [8, 8, 4];\n    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);\n    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);\n    const volume = cache.getVolume(referenceVolumeId);\n    const labelmap = cache.getVolume(labelmapVolumeId);\n    const [columns, rows, numSlices] = volume.dimensions;\n    if (labelmap.dimensions[0] !== columns ||\n        labelmap.dimensions[1] !== rows ||\n        labelmap.dimensions[2] !== numSlices) {\n        throw new Error('Volume and labelmap must have the same size');\n    }\n    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);\n    numIterations = Math.min(numIterations, 500);\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();\n    if (!(volumePixelData instanceof Float32Array)) {\n        volumePixelData = new Float32Array(volumePixelData);\n    }\n    const requiredLimits = {\n        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,\n        maxBufferSize: WEBGPU_MEMORY_LIMIT,\n    };\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter.requestDevice({ requiredLimits });\n    const BUFFER_SIZE = volumePixelData.byteLength;\n    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;\n    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;\n    const shaderModule = device.createShaderModule({\n        code: shaderCode,\n    });\n    const numIterationIndex = 3;\n    const paramsArrayValues = new Uint32Array([\n        columns,\n        rows,\n        numSlices,\n        0,\n    ]);\n    const gpuParamsBuffer = device.createBuffer({\n        size: paramsArrayValues.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const gpuVolumePixelDataBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);\n    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    }));\n    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));\n    const gpuStrengthBuffers = [0, 1].map(() => {\n        const strengthBuffer = device.createBuffer({\n            size: BUFFER_SIZE,\n            usage: GPUBufferUsage.STORAGE |\n                GPUBufferUsage.COPY_SRC |\n                GPUBufferUsage.COPY_DST,\n        });\n        return strengthBuffer;\n    });\n    const gpuCounterBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const gpuBoundsBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const initialBounds = new Int32Array([\n        columns,\n        rows,\n        numSlices,\n        -1,\n        -1,\n        -1,\n    ]);\n    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'uniform',\n                },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n        ],\n    });\n    const bindGroups = [0, 1].map((i) => {\n        const outputLabelmapBuffer = gpuLabelmapBuffers[i];\n        const outputStrengthBuffer = gpuStrengthBuffers[i];\n        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];\n        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];\n        return device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: gpuParamsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: gpuVolumePixelDataBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: outputLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 4,\n                    resource: {\n                        buffer: previouLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 5,\n                    resource: {\n                        buffer: previousStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 6,\n                    resource: {\n                        buffer: gpuCounterBuffer,\n                    },\n                },\n                {\n                    binding: 7,\n                    resource: {\n                        buffer: gpuBoundsBuffer,\n                    },\n                },\n            ],\n        });\n    });\n    const pipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n        }),\n        compute: {\n            module: shaderModule,\n            entryPoint: 'main',\n            constants: {\n                workGroupSizeX: workGroupSize[0],\n                workGroupSizeY: workGroupSize[1],\n                workGroupSizeZ: workGroupSize[2],\n                windowSize,\n            },\n        },\n    });\n    const numWorkGroups = [\n        Math.ceil(columns / workGroupSize[0]),\n        Math.ceil(rows / workGroupSize[1]),\n        Math.ceil(numSlices / workGroupSize[2]),\n    ];\n    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const limitProcessingTime = maxProcessingTime\n        ? performance.now() + maxProcessingTime\n        : 0;\n    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n    let belowThresholdCounter = 0;\n    for (let i = 0; i < numIterations; i++) {\n        paramsArrayValues[numIterationIndex] = i;\n        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);\n        const commandEncoder = device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroups[i % 2]);\n        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);\n        passEncoder.end();\n        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);\n        device.queue.submit([commandEncoder.finish()]);\n        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);\n        if (inspect) {\n            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));\n            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;\n            gpuUpdatedVoxelsCounterStagingBuffer.unmap();\n            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {\n                currentInspectionNumCyclesInterval = 1;\n                belowThresholdCounter++;\n                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {\n                    break;\n                }\n            }\n            else {\n                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n            }\n        }\n        if (limitProcessingTime && performance.now() > limitProcessingTime) {\n            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);\n            break;\n        }\n    }\n    const commandEncoder = device.createCommandEncoder();\n    const outputLabelmapBufferIndex = (numIterations + 1) % 2;\n    const labelmapStagingBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const boundsStagingBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);\n    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);\n    device.queue.submit([commandEncoder.finish()]);\n    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);\n    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);\n    const labelmapResult = new Uint32Array(labelmapResultBuffer);\n    labelmapData.set(labelmapResult);\n    labelmapStagingBuffer.unmap();\n    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);\n    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);\n    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));\n    boundsStagingBuffer.unmap();\n    const minX = boundsResult[0];\n    const minY = boundsResult[1];\n    const minZ = boundsResult[2];\n    const maxX = boundsResult[3];\n    const maxY = boundsResult[4];\n    const maxZ = boundsResult[5];\n    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);\n    labelmap.voxelManager.clearBounds();\n    labelmap.voxelManager.setBounds([\n        [minX, maxX],\n        [minY, maxY],\n        [minZ, maxZ],\n    ]);\n}\nexport { runGrowCut as default, runGrowCut as run };\n","import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nfunction _setNegativeSeedValues(subVolume, labelmap, options) {\n    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const visited = new Array(width * height).fill(false);\n    const sliceOffset = middleSliceIndex * width * height;\n    const bfs = (startX, startY) => {\n        const queue = [[startX, startY]];\n        while (queue.length) {\n            const [x, y] = queue.shift();\n            const slicePixelIndex = y * width + x;\n            if (x < 0 ||\n                x >= width ||\n                y < 0 ||\n                y >= height ||\n                visited[slicePixelIndex]) {\n                continue;\n            }\n            visited[slicePixelIndex] = true;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);\n            queue.push([x - 1, y]);\n            queue.push([x + 1, y]);\n            queue.push([x, y - 1]);\n            queue.push([x, y + 1]);\n        }\n    };\n    const scanLine = (startX, limitX, incX, y) => {\n        for (let x = startX; x !== limitX; x += incX) {\n            const slicePixelIndex = y * width + x;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                break;\n            }\n            if (!visited[slicePixelIndex]) {\n                bfs(x, y);\n            }\n        }\n    };\n    for (let y = 0; y < height; y++) {\n        scanLine(0, width - 1, 1, y);\n        scanLine(width - 1, 0, -1, y);\n    }\n}\nfunction _setPositiveSeedValues(subVolume, labelmap, options) {\n    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);\n    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);\n    const pixelsPerSlice = width * height;\n    for (let z = startSliceIndex; z < stopSliceIndex; z++) {\n        const zOffset = z * pixelsPerSlice;\n        for (let y = 0; y < height; y++) {\n            const yOffset = y * width;\n            for (let x = 0; x < width; x++) {\n                const index = zOffset + yOffset + x;\n                const pixelValue = subVolPixelData[index];\n                const isPositiveValue = pixelValue >= positivePixelRange[0] &&\n                    pixelValue <= positivePixelRange[1];\n                if (isPositiveValue) {\n                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);\n                }\n            }\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, options);\n    _setNegativeSeedValues(subVolume, labelmap, options);\n    return labelmap;\n}\nasync function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {\n    const { boundingBox } = boundingBoxInfo;\n    const { ijkTopLeft, ijkBottomRight } = boundingBox;\n    const subVolumeBoundsIJK = {\n        minX: ijkTopLeft[0],\n        maxX: ijkBottomRight[0],\n        minY: ijkTopLeft[1],\n        maxY: ijkBottomRight[1],\n        minZ: ijkTopLeft[2],\n        maxZ: ijkBottomRight[2],\n    };\n    const subVolume = csUtils.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForBoundingBox as default, runGrowCutForBoundingBox };\n","import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n","import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n","function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n","export var ColorbarRangeTextPosition;\n(function (ColorbarRangeTextPosition) {\n    ColorbarRangeTextPosition[\"Top\"] = \"top\";\n    ColorbarRangeTextPosition[\"Left\"] = \"left\";\n    ColorbarRangeTextPosition[\"Bottom\"] = \"bottom\";\n    ColorbarRangeTextPosition[\"Right\"] = \"right\";\n})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));\n","const DataTypeByteSize = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\nconst VtkDataTypes = {\n  VOID: '',\n  // not sure to know what that should be\n  CHAR: 'Int8Array',\n  SIGNED_CHAR: 'Int8Array',\n  UNSIGNED_CHAR: 'Uint8Array',\n  UNSIGNED_CHAR_CLAMPED: 'Uint8ClampedArray',\n  // should be used for VTK.js internal purpose only\n  SHORT: 'Int16Array',\n  UNSIGNED_SHORT: 'Uint16Array',\n  INT: 'Int32Array',\n  UNSIGNED_INT: 'Uint32Array',\n  FLOAT: 'Float32Array',\n  DOUBLE: 'Float64Array'\n};\nconst DefaultDataType = VtkDataTypes.FLOAT;\nvar Constants = {\n  DefaultDataType,\n  DataTypeByteSize,\n  VtkDataTypes\n};\n\nexport { DataTypeByteSize, DefaultDataType, VtkDataTypes, Constants as default };\n","const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n"],"names":["enabledElement","invalidated","image","canvas","start","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","render","viewport","colormap","color","renderTimeInMs","invalid","needsRedraw","scale","transform","displayedArea","translate","width","height","angle","rotation","rotate","Math","PI","widthScale","heightScale","brhc","x","tlhc","y","presentationSizeMode","rowPixelSpacing","columnPixelSpacing","verticalScale","horizontalScale","min","translation","undefined","hflip","vflip","modality","Error","scaleFactor","voi","isPreScaled","windowWidth","windowCenter","Array","isArray","invert","pixelReplication","modalityLUT","voiLUT","columns","rows","GenerateImageType","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","options","cachedImageLoadObject","getImageLoadObject","handleImageLoadPromise","promise","scheme","loader","imageLoadObject","imagePromise","Promise","resolve","then","voxelManager","numberOfComponents","createImageVoxelManager","scalarData","getPixelData","getScalarData","imageFrame","pixelData","ensureVoxelManager","IMAGE_LOADED","catch","error","errorDetails","IMAGE_LOAD_FAILED","loadImage","priority","requestType","loadAndCacheImage","putImageLoadObject","loadAndCacheImages","imageIds","map","createAndCacheDerivedImage","referencedImageId","skipCreateBuffer","onCacheAdd","voxelRepresentation","imagePlaneModule","TypedArrayConstructor","targetBuffer","type","imageScalarData","derivedImageId","referencedImagePlaneMetadata","metadata","referencedImageGeneralSeriesMetadata","instanceNumber","imagePixelModule","bitsAllocated","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","dimensions","spacing","origin","imagePositionPatient","direction","imageOrientationPatient","frameOfReferenceUID","putImageSync","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","index","newOptions","getDerivedImageId","push","rowCosines","columnCosines","pixelSpacing","scalarDataToUse","Uint8Array","Float32Array","Uint16Array","Int16Array","photometricInterpretation","id","RLE","createRLEImageVoxelManager","minPixelValue","maxPixelValue","i","intercept","dataType","slope","getCanvas","rgba","FrameOfReferenceUID","sizeInBytes","byteLength","cancelLoadImage","filterRequests","additionalDetails","cancelFn","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","requestDetails","pop","volumeId","loadObject","getVolumeLoadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedLabelmapImages","createAndCacheDerivedLabelmapImage","FrameRange","frameRangeExtractor","imageIdToFrames","match","range","it","Number","imageIdToFrameEnd","imageIdToFrameStart","framesToString","String","framesToImageId","newRangeString","replace","PointsManager","configuration","_dimensions","_length","_byteSize","growSize","initialSize","itemLength","array","ArrayBuffer","data","func","getPoint","dimensionLength","offset","subarray","getPointArray","grow","additionalSize","newSize","newArray","newData","reverse","midLength","floor","indexStart","indexEnd","dimension","valueStart","getTypedArray","point","f","mapData","points","p","toXYZ","xyz","z","fromXYZ","create3","subselect","count","selected","max","newPoints","create2","ProgressiveIterator","as","iterator","v","e","reject","reason","done","nextValue","waiting","rejectReason","getRecent","asyncIterator","errorCallback","console","warn","generate","processFunction","bind","nextPromise","donePromise","getNextPromise","getDonePromise","ADJACENT_ALL","ADJACENT_SINGLE_PLANE","ADJACENT_IN","ADJACENT_OUT","RLEVoxelMap","copyMap","destination","source","row","structuredClone","depth","Map","jMultiple","kMultiple","numComps","pixelDataConstructor","updateScalarData","fill","rle","end","j","getRLE","defaultValue","getRun","k","runIndex","rleIndex","findIndex","rle1","rle0","oldValue","rleInsert","isAfter","insertIndex","rlePrev","rleNext","splice","nextnext","ArrayType","Uint8ClampedArray","frameSize","toIJK","toIndex","newRle","iEnd","rowModified","baseIndex","rowToUse","forEachRow","clear","rowOffset","comp","floodFill","stack","replaceValue","flood","sourceValue","sum","planar","diagonals","singlePlane","childOptions","top","adjacents","findAdjacents","filter","adjacent","fillFrom","getter","boundsIJK","item","adjacentsDelta","leftRle","rightRle","delta","delta1","delta2","testJ","testK","testRle","newAdjacentDelta","isImageActor","actorEntry","actorIsA","actorType","actorToCheck","actor","isA","applyPreset","preset","colorTransferArray","colorTransfer","parseFloat","shiftRange","Infinity","center","getShiftRange","cfun","normColorTransferValuePoints","r","g","b","rescaled","removeAllPoints","addRGBPoint","applyPointsToRGBFunction","getProperty","setRGBTransferFunction","scalarOpacityArray","scalarOpacity","ofun","normPoints","opacity","pwf","addPoint","applyPointsToPiecewiseFunction","property","setScalarOpacity","gradientMinValue","gradientMinOpacity","gradientMaxValue","gradientMaxOpacity","gradientOpacity","setUseGradientOpacity","setGradientOpacityMinimumValue","setGradientOpacityMinimumOpacity","setGradientOpacityMaximumValue","setGradientOpacityMaximumOpacity","interpolation","setInterpolationTypeToFastLinear","setShade","shade","ambient","diffuse","specular","specularPower","setAmbient","setDiffuse","setSpecular","setSpecularPower","renderingEngineAndViewportIds","renderingEnginesArray","renderingEngine","viewports","viewportIds","getRenderingEngineAndViewportsContainingVolume","hasBeenDestroyed","renderViewports","getImagePlaneModule","newImagePlaneModule","MetadataModules","IMAGE_PLANE","buildMetadata","voiLUTFunction","imageIdScalingFactor","calibration","CALIBRATION","voiLUTFunctionEnum","values","VOILUTFunctionType","includes","LINEAR","getValidVOILUTFunction","scalingFactor","calculateSpacingBetweenImageIds","referenceImagePositionPatient","rowCosineVec","colCosineVec","scanAxisNormal","refIppVec","getDistance","positionVector","ippVec","prefetchedImageIds","metadataForMiddleImage","middleIppVec","distanceBetweenFirstAndMiddleImages","abs","distanceImagePairs","distance","sort","a","numImages","sliceThickness","spacingBetweenSlices","strictZSpacingForVolumeViewport","rendering","isNaN","debug","clamp","_colormaps","registerColormap","Name","getColormap","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","find","RGBPoints","presetRGBPoints","opacityPoints","getScalarOpacity","getDataPointer","createLinearRGBTransferFunction","voiRange","lower","upper","createSigmoidRGBTransferFunction","approximationNodes","table","_","flatMap","buildFunctionFromArray","decimate","list","interleave","interleaveIndices","deepClone","obj","clonedObj","fnv1aHash","str","hash","charCodeAt","toString","getClosestImageId","imageVolume","worldPos","viewPlaneNormal","kVector","dotProducts","EPSILON","halfSpacingInNormalDirection","imageIdForTool","dir","dot","getImageDataMetadata","xSpacing","ySpacing","xVoxels","yVoxels","zSpacing","_getNumCompsFromPhotometricInterpretation","numVoxels","camera","getCamera","spacingInNormalDirection","focalPoint","getActors","referencedId","uid","volumeActor","sliceRange","numberOfSlices","round","imageIndex","getScalingParameters","modalityLutModule","generalSeriesModule","scalingParameters","rescaleSlope","rescaleIntercept","suvFactor","suvbw","suvbsa","suvlbm","SMALL_EPSILON","isOne","isUnit","off","isOrthonormal","getSliceRange","imageData","getMapper","getInputData","corners","getDirection","dx","dy","dz","getDimensions","indexToWorld","buildFromDegree","identity","rotateFromDirections","pt","apply","transformedFocalPoint","currentSlice","minX","maxX","getSpacingInNormalDirection","iVector","jVector","projectedSpacing","EPSILON_PART","isPrimaryVolume","volume","getVolumeLoaderSchemes","starts","substring","getTargetVolumeAndSpacingInNormalDir","targetId","useSlabThickness","volumeActors","actorUID","imageVolumes","va","getVolume","iv","targetVolumeId","imageVolumeIndex","getSpacingInNormal","smallest","hasPrimaryVolume","slabThickness","getProperties","renderingEngines","targetViewports","filteredViewports","getVolumeViewports","vp","hasVolumeId","getVoiFromSigmoidRGBTransferFunction","cfunRange","getRange","getTable","cfunDomain","y1","logy1","log","x1","y2","logy2","x2","ww","wc","getVolumeActorCorners","bounds","extentToBounds","getExtent","getVolumeId","getActor","numScrollSteps","floatingStepNumber","currentStepIndex","sliceRangeInfo","hasFloatScalingParameters","some","isInteger","hasNaNValues","input","imageIdToURI","colonIndex","retrieveConfigurationState","IMAGE_RETRIEVE_CONFIGURATION","imageRetrieveMetadataProvider","payload","clone","restore","state","queries","query","addProvider","EventListenerPhases","TargetEventListeners","target","_eventListeners","_children","_target","isEmpty","size","addEventListener","dotIndex","namespaceToken","childElementEventListener","_addEventListener","removeEventListener","_removeEventListener","reset","entries","child","_unregisterAllEvents","listenersMap","listenerPhase","capture","Capture","Bubble","registeredPhases","None","callbackItem","newListenerPhase","_unregisterAllListeners","listener","eventPhases","currentPhase","useCapture","MultiTargetEventListenerManager","_targetsEventListeners","eventListeners","targetEventListeners","scaleRGBTransferFunction","rgbTransferFunction","getSize","nodeValue1","getNodeValue","setNodeValue","getMinMax","storedPixelData","storedPixel","numPixels","LAST_RUNTIME_ID","GLOBAL_CONTEXT","DEFAULT_MAX","DEFAULT_SEPARATOR","getRuntimeId","symbol","idComponents","carry","n","getNextRuntimeId","join","imageURI","isOpposite","v1","v2","tolerance","indexWithinDimensions","targetViewport","renderingEngineId","getRenderingEngine","sameVolumesViewports","targetActors","vpActors","every","vpActor","preScale","scaled","renderToCanvasGPU","imageOrVolume","viewportOptions","displayArea","imageArea","HTMLCanvasElement","isVolume","viewportId","element","document","createElement","devicePixelRatio","window","originalWidth","originalHeight","style","visibility","position","body","appendChild","uniqueId","setAttribute","temporaryCanvas","getOrCreateCanvas","RenderingEngine","getViewport","viewportInput","ViewportType","ORTHOGRAPHIC","STACK","defaultOptions","suppressEvents","enableElement","elementRendered","viewReference","onImageRendered","eventDetail","useViewRef","setViewReference","getContext","drawImage","canvasToWorld","topRight","bottomLeft","rightVector","downVector","Events","IMAGE_RENDERED","setTimeout","disableElement","querySelectorAll","remove","thicknessMm","setVolumes","renderImageObject","resetCamera","setProperties","renderToCanvasCPU","_renderingEngineId","_viewportOptions","getDefaultViewport","renderingTools","calculateTransform","drawImageSync","loadImageToCanvas","RequestType","Thumbnail","useCPURendering","thumbnail","imageAspect","baseViewportOptions","renderFn","successCallback","metaData","useRGBA","cache","imageLoadPoolManager","addRequest","imageIdIndex","HistoryMemo","label","redoAvailable","undoAvailable","ring","_size","undo","items","restoreMemo","eventTarget","dispatchEvent","CustomEvent","detail","isUndo","operationType","memo","undoIf","condition","redo","newPosition","createMemo","DefaultHistoryMemo","worldCoords","newOrigin","sub","imageToWorldCoords","imageCoords","imageCoordsInWorld","getViewportsWithImageURI","getViewports","hasImageURI","getClosestStackImageIndexForPoint","minimalDistance","getImageIds","currentImageIdIndex","getCurrentImageIdIndex","planeMetadata","targetImagePlane","rowVec","colVec","planeNormal","getPlaneMetadata","plane","planeEquation","planeDistanceToPoint","closestStack","higherImageIds","lowerImageIds","calculateMinimalDistanceForStackViewport","getCurrentVolumeViewportSlice","canvasWidth","canvasHeight","sliceToIndexMatrix","indexToSliceMatrix","getSliceViewInfo","ijkOriginPoint","transformCanvasToIJK","ijkRowPoint","ijkColPoint","ijkRowVec","ijkColVec","ijkSliceVec","maxIJKRowVec","maxIJKColVec","getImageData","sliceViewInfo","getSliceData","spatialRegistrationMetadataProvider","viewportId1","viewportId2","entryId","entryIdReverse","viewport1","viewport2","imageId1","getSliceIndex","imageId2","imagePlaneModule1","imagePlaneModule2","iop2","imagePositionPatient1","imagePositionPatient2","mat","getViewportImageCornersInWorld","ratio","topRightCanvas","bottomRightCanvas","bottomLeftCanvas","topLeftWorld","topRightWorld","bottomRightWorld","bottomLeftWorld","topLeftImage","worldToIndex","topRightImage","bottomRightImage","bottomLeftImage","topLeftImageWorld","_isInBounds","topRightImageWorld","bottomRightImageWorld","bottomLeftImageWorld","_getStackViewportImageCorners","imageCoord","getEnabledElement","StackViewport","getCornerstoneImage","isValidVolume","imageId0","seriesInstanceUID","usingDefaultValues","baseMetadata","validVolume","isEqual","videoUIDs","Set","isVideoTransferSyntax","uidOrUids","async","convertStackToVolumeViewport","uuidv4","getUnknownVolumeLoaderSchema","prevViewPresentation","getViewPresentation","prevViewReference","getViewReference","background","orientation","createAndCacheVolume","load","volumeViewport","volumeViewportNewVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","setViewPresentation","convertVolumeToStackViewport","ImageVolume","prevView","stackViewport","setStack","roundToPrecision","roundNumber","precision","absValue","fixedPrecision","toFixed","convertToGrayscale","isRGBA","isRGB","newScalarData","destOffset","increment","getRandomSampleFromArray","clonedArray","shuffleArray","random","componentToHex","c","hex","rgbToHex","hexToRgb","result","exec","parseInt","deepEqual","obj1","obj2","JSON","stringify","groupBy","reduce","rv","test4DTag","IPPGroups","value_getter","frame_groups","first_frame_value_set","positions","frame_value_set","frames","frame_value","setEquals","getTagValue","tag","getPhilipsPrivateBValue","InlineBinary","value_bytes","atob","ary_buf","dv","DataView","setUint8","getSiemensPrivateBValue","getGEPrivateBValue","set_a","set_b","getPetFrameReferenceTime","moduleInfo","positionGroups","ippMetadata","frame_count","getIPPGroups","imageIdGroups","splittingTag","tags","fncList2","timePoints","isDynamicVolume","scaleArray","arrayLength","clip","val","low","high","scrollSlabs","getVolumeViewportScrollInfo","newFocalPoint","snapFocalPointToSlice","setCamera","desiredStepIndex","VolumeScrollEventDetail","currentImageId","getCurrentImageId","triggerEvent","VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","eventData","STACK_SCROLL_OUT_OF_BOUNDS","scroll","debounceLoading","loop","jumpToSlice","currentImageIndex","getTargetImageIdIndex","getNumberOfSlices","_getImageSliceData","imageIndexToJump","lastSliceIndex","_getImageIndexToJump","createSubVolume","referencedVolumeId","referencedVolume","refVolumeDim","minY","maxY","minZ","maxZ","ijkTopLeft","boundingBoxOriginWorld","transformIndexToWorld","subVolumeOptions","subVolume","createLocalVolume","subVolumeData","getCompleteScalarDataArray","subVolumeSliceSize","refVolumeSliceSize","refVolumeData","rowStartWorld","refVolumeRowStartIJK","transformWorldToIndex","refVolumeRowStartOffset","rowData","subVolumeLineStartOffset","setCompleteScalarDataArray","getVolumeDirectionVectors","viewUp","ijkOrigin","worldVecColDir","worldVecSliceDir","worldVecRowDir","ijkVecColDir","ijkVecSliceDir","ijkVecRowDir","calculateNeighborhoodStats","centerIjk","radius","numSlices","numPixelsPerSlice","sumSq","cx","cy","cz","centerIndex","mean","stdDev","variance","sqrt","getViewportModality","Modality","_getViewportModality","invertRgbTransferFunction","areNumbersEqualWithTolerance","num1","num2","isNumberType","isNumberArrayLike","arr1","arr2","areArraysEqual","negative","isEqualNegative","isEqualAbs","loglevel","getRootLogger","logger","getLogger","names","cs3dLog","coreLog","toolsLog","loaderLog","aiLog","examplesLog","dicomConsistencyLog","imageConsistencyLog","makeVolumeMetadata","voiLut","voiLutModule","BitsAllocated","BitsStored","SamplesPerPixel","HighBit","PhotometricInterpretation","PixelRepresentation","ImageOrientationPatient","PixelSpacing","Columns","Rows","VOILUTFunction","SeriesInstanceUID","linePlaneIntersection","p0","p1","x0","y0","z0","z1","A","B","C","D","t","normal","normalized","threePlaneIntersection","firstPlane","secondPlane","thirdPlane","A1","B1","C1","D1","A2","B2","C2","D2","A3","B3","C3","D3","m0","m1","m2","m3","signed","numerator","sign","pointInShapeCallback","pointInShapeFn","returnPoints","scalars","getPointData","getScalars","getData","defaultBoundsIJK","pointsInShape","iMin","iMax","jMin","jMax","kMin","kMax","pointIJK","xMultiple","yMultiple","zMultiple","indexK","indexJK","pointLPS","iterateOverPointsInShape","iterateOverPointsInShapeVoxelManager","getAtIndex","deltaFrames","posDiffFromFocalPoint","steps","frameIndex","newSlicePosFromMin","sortImageIdsAndGetSpacing","usingWadoUri","sortedImageIds","getTransferFunctionNodes","transferFunction","setTransferFunctionNodes","nodes","node","canvasPoint","vtkImageData","worldPoint","voxelPos","transformWorldToIndexContinuous","updateVTKImageDataWithCornerstoneImage","sourceImageData","newPixelData","modified","toWindowLevel","toLowHighRange","LINEAR_EXACT","SAMPLED_SIGMOID","Active","Passive","Enabled","ToolModes","CAMERA_MODIFIED","Enums","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","calibratedPixelSpacingMetadataProvider","utilities","ViewportStatus","sumOverDimensionGroups","dimensionGroups","getScalarDataLength","resultArray","dimensionGroupNumber","getDimensionGroupScalarData","SUM","AVERAGE","SUBTRACT","idx","idx3","getPolyDataPointIndexes","polyData","linesData","getLines","lineSegments","segmentSize","segment","contours","findStartingPoint","startPoint","contour","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","getPoints","contourIndexes","ColorbarRangeTextPosition","Right","Widget","extractWindowLevelRegionToolData","VolumeViewport","extractImageDataVolume","extractImageDataStack","setAnnotationLabel","annotation","updatedLabel","triggerAnnotationModified","ChangeTypes","LabelChange","props","_controlPoints","_invalidated","_resolution","resolution","_fixedResolution","fixedResolution","_closed","closed","controlPoints","numControlPoints","aabb","_update","_aabb","hasTangentPoints","addControlPoint","addControlPoints","addControlPointAtU","u","lineSegment","_getLineSegmentAt","endPoint","curveSegmentIndex","curveSegment","_curveSegments","controlPointPos","deleteControlPointByIndex","minControlPoints","clearControlPoints","setControlPoints","updateControlPoint","newControlPoint","getControlPoints","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","len","squaredDist","getClosestControlPointWithinDistance","maxDist","closestControlPoint","getClosestPoint","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","closestPoint","csA","csB","distanceSquared","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","math","distanceToPointSquaredInfo","uValue","previousLineSegmentsLength","distanceToPoint","getClosestPointOnControlPointLines","linePoints","getPolylinePoints","_convertCurveSegmentsToPolyline","getPreviewPolylinePoints","controlPointPreview","closeDistance","closeSpline","previewCurveSegments","getPreviewCurveSegments","isPointNearCurve","curveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","distanceToPointSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","p2","isVerticalLine","xIntersection","getSplineCurves","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","CubicSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","getTransformMatrix","_getCurveSegment","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","p3","_getCurveSegmentPoints","tt","ttt","tValues","qValues","p0Index","p2Index","p3Index","mirror","_getLineSegments","numLineSegments","inc","maxU","curveSegmentLength","lineSegAABB","lineSegLength","TRANSFORM_MATRIX","BSpline","CardinalSpline","super","_scale","_fixedScale","fixedScale","s","s2","CatmullRomSpline","LinearSpline","PanTool","toolProps","defaultToolProps","supportedInteractionTypes","touchDragCallback","evt","_dragCallback","mouseDragCallback","deltaPoints","deltaPointsWorld","world","updatedPosition","updatedFocalPoint","toolName","TrackballRotateTool","rotateIncrementDegrees","_resizeObservers","_hasResolutionChanged","preMouseDownCallback","mapper","getDefaultActor","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_getViewportsInfo","getToolGroup","toolGroupId","viewportsInfo","onSetToolActive","subscribeToElementResize","getEnabledElementByIds","resizeObserver","ResizeObserver","viewPresentation","observe","_viewportAddedListener","TOOLGROUP_VIEWPORT_ADDED","onSetToolDisabled","disconnect","rotateCamera","centerWorld","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPoints","lastPoints","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","upVec","atV","rightV","forwardV","angleY","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","frame","buffer","_getMinMax","newRange","viewportsContainingVolumeUID","properties","scaling","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","voiLutFunction","imageDynamicRange","calculatedDynamicRange","getMiddleSliceData","acc","pixel","metadataDynamicRange","_getImageDynamicRangeFromViewport","imageDataRange","voxel","WindowLevelRegionTool","minWindowWidth","addNewAnnotation","isDrawing","getReferencedImageId","getFrameOfReferenceUID","highlighted","getToolName","handles","cachedStats","viewportIdsToRender","getViewportIdsWithToolToRender","editData","_activateDraw","hideElementCursor","preventDefault","triggerAnnotationRenderForViewportIds","_endCallback","_deactivateDraw","resetElementCursor","annotationUID","triggerAnnotationCompleted","applyWindowLevelRegion","worldToCanvas","topLeftCanvas","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","renderAnnotation","svgDrawingHelper","renderStatus","annotations","filterInteractableAnnotationsForElement","styleSpecifier","canvasCoordinates","lineWidth","lineDash","getAnnotationStyle","dataId","rectangleUID","drawRect","startCanvas","endCanvas","left","pixelLuminanceData","luminance","spIndex","column","red","green","blue","minMaxMean","pixelLuminance","globalMin","globalMax","spv","isPointNearTool","toolSelectedCallback","handleSelectedCallback","_activateModify","_deactivateModify","StackScrollTool","debounceIfNotLoaded","deltaY","mouseWheelCallback","_scroll","_scrollDrag","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","wheel","BaseVolumeViewport","offsetHeight","PlanarRotateTool","setAngle","startPoints","currentPointWorld","startPointWorld","centerCanvas","angleBetweenLines","cross","rotAngle","rotMat","rotatedViewUp","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","preTouchStartCallback","_dragParallelProjection","pinch","deltaDistance","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","currentPointsList","parallelProjection","_panCallback","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","getToolGroupForViewport","jumpToWorld","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","shadow","viewportIndicators","viewportIndicatorsConfig","autoPan","enabled","panSize","handleRadius","enableHDPIHandles","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","mobile","toolCenter","initializeViewport","_getAnnotations","removeAnnotation","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","addAnnotation","resetCrosshairs","viewportInfo","resetPan","resetZoom","resetToCenter","resetRotation","resetSlabThickness","_computeToolCenter","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","setToolCenter","jumpWorld","_jump","filteredAnnotations","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","canvasCoords","proximity","_pointNearTool","interactionType","onCameraModified","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","CROSSHAIR_TOOL_CENTER_CHANGED","getViewportIds","_autoPanViewportIfNecessary","onResetCamera","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","isAnnotationLocked","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","viewportUIDSpecificCrosshairs","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","line","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","lineUID","drawLine","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","drawHandles","referenceColorCoordinates","xOffset","yOffset","circleRadius","circleUID","drawCircle","getAnnotations","toolGroupAnnotations","_onNewVolume","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewportsAnnotationsWithSameCameraDirection","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","volumeIds","getAllVolumeIds","otherVolumeIds","viewportsAnnotationsToUpdate","sameScene","_applyDeltaShiftToSelectedViewportCameras","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","otherViewportsIds","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","onSetToolPassive","onSetToolEnabled","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","_applyDeltaShiftToViewportCamera","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","viewportProperties","originalViewportRotation","canvasPos","magnifyToolElement","querySelector","magnifyElement","classList","display","magnifyViewport","pow","_dragEndCallback","viewportElement","removeChild","getTargetId","csEvents","isSegmentation","AdvancedMagnifyToolActions","PARALLEL_THRESHOLD","AdvancedMagnifyTool","Actions","magnifyingGlass","zoomFactor","zoomFactorList","padding","actions","showZoomFactorsList","method","bindings","mouseButton","MouseBindings","Secondary","modifierKey","KeyboardBindings","Shift","config","canvasHandlePoints","_getCanvasHandlePoints","magnifyViewportId","sourceViewportId","isCanvasAnnotation","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","dispose","getAllAnnotations","canvasTop","canvasBottom","canvasLeft","radiusPoint","getCanvasCircleRadius","handle","handleIndex","newAnnotation","_dragDrawCallback","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","getStyle","activeHandleCanvasCoords","isAnnotationVisible","handleGroupUID","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","assign","focus","onChangeCallback","eventName","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","sourceViewport","sourceElement","AdvancedMagnifyViewport","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","_annotationRemovedCallback","destroyViewport","_newStackImageCallback","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","getEnabledElementByViewportId","stackActorReInitialized","_reset","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_initialize","_singleton","_removeEventListeners","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","_addEventListeners","ANNOTATION_REMOVED","newStackHandler","VIEWPORT_NEW_IMAGE_SET","newVolumeHandler","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","visible","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","debounce","_resizeViewport","_syncViewports","parentNode","magnifyToolGroup","mode","toolBindingsOptions","setToolActive","setToolPassive","setToolEnabled","Disabled","setToolDisabled","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","toolInstance","addViewport","addSegmentationRepresentations","segmentationId","SegmentationRepresentations","Labelmap","_cloneStack","_cloneVolumes","volumeInputArray","_cloneViewport","sourceViewportOptions","toolGroups","_cancelMouseEventCallback","closest","canvasCurrent","magnifyRadius","dist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","newWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","TOOL_MODE_CHANGED","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","ReferenceLines","AnnotationDisplayTool","enforceSameFrameOfReference","showFullDimension","_init","getRenderingEngines","filterViewportsWithToolEnabled","sourceViewportCanvasCornersInWorld","onSetToolConfiguration","topLeft","bottomRight","sourceViewPlaneNormal","isParallel","targetViewportPlane","pointSet1","pointSet2","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","vec2","targetImage","getTargetImageData","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","OverlayGridTool","sourceImageIds","pointSets","calculateImageIdPointSets","viewportData","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","actorEntries","cacheId","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","canvasPoints","fillColor","fillOpacity","closePath","polyLineUID","drawPath","actorWorldPointsMap","getOutputData","colorArray","colorComponentToString","component","componentString","colorToString","getColor","decimals","pointToString","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","textBox","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","dotProduct","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","right","centerSpace","lineLength","currentMousePosition","closestIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","enabledElements","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","bottom","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","fontFamily","fontSize","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","HandlesUpdated","dragCallback","polyline","sculpt","registerShapes","CircleSculptCursor","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mousePoint","mouseCanvasPoint","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertHandleRadially","previousIndex","nextIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","toolIndex","isLocked","isVisible","distanceFromTool","distancePointToContour","AnnotationStyleStates","Default","Highlighted","renderShape","DIRECTIONS","VolumeRotateTool","ax","ay","az","LabelTool","getTextCallback","changeTextCallback","svgLayer","textGroup","textGroupElement","bbox","getBBox","getAttribute","translateX","translateY","matches","text","initialWorldPos","anchorWorldPos","doneEditMemo","getLinkedTextBoxStyle","textBoxUID","hydrate","instance","autoGenerated","_doneChangingTextCallback","updatedText","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","LengthTool","getTextLines","defaultGetTextLines","movingTextBox","canvasPoint1","canvasPoint2","worldPosDelta","unit","_throttledCalculateCachedStats","_calculateCachedStats","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","boundingBox","drawLinkedTextBox","throttle","trailing","hydrateBase","_calculateLength","pos1","pos2","worldPos1","worldPos2","targetIds","StatsUpdated","cachedVolumeStats","HeightTool","heightUID","drawHeight","_calculateHeight","outside","ProbeTool","probeDefaults","mergeDefaultProps","createAnnotationForViewport","eventDispatchDetail","getStackViewports","referencedImageURI","currentImageURI","textUID","changeType","pixelUnitsOptions","isViewportPreScaled","isSuvScaled","ijk","modalityUnit","getAtIJKPoint","calibratedResults","hasEnhancedRegionValues","units","getPixelValueUnits","DragProbeTool","postMouseDownCallback","postTouchStartCallback","EllipticalROITool","storePointData","centerPointRadius","statsCalculator","BasicStatsCalculator","initialRotation","getRotation","canvasCorners","getCanvasEllipseCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","dYCanvas","newHalfCanvasWidth","canvasRight","dXCanvas","newHalfCanvasHeight","areaUnit","area","ellipseUID","centerPoint","_getCanvasEllipseCenter","pos1Index","post2Index","ellipseObj","xRadius","yRadius","zRadius","worldWidth","worldHeight","getWorldWidthAndHeightFromTwoPoints","isEmptyArea","statsCallback","isInObject","pointInEllipse","fast","getStatistics","statsArray","ellipse","ellipseCanvasPoints","areaLine","CircleROITool","canvasEnd","getCanvasCircleCorners","radiusUnit","perimeter","wasInvalidated","pos2Index","aspect","radiusLine","ETDRSGridTool","degrees","diameters","diametersCanvas","diameter","worldMeasureToCanvas","degreesRad","angleRadians","degree","cos","sin","measurement","p1Canvas","p2Canvas","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","ContourSegmentationBaseTool","SplineTypes","contourHoleAdditionModifierKey","epsilon","spline","Cardinal","Class","CatmullRom","Linear","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","contourHoleProcessingEnabled","Completed","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","_mouseMoveCallback","lastCanvasPoint","_mouseDownCallback","doubleClick","MOUSE_DOUBLE_CLICK","closeContour","addNewPoint","moveAnnotation","eventType","ANNOTATION_COMPLETED","ANNOTATION_MODIFIED","triggerChangeEvent","KEY_DOWN","MOUSE_DOWN","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","closestPointInfo","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","canvasMaxX","canvasMaxY","canvasMinX","canvasMinY","getAABB","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","getArea","getMouseModifier","event","createAnnotation","cancelAnnotation","isContourSegmentationTool","renderAnnotationInstance","renderContext","annotationStyle","locked","annotationLocked","childAnnotations","getChildAnnotations","childAnnotationUIDs","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","updateContourPolyline","targetWindingDirection","Clockwise","updateWindingDirection","previewPolylinePoints","drawPolyline","controlPointsConnectors","textbox","createInterpolatedSplineControl","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","splineInstance","SplineClass","SplineContourSegmentationTool","LivewireContourTool","snapHandleNearby","nearestEdge","showInterpolationPolyline","cancelInProgress","proximitySquared","clearAnnotation","clearEditData","triggerContourAnnotationCompleted","worldToSlice","sliceToWorld","worldPosOriginal","currentPath","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","scissors","findMinNearby","pathPoints","findPathToPoint","addPoints","prependPath","confirmedPath","lastPoint","getLastPoint","startSearch","updateAnnotation","imgWidth","imgHeight","slicePoint","editHandle","setupBaseEditData","nextPos","viewportImageData","sliceImageData","ijkPoint","startPos","LivewireScissors","createInstanceFromRawPixelData","scissorsNext","currentPathNext","confirmedPathNext","handlePoints","numHandles","previousHandle","nextHandle","findHandlePolylineIndex","slicePos","pathPointsLeft","pathPointsRight","appendPath","contourSegmentationAnnotation","canvasHandles","livewirePath","pointArray","imagePoints","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","repeatInterpolation","originalPoints","handleSmoothing","hIndex","testPoint","minPoint","acceptedPath","path","InterpolationUpdated","rendered","polylineCanvasPoints","ArrowAnnotateTool","arrowFirst","arrowHeadStyle","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","stopImmediatePropagation","markerSize","arrowUID","drawArrow","viaMarker","AngleTool","angleStartedNotYetCompleted","line1","canvasPoint3","line2","worldPos3","fromCharCode","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","TOUCH_START","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","firstLine","secondLine","mid1","midPoint","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","units1","values2","units2","dist1","dist2","KeyImageTool","dataSeries","seriesLevel","dataPoint","isPoint","canvasPosition","setPoint","AnnotationEraserTool","_deleteNearbyAnnotations","toolGroup","tools","_toolInstances","annotationsToRemove","interactableAnnotations","setAnnotationSelected","getAnnotation","createAnnotationMemo","deleting","RegionSegmentTool","GrowCutBaseTool","isPartialVolume","positiveSeedVariance","negativeSeedVariance","currentWorldPoint","growCutData","circleBorderPoint","runGrowCut","circleCenterPoint","getGrowCutLabelmap","segmentation","sphereInfo","growCut","segmentationData","canvasCenterPoint","canvasBorderPoint","vecCenterToBorder","getSegmentStyle","segmentIndex","RegionSegmentPlusTool","subVolumePaddingPercentage","islandRemoval","mouseTimer","allowedToProceed","cursor","clearTimeout","onMouseStable","mouseStabilityDelay","refVolume","seeds","positiveSeedIndices","negativeSeedIndices","requestAnimationFrame","worldIslandPoints","getRemoveIslandData","mergedOptions","NEGATIVE_PIXEL_RANGE","POSITIVE_PIXEL_RANGE","ISLAND_PIXEL_RANGE","WholeBodySegmentTool","positivePixelRange","negativePixelRange","islandPixelRange","_getHorizontalLineWorldPoints","horizontalLines","worldLine1P1","worldLine1P2","worldLine2P1","worldLine2P2","worldSquarePoints","worldTopLeft","worldBottomRight","_getWorldBoundingBoxFromProjectedSquare","boundingBoxInfo","ijkBottomRight","positiveSeedValue","negativeSeedValue","labelmapVolumeId","labelmapVolume","referencedVolumeData","labelmapData","islandPointIndexes","pixelValue","_projectWorldPointAcrossSlices","worldEdgePoint","vecDirection","_getViewportVolume","ijkLineP1","ijkLineP2","_getCuboidIJKEdgePointsFromProjectedWorldPoint","_getWorldCuboidCornerPoints","cuboidPoints","worldSquarePoint","worldEdgePoints","worldCuboidPoints","_getHorizontalLineIJKPoints","ijkPoint1","ijkPoint2","RectangleScissorsTool","LabelmapBaseTool","strategies","FILL_INSIDE","ERASE_INSIDE","defaultStrategy","activeStrategy","activeLabelmapSegmentation","activeSegmentation","segmentsLocked","segmentLocking","segmentColor","representationData","getSegmentation","segmentationImageId","getCurrentLabelmapImageIdForViewport","operationData","applyActiveStrategy","toolMetadata","CircleScissorsTool","SphereScissorsTool","activeSegmentationRepresentation","getEditData","CircleROIStartEndThresholdTool","numSlicesToPropagate","calculatePointsInsideVolume","showTextBox","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","statistics","labelmapUID","_computeProjectionPoints","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","viewplaneNormal","tempStartCoordinate","tempEndCoordinate","_getCoordinateForViewplaneNormal","roundedStartCoordinate","roundedEndCoordinate","cameraCoordinate","roundedCameraCoordinate","middleCoordinate","isMiddleSlice","_getIndexOfCoordinatesForViewplaneNormal","lineWidthToUse","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","handlesToStart","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","newPoint","pointsInsideVolume","measureInfo","modalityUnitOptions","worldPos1Index","worldProjectionPointIndex","indexOfProjection","worldPos2Index","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","endPos","viewplaneNormalAbs","pos","_context","PaintFillTool","currentSegmentationImageId","getImage","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataIndex","setAtIndex","framesModified","getFramesModified","triggerSegmentationDataModified","boundaries","minJ","maxJ","seedIndex3D","getAtIJK","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","getScalarDataPosition","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","OverlayMarkerType","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","ANNOTATED_CUBE","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","AXES","CUSTOM","polyDataURL","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","updatingOrientationMarker","unsubscribe","unobserve","setEnabled","offscreenMultiRenderWindow","getRenderWindow","widget","getWidget","isDeleted","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","url","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setInputData","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","SegmentSelectTool","SelectMode","Inside","Border","hoverTimeout","searchRadius","hoverTimer","_setActiveSegment","getActiveSegmentation","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentIndexAtWorldPoint","getSegmentIndexAtLabelmapBorder","Contour","getHoveredContourSegmentationAnnotation","Surface","setActiveSegmentIndex","triggerSegmentationModified","SegmentBidirectionalTool","BidirectionalTool","getSegmentIndexColor","dataId1","dataId2","secondLineUID","toolAnnotations","existingAnnotation","majorAxis","minorAxis","major0","major1","minor0","minor1","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","rect","_getRectangleImageCoordinates","rectangle","active","drawRedactionRect","point0","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","getVolumeActors","coloneIndex","_getTargetStackUID","Dir","Forward","Backward","visited","DEFAULT_VALUES","publicAPI","model","initialValues","arguments","m","algo","requestData","inData","outData","output","extractContours","traverseLoop","pd","startLineId","startPtId","loopPoints","lineId","lastPtId","terminated","numInserted","cellPointIds","getCellPoints","ptId","lineCell","getPointCells","loops","inLines","setData","li","getNumberOfCells","outLines","insertNextCell","vtkContourLoopExtraction","newInstance","projectTo2D","geometricSurfaceUtils","checkStandardBasis","rotatePoints","getBoundingBoxAroundShapeWorld","isPlaneIntersectingAABB","polySegConverters","polySeg","polySegInitializing","polySegInitializingPromise","initializePolySeg","progressCallback","ICRPolySeg","moduleId","peerImport","default","initialize","updateProgress","convertContourToSurface","args","callbacks","polylines","numPointsArray","convertContourRoiToSurface","convertLabelmapToSurface","results","rotationInfo","isStandard","rotatedPoints","rotationMatrix","convertContourToVolumeLabelmap","segmentIndices","annotationUIDsInSegmentMap","segmentationVoxelManager","createScalarVolumeVoxelManager","setDimensions","setOrigin","setDirection","setSpacing","scalarArray","setScalars","holesPolyline","projectedPolyline","sharedDimensionIndex","holes","hole","projectedHole","firstDim","secondDim","setAtIJKPoint","point2D","convertContourToStackLabelmap","segmentationsInfo","segmentationVoxelManagers","segmentationInfo","manager","convertSurfaceToVolumeLabelmap","convertSurfaceToLabelmap","polys","convertSurfacesToVolumeLabelmap","segmentsInfo","promises","all","targetImageData","totalSize","outputVolumesInfo","extent","volumeInfo","roundedIndex","getSurfacesAABBs","surfacesInfo","aabbs","numDimensions","cutSurfacesIntoPlanes","planesInfo","surfacesAABB","updateCacheCallback","numberOfPlanes","cutter","plane1","setCutFunction","surfacePolyData","planeInfo","sliceIndex","planes","polyDataResults","polyDataInfo","aabb3","getPolys","setNormal","cutterOutput","buildLinks","loopExtraction","loopOutput","lines","numberOfCells","progress","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","setNodeTouched","clearUntouched","cacheEntry","internalDivElement","_getSvgLayer","svgNodeCacheForCanvas","fn","strokeOpacity","strokeWidth","svgNodeHash","existingCircleElement","attributes","stroke","newCircleElement","createElementNS","existingEllipse","w","hypot","h","atan2","rx","ry","svgEllipseElement","linkUID","annotationAnchorPoints","refPoint","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","centering","canvasBoundingBox","midX","endfirstLine","endsecondLine","threeLine","svgns","headLength","legacyDrawArrow","markerFullId","defs","arrowMarker","arrowPath","markerEndId","_width","_getHash","existingRect","svgRectElement","Swipe","DEFAULT_CONTOUR_SEG_TOOL_NAME","convertContourPolylineToCanvasSpace","numPoints","createPolylineHole","targetAnnotation","holeAnnotation","windingDirection","holeWindingDirection","addChildAnnotation","removeContourSegmentationAnnotation","holeContour","holePolyline","updatedToolNames","renderers","planarContourToolName","triggerSegmentationRender","segmentationRenderingEngine","renderSegmentationsForViewport","_needsRender","_animationFrameSet","_animationFrameHandle","_getAllViewports","_renderFlaggedSegmentations","_throwIfDestroyed","_triggerRender","_getViewportIdsForSegmentation","_setViewportsToBeRenderedNextFrame","renderSegmentation","segmentationRepresentations","_render","viewportRenderList","segmentationRenderList","representation","_addPlanarFreeHandToolIfAbsent","allSettled","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","hasTool","addTool","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","internalComputeVolumeLabelmapFromStack","segmentationImageIds","volumeLoader","internalConvertStackToVolumeLabelmap","defaultSegmentationStateManager","getDefaultRenderingConfig","_stackLabelmapImageIdReferenceMap","_labelmapImageIdReferenceMap","freeze","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","updateSegmentation","draftState","addSegmentation","newSegmentation","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getSegmentationRepresentations","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","segments","colorLUTIndex","_setActiveSegmentation","processLabelmapRepresentationAddition","isBaseVolumeSegmentation","updateLabelmapSegmentationImageReferences","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","referenceImageId","viewableLabelmapImageIdFound","labelmapImageId","isReferenceViewable","asOverlay","_updateLabelmapImageIdReferenceMap","_updateAllLabelmapSegmentationImageReferences","withNavigation","getLabelmapImageIdsForImageId","_generateMapKey","getCurrentLabelmapImageIdsForViewport","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","currentValues","newValues","setActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentation","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","addColorLUT","removeColorLUT","_getStackIdForImageIds","getAllViewportSegmentationRepresentations","representations","getSegmentationRepresentationsBySegmentationId","viewportReps","filteredReps","segmentationStyle","global","viewportsStyle","setStyle","styles","currentStyles","updatedStyles","copyActiveToInactiveIfNotProvided","renderInactiveSegmentations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","contourStyles","outlineDashInactive","outlineDash","combinedStyle","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","segmentationStateManager","indexToUse","colorLUTToUse","missingColorLUTs","segmentationInputArray","segmentationInput","inputData","contourData","geometryIds","annotationUIDsMap","normalizedSegments","segmentsConfig","surfaceData","geometryId","geometry","getGeometry","normalizeSurfaceSegments","normalizeSegments","addSegmentations","setColorLUT","colorLUTsIndex","segmentationRepresentation","colorValue","setSegmentIndexColor","colorReference","modifiedSlicesToUse","SEGMENTATION_DATA_MODIFIED","getSegmentations","getViewportSegmentations","convertVolumeToStackLabelmap","segmentationVolume","computeVolumeLabelmapFromStack","internalAddSegmentationRepresentation","representationInput","getColorLUTIndex","colorLUTOrIndex","parse","rep","removeAllSegmentations","immediate","_removeSegmentationRepresentations","labelmapDisplay","contourDisplay","removeRepresentation","surfaceDisplay","_removeRepresentationObject","removeAllSegmentationRepresentations","removeLabelmapRepresentation","removeContourRepresentation","removeSurfaceRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegmentIndices","destroy","re","toolGroupFilteredByIds","tg","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","index3","index4","handles1","handles2","scale1","scale2","widthUnit","vector1","vector2","PlanarFreehandContourSegmentationTool","allowOpenContours","renderResult","pointCanProjectOnLine","PlanarFreehandROITool","alwaysRenderOpenContourHandles","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","displayOnePointAsCrosshairs","isEditingClosed","isEditingOpen","activateDraw","activateOpenContourEndEdit","activateClosedContourEdit","activateOpenContourEdit","previousPoint","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","calibratedScale","updateClosedCachedStats","updateOpenCachedStats","annotationsToDisplay","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","annotationsWithinSlice","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","worldPosIndex","worldPosIndex2","iDelta","jDelta","kDelta","ceil","worldPosEnd","canvasPosEnd","curRow","intersections","intersectionCounter","_pointIJK","getLineSegmentIntersectionsCoordinates","shift","isFinite","RectangleROITool","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL","brushSize","useCenterSegmentIndex","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","StrategyCallbacks","AcceptPreview","RejectPreview","Interpolate","useBallStructuringElement","noUseDistanceTransform","noUseExtrapolation","interpolateExtrapolation","_editData","createEditData","_previewData","isDrag","timerStart","Date","now","hoverData","_hoverData","createHoverData","getOperationData","applyActiveStrategyCallback","OnInteractionStart","timer","time","rejectPreview","previewCallback","strategyData","strategy","Preview","OnInteractionEnd","acceptPreview","_calculateCursor","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","brushCursor","computeInnerCircleRadius","GetStatistics","interpolate","invalidateBrushCursor","getActiveSegmentationData","brushCursorUID","centerSegmentIndexInfo","dynamicRadiusInCanvas","threshold","circleUID1","previewData","NaN","memoMap","acceptedMemoIds","hasSegmentIndex","hasPreviewIndex","changedIndices","_historyRedoHandler","memoData","voxelManagerId","redoVoxelManager","ERROR_EVENT","message","cancelable","actors","volumes","referencedVolumeIdToThreshold","activeRepresentation","configColor","previewColor","previewSegmentIndex","factor","lightenColor","previewOnHover","addPreview","acceptReject","AddPreview","viewportContoursToLabelmap","removeContours","viewAnnotations","contourAnnotations","fillInsideCircle","previewVoxels","segmentationVoxels","sourceVoxelManager","bound","activeIndex","startIndex","startValue","hasZeroIndex","hasPositiveIndex","polyPoint","polyIndex","polyValue","isPointInsidePolyline3D","setAtIJK","slices","getArrayOfModifiedSlices","initializeCircle","Initialize","segmentationImageData","centerIJK","circleCornersIJK","getBoundingBoxAroundShapeIJK","createPointInEllipse","isInObjectBoundsIJK","worldInfo","sphereObj","radius2","precalculated","precalculatePointInEllipse","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","labelmapStatistics","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","strategyFunction","thresholdInsideCircle","initializeRectangle","imageVoxelManager","rectangleCornersIJK","coord","isStackViewport","isAligned","getSpacing","EPS","pointsBoundsLPS","xMin","xMax","yMin","yMax","zMin","zMax","createPointInRectangle","RECTANGLE_STRATEGY","RECTANGLE_THRESHOLD_STRATEGY","fillInsideRectangle","getClosestImageIdForStackViewport","ImagePositionPatient","calculateDistanceToImage","numSlicesToProject","sliceNormalIndex","addContourSegmentationAnnotation","parentAnnotationUID","annotationsUIDsSet","closestDistance","testIndex","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","TypeError","invokeFunc","thisArg","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Boolean","cancelAnimationFrame","cancelTimer","flush","pending","annotationCanvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","_determineCorners","centerY","CalibrationTypes","PIXEL_UNITS","VOXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","hasPixelSpacing","volumeUnit","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","USER","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","_getSphereBoundsInfo","circlePoints","directionVectors","radiusWorld","rowCosine","columnCosine","vecNormal","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJK","getSphereBoundsInfo","scanAxis","getSphereBoundsInfoFromViewport","getViewportForAnnotation","pointInSphere","sphere","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","vec","SegmentStatsCalculator","calculators","indices","statsInit","statsData","calculator","lpad","string","character","seed","onFlood","onBoundary","equals","startNode","permutations","perms","permutation","permute","perm","countNonZeroes","prunedPermutations","visits","currentArgs","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getBrushToolInstances","toolInstances","annotationUIDs","indexIJK","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","segmentationActorEntry","deltaK","neighborIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","desiredRepresentation","representationType","getScalarValueFromWorld","getSegmentIndexAtWorldForLabelmap","annotationsSet","getSegmentIndexAtWorldForContour","WEBGPU_MEMORY_LIMIT","DEFAULT_GROWCUT_OPTIONS","windowSize","maxProcessingTime","inspection","numCyclesInterval","numCyclesBelowThreshold","referenceVolumeId","workGroupSize","labelmap","numIterations","volumePixelData","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","adapter","navigator","gpu","requestAdapter","device","requestDevice","BUFFER_SIZE","UPDATED_VOXELS_COUNTER_BUFFER_SIZE","Uint32Array","BYTES_PER_ELEMENT","BOUNDS_BUFFER_SIZE","Int32Array","shaderModule","createShaderModule","code","paramsArrayValues","gpuParamsBuffer","createBuffer","usage","GPUBufferUsage","UNIFORM","COPY_DST","gpuVolumePixelDataBuffer","STORAGE","queue","writeBuffer","gpuLabelmapBuffers","COPY_SRC","gpuStrengthBuffers","gpuCounterBuffer","gpuBoundsBuffer","initialBounds","bindGroupLayout","createBindGroupLayout","binding","GPUShaderStage","COMPUTE","bindGroups","outputLabelmapBuffer","outputStrengthBuffer","previouLabelmapBuffer","previousStrengthBuffer","createBindGroup","layout","resource","pipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","workGroupSizeX","workGroupSizeY","workGroupSizeZ","numWorkGroups","gpuUpdatedVoxelsCounterStagingBuffer","MAP_READ","limitProcessingTime","performance","currentInspectionNumCyclesInterval","belowThresholdCounter","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","updatedVoxelsCounterResultBuffer","getMappedRange","updatedVoxelsRatio","unmap","outputLabelmapBufferIndex","labelmapStagingBuffer","boundsStagingBuffer","labelmapResultBuffer","labelmapResult","boundsResultBuffer","boundsResult","clearBounds","setBounds","POSITIVE_SEED_VALUE","NEGATIVE_SEED_VALUE","_createAndCacheSegmentationSubVolumeForBoundingBox","subVolPixelData","startSliceIndex","stopSliceIndex","pixelsPerSlice","zOffset","_setPositiveSeedValues","sliceOffset","bfs","slicePixelIndex","volumeVoxelIndex","volumeVoxelValue","scanLine","limitX","incX","_setNegativeSeedValues","runGrowCutForBoundingBox","subVolumeBoundsIJK","POSITIVE_SEED_VARIANCE","NEGATIVE_SEED_VARIANCE","vecColumn","sphereCenterPoint","sphereRadius","refVolImageData","topCirclePoint","bottomCirclePoint","sphereBoundsInfo","_getGrowCutSphereBoundsInfo","_createAndCacheSegmentationSubVolumeForSphere","refVolumePixelData","worldStartPos","ijkStartPosition","referencePixelValue","positiveSeedVarianceValue","minPositivePixelValue","maxPositivePixelValue","neighborsCoordDelta","startVoxelIndex","ijkVoxel","neighborCoordDelta","nx","ny","nz","neighborVoxelIndex","neighborPixelValue","ijkSphereCenter","negativeSeedVarianceValue","minNegativePixelValue","maxNegativePixelValue","rotationAngle","worldQuat","vecRotation","worldCircleBorderPoint","ijkCircleBorderPoint","runGrowCutForSphere","sphereBoundsIJK","_createSubVolumeFromSphere","MAX_POSITIVE_SEEDS","calculateGrowCutSeeds","refImageData","referenceVolumeVoxelManager","neighborhoodRadius","initialNeighborhoodRadius","positiveK","positiveStdDevMultiplier","negativeK","negativeStdDevMultiplier","negativeSeedMargin","negativeSeedsTargetPatches","ijkStart","initialStats","positiveIntensityMin","positiveIntensityMax","currentQueueIndex","neighborValue","positiveSum","positiveSumSq","positiveCount","positiveMean","positiveVariance","negativeDiffThreshold","minXm","minYm","minZm","maxXm","maxYm","maxZm","attempts","patchesAdded","maxAttempts","rz","centerValue","patchContributed","runOneClickGrowCut","positiveSeedLabel","negativeSeedLabel","tool","getViewportsInfo","getDeltaPoints","curr","getMeanPoints","page","_subtractPoints2D","client","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaDistanceBetweenIPoints","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","pairedDistance","triggerAnnotationRenderForToolGroupIds","toolGroupIds","DataTypeByteSize","Int8Array","Float64Array","VtkDataTypes","VOID","CHAR","SIGNED_CHAR","UNSIGNED_CHAR","UNSIGNED_CHAR_CLAMPED","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","DOUBLE","Constants","DefaultDataType","DesiredOutputPrecision","DEFAULT","SINGLE","AttributeCopyOperations","COPYTUPLE","INTERPOLATE","PASSDATA","ALLCOPY","AttributeLimitTypes","MAX","EXACT","NOLIMIT","AttributeTypes","SCALARS","VECTORS","NORMALS","TCOORDS","TENSORS","GLOBALIDS","PEDIGREEIDS","EDGEFLAG","NUM_ATTRIBUTES","CellGhostTypes","DUPLICATECELL","HIGHCONNECTIVITYCELL","LOWCONNECTIVITYCELL","REFINEDCELL","EXTERIORCELL","HIDDENCELL","PointGhostTypes","DUPLICATEPOINT","HIDDENPOINT","ghostArrayName","vtkErrorMacro","vtkDebugMacro","vtkImageMarchingSquares","classHierarchy","getContourValues","contourValues","setContourValues","cValues","ids","pixelScalars","pixelPts","edgeLocator","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","insertEdge","getOrigin","computeIncrements","getKernels","cv","polydata","timeEnd","setGet","out","fromValues","copy","subtract","multiply","divide","scaleAndAdd","squaredDistance","squaredLength","negate","inverse","normalize","bx","by","bz","lerp","hermite","d","factorTimes2","factor1","factor2","factor3","factor4","bezier","inverseFactor","inverseFactorTimesTwo","zScale","transformMat4","transformMat3","transformQuat","q","qx","qy","qz","qw","uvx","uvy","uvz","uuvx","uuvy","uuvz","w2","rotateX","rad","rotateY","mag","cosine","zero","exactEquals","a0","b0","mul","div","sqrDist","sqrLen","stride","arg","l","zip","interpolator","samples"],"sourceRoot":""}